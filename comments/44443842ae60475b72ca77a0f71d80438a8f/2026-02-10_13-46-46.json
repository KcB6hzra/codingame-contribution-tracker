[
  {
    "commentId": 20948,
    "codingamerId": 2870586,
    "commentableId": 10974119,
    "responseCount": 1,
    "upVotes": 0,
    "downVotes": 0,
    "votableId": 11049254,
    "userVoteValue": 0,
    "nickname": "MattZ",
    "content": "The \"Two loops\" test should have a corresponding validator and the \"One missing vertex\" validator should have a corresponding test :)\n\nBesides that, this looks wonderful.",
    "codingamerHandle": "987a9722eec1d3465d8a8cba20010de46850782",
    "avatar": 21782473296749,
    "elapsedTime": 207424024000
  },
  {
    "commentId": 20941,
    "codingamerId": 1771970,
    "commentableId": 10974119,
    "responseCount": 3,
    "upVotes": 1,
    "downVotes": 0,
    "votableId": 11047069,
    "userVoteValue": 0,
    "nickname": "Entei",
    "content": "Took me about 4 minutes so it would definitely fit as a clash. Your solution seems a bit complicated, but it's how someone with graph theory background would do. A very simple approach would be:\n\nvisited = [1] + [0]*(n-1)  # starting from zero again\nval = [[int(j) for j in input().split()] for i in range(m)]\n\nb = True\nwhile b: # while visited[] is being modified\n    b = False\n    for v in val:\n        if (visited[v[0]] != visited[v[1]]): # if one edge is in and the other is out\n            visited[v[1]] = 1 \n            visited[v[0]] = 1 \n            b = True\n\nprint(visited.count(1) == n )\n\n\nI'm sharing this so people get a better idea of why this was less complicated than it looked like :)",
    "codingamerHandle": "e2cd4fd981e1703c50ee86fe601966400791771",
    "avatar": 22958773542415,
    "elapsedTime": 207446111000
  },
  {
    "commentId": 20934,
    "codingamerId": 2976964,
    "commentableId": 10974119,
    "responseCount": 1,
    "upVotes": 0,
    "downVotes": 0,
    "votableId": 11045802,
    "userVoteValue": 0,
    "nickname": "BenjaminUrquhart",
    "content": "It makes more sense to output the literal strings true/false (rather than 1 or 0) for a clash determining the validity of something.",
    "codingamerHandle": "56db73bce00f9f3bc03e675067ce577a4696792",
    "avatar": 26083283518959,
    "elapsedTime": 207454286000
  },
  {
    "commentId": 20933,
    "codingamerId": 2405048,
    "commentableId": 10974119,
    "responseCount": 1,
    "upVotes": 0,
    "downVotes": 0,
    "votableId": 11045748,
    "userVoteValue": 0,
    "nickname": "Haitaka",
    "content": "I think that the ability to code a graph exploration fast is something that any programmer must have. Sorry if it is a duplicate!",
    "codingamerHandle": "fd45463b1fd01c8aaba8eadeba59b1508405042",
    "elapsedTime": 207454586000
  },
  {
    "commentId": 20938,
    "codingamerId": 2976964,
    "commentableId": 10974119,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 20933,
    "votableId": 11046342,
    "userVoteValue": 0,
    "nickname": "BenjaminUrquhart",
    "content": "I don't remember this being a duplicate.\n\nIt is possible to complete in 15 minutes, but I was cutting it a bit close (roughly 10-11 minutes). There are already clashes that take this long though, so no big deal.",
    "codingamerHandle": "56db73bce00f9f3bc03e675067ce577a4696792",
    "avatar": 26083283518959,
    "elapsedTime": 207451054000
  },
  {
    "commentId": 20936,
    "codingamerId": 2405048,
    "commentableId": 10974119,
    "responseCount": 0,
    "upVotes": 1,
    "downVotes": 0,
    "parentCommentId": 20934,
    "votableId": 11045920,
    "userVoteValue": 0,
    "nickname": "Haitaka",
    "content": "fixed",
    "codingamerHandle": "fd45463b1fd01c8aaba8eadeba59b1508405042",
    "elapsedTime": 207453612000
  },
  {
    "commentId": 20942,
    "codingamerId": 2976964,
    "commentableId": 10974119,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 20941,
    "votableId": 11047221,
    "userVoteValue": 0,
    "nickname": "BenjaminUrquhart",
    "content": "I traveled the graph the same way a BFS would, starting from the vertex with the least amount of edges. I checked the size of visited nodes to see if it's the same size as the total number of vertices. A bit more complicated IMO than your solution, but it worked /shrug",
    "codingamerHandle": "56db73bce00f9f3bc03e675067ce577a4696792",
    "avatar": 26083283518959,
    "elapsedTime": 207444875000
  },
  {
    "commentId": 20960,
    "codingamerId": 2405048,
    "commentableId": 10974119,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 20948,
    "votableId": 11052931,
    "userVoteValue": 0,
    "nickname": "Haitaka",
    "content": "Fixed",
    "codingamerHandle": "fd45463b1fd01c8aaba8eadeba59b1508405042",
    "elapsedTime": 207375001000
  },
  {
    "commentId": 20961,
    "codingamerId": 2405048,
    "commentableId": 10974119,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 20941,
    "votableId": 11052951,
    "userVoteValue": 0,
    "nickname": "Haitaka",
    "content": "Your method is very interesting, I hadn't thought about that! You get a worst case complexity in O(NM) instead of O(N+M), but that doesn't matter here, so it is indeed faster.",
    "codingamerHandle": "fd45463b1fd01c8aaba8eadeba59b1508405042",
    "elapsedTime": 207374819000
  },
  {
    "commentId": 20968,
    "codingamerId": 1771970,
    "commentableId": 10974119,
    "responseCount": 0,
    "upVotes": 1,
    "downVotes": 0,
    "parentCommentId": 20941,
    "votableId": 11055631,
    "userVoteValue": 0,
    "nickname": "Entei",
    "content": "Actually, I could make it even faster by removing edges if there's linking 2 vertices already seen. It would be smth like O(M log(N) ) or even lower",
    "codingamerHandle": "e2cd4fd981e1703c50ee86fe601966400791771",
    "avatar": 22958773542415,
    "elapsedTime": 207352981000
  }
]