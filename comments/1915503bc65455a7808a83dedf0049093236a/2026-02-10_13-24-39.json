[
  {
    "commentId": 76327,
    "codingamerId": 3647844,
    "commentableId": 23812677,
    "responseCount": 0,
    "upVotes": 1,
    "downVotes": 0,
    "votableId": 24304697,
    "userVoteValue": 0,
    "nickname": "rc95401",
    "content": "✅ Approved the contribution.\nComment: Good example of a clash where there's a shortcut to the solution. Carefully worded with a complete set of test cases/validators.",
    "codingamerHandle": "3d94aced9ce3f28d3ee6e456d5257b4e4487463",
    "avatar": 39486169555819,
    "elapsedTime": 114617872000
  },
  {
    "commentId": 76266,
    "codingamerId": 4539012,
    "commentableId": 23812677,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "votableId": 24293865,
    "userVoteValue": 0,
    "nickname": "extralucide",
    "content": "✅ Approved the contribution.\nComment: J'accepte cette contibution car elle répond aux 3 premiers critères et que cette contribution mérite d'être intégré dans un clash",
    "codingamerHandle": "8079eaef084e9196e622d6e01312f61e2109354",
    "avatar": 83814860617511,
    "elapsedTime": 114663872000
  },
  {
    "commentId": 76264,
    "codingamerId": 4539012,
    "commentableId": 23812677,
    "responseCount": 1,
    "upVotes": 0,
    "downVotes": 0,
    "votableId": 24293825,
    "userVoteValue": 0,
    "nickname": "extralucide",
    "content": "Cool challenge.  I passed all 16 tests but may be you could add a validator where the final location has been visited twice like\n\nInput\n3 1\n1 2\n2 3\n3 2",
    "codingamerHandle": "8079eaef084e9196e622d6e01312f61e2109354",
    "avatar": 83814860617511,
    "elapsedTime": 114664044000
  },
  {
    "commentId": 74202,
    "codingamerId": 3450837,
    "commentableId": 23812677,
    "responseCount": 0,
    "upVotes": 1,
    "downVotes": 0,
    "votableId": 24080407,
    "userVoteValue": 0,
    "nickname": "eliminator",
    "content": "✅ Approved the contribution.\nComment: it's an interesting challenge with clear instructions.",
    "codingamerHandle": "3e040c28eff19643d6565ee1d33d93457380543",
    "avatar": 85348927427986,
    "elapsedTime": 115919068000
  },
  {
    "commentId": 74201,
    "codingamerId": 3450837,
    "commentableId": 23812677,
    "responseCount": 1,
    "upVotes": 0,
    "downVotes": 0,
    "votableId": 24080387,
    "userVoteValue": 0,
    "nickname": "eliminator",
    "content": "is there a way to solve this with graph data structure?",
    "codingamerHandle": "3e040c28eff19643d6565ee1d33d93457380543",
    "avatar": 85348927427986,
    "elapsedTime": 115919162000
  },
  {
    "commentId": 73786,
    "codingamerId": 3338757,
    "commentableId": 23812677,
    "responseCount": 1,
    "upVotes": 0,
    "downVotes": 0,
    "votableId": 24015258,
    "userVoteValue": 0,
    "nickname": "Wassel",
    "content": "There is a simple way to solve that problem for each test and validator : if a place is somewhere in b list but never in a list, then it is the solution. Is it the way it should be solved ?",
    "codingamerHandle": "fd2aadac023438adcd77377694fe47647578333",
    "avatar": 28544506206817,
    "elapsedTime": 116308746000
  },
  {
    "commentId": 73295,
    "codingamerId": 4433844,
    "commentableId": 23812677,
    "responseCount": 3,
    "upVotes": 0,
    "downVotes": 0,
    "votableId": 23957889,
    "userVoteValue": 0,
    "nickname": "Lisa-Has-Ideas",
    "content": "In the constrains sections, this is confusing to me:\n a[i] = b[i-1] for 0 < i < n",
    "codingamerHandle": "6057618d773e6e27a20abefa031c4e674483344",
    "avatar": 94714081045618,
    "elapsedTime": 116687936000
  },
  {
    "commentId": 73151,
    "codingamerId": 2874091,
    "commentableId": 23812677,
    "responseCount": 1,
    "upVotes": 1,
    "downVotes": 0,
    "votableId": 23928905,
    "userVoteValue": 0,
    "nickname": "5DN1L",
    "content": "Please also state the lower bounds of the variables in the Constraint section. Thanks.",
    "codingamerHandle": "bbb8f47ea4601179303c20acdbf5fb6c1904782",
    "onlineSince": 1770727666105,
    "avatar": 134264063920528,
    "elapsedTime": 116841998000
  },
  {
    "commentId": 73150,
    "codingamerId": 1205098,
    "commentableId": 23812677,
    "responseCount": 2,
    "upVotes": 2,
    "downVotes": 0,
    "votableId": 23928433,
    "userVoteValue": 0,
    "nickname": "AlMag",
    "content": "Solution: every place, apart from start position and end position will be present even amount of times in the notes, so xoring everything together (along with start position) will leave only end position as a result, which is the answer",
    "codingamerHandle": "15c37159b932c69b57c0e52d5f98017b8905021",
    "elapsedTime": 116850109000
  },
  {
    "commentId": 73153,
    "codingamerId": 4806550,
    "commentableId": 23812677,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 73150,
    "votableId": 23929094,
    "userVoteValue": 0,
    "nickname": "Rafarafa",
    "content": "Mind explaining a bit more, I don't understand your answer :(. Fun clash though. \n\nMy dummy solution in py (just to consult it after in case you answer):\n\n# n, start_position = [int(i) for i in input().split()]\n# positions = [[int(j) for j in input().split()] for i in range(n)]\n# visited = []\n# for _ in range(n):\n#     for position in positions:\n#         p1, p2 = position\n#         if start_position == p1 and position not in visited:\n#             start_position = p2\n#             visited.append(position)\n# print(start_position)",
    "codingamerHandle": "68977779383d7e4ea558c7a5446487f40556084",
    "avatar": 80946308795008,
    "elapsedTime": 116839624000
  },
  {
    "commentId": 73288,
    "codingamerId": 1205098,
    "commentableId": 23812677,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 73151,
    "votableId": 23957492,
    "userVoteValue": 0,
    "nickname": "AlMag",
    "content": "Fair, my mistake. Adding",
    "codingamerHandle": "15c37159b932c69b57c0e52d5f98017b8905021",
    "elapsedTime": 116692394000
  },
  {
    "commentId": 73298,
    "codingamerId": 1205098,
    "commentableId": 23812677,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 73295,
    "votableId": 23957953,
    "userVoteValue": 0,
    "nickname": "AlMag",
    "content": "\"a\" represents where keys moved from, \"b\" represents where keys moved to for each individual note. So chronologically ordered notes will look like\na[0] b[0]\na[1] b[1]\na[2] b[2], meaning\nb[0] = a[1], b[1] = a[2], etc.\nIn order to get keys from a[i] somewhere, previous note (b[i-1]) should put keys to this place a[i].\nLike\nA             B <- b[0]\nB <- a[1] C <- b[1]\nC <- a[2] D\n....\n\nThat sentense only means that input is valid, and there's exist proper order for these notes that Vitalii originally had, before they got shuffled",
    "codingamerHandle": "15c37159b932c69b57c0e52d5f98017b8905021",
    "elapsedTime": 116687404000
  },
  {
    "commentId": 73835,
    "codingamerId": 1205098,
    "commentableId": 23812677,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 73786,
    "votableId": 24022646,
    "userVoteValue": 0,
    "nickname": "AlMag",
    "content": "Almost, because places can repeat. Take a look at the last 2 tests. Instead, you should look at parity",
    "codingamerHandle": "15c37159b932c69b57c0e52d5f98017b8905021",
    "elapsedTime": 116265644000
  },
  {
    "commentId": 74239,
    "codingamerId": 1205098,
    "commentableId": 23812677,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 74201,
    "votableId": 24082468,
    "userVoteValue": 0,
    "nickname": "AlMag",
    "content": "Sure thing. Euclidean path, i think",
    "codingamerHandle": "15c37159b932c69b57c0e52d5f98017b8905021",
    "elapsedTime": 115897053000
  },
  {
    "commentId": 77756,
    "codingamerId": 1205098,
    "commentableId": 23812677,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 76264,
    "votableId": 24422927,
    "userVoteValue": 0,
    "nickname": "AlMag",
    "content": "You're right, i thought i did, for some reason :( Apologies for not seeing this in time",
    "codingamerHandle": "15c37159b932c69b57c0e52d5f98017b8905021",
    "elapsedTime": 113855171000
  },
  {
    "commentId": 73301,
    "codingamerId": 4433844,
    "commentableId": 23812677,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 73295,
    "votableId": 23958076,
    "userVoteValue": 0,
    "nickname": "Lisa-Has-Ideas",
    "content": "Okay I get it now.\n\nBut I would work on that a bit, because you are saying that A and B and C and D are all places, but also a and b are arrays.\n\nI see that its upper vs lower case, but it could be clearer I think.\n\n(BTW, in general, I like this: easy to understand otherwise)",
    "codingamerHandle": "6057618d773e6e27a20abefa031c4e674483344",
    "avatar": 94714081045618,
    "elapsedTime": 116685966000
  },
  {
    "commentId": 73379,
    "codingamerId": 1205098,
    "commentableId": 23812677,
    "responseCount": 0,
    "upVotes": 1,
    "downVotes": 0,
    "parentCommentId": 73295,
    "votableId": 23971609,
    "userVoteValue": 0,
    "nickname": "AlMag",
    "content": "Open to suggestions. I can remove specifics, saying only that \"All inputs are valid\", or rework it in some other way. Let me know if you have something in mind, otherwise i'll wait a little, in case community has suggestions.\n\nSo far updated to:\n\nAll notes are valid (e. g. there will exist an order, for which each next note starts with the same number as preceding note ended with)",
    "codingamerHandle": "15c37159b932c69b57c0e52d5f98017b8905021",
    "elapsedTime": 116608956000
  },
  {
    "commentId": 73289,
    "codingamerId": 1205098,
    "commentableId": 23812677,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 73150,
    "votableId": 23957528,
    "userVoteValue": 0,
    "nickname": "AlMag",
    "content": "When you order notes chronologically, you'll get something like this:\nstartPosition A1\nA1 A2\nA2 A3\nA3 A4\n.....\nAn endPosition\n\nYou are given everything, except endPosition.\nYou can notice, that everything, apart from startPosition and endPosition appears twice (or even number of times, once as \"enter\", once as \"exit\"). This means there will be only 2 integers, appearing odd amount of times - startPosition and endPosition (and note, they might be the same number).\nSo you can do bitwise-or all notes, leaving you with startPosition ^ endPosition. Then when you bitwise-or with startPosition, you will get endPosition, which is the answer.\nHope it's more clear",
    "codingamerHandle": "15c37159b932c69b57c0e52d5f98017b8905021",
    "elapsedTime": 116692110000
  }
]