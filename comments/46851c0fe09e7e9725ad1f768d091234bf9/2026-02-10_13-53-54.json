[
  {
    "commentId": 6123,
    "codingamerId": 154906,
    "commentableId": 3699660,
    "responseCount": 7,
    "upVotes": 1,
    "downVotes": 0,
    "votableId": 4143433,
    "userVoteValue": 0,
    "nickname": "JBM",
    "content": "Got it temporarily in draft mode because of the LCG vulnerability Zexion found. In a nutshell:\n- whatever the seed, the answer to the puzzle converges as M grows big\n- this happens between the validators' two biggest M sizes.\n- in pure-LCG cases, the brutish algo could find the right answer by sorting on any dimension and computing dimensions PAIRWISE BY NEIGHBORS\n\nCountermeasures:\n- the two last validator pairs use the N horses to put the two horses composing the best answer more than 512 apart in the two dimensional sorting orders.\n- so now if you want to do that the algo is O(512*(N+M))\n- which times out in naive C++\n\nI suppose it's still easy to extract the answer from statistical analysis on the N horses.\nI'll make that a bit harder if it gets to there.\n\nThis was an algorithmic puzzle, folks, not a cryptanalysis one! :(\n\nAlso, fixed the stub generator to the currentdimension names.",
    "codingamerHandle": "0d71f9df5da706f9f77c07c34d12480e609451",
    "elapsedTime": 291337252000
  },
  {
    "commentId": 6078,
    "codingamerId": 491426,
    "commentableId": 3699660,
    "responseCount": 11,
    "upVotes": 1,
    "downVotes": 0,
    "votableId": 4129567,
    "userVoteValue": 0,
    "nickname": "Zexion",
    "content": "Python can solve the N+M = 200k cases in time with a O(n log n) implementation.\nBy bruteforcing small sets, it can return a solution for N+M = 600k under 6s.\n\nInteresting problem, which can be linked to the hardest Batman puzzle.",
    "codingamerHandle": "3fa74202a2163b7580575b4574ee6fc8624194",
    "avatar": 6917924166789,
    "elapsedTime": 291510995000
  },
  {
    "commentId": 5145,
    "codingamerId": 154906,
    "commentableId": 3699660,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "votableId": 3760422,
    "userVoteValue": 0,
    "nickname": "JBM",
    "content": "My Perl solves a bit over N+M=200000 in time, so I've set the max case to half of that. I'm afraid pure bash won't cut it here.\nMy C failed to bruteforce it, so I hope yours can't either, but do let me know if it did come to happen.\nImprovements to the second sentence are very welcome.",
    "codingamerHandle": "0d71f9df5da706f9f77c07c34d12480e609451",
    "elapsedTime": 295057549000
  },
  {
    "commentId": 6080,
    "codingamerId": 154906,
    "commentableId": 3699660,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 6078,
    "votableId": 4131474,
    "userVoteValue": 0,
    "nickname": "JBM",
    "content": "Just so we're clear: there's no 200k case in the set *I* provided. I cut it off at 100k specifically to give the slower languages some leeway.\n\nThanks for taking the time to test it. Much appreciated!",
    "codingamerHandle": "0d71f9df5da706f9f77c07c34d12480e609451",
    "elapsedTime": 291493207000
  },
  {
    "commentId": 6138,
    "codingamerId": 491426,
    "commentableId": 3699660,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 6123,
    "votableId": 4153277,
    "userVoteValue": 0,
    "nickname": "Zexion",
    "content": "I laughed when I saw these last two testcases!\nWhen you said failing in c++, did you mean by implementing this somewhat falsy stub I provided?\n\nIf so, 512 seems still smaller compared 100k, so should be the constant in a naive implementation.\nIf number of classical horses is still too small, I think you can gain more characters by decreasing the magnitude of their coordinates.",
    "codingamerHandle": "3fa74202a2163b7580575b4574ee6fc8624194",
    "avatar": 6917924166789,
    "elapsedTime": 291228368000
  },
  {
    "commentId": 6140,
    "codingamerId": 154906,
    "commentableId": 3699660,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 6123,
    "votableId": 4153722,
    "userVoteValue": 0,
    "nickname": "JBM",
    "content": "That's more or less what I did.\nThe tradeoff is that if they're too small, the closest pair is necessarily among them, which is another vulnerability class in itself.\n(the closest pair in the last two pairs is between a static and an LCG, 1% smaller than the closest pair among LCG)",
    "codingamerHandle": "0d71f9df5da706f9f77c07c34d12480e609451",
    "elapsedTime": 291223708000
  },
  {
    "commentId": 6141,
    "codingamerId": 154906,
    "commentableId": 3699660,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 6123,
    "votableId": 4153767,
    "userVoteValue": 0,
    "nickname": "JBM",
    "content": "When I say failing C++, I mean the alg \"sort on one dimension, then compare all pairs of horses less than W indices apart in the sorted array\", implemented in natural C++.\n512 * 100k ~= 50M; incrementing an L1 64-bit int times out if done 500M times; so it doesn't seem that small to me.",
    "codingamerHandle": "0d71f9df5da706f9f77c07c34d12480e609451",
    "elapsedTime": 291223132000
  },
  {
    "commentId": 6142,
    "codingamerId": 491426,
    "commentableId": 3699660,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 6123,
    "votableId": 4153866,
    "userVoteValue": 0,
    "nickname": "Zexion",
    "content": "As you can cut the search for each point, as soon as you find a neighbour at a distance greater than current minimal one following the dimension you use for sorting, it doesn't increase execution time so much.\nThat's the technique someone used to bruteforce it in Python, and I was quite surprised when I saw it.",
    "codingamerHandle": "3fa74202a2163b7580575b4574ee6fc8624194",
    "avatar": 6917924166789,
    "elapsedTime": 291221870000
  },
  {
    "commentId": 6143,
    "codingamerId": 154906,
    "commentableId": 3699660,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 6123,
    "votableId": 4153978,
    "userVoteValue": 0,
    "nickname": "JBM",
    "content": "Smart!\nI'm running out of countermeasures ideas here.\nWe need a petition for actually large input sizes.",
    "codingamerHandle": "0d71f9df5da706f9f77c07c34d12480e609451",
    "elapsedTime": 291220467000
  },
  {
    "commentId": 6144,
    "codingamerId": 491426,
    "commentableId": 3699660,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 6123,
    "votableId": 4154059,
    "userVoteValue": 0,
    "nickname": "Zexion",
    "content": "That's exactly the\nif points[j][1] - points[i][1] >= minDistance: break\nxas for in my implementation XD\nI will be glad to sign that petition again!",
    "codingamerHandle": "3fa74202a2163b7580575b4574ee6fc8624194",
    "avatar": 6917924166789,
    "elapsedTime": 291219379000
  },
  {
    "commentId": 6145,
    "codingamerId": 154906,
    "commentableId": 3699660,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 6123,
    "votableId": 4154099,
    "userVoteValue": 0,
    "nickname": "JBM",
    "content": "Brainstorm time. What protects against that?\nHaving more dense data. But it can't go near Espan*Vspan.\nHaving many streaks of [E0 + i, V0 + 100000*i] (and symmetrical). Would need way more input, or a very weird generator (a bit late to change that. and if the generator's specified, it's just as vulnerable)\nCan't think of much more for now (and none of it really actionable in the current context. :/ )",
    "codingamerHandle": "0d71f9df5da706f9f77c07c34d12480e609451",
    "elapsedTime": 291218485000
  },
  {
    "commentId": 6095,
    "codingamerId": 491426,
    "commentableId": 3699660,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 6078,
    "votableId": 4134709,
    "userVoteValue": 0,
    "nickname": "Zexion",
    "content": "Python isn't a slow langage? ;-)",
    "codingamerHandle": "3fa74202a2163b7580575b4574ee6fc8624194",
    "avatar": 6917924166789,
    "elapsedTime": 291442192000
  },
  {
    "commentId": 6096,
    "codingamerId": 154906,
    "commentableId": 3699660,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 6078,
    "votableId": 4134744,
    "userVoteValue": 0,
    "nickname": "JBM",
    "content": "I'm not entering *that* debate! :D",
    "codingamerHandle": "0d71f9df5da706f9f77c07c34d12480e609451",
    "elapsedTime": 291441757000
  },
  {
    "commentId": 6097,
    "codingamerId": 491426,
    "commentableId": 3699660,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 6078,
    "votableId": 4135024,
    "userVoteValue": 0,
    "nickname": "Zexion",
    "content": "Nevermind, 100k is enough but I get the feeling that if Python achieves 500k test, C can solve a test with some millions and may be fast enough to solve it with a \"clever\" bruteforce.",
    "codingamerHandle": "3fa74202a2163b7580575b4574ee6fc8624194",
    "avatar": 6917924166789,
    "elapsedTime": 291438547000
  },
  {
    "commentId": 6100,
    "codingamerId": 154906,
    "commentableId": 3699660,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 6078,
    "votableId": 4136030,
    "userVoteValue": 0,
    "nickname": "JBM",
    "content": "The general spirit is: I want a smart algo to be mandatory on this puzzle, but I'd like to exclude as few languages as possible.\nRight now, I think we're there, but I'd be very interested to hear about counterexamples should they show up.\n\nI'm on the assumption that \"good alg\" is O(NlgN), \"bad alg\" is O(N^2).\nIf there some intermediate version... I'd say who cares: if the coder's smart enough to come up with something in that gray area, he's smart enough to write it in a high-level language too.\n\nWhat \"clever bruteforce\" do you have in mind?",
    "codingamerHandle": "0d71f9df5da706f9f77c07c34d12480e609451",
    "elapsedTime": 291429019000
  },
  {
    "commentId": 6110,
    "codingamerId": 491426,
    "commentableId": 3699660,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 6078,
    "votableId": 4138513,
    "userVoteValue": 0,
    "nickname": "Zexion",
    "content": "I haven't tested it but an idea would be to:\n- sort all points given a coordinate;\n- for each point, try only a fraction of its neigbors given this sort;\n- try to break computation earlier given current minimal distance.",
    "codingamerHandle": "3fa74202a2163b7580575b4574ee6fc8624194",
    "avatar": 6917924166789,
    "elapsedTime": 291406408000
  },
  {
    "commentId": 6113,
    "codingamerId": 154906,
    "commentableId": 3699660,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 6078,
    "votableId": 4139516,
    "userVoteValue": 0,
    "nickname": "JBM",
    "content": "Seems like a lot of ifs and tries to end up with the same NlgN. :D",
    "codingamerHandle": "0d71f9df5da706f9f77c07c34d12480e609451",
    "elapsedTime": 291398006000
  },
  {
    "commentId": 6114,
    "codingamerId": 491426,
    "commentableId": 3699660,
    "responseCount": 0,
    "upVotes": 1,
    "downVotes": 0,
    "parentCommentId": 6078,
    "votableId": 4139653,
    "userVoteValue": 0,
    "nickname": "Zexion",
    "content": "Really?\n\nminDistance = 2 ^ 32\npoints = [(a,b), ..., (y,z)]\npoints.sort(lambda p: p[1])\nfor i = 0 .. length(points):\n    for j = i .. i + 0.2 * length(points):\n        if points[j][1] - points[i][1] >= minDistance:\n            break\n        dist = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n        if dist < minDistance:\n            minDistance = dist\nprint(minDistance)\n\nIt seems a tad simpler than a divide-and-conquer approach in O(n log n)!",
    "codingamerHandle": "3fa74202a2163b7580575b4574ee6fc8624194",
    "avatar": 6917924166789,
    "elapsedTime": 291396875000
  },
  {
    "commentId": 6115,
    "codingamerId": 154906,
    "commentableId": 3699660,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 6078,
    "votableId": 4139760,
    "userVoteValue": 0,
    "nickname": "JBM",
    "content": "(my previous post wasn't meant as provocation, but oh well)\n\nIt looks like:\n- it's O(N^2) [with an as-low-as-wanted constant, granted]\n- it's incorrect\nThough of course it's more work to me to write up the cases that make it fail.\nWould it currently pass?",
    "codingamerHandle": "0d71f9df5da706f9f77c07c34d12480e609451",
    "elapsedTime": 291395960000
  },
  {
    "commentId": 6116,
    "codingamerId": 491426,
    "commentableId": 3699660,
    "responseCount": 0,
    "upVotes": 1,
    "downVotes": 0,
    "parentCommentId": 6078,
    "votableId": 4139862,
    "userVoteValue": 0,
    "nickname": "Zexion",
    "content": "(Don't mind the \"really\" bit at the beginning of my previous message, I provided this pseudo-code to make my point clearer, no more)\n\nWhat I am really interested in is to which extent this stub is correct, ie. how much you need to lower this constant to make it pass the tests.\nWith a pseudo-random generator as LCG, it is fair enough to admit that such a  constant exists (and that it is certainly not that big too).",
    "codingamerHandle": "3fa74202a2163b7580575b4574ee6fc8624194",
    "avatar": 6917924166789,
    "elapsedTime": 291395236000
  },
  {
    "commentId": 6118,
    "codingamerId": 154906,
    "commentableId": 3699660,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 6078,
    "votableId": 4140045,
    "userVoteValue": 0,
    "nickname": "JBM",
    "content": "I'd be curious too.\n\nThe \"classical\" horse input provides some margin for edge cases, but not really in the right direction for this.\nIt's hard to ask for better deterministic randomness than LCG in a CG puzzle that's about something completely different anyway.\n\nLooks a bit like a dead-end :(",
    "codingamerHandle": "0d71f9df5da706f9f77c07c34d12480e609451",
    "elapsedTime": 291393099000
  }
]