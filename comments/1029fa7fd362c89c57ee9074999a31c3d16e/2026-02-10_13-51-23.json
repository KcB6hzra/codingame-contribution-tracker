[
  {
    "commentId": 54118,
    "codingamerId": 2874091,
    "commentableId": 6782869,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "votableId": 20688575,
    "userVoteValue": 0,
    "nickname": "5DN1L",
    "content": "Added \"write MATCH OR FAIL\" to stub generator.",
    "codingamerHandle": "bbb8f47ea4601179303c20acdbf5fb6c1904782",
    "onlineSince": 1770727666105,
    "avatar": 134264063920528,
    "elapsedTime": 134752300000
  },
  {
    "commentId": 10802,
    "codingamerId": 911777,
    "commentableId": 6782869,
    "responseCount": 2,
    "upVotes": 2,
    "downVotes": 0,
    "votableId": 6854749,
    "userVoteValue": 0,
    "nickname": "MasakiKyosuke",
    "content": "It seems a little bit easy for a community puzzle, I did it in less than 5min using just replace and regex (112 chars in Ruby).\nSo I'm sorry but I will not accept it as a community puzzle, but it's really intersting as a CoC (shortest, fastest and even reverse).",
    "codingamerHandle": "0f69ca699af992e73c1147459b20c2d5777119",
    "avatar": 1954689592247,
    "elapsedTime": 257377519000
  },
  {
    "commentId": 10783,
    "codingamerId": 2341447,
    "commentableId": 6782869,
    "responseCount": 7,
    "upVotes": 0,
    "downVotes": 0,
    "votableId": 6847957,
    "userVoteValue": 0,
    "nickname": "algmyr",
    "content": "There are a few ways to solve this one. Did you intend on a regex based one or a dynamic programming (DP) one?\n\nA regex one chokes for simple but pathological inputs like\n\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaawhatever\na~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a\n\nand for even longer texts to match this basically scales exponentially. Solving this with a DP approach you can solve those kinds of examples with ease.\n\nI know this first hand from encountering such a horrible example in a programming competition. Problem E here: https://ncpc.idi.ntnu.no/ncpc2011/ncpc2011problems.pdf",
    "codingamerHandle": "86f39b7cda6d832e5c8873e1e905646c7441432",
    "avatar": 16056481834828,
    "elapsedTime": 257473259000
  },
  {
    "commentId": 10776,
    "codingamerId": 2130169,
    "commentableId": 6782869,
    "responseCount": 2,
    "upVotes": 0,
    "downVotes": 0,
    "votableId": 6845872,
    "userVoteValue": 0,
    "nickname": "CyberLemonade",
    "content": "Do wild cards in the text simply represent characters? Or are they also wild cards? \"Text\" meaning the first line of text",
    "codingamerHandle": "d8a0152458f424d53995a613b5abea4f9610312",
    "avatar": 57032502077757,
    "elapsedTime": 257507803000
  },
  {
    "commentId": 10780,
    "codingamerId": 2178794,
    "commentableId": 6782869,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 10776,
    "votableId": 6847087,
    "userVoteValue": 0,
    "nickname": "Unihedron",
    "content": "They represent the characters and therefore can only be matched by wild cards. See the second last paragraph: \"[...] so ? and ~ in text may only be matched by ? and ~ under the right circumstances.\"",
    "codingamerHandle": "1d1729a2d8c008c6cf728ee88f1faa6d4978712",
    "avatar": 17500773502453,
    "elapsedTime": 257482427000
  },
  {
    "commentId": 10784,
    "codingamerId": 2178794,
    "commentableId": 6782869,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 10783,
    "votableId": 6848034,
    "userVoteValue": 0,
    "nickname": "Unihedron",
    "content": "Well, if you can solve test case 6 (which uses both constructs that would trip up regex metacharacters and string length approaching constraints max), any approach is good.",
    "codingamerHandle": "1d1729a2d8c008c6cf728ee88f1faa6d4978712",
    "avatar": 17500773502453,
    "elapsedTime": 257472645000
  },
  {
    "commentId": 10808,
    "codingamerId": 2178794,
    "commentableId": 6782869,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 2,
    "parentCommentId": 10802,
    "votableId": 6856227,
    "userVoteValue": 0,
    "nickname": "Unihedron",
    "content": "I don't pretend that this is a difficult puzzle, but there has never been requirements that community puzzles need to be not easy.\n\nAlso: Originally this was written (and submitted) as a clash. It was then changed into a community puzzle.",
    "codingamerHandle": "1d1729a2d8c008c6cf728ee88f1faa6d4978712",
    "avatar": 17500773502453,
    "elapsedTime": 257360475000
  },
  {
    "commentId": 10945,
    "codingamerId": 911777,
    "commentableId": 6782869,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 1,
    "parentCommentId": 10802,
    "votableId": 6909864,
    "userVoteValue": 0,
    "nickname": "MasakiKyosuke",
    "content": "It's not a requirement for sure, that's my own opinion and what I'm used to see in Codingame.\nConsider it as an advice not as a duty.\n\nWhy did you change it then ? I would like to know.",
    "codingamerHandle": "0f69ca699af992e73c1147459b20c2d5777119",
    "avatar": 1954689592247,
    "elapsedTime": 256364036000
  },
  {
    "commentId": 10786,
    "codingamerId": 2341447,
    "commentableId": 6782869,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 10783,
    "votableId": 6848087,
    "userVoteValue": 0,
    "nickname": "algmyr",
    "content": "So just correctness (rather than performance) is the idea here? I can't see your solution, so I don't know the path you took. Would be interesting to see if it handles my pathological cases though.",
    "codingamerHandle": "86f39b7cda6d832e5c8873e1e905646c7441432",
    "avatar": 16056481834828,
    "elapsedTime": 257472141000
  },
  {
    "commentId": 10787,
    "codingamerId": 2178794,
    "commentableId": 6782869,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 10783,
    "votableId": 6848264,
    "userVoteValue": 0,
    "nickname": "Unihedron",
    "content": "IboJSRam>|6&V17T_M|pw`w)m,<ns8{%9G5%%WT\"S=f}k`ztLQ^eP-T/P-u@?LGbWjnmE/JB<cGY4a)hPIX.oVb,V>k#vMQ5pL=iqISz8\"QqXe_:3^;!Y#JnQ?RS^E$8>[$I !=:MHz;;hBX;pbh> q93fNuKHK8j1kQzT0WxQ54BcKC22(&`\\39Ti/J\"A;I+GYLO1HqvWJF0';8-Y6Wb8YU]Qf}*^5z2]MsbYB!,=RSq+1g)[z&[]kZ<T,>X!?z/_e].N<yEuo\n\nIbo~>|6&~pw~)m~{~-u@?LGbWjnm?/JB<c~q?~>[$I !=:M~X;p~K?j~0~2~\\39T?/?\"A;I+~v~W~[z&[]kZ<~>X!?z/_~u?",
    "codingamerHandle": "1d1729a2d8c008c6cf728ee88f1faa6d4978712",
    "avatar": 17500773502453,
    "elapsedTime": 257470379000
  },
  {
    "commentId": 10788,
    "codingamerId": 2341447,
    "commentableId": 6782869,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 10783,
    "votableId": 6848417,
    "userVoteValue": 0,
    "nickname": "algmyr",
    "content": "No, I can see the testcases. I can't see any sample solution (if you have added any), which is what would be interesting to test. For example, would your code handle the input\n\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaawhatever a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a~a\n\nor would it timeout?",
    "codingamerHandle": "86f39b7cda6d832e5c8873e1e905646c7441432",
    "avatar": 16056481834828,
    "elapsedTime": 257469018000
  },
  {
    "commentId": 10789,
    "codingamerId": 2178794,
    "commentableId": 6782869,
    "responseCount": 0,
    "upVotes": 1,
    "downVotes": 0,
    "parentCommentId": 10783,
    "votableId": 6848671,
    "userVoteValue": 0,
    "nickname": "Unihedron",
    "content": "It does handle it! :) I'm using an array of arrays. Storage complexity is `O(length of text * length of format)`and regex would require exponential time due to the nature of backtracking - while I am sure you can craft an effective regex with languages that allow atomic capturing groups, it will be no small feat!",
    "codingamerHandle": "1d1729a2d8c008c6cf728ee88f1faa6d4978712",
    "avatar": 17500773502453,
    "elapsedTime": 257467105000
  },
  {
    "commentId": 10790,
    "codingamerId": 2341447,
    "commentableId": 6782869,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 10783,
    "votableId": 6848762,
    "userVoteValue": 0,
    "nickname": "algmyr",
    "content": "So you do the DP solution. Neat! :)\n\nIf I were to write test cases I would probably add one to really push regex users to learn about the DP alternative, but it seems you're ok with letting regex users through. I guess escaping all characters for the regex is more tedious than doing the proper DP algorithm anyway.",
    "codingamerHandle": "86f39b7cda6d832e5c8873e1e905646c7441432",
    "avatar": 16056481834828,
    "elapsedTime": 257466457000
  },
  {
    "commentId": 10794,
    "codingamerId": 2178794,
    "commentableId": 6782869,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 10783,
    "votableId": 6850840,
    "userVoteValue": 0,
    "nickname": "Unihedron",
    "content": "Trying to compile a regex without using possession for test case 6 is, what, O(n^10)?  atomic groups will be necessary to limit the behaviour of backtracking done by most regex implementations, but by the time the user gets to that, they'll probably start getting headaches and hallucinate :D",
    "codingamerHandle": "1d1729a2d8c008c6cf728ee88f1faa6d4978712",
    "avatar": 17500773502453,
    "elapsedTime": 257440139000
  },
  {
    "commentId": 10781,
    "codingamerId": 2130169,
    "commentableId": 6782869,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 10776,
    "votableId": 6847349,
    "userVoteValue": 0,
    "nickname": "CyberLemonade",
    "content": "Okay thanks :)",
    "codingamerHandle": "d8a0152458f424d53995a613b5abea4f9610312",
    "avatar": 57032502077757,
    "elapsedTime": 257479218000
  }
]