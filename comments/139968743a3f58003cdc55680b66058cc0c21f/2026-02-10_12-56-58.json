[
  {
    "commentId": 485089,
    "codingamerId": 5377868,
    "commentableId": 38674304,
    "responseCount": 0,
    "upVotes": 1,
    "downVotes": 1,
    "votableId": 39010944,
    "userVoteValue": 0,
    "nickname": "YALOKGAR",
    "content": "✅ Approved the contribution.\nComment: Well designed combinatorics puzzle. Clear statement, solid test coverage, appropriate difficulty.",
    "codingamerHandle": "71ce77dc02b52055debde214148067dc8687735",
    "onlineSince": 1770727536021,
    "avatar": 157535060876255,
    "elapsedTime": 1738914000
  },
  {
    "commentId": 481030,
    "codingamerId": 3276896,
    "commentableId": 38674304,
    "responseCount": 2,
    "upVotes": 1,
    "downVotes": 0,
    "votableId": 38965826,
    "userVoteValue": 0,
    "nickname": "kozuechan",
    "content": "Modifying the author's solution as follows passes all tests and validators but fails on a custom case.\n\n1. Replace the phi function with `def phi(n): return max(1, n - 1)`. This incorrect phi function works for primes but fails for composites.\n2. Remove all occurrences of `% MOD`.\n3. Replace `* modinv(denom)` with `// denom`.\n4. Replace `* modinv(n)` with `// n`.\n5. Replace `polya(n, list(v))` with `polya(n, list(v)) % MOD`.\n\nCustom case:\n\n16\n1\n1\n1\n1\n2\n2\n2\n2\n3\n3\n3\n3\n4\n4\n4\n4",
    "codingamerHandle": "00ff9c85fcc84fd753d84c98ec18ca0a6986723",
    "avatar": 26189736775264,
    "elapsedTime": 2416846000
  },
  {
    "commentId": 480832,
    "codingamerId": 6940002,
    "commentableId": 38674304,
    "responseCount": 0,
    "upVotes": 1,
    "downVotes": 0,
    "votableId": 38961931,
    "userVoteValue": 0,
    "nickname": "Kk81",
    "content": "✅ Approved the contribution.\nComment: Good puzzle. I saw no issues when reviewing it and I enjoyed learning about Polya enumeration theorem.",
    "codingamerHandle": "9afe8a8fc63a1f62c8e5e04a82b865912000496",
    "avatar": 153094727600262,
    "elapsedTime": 2475474000
  },
  {
    "commentId": 474370,
    "codingamerId": 1179950,
    "commentableId": 38674304,
    "responseCount": 0,
    "upVotes": 1,
    "downVotes": 0,
    "votableId": 38892490,
    "userVoteValue": 0,
    "nickname": "KAKAROT_MPL",
    "content": "✅ Approved the contribution.\nComment: Ok for me!",
    "codingamerHandle": "84c61a4bef55e7727c2017c65d929b1a0599711",
    "avatar": 157814368867610,
    "elapsedTime": 3554592000
  },
  {
    "commentId": 472087,
    "codingamerId": 2874091,
    "commentableId": 38674304,
    "responseCount": 4,
    "upVotes": 1,
    "downVotes": 0,
    "votableId": 38869876,
    "userVoteValue": 0,
    "nickname": "5DN1L",
    "content": "Conceptually, this task is somewhat similar to the puzzle \"N Pearls Necklace\" ( https://www.codingame.com/training/hard/n-pearls-necklace ), which is classified as Hard and currently has a 49% community success rate.\n\nGiven the similarity of the tasks and levels of mathematical reasoning required, and the success rate of the existing puzzle, I would suggest reclassifying this puzzle from Easy to Medium.\n\nFor reference: @TBali's analysis of the difficulty of \"N Pearls Necklace\": https://forum.codingame.com/t/community-puzzle-n-pearls-necklace/196674/4",
    "codingamerHandle": "bbb8f47ea4601179303c20acdbf5fb6c1904782",
    "onlineSince": 1770727666105,
    "avatar": 134264063920528,
    "elapsedTime": 3966181000
  },
  {
    "commentId": 468754,
    "codingamerId": 3232421,
    "commentableId": 38674304,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "votableId": 38840590,
    "userVoteValue": 0,
    "nickname": "User123",
    "content": "This puzzle was previously suggested as a Clash of Code: https://www.codingame.com/contribute/view/137592f0225707fe4383d872cac94433a66a0d",
    "codingamerHandle": "c3b956997f0e142fcaa109d71c0ecd431242323",
    "avatar": 143871801993425,
    "elapsedTime": 4479181000
  },
  {
    "commentId": 472252,
    "codingamerId": 3232421,
    "commentableId": 38674304,
    "responseCount": 0,
    "upVotes": 1,
    "downVotes": 0,
    "parentCommentId": 472087,
    "votableId": 38871804,
    "userVoteValue": 0,
    "nickname": "User123",
    "content": "Thanks @5DN1L. The reason why I chose the Easy classification is precisely due to the searchable problem / formula. I have reclassified the problem as a Medium.",
    "codingamerHandle": "c3b956997f0e142fcaa109d71c0ecd431242323",
    "avatar": 143871801993425,
    "elapsedTime": 3934624000
  },
  {
    "commentId": 481063,
    "codingamerId": 3232421,
    "commentableId": 38674304,
    "responseCount": 0,
    "upVotes": 1,
    "downVotes": 0,
    "parentCommentId": 481030,
    "votableId": 38966135,
    "userVoteValue": 1,
    "nickname": "User123",
    "content": "Thanks @kozuechan. I have generated 3 new test cases (the \"Similar\" cases) with larger and larger GCDs among the frequencies of the various nodes to ensure that the phi() function handles both prime and composite numbers.\n\nApplying the modulo operation at the end of all computation is inconsequential for Python but crucial for typed languages that will face overflow errors due to the large numbers involved. I was giving myself the additional challenge of handling modulo operations as though coding in a typed language. Not necessary for Python, but I learnt about the modinverse along the way.",
    "codingamerHandle": "c3b956997f0e142fcaa109d71c0ecd431242323",
    "avatar": 143871801993425,
    "elapsedTime": 2414018000
  },
  {
    "commentId": 481096,
    "codingamerId": 3276896,
    "commentableId": 38674304,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 481030,
    "votableId": 38966211,
    "userVoteValue": 0,
    "nickname": "kozuechan",
    "content": "I have confirmed that the incorrect solution now fails the test. Thank you.",
    "codingamerHandle": "00ff9c85fcc84fd753d84c98ec18ca0a6986723",
    "avatar": 26189736775264,
    "elapsedTime": 2413410000
  },
  {
    "commentId": 483703,
    "codingamerId": 2874091,
    "commentableId": 38674304,
    "responseCount": 0,
    "upVotes": 1,
    "downVotes": 0,
    "parentCommentId": 472087,
    "votableId": 38996902,
    "userVoteValue": 0,
    "nickname": "5DN1L",
    "content": "In the puzzle, the actual numeric values of the nodes are not meaningful by themselves; they only serve to indicate whether two nodes are equal. Given that the maximum number of nodes is 4000, the second constraint limiting node values to the range from -10⁹ to 10⁹ is broader than necessary.\n\nBecause such a wide range is specified, one would expect it to be more fully utilised. However, the current distribution shows an unbalanced picture:\n\nThe value 0: 1039\n1-digit values (excluding 0): 16204\n2-digit values: 2361\n3-digit values: 1759\n4-digit values: 20\n5-digit values: 3\n6-digit values: 45\n7-digit values: 7\n8-digit values: 56\n9-digit values: 1337\n\nIf it's possible to adjust the cases to achieve a more balanced distribution across value ranges, that'd be great. That said, it's also fine to leave the cases as they are.\n\nThanks.",
    "codingamerHandle": "bbb8f47ea4601179303c20acdbf5fb6c1904782",
    "onlineSince": 1770727666105,
    "avatar": 134264063920528,
    "elapsedTime": 1921030000
  },
  {
    "commentId": 483736,
    "codingamerId": 3232421,
    "commentableId": 38674304,
    "responseCount": 0,
    "upVotes": 1,
    "downVotes": 0,
    "parentCommentId": 472087,
    "votableId": 38997749,
    "userVoteValue": 0,
    "nickname": "User123",
    "content": "I've balanced out the distribution of node values as requested, however, the way I count input distribution of k-digit values seems to differ from your analysis.\n\nHere's the revised distribution:\nNumber of '0' instances: 7\nNumber of 1-digit instances: 68\nNumber of 2-digit instances: 43\nNumber of 3-digit instances: 41\nNumber of 4-digit instances: 58\nNumber of 5-digit instances: 36\nNumber of 6-digit instances: 55\nNumber of 7-digit instances: 32\nNumber of 8-digit instances: 48\nNumber of 9-digit instances: 29\n\nHere's the Python code used to generate this distribution (run using python3 distribution.py < input.txt, with input.txt being the direct concatenation of all input values both in tests and validators):\n\nfrom collections import Counter\n\nN = 19 * 2\ncounts: list[Counter[int]] = []\ndigits = [0] * 10\nfor _ in range(N):\n    counts.append(Counter())\n    for _ in range(int(input())):\n        s = input()\n        counts[-1][int(s)] += 1\n        digits[0 if s == \"0\" else len(s.replace(\"-\", \"\"))] += counts[-1][int(s)] == 1\n\nprint()\nfor i, count in enumerate(counts):\n    q, r = divmod(i, 2)\n    print((\"Test\", \"Validator\")[r], f\"{q + 1}:\", sorted(count.keys()))\n\nprint()\nfor i, frq in enumerate(digits):\n    print(\"Number of\", f\"{i}-digit\" if i else \"'0'\", \"instances:\", frq)\n\nI should also note that the 1-digit numbers were used quite a fair bit towards the end due to input length limits.",
    "codingamerHandle": "c3b956997f0e142fcaa109d71c0ecd431242323",
    "avatar": 143871801993425,
    "elapsedTime": 1910629000
  },
  {
    "commentId": 483769,
    "codingamerId": 2874091,
    "commentableId": 38674304,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 472087,
    "votableId": 38997909,
    "userVoteValue": 0,
    "nickname": "5DN1L",
    "content": "Understood. Thanks!",
    "codingamerHandle": "bbb8f47ea4601179303c20acdbf5fb6c1904782",
    "onlineSince": 1770727666105,
    "avatar": 134264063920528,
    "elapsedTime": 1908899000
  }
]