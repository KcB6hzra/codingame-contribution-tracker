[
  {
    "commentId": 24620,
    "codingamerId": 1687754,
    "commentableId": 12343339,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "votableId": 12430609,
    "userVoteValue": 0,
    "nickname": "cg123",
    "content": "âœ… Approved the contribution.\nComment: Interesting problem.",
    "codingamerHandle": "e1503ab4da5481c50ba7dc820e5799324577861",
    "avatar": 11844752916555,
    "elapsedTime": 190998075000
  },
  {
    "commentId": 24619,
    "codingamerId": 1687754,
    "commentableId": 12343339,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "votableId": 12430604,
    "userVoteValue": 0,
    "nickname": "cg123",
    "content": "I didn't notice timer issue, neither in Java nor in C.\nSo it's ok for me, good puzzle ;)",
    "codingamerHandle": "e1503ab4da5481c50ba7dc820e5799324577861",
    "avatar": 11844752916555,
    "elapsedTime": 190998130000
  },
  {
    "commentId": 24616,
    "codingamerId": 2387233,
    "commentableId": 12343339,
    "responseCount": 2,
    "upVotes": 0,
    "downVotes": 0,
    "votableId": 12429630,
    "userVoteValue": 0,
    "nickname": "SinOfWrath",
    "content": "I like this puzzle a lot but the solution overflows for signed ints for the last validator and not the corresponding test case. Can you decrease it so every language is dafe to use?\n\nIf that happens I am happy to approve it, if no one else does it before me.\n\nEdit: unsigned int would actually solve it, but I think we should aim for all language support. Maybe decrease n upper value by an order of 2.\nlog2(2851087360)=31.40...",
    "codingamerHandle": "c52068985d3835317974dc0dad47019a3327832",
    "avatar": 41207346605394,
    "elapsedTime": 191007339000
  },
  {
    "commentId": 24612,
    "codingamerId": 2130169,
    "commentableId": 12343339,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 1,
    "votableId": 12427896,
    "userVoteValue": 0,
    "nickname": "CyberLemonade",
    "content": "âœ… Approved the contribution.\nComment: Loved it! Keep up the mathematical puzzles please ðŸ˜€",
    "codingamerHandle": "d8a0152458f424d53995a613b5abea4f9610312",
    "avatar": 57032502077757,
    "elapsedTime": 191023259000
  },
  {
    "commentId": 24605,
    "codingamerId": 3230794,
    "commentableId": 12343339,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "votableId": 12421154,
    "userVoteValue": 0,
    "nickname": "tutubalin",
    "content": "âœ… Approved the contribution.\nComment: It is a nice problem, and puzzle is well prepared.",
    "codingamerHandle": "fcf5c75ef75e383465760cad6ef7487a4970323",
    "avatar": 25714480415254,
    "elapsedTime": 191094154000
  },
  {
    "commentId": 24617,
    "codingamerId": 1962352,
    "commentableId": 12343339,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 24616,
    "votableId": 12429860,
    "userVoteValue": 0,
    "nickname": "DPAmar",
    "content": "I know. The goal was actually to get as close to 2^32 as possible, as per explicit constraint : result <2^32\n\nOn the other hand, this means that max N has to be between  2^28 and 2^29 (cosâ€™ result is 29*2^28 and 29>16 and 28*2^27 with 28<32)\nAnyway, it is definitely possible with a damn fast code to go through the whole 2^29 range I guess. So decreasing  the limit is like having a completely different problem...",
    "codingamerHandle": "1aa3b57d313d36f2b421bf8a30a7dfef2532691",
    "avatar": 56994389567033,
    "elapsedTime": 191005312000
  },
  {
    "commentId": 24618,
    "codingamerId": 1962352,
    "commentableId": 12343339,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 24616,
    "votableId": 12430046,
    "userVoteValue": 0,
    "nickname": "DPAmar",
    "content": "Edit: just tested a C code with the fast bit counting function ( the \"x & (x-1)\" trick)\nwith N = 2^28 result comes in less than 10 seconds (on a \"mid 2013\" MBA)\n\nint count(int n)\n{\n    int res=0, o=n;\n    while(o){\n      res++;\n      o=o & (o-1);\n    }\n    return res;\n}\n\nint main()\n{\n    int n = 1<<28, res = 0;\n    for(int i=0; i<=n; i++)\n        res += count(i);\n    return 0;\n}\n\ntime ./a.out\nreal 0m9.774s\nuser 0m9.742s\nsys 0m0.013s\n\nLast test case : 208823295 ==> 8 seconds\nand to avoid overflows (2^31) limit is 2^27 ==> 5 seconds\n\nNot sure how long the CG limit is, but there is already a flaw in problem complexity if you are a C developer.",
    "codingamerHandle": "1aa3b57d313d36f2b421bf8a30a7dfef2532691",
    "avatar": 56994389567033,
    "elapsedTime": 191003717000
  }
]