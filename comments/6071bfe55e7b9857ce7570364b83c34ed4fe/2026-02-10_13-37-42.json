[
  {
    "commentId": 41589,
    "codingamerId": 1607522,
    "commentableId": 16548335,
    "responseCount": 1,
    "upVotes": 0,
    "downVotes": 0,
    "votableId": 17348131,
    "userVoteValue": 0,
    "nickname": "RoboStac",
    "content": "✅ Approved the contribution.\nComment: Interesting problem",
    "codingamerHandle": "771485904355a5f6267beb29429cad302257061",
    "avatar": 11333369102997,
    "elapsedTime": 155356298000
  },
  {
    "commentId": 41585,
    "codingamerId": 4208158,
    "commentableId": 16548335,
    "responseCount": 6,
    "upVotes": 1,
    "downVotes": 0,
    "votableId": 17347829,
    "userVoteValue": 0,
    "nickname": "Tiouz",
    "content": "It would be very interesting to increase the size of a and b even more. It is possible to compute one fibonacci term using quick exponent of a matrix. The computations can be done modulo a value, and the sum can be factorized so clearly with a < 2^1000 and b-a < 1000000 it would be possible to compute. I am not sure if it is possible for big values of b-a",
    "codingamerHandle": "6089b68d27cfd6f7fd9250dbdeebb27d8518024",
    "avatar": 72554823729381,
    "elapsedTime": 155357911000
  },
  {
    "commentId": 41579,
    "codingamerId": 3845610,
    "commentableId": 16548335,
    "responseCount": 2,
    "upVotes": 0,
    "downVotes": 0,
    "votableId": 17347275,
    "userVoteValue": 0,
    "nickname": "pardouin",
    "content": "✅ Approved the contribution.\nComment: Good puzzle, tested my own code and it works well.",
    "codingamerHandle": "f5e3b2911a0a16192867d634937546a60165483",
    "avatar": 60364063762936,
    "elapsedTime": 155361514000
  },
  {
    "commentId": 41568,
    "codingamerId": 3230794,
    "commentableId": 16548335,
    "responseCount": 1,
    "upVotes": 0,
    "downVotes": 0,
    "votableId": 17344407,
    "userVoteValue": 0,
    "nickname": "tutubalin",
    "content": "✅ Approved the contribution.\nComment: Good puzzle about the proper way to calculate Fibonacci numbers",
    "codingamerHandle": "fcf5c75ef75e383465760cad6ef7487a4970323",
    "avatar": 25714480415254,
    "elapsedTime": 155393401000
  },
  {
    "commentId": 39804,
    "codingamerId": 4084909,
    "commentableId": 16548335,
    "responseCount": 7,
    "upVotes": 0,
    "downVotes": 0,
    "votableId": 16970838,
    "userVoteValue": 0,
    "nickname": "bluehipy",
    "content": "At the test case Big Numbers you are expecting that F_20 + ... + F_100 is  NOT divisible by 4\n\nOn my implementation the sum is: 927372692193079000000\nwhich looks very divisible by 4 :)\n\nIf I am not wrong",
    "codingamerHandle": "71f1d63c5e71a957620a3afe71adf2f79094804",
    "avatar": 59108125311613,
    "elapsedTime": 158024434000
  },
  {
    "commentId": 39799,
    "codingamerId": 4084909,
    "commentableId": 16548335,
    "responseCount": 1,
    "upVotes": 1,
    "downVotes": 0,
    "votableId": 16969512,
    "userVoteValue": 0,
    "nickname": "bluehipy",
    "content": "I think the example should follow the default input/output structure for more clarity :)",
    "codingamerHandle": "71f1d63c5e71a957620a3afe71adf2f79094804",
    "avatar": 59108125311613,
    "elapsedTime": 158034075000
  },
  {
    "commentId": 38352,
    "codingamerId": 1407583,
    "commentableId": 16548335,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "votableId": 16637674,
    "userVoteValue": 0,
    "nickname": "OPi",
    "content": "The Python solution contains several implementations. The function fibonacci_pair() is the right solution, enough efficient. It is possible to do better but it is enough.\n\nFunctions fibonacci_pair_iteration() and fibonacci_pair_iteration_memo() can be used to check that these implementations are not enough efficient. They failed on the two last test cases.",
    "codingamerHandle": "3b9f76c06bfe94afb9608048e12411ab3857041",
    "avatar": 4287227197454,
    "elapsedTime": 160501954000
  },
  {
    "commentId": 38351,
    "codingamerId": 1407583,
    "commentableId": 16548335,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "votableId": 16637631,
    "userVoteValue": 0,
    "nickname": "OPi",
    "content": "In addition to the Python solution this challenge also tested in C, C++ and Objective-C with this C code:\nhttps://bitbucket.org/OPiMedia/codingame-divisibility-of-fibonacci-numbers-sum/src/master/C/solution.c\n\nAnd in JavaScript with:\nhttps://bitbucket.org/OPiMedia/codingame-divisibility-of-fibonacci-numbers-sum/src/master/JavaScript/solution.js",
    "codingamerHandle": "3b9f76c06bfe94afb9608048e12411ab3857041",
    "avatar": 4287227197454,
    "elapsedTime": 160502150000
  },
  {
    "commentId": 39805,
    "codingamerId": 1407583,
    "commentableId": 16548335,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 39799,
    "votableId": 16970861,
    "userVoteValue": 0,
    "nickname": "OPi",
    "content": "I improved the example. I think it is more clear now. Thanks.\nI also modified the first test case. Before that nb=b=12. It could be ambigue. Now nb=13.",
    "codingamerHandle": "3b9f76c06bfe94afb9608048e12411ab3857041",
    "avatar": 4287227197454,
    "elapsedTime": 158024277000
  },
  {
    "commentId": 39806,
    "codingamerId": 1407583,
    "commentableId": 16548335,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 39804,
    "votableId": 16970871,
    "userVoteValue": 0,
    "nickname": "OPi",
    "content": "I will check that... But I guess you are a wrong value due to an overflow. I check...",
    "codingamerHandle": "3b9f76c06bfe94afb9608048e12411ab3857041",
    "avatar": 4287227197454,
    "elapsedTime": 158024203000
  },
  {
    "commentId": 41570,
    "codingamerId": 1407583,
    "commentableId": 16548335,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 41568,
    "votableId": 17345966,
    "userVoteValue": 0,
    "nickname": "OPi",
    "content": "Thanks :)",
    "codingamerHandle": "3b9f76c06bfe94afb9608048e12411ab3857041",
    "avatar": 4287227197454,
    "elapsedTime": 155371562000
  },
  {
    "commentId": 41594,
    "codingamerId": 1407583,
    "commentableId": 16548335,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 41579,
    "votableId": 17351203,
    "userVoteValue": 0,
    "nickname": "OPi",
    "content": "Thanks :)\nIn which language?",
    "codingamerHandle": "3b9f76c06bfe94afb9608048e12411ab3857041",
    "avatar": 4287227197454,
    "elapsedTime": 155338984000
  },
  {
    "commentId": 41586,
    "codingamerId": 3230794,
    "commentableId": 16548335,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 41585,
    "votableId": 17348022,
    "userVoteValue": 0,
    "nickname": "tutubalin",
    "content": "I would say this puzzle is already challenging enough.\nNo need to force players to use BigInteger and similar types.",
    "codingamerHandle": "fcf5c75ef75e383465760cad6ef7487a4970323",
    "avatar": 25714480415254,
    "elapsedTime": 155356989000
  },
  {
    "commentId": 41593,
    "codingamerId": 1407583,
    "commentableId": 16548335,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 41589,
    "votableId": 17351196,
    "userVoteValue": 0,
    "nickname": "OPi",
    "content": "Thanks :)",
    "codingamerHandle": "3b9f76c06bfe94afb9608048e12411ab3857041",
    "avatar": 4287227197454,
    "elapsedTime": 155339011000
  },
  {
    "commentId": 41588,
    "codingamerId": 3845610,
    "commentableId": 16548335,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 41585,
    "votableId": 17348127,
    "userVoteValue": 0,
    "nickname": "pardouin",
    "content": "Any F_n can be calculated in O(log(n)) with a trick similar to fast exponentiation that relies on divisions by 2.\nAnd there's a trick for the sum that only requires to compute TWO values of F_n so it's O(log(n)) too, without any matrix or what, with only basic operations.\nSo you could in theory use VERY high numbers but I agree with tutubalin, it doesn't bring much and would force some languages to redefine modular multiplication to not overflow so it adds difficulty to some languages for nothing, the puzzle is good as it is now.",
    "codingamerHandle": "f5e3b2911a0a16192867d634937546a60165483",
    "avatar": 60364063762936,
    "elapsedTime": 155356325000
  },
  {
    "commentId": 41598,
    "codingamerId": 1407583,
    "commentableId": 16548335,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 41585,
    "votableId": 17351598,
    "userVoteValue": 0,
    "nickname": "OPi",
    "content": "\"Any F_n can be calculated in O(log(n)) with a trick similar to fast exponentiation\"\nYes, this is exactly the goal of this challenge.\nI designed test cases to require this complexity.\n\n\"a trick for the sum that only requires to compute TWO values of F_n so it's O(log(n)) too\"\nMy solution in Python do that in fibonacci_sum(), but only to double check results. Combine the two tricks is I think an optimal solution, but this is not required to complete this challenge.\n\nNote that the log(n) complexity is not the real complexity of the general computation, because the result increase exponentially. log(n) is the number of steps without regard the time of elementary operations.\n\nThe question of the divisibility is way to allow modulo computation. It is a way to limit the size of results. Big values are required to force to found the log(n) way, but big values are difficult because the exponentionnal increasing of values and languages limitations. Big integers are nice but I found that too language dependent.\n\nSo in summary, this challenge to be solved require modulo computation and algorithm to compute a Fibonacci number in a log(n) steps.\nAfter that it is possible to improve the computation of the sum but it is not required.",
    "codingamerHandle": "3b9f76c06bfe94afb9608048e12411ab3857041",
    "avatar": 4287227197454,
    "elapsedTime": 155336824000
  },
  {
    "commentId": 41601,
    "codingamerId": 3230794,
    "commentableId": 16548335,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 41585,
    "votableId": 17352066,
    "userVoteValue": 0,
    "nickname": "tutubalin",
    "content": "I'm using log2(n) algorithm, which requires only 2 multiplications per iteration. Probably that's the most efficient algorithm for Fibonacci numbers.",
    "codingamerHandle": "fcf5c75ef75e383465760cad6ef7487a4970323",
    "avatar": 25714480415254,
    "elapsedTime": 155334297000
  },
  {
    "commentId": 41602,
    "codingamerId": 1407583,
    "commentableId": 16548335,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 41585,
    "votableId": 17352119,
    "userVoteValue": 0,
    "nickname": "OPi",
    "content": "Yes, but these numbers increase exponentially, so their sizes increase linearly.",
    "codingamerHandle": "3b9f76c06bfe94afb9608048e12411ab3857041",
    "avatar": 4287227197454,
    "elapsedTime": 155334033000
  },
  {
    "commentId": 41603,
    "codingamerId": 3230794,
    "commentableId": 16548335,
    "responseCount": 0,
    "upVotes": 1,
    "downVotes": 0,
    "parentCommentId": 41585,
    "votableId": 17352171,
    "userVoteValue": 0,
    "nickname": "tutubalin",
    "content": "I mean log2(n) iterations. Of course, the real time consuming thing is multiplication as numbers grow fast.\nThough in this case we calculate by modulo, so we may assume that 1 iteration is O(1).",
    "codingamerHandle": "fcf5c75ef75e383465760cad6ef7487a4970323",
    "avatar": 25714480415254,
    "elapsedTime": 155333768000
  },
  {
    "commentId": 41597,
    "codingamerId": 3845610,
    "commentableId": 16548335,
    "responseCount": 0,
    "upVotes": 1,
    "downVotes": 0,
    "parentCommentId": 41579,
    "votableId": 17351323,
    "userVoteValue": 0,
    "nickname": "pardouin",
    "content": "Python. I use the log2(n) method but I in an ascending DP way instead of a descending recursion.",
    "codingamerHandle": "f5e3b2911a0a16192867d634937546a60165483",
    "avatar": 60364063762936,
    "elapsedTime": 155338326000
  },
  {
    "commentId": 39807,
    "codingamerId": 1407583,
    "commentableId": 16548335,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 39804,
    "votableId": 16970874,
    "userVoteValue": 0,
    "nickname": "OPi",
    "content": "Which language use you?",
    "codingamerHandle": "3b9f76c06bfe94afb9608048e12411ab3857041",
    "avatar": 4287227197454,
    "elapsedTime": 158024167000
  },
  {
    "commentId": 39808,
    "codingamerId": 1407583,
    "commentableId": 16548335,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 39804,
    "votableId": 16970944,
    "userVoteValue": 0,
    "nickname": "OPi",
    "content": "I found  927372692193078988230.\nSo your 927372692193079000000 is probably rounded due to an overflow.\nThis is the first difficulty for this challenge. You don't have to compute the exact sum. ;-)",
    "codingamerHandle": "3b9f76c06bfe94afb9608048e12411ab3857041",
    "avatar": 4287227197454,
    "elapsedTime": 158023751000
  },
  {
    "commentId": 39810,
    "codingamerId": 1407583,
    "commentableId": 16548335,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 39804,
    "votableId": 16970991,
    "userVoteValue": 0,
    "nickname": "OPi",
    "content": "I double checked with a direct formula. So I confirm that\nF_20 + ... + F_100 = 927372692193078988230.",
    "codingamerHandle": "3b9f76c06bfe94afb9608048e12411ab3857041",
    "avatar": 4287227197454,
    "elapsedTime": 158023459000
  },
  {
    "commentId": 39811,
    "codingamerId": 1407583,
    "commentableId": 16548335,
    "responseCount": 0,
    "upVotes": 1,
    "downVotes": 0,
    "parentCommentId": 39804,
    "votableId": 16971027,
    "userVoteValue": 0,
    "nickname": "OPi",
    "content": "I found this list of the 300 first Fibonacci numbers and their factorization:\nhttp://www.maths.surrey.ac.uk/hosted-sites/R.Knott/Fibonacci/fibtable.html#100\nI will add the link to the statement.",
    "codingamerHandle": "3b9f76c06bfe94afb9608048e12411ab3857041",
    "avatar": 4287227197454,
    "elapsedTime": 158023246000
  },
  {
    "commentId": 39846,
    "codingamerId": 4084909,
    "commentableId": 16548335,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 39804,
    "votableId": 16980487,
    "userVoteValue": 0,
    "nickname": "bluehipy",
    "content": "Thanks for taking the time to check!\n\nMy test used JS and there is no exception triggered but you are probably right about the value being wrong.\n\nMaybe I ll try again in python ;)",
    "codingamerHandle": "71f1d63c5e71a957620a3afe71adf2f79094804",
    "avatar": 59108125311613,
    "elapsedTime": 157948861000
  },
  {
    "commentId": 39856,
    "codingamerId": 1407583,
    "commentableId": 16548335,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 39804,
    "votableId": 16983875,
    "userVoteValue": 0,
    "nickname": "OPi",
    "content": "My main solution is in Python but I also checked in C and JavaScript. (See links in other comments.)\nInstead to compute the exact sum you need to find an other way. Else you can't solve the bigger test cases. They designed to force to find 2 ideas...",
    "codingamerHandle": "3b9f76c06bfe94afb9608048e12411ab3857041",
    "avatar": 4287227197454,
    "elapsedTime": 157930964000
  }
]