[
  {
    "commentId": 120739,
    "codingamerId": 5505967,
    "commentableId": 29130864,
    "responseCount": 0,
    "upVotes": 1,
    "downVotes": 0,
    "votableId": 29468485,
    "userVoteValue": 0,
    "nickname": "JohnG.A",
    "content": "✅ Approved the contribution.\nComment: It's an understandable moderate difficult problem which is interesting to solve",
    "codingamerHandle": "cafb4b7ea7ce4b4073c631ae07422ae87695055",
    "elapsedTime": 85778961000
  },
  {
    "commentId": 120702,
    "codingamerId": 5444472,
    "commentableId": 29130864,
    "responseCount": 0,
    "upVotes": 1,
    "downVotes": 0,
    "votableId": 29465061,
    "userVoteValue": 0,
    "nickname": "PatrickGPT",
    "content": "✅ Approved the contribution.\nComment: I like how this clash is harder than it appears. That's generally something good with these unexpected clashes.",
    "codingamerHandle": "f8ad6219cd08f7917e2fea30f791f8552744445",
    "avatar": 105170388187193,
    "elapsedTime": 85794967000
  },
  {
    "commentId": 119879,
    "codingamerId": 5443984,
    "commentableId": 29130864,
    "responseCount": 1,
    "upVotes": 1,
    "downVotes": 0,
    "votableId": 29400567,
    "userVoteValue": 0,
    "nickname": "baltimoore",
    "content": "The NATO alphabet replacement certainly seems to be easy to do with simple regex manipulations, but the spacing requirement makes it need a loop instead, to check if the previous word was in the alphabet. Not sure I could figure it out under 5 mins though, lol. Still, I like the idea in general.",
    "codingamerHandle": "2731afdd0df7883527b6a26253309bf94893445",
    "avatar": 104512284800413,
    "elapsedTime": 86253706000
  },
  {
    "commentId": 119153,
    "codingamerId": 5484719,
    "commentableId": 29130864,
    "responseCount": 0,
    "upVotes": 1,
    "downVotes": 0,
    "votableId": 29360345,
    "userVoteValue": 0,
    "nickname": "DirtyMagic",
    "content": "✅ Approved the contribution.\nComment: It's probably more on the hard side for Clash standards, but definitely solvable in less than 5 min in Python.",
    "codingamerHandle": "38d2a402efe7bf55565ba8fb619a8ae99174845",
    "avatar": 104569189183232,
    "elapsedTime": 86514045000
  },
  {
    "commentId": 117705,
    "codingamerId": 3479792,
    "commentableId": 29130864,
    "responseCount": 0,
    "upVotes": 2,
    "downVotes": 0,
    "votableId": 29264037,
    "userVoteValue": 0,
    "nickname": "StepBack13",
    "content": "Credit to Lisa-Has-Ideas for the original version. I have created an inverse version with her permission. :)\n\nOriginal here: https://www.codingame.com/contribute/view/553895f9b0ff11e1b6e3322281db1638addbe",
    "codingamerHandle": "da2fe4fbf3c0ab008c6dcf304920ec602979743",
    "avatar": 33990586394707,
    "elapsedTime": 87205421000
  },
  {
    "commentId": 119946,
    "codingamerId": 3479792,
    "commentableId": 29130864,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 119879,
    "votableId": 29402287,
    "userVoteValue": 0,
    "nickname": "StepBack13",
    "content": "The spacing definitely complicates things, but it's possible to do the whole algorithm with just regex global substitutions and some conditional logic about what to do if the thing you substitute ends with a space.\nOf course the substitution regex would need to include all 26 NATO alphabet words as possible matches though. /((Alpha|Bravo|...) )+/g",
    "codingamerHandle": "da2fe4fbf3c0ab008c6dcf304920ec602979743",
    "avatar": 33990586394707,
    "elapsedTime": 86241680000
  }
]