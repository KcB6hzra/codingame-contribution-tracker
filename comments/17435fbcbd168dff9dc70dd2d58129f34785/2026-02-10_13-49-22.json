[
  {
    "commentId": 261878,
    "codingamerId": 2874091,
    "commentableId": 9186745,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "votableId": 35048757,
    "userVoteValue": 0,
    "nickname": "5DN1L",
    "content": "I've changed the upper limit of N to 1000 in Constraints section just now (several players raised the issue in the comments below). Also did a few minor edits.",
    "codingamerHandle": "bbb8f47ea4601179303c20acdbf5fb6c1904782",
    "onlineSince": 1770727666105,
    "avatar": 134264063920528,
    "elapsedTime": 43657861000
  },
  {
    "commentId": 24253,
    "codingamerId": 2130169,
    "commentableId": 9186745,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "votableId": 12288374,
    "userVoteValue": 0,
    "nickname": "CyberLemonade",
    "content": "The problem is fun, but the constraints are misleading. My program gets stack overflow at N = 8200, so it isn't an optimal algorithm. But largest test is 256.",
    "codingamerHandle": "d8a0152458f424d53995a613b5abea4f9610312",
    "avatar": 57032502077757,
    "elapsedTime": 192611519000
  },
  {
    "commentId": 15749,
    "codingamerId": 301922,
    "commentableId": 9186745,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 1,
    "votableId": 9361596,
    "userVoteValue": 0,
    "nickname": "tyrcho",
    "content": "did you notice that the result is always the same when N > 70 ?\nyou're right, I should have implemented this optimization in the proposed solution, I was a bit lazy and did not test with numbers above 300.",
    "codingamerHandle": "e30e2eaed69f0747e8826dbf32015ea1229103",
    "avatar": 1742081719876,
    "elapsedTime": 228116879000
  },
  {
    "commentId": 15744,
    "codingamerId": 1500515,
    "commentableId": 9186745,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "votableId": 9357494,
    "userVoteValue": 0,
    "nickname": "eulerscheZahl",
    "content": "Inputs only go up to 255, I'm disappointed.\nYour proposed solution even times out on the higher constraint.",
    "codingamerHandle": "8374201b6f1d19eb99d61c80351465b65150051",
    "avatar": 43135502422075,
    "elapsedTime": 228172410000
  },
  {
    "commentId": 15489,
    "codingamerId": 1536085,
    "commentableId": 9186745,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "votableId": 9280094,
    "userVoteValue": 0,
    "nickname": "Wladek",
    "content": "And again, description says N can be up to 100000 and the maximum test is mere 255...",
    "codingamerHandle": "8fd7845a80313eea2cb383a1b2ec16155806351",
    "avatar": 7749586185627,
    "elapsedTime": 229056446000
  },
  {
    "commentId": 15451,
    "codingamerId": 154906,
    "commentableId": 9186745,
    "responseCount": 5,
    "upVotes": 1,
    "downVotes": 0,
    "votableId": 9269354,
    "userVoteValue": 0,
    "nickname": "JBM",
    "content": "All validators are harder than the corresponding tests Bad! Please swap.\n\nI agreed with ctd about key #6, but it appears you've already fixed that.\n\nWhile the example clarifies most of the innards, I do agree with Wei-1 the \"rules\" are a bit vague. A proper specification would be appreciated wrt the following points:\n* what's \"near\"\n* repeatability of previous digits\n\nApart from that, cool problem, thanks!",
    "codingamerHandle": "0d71f9df5da706f9f77c07c34d12480e609451",
    "elapsedTime": 229170223000
  },
  {
    "commentId": 15449,
    "codingamerId": 1733593,
    "commentableId": 9186745,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "votableId": 9268219,
    "userVoteValue": 0,
    "nickname": "Wei-1",
    "content": "From the code, we see that choosing 5 will not prevent the next player from selecting any number other than 5.\nI think this should also be stated in the question.",
    "codingamerHandle": "3f4adfba53d1ae216fb40f9c51b72c843953371",
    "avatar": 12250588953001,
    "elapsedTime": 229188568000
  },
  {
    "commentId": 15434,
    "codingamerId": 1110733,
    "commentableId": 9186745,
    "responseCount": 4,
    "upVotes": 2,
    "downVotes": 0,
    "votableId": 9259176,
    "userVoteValue": 0,
    "nickname": "crashtestdummy",
    "content": "I've not finished a test program yet and Scala is only synonymous with headaches as far as I'm concerned, but your neighbour list for key #6 seems a bit off (it seems to have a 7 where I'd expect a 9). I wonder if that might change the test results?\n\nAlso I wonder if that deserves a \"hard\" difficulty rating. There are some apparently similar branch and bound problems in \"medium\" level already.",
    "codingamerHandle": "c0f03664bd43bf3dcb8bed1b2f0e56803370111",
    "avatar": 2887336002045,
    "elapsedTime": 229284208000
  },
  {
    "commentId": 15432,
    "codingamerId": 1569823,
    "commentableId": 9186745,
    "responseCount": 1,
    "upVotes": 0,
    "downVotes": 0,
    "votableId": 9258020,
    "userVoteValue": 0,
    "nickname": "Niako",
    "content": "Great idea! I would not consider that as a \"Hard\" problem (relatively simple dynamic programming). A harder variant might be for instance to play on several calculators at the same time (at each turn, a player picks a calculator among those that still display an N>=0 and plays).\n\nAlso, it's a shame that for any N>=66, the first player only has to play any corner (which obviously forbids his opponent to play a corner in the next turn) and that for any N>=12, the first player can simply play 1. But that's the way it is ;-) (we can hardly imagine such a simple game turning out to be very deep).",
    "codingamerHandle": "eb89cbdf69d07106c84edf1d191caaf33289651",
    "avatar": 11911528647474,
    "elapsedTime": 229294906000
  },
  {
    "commentId": 15426,
    "codingamerId": 2716329,
    "commentableId": 9186745,
    "responseCount": 2,
    "upVotes": 0,
    "downVotes": 0,
    "votableId": 9255610,
    "userVoteValue": 0,
    "nickname": "Recher",
    "content": "I am not sure to understand how a winning move can be deducted with high numbers such as 138 or 256.\n\nThere can have so much possibilities along the next turns, depending on what the opponent players chooses.\n\nCan you add a solution, or an explanation in the comments, please ?",
    "codingamerHandle": "496bc5e8fd0fde14aacaa21b21b1d1fc9236172",
    "avatar": 19985093844366,
    "elapsedTime": 229314344000
  },
  {
    "commentId": 15447,
    "codingamerId": 301922,
    "commentableId": 9186745,
    "responseCount": 0,
    "upVotes": 1,
    "downVotes": 0,
    "parentCommentId": 15426,
    "votableId": 9267553,
    "userVoteValue": 0,
    "nickname": "tyrcho",
    "content": "Here is how you solve it by hand:\n- with N=1, only 1 is a winning move\n- with N=2, 2 is winning, and 1 brings you back to N=1 but with 1 not playable.\n- with N=2, 3 is winning, 1 brings you back to 2 and 2 brings you back to 1\n- you can construct a list or array of all situations up to N in time 0(N) since at each step you only need to consider the 9 possible moves and which situation they put you in. That's what Niako refers to with \"dynamic programming\".\nHere is what I scribbled by hand:\nhttps://photos.app.goo.gl/HJLH6VLgeCt2sfWt5\n\nAnd here is an explaination (in French, p4) http://www.lepetitarchimede.fr/pa/PA71-72.pdf",
    "codingamerHandle": "e30e2eaed69f0747e8826dbf32015ea1229103",
    "avatar": 1742081719876,
    "elapsedTime": 229194211000
  },
  {
    "commentId": 15446,
    "codingamerId": 301922,
    "commentableId": 9186745,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 15432,
    "votableId": 9267518,
    "userVoteValue": 0,
    "nickname": "tyrcho",
    "content": "I updated the difficulty to Medium, I was unsure about that.",
    "codingamerHandle": "e30e2eaed69f0747e8826dbf32015ea1229103",
    "avatar": 1742081719876,
    "elapsedTime": 229194482000
  },
  {
    "commentId": 15445,
    "codingamerId": 301922,
    "commentableId": 9186745,
    "responseCount": 0,
    "upVotes": 1,
    "downVotes": 0,
    "parentCommentId": 15434,
    "votableId": 9267510,
    "userVoteValue": 0,
    "nickname": "tyrcho",
    "content": "You're completely right, good catch ! I've fixed the neighbour list and checked the test scenarios.",
    "codingamerHandle": "e30e2eaed69f0747e8826dbf32015ea1229103",
    "avatar": 1742081719876,
    "elapsedTime": 229194562000
  },
  {
    "commentId": 15452,
    "codingamerId": 1110733,
    "commentableId": 9186745,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 15451,
    "votableId": 9269908,
    "userVoteValue": 0,
    "nickname": "crashtestdummy",
    "content": "You can solve this in O(N) by computing the winning sequences of N+1 using the winning sequences of [N-9...N], so execution time is not really an issue.\n\nA brute-force approach would be in about O(5^N) (assuming you have an average of 5 neighbours per key). That would timeout real fast, probably before N reached even 10.\nI suppose some people could try to do some suboptimal cuts and end up with speedier but still not O(N) code, but the idea is rather to find the proper algorithm I guess.\n\nI agree it would be nicer to swap the two values as a matter of principle, but I doubt a program able to solve for 138 will have any serious difficulty reaching 256 or even 1000.\n\nI would rather push the limit of N to 10 000 or so, to let people know the brute force approach is not the solution (my not particularly optimized C++ code times out around 150 000, probably spending most of its time reallocating a useless huge array since I keep all the winning moves in memory while only the last 10 matter).\n\nThe main issue I see is that the sequence of winning keys becomes a constant (the 4 corner keys)  for N > 60 or so. It's not by chance that N=138 and N=256 yield the same result.\nI proposed to change the rules of selection for the next key so that we get at least a periodic result (repeating every 10 values of N).",
    "codingamerHandle": "c0f03664bd43bf3dcb8bed1b2f0e56803370111",
    "avatar": 2887336002045,
    "elapsedTime": 229160054000
  },
  {
    "commentId": 15466,
    "codingamerId": 154906,
    "commentableId": 9186745,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 15451,
    "votableId": 9273333,
    "userVoteValue": 0,
    "nickname": "JBM",
    "content": "Just because you *can* solve linearly doesn't mean it's going to be every one's first attempt. It's mostly a matter of principle at this point.",
    "codingamerHandle": "0d71f9df5da706f9f77c07c34d12480e609451",
    "elapsedTime": 229129574000
  },
  {
    "commentId": 15467,
    "codingamerId": 1110733,
    "commentableId": 9186745,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 15451,
    "votableId": 9274045,
    "userVoteValue": 0,
    "nickname": "crashtestdummy",
    "content": "Yes, I agree with that.\nI just meant it could be better to increase N max value so that people realize there is a linear solution to be found instead of writing lots of complicated code leading to a dead end.",
    "codingamerHandle": "c0f03664bd43bf3dcb8bed1b2f0e56803370111",
    "avatar": 2887336002045,
    "elapsedTime": 229124659000
  },
  {
    "commentId": 15472,
    "codingamerId": 301922,
    "commentableId": 9186745,
    "responseCount": 0,
    "upVotes": 1,
    "downVotes": 0,
    "parentCommentId": 15451,
    "votableId": 9275966,
    "userVoteValue": 0,
    "nickname": "tyrcho",
    "content": "Thanks for the feedback !\n\nWhat I changed :\n- I detailed the rules in the end, in addition to the example it should be clear enough now.\n- I swapped tests and validators.\n- I changed max N in the constraints and added the tag \"dynamic programming\" to hint about avoid brute force solutions.\n\nI'm not going to change the rules for selecting allowed next keys. \nThis would make a different problem and I like the idea that it's visually clear by looking at the numpad which moves are allowed. In addition I have no idea what kind of rules would give this property of periodic result, and I don't think it would change in any meaningful way the implementation.",
    "codingamerHandle": "e30e2eaed69f0747e8826dbf32015ea1229103",
    "avatar": 1742081719876,
    "elapsedTime": 229108035000
  },
  {
    "commentId": 15474,
    "codingamerId": 1110733,
    "commentableId": 9186745,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 15451,
    "votableId": 9276188,
    "userVoteValue": 0,
    "nickname": "crashtestdummy",
    "content": "The implementation will not change except for the neighbouring keys list.\nAn alternative key selection method would simply make it more difficult to hard-code a solution.\nThe rule \"you can't reuse keys in the same column\" is pretty simple to explain.\nIt corresponds to these neighbour lists:\n    {2,3,5,6,8,9}, // 1\n    {1,4,7,3,6,9},\n    {1,2,4,5,7,8},\n    {2,3,5,6,8,9},\n    {1,4,7,3,6,9},\n    {1,2,4,5,7,8},\n    {2,3,5,6,8,9},\n    {1,4,7,3,6,9},\n    {1,2,4,5,7,8} // 9\nand gives this pattern:\n100: 0 0 0 0 0 0 0 0 0\n101: 1 0 0 1 0 0 1 0 0\n102: 1 1 1 0 0 1 0 0 1\n103: 0 0 1 0 0 0 0 0 0\n104: 0 0 0 1 0 0 1 0 0\n105: 1 0 0 1 1 1 0 0 1\n106: 0 0 1 0 0 1 0 0 0\n107: 0 0 0 0 0 0 1 0 0\n108: 1 0 0 1 0 0 1 1 1\n109: 0 0 1 0 0 1 0 0 1\nYou just have to provide an output in case no winning move is available (displaying \"NOTHING\" instead of a blank output or something like that).\n\nYou can do the same with rows, but apparently you get immediately a periodic sequence. When using colums you get a random-looking mess for at least a few values before the sequence emerges.\n\nPersonally I don't really care about people brute-forcing their way through validators, keeping the current key selection rule is fine with me.\nI just provided an alternative in case people would find the validators too easy to fool :)",
    "codingamerHandle": "c0f03664bd43bf3dcb8bed1b2f0e56803370111",
    "avatar": 2887336002045,
    "elapsedTime": 229106636000
  },
  {
    "commentId": 15448,
    "codingamerId": 1569823,
    "commentableId": 9186745,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 15434,
    "votableId": 9267914,
    "userVoteValue": 0,
    "nickname": "Niako",
    "content": "Maybe you could also add a few more testcases as this tends to prove that the current ones might be a bit too weak.",
    "codingamerHandle": "eb89cbdf69d07106c84edf1d191caaf33289651",
    "avatar": 11911528647474,
    "elapsedTime": 229191255000
  },
  {
    "commentId": 15450,
    "codingamerId": 1110733,
    "commentableId": 9186745,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 15434,
    "votableId": 9269266,
    "userVoteValue": 0,
    "nickname": "crashtestdummy",
    "content": "Well, apparently the winning set becomes stable after a while. Somewhere around N=60. As soon as you get 9 consecutive identical sets of winning keys, the sequence is bound to repeat indefinitely.\n\nI'm quite ok with \"nice\" validators, but anyone could fool them by hard coding the 60 or so first results and giving the stable sequence for N > 60 or so.\n\nI wonder if changing the rules to allow a different set of neighbours might produce less stable results.\n\nI tried to add 9 in key#1 neighbours and you get a more complicated sequence.  It has a period of 10 but at least it's not a constant and it produces between 2 and 4 winning moves for each number.\nI didn't try many combinations but so far i couldn't find a symetric configuration that doesn't become stable fast.\nI suppose you could add this exception in the problem definition (\"for some reason you can also press 9 after pressing 1\" :) ), though it might sound a bit artificial.\n\nI came up with a nice periodic pattern if the neighbouring rule is to forbid reusing keys in the same row:\n230: 0 0 0 0 0 0 0 0 0\n231: 1 0 0 0 0 0 0 0 0\n232: 1 1 0 0 0 0 0 0 0\n233: 1 1 1 0 0 0 0 0 0\n234: 1 1 1 1 0 0 1 0 0\n235: 0 1 1 0 1 0 1 1 0\n236: 0 0 1 0 0 1 1 1 1\n237: 0 0 0 0 0 0 1 1 1\n238: 0 0 0 0 0 0 0 1 1\n239: 0 0 0 0 0 0 0 0 1\nThere are numbers that yield no winning moves though.",
    "codingamerHandle": "c0f03664bd43bf3dcb8bed1b2f0e56803370111",
    "avatar": 2887336002045,
    "elapsedTime": 229171892000
  },
  {
    "commentId": 15473,
    "codingamerId": 301922,
    "commentableId": 9186745,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 15434,
    "votableId": 9276016,
    "userVoteValue": 0,
    "nickname": "tyrcho",
    "content": "Thanks for the detailed proposal.\nActually the way this was solved 30 years ago was by hard coding the 60 first results (see the link in my first response hereunder). But in order to do that you are actually running the algorithm by hand so I would accept that solution. It is in my opinion more work to do this by hand that to actually code it (I dit it by hand up to 10 and it's already quite painful).\nI'd like to keep the \"spirit\" of the initial problem.",
    "codingamerHandle": "e30e2eaed69f0747e8826dbf32015ea1229103",
    "avatar": 1742081719876,
    "elapsedTime": 229107722000
  },
  {
    "commentId": 15453,
    "codingamerId": 2716329,
    "commentableId": 9186745,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 15426,
    "votableId": 9270342,
    "userVoteValue": 0,
    "nickname": "Recher",
    "content": "Cool. I will study that.\n\nThank you.",
    "codingamerHandle": "496bc5e8fd0fde14aacaa21b21b1d1fc9236172",
    "avatar": 19985093844366,
    "elapsedTime": 229153042000
  }
]