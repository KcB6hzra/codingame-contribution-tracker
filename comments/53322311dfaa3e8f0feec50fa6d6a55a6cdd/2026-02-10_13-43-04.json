[
  {
    "commentId": 30035,
    "codingamerId": 2416641,
    "commentableId": 14626477,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "votableId": 14743097,
    "userVoteValue": 0,
    "nickname": "Zenoscave",
    "content": "✅ Approved the contribution.\nComment: Interesting take on run-length sequences. I like it.",
    "codingamerHandle": "df4e9a1fb8d928f54db1f30a63dcfa511466142",
    "avatar": 16732569385856,
    "elapsedTime": 172871125000
  },
  {
    "commentId": 29898,
    "codingamerId": 3903847,
    "commentableId": 14626477,
    "responseCount": 1,
    "upVotes": 1,
    "downVotes": 0,
    "votableId": 14714379,
    "userVoteValue": 0,
    "nickname": "UnicornP",
    "content": "✅ Approved the contribution.\nComment: Very straightforward. Reminds me of the unary puzzle :). I'm not sure why you decided to restrict n < 512, but it probably wouldn't matter anyway.",
    "codingamerHandle": "d2306f40567a276663b3ab4ebe84a3277483093",
    "avatar": 46874260719816,
    "elapsedTime": 173104606000
  },
  {
    "commentId": 29894,
    "codingamerId": 1678976,
    "commentableId": 14626477,
    "responseCount": 0,
    "upVotes": 1,
    "downVotes": 0,
    "votableId": 14713728,
    "userVoteValue": 0,
    "nickname": "Gorbit99",
    "content": "✅ Approved the contribution.\nComment: Simple and fun, I liked it",
    "codingamerHandle": "fcc8d4797370b02bd6fe0183b19300336798761",
    "avatar": 10176759624461,
    "elapsedTime": 173114004000
  },
  {
    "commentId": 29864,
    "codingamerId": 1678976,
    "commentableId": 14626477,
    "responseCount": 7,
    "upVotes": 2,
    "downVotes": 0,
    "votableId": 14707188,
    "userVoteValue": 0,
    "nickname": "Gorbit99",
    "content": "The part \"The first two integers are 0 and 1 (same as Earth)\" doesn't actually get tested, putting in a 0 testcase would probably trip up some implementations",
    "codingamerHandle": "fcc8d4797370b02bd6fe0183b19300336798761",
    "avatar": 10176759624461,
    "elapsedTime": 173167682000
  },
  {
    "commentId": 29863,
    "codingamerId": 3858550,
    "commentableId": 14626477,
    "responseCount": 1,
    "upVotes": 1,
    "downVotes": 0,
    "votableId": 14707161,
    "userVoteValue": 0,
    "nickname": "SPDene",
    "content": "In your examples (in the Goal):\n15 → 1111 → 5\nshould be\n15 → 1111 → 4\n\nFor an input of 0, your solution gives the output: 1 (should be 0)\nI would add a test case for this",
    "codingamerHandle": "ba8820874fca30b9f19db9cfa314224b0558583",
    "avatar": 45804347289477,
    "elapsedTime": 173168074000
  },
  {
    "commentId": 29869,
    "codingamerId": 3479792,
    "commentableId": 14626477,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 29863,
    "votableId": 14707440,
    "userVoteValue": 0,
    "nickname": "StepBack13",
    "content": "Hi SPDene,\n\nGood points. I will fix the typo and add that 0 test case.",
    "codingamerHandle": "da2fe4fbf3c0ab008c6dcf304920ec602979743",
    "avatar": 33990586394707,
    "elapsedTime": 173164712000
  },
  {
    "commentId": 29867,
    "codingamerId": 2387233,
    "commentableId": 14626477,
    "responseCount": 0,
    "upVotes": 1,
    "downVotes": 1,
    "parentCommentId": 29864,
    "votableId": 14707369,
    "userVoteValue": 0,
    "nickname": "SinOfWrath",
    "content": "I am strongly against 0, as all of the description suggests we are converting positive numbers, even though the constraint also lets 0 happen. Regardless 0 is also 0 in binary which starts with 0, not 1, so the whole rather shaky explanation falls apart for it. Not to mention even if you convert it it becomes 1 I guess, which is the same as 1 converted. I suggest to rephrase everywhere so n becomes positive integer and thus the constraint is 0<n<512. Also in the Input and output section integer should be substituted with the yellow n variable notation.\n\nAlso there are at least two places where you can fit in the word \"alternating\" (or some other form of it) to emphasize the importance of changing between 0s and 1s.",
    "codingamerHandle": "c52068985d3835317974dc0dad47019a3327832",
    "avatar": 41207346605394,
    "elapsedTime": 173165357000
  },
  {
    "commentId": 29967,
    "codingamerId": 3479792,
    "commentableId": 14626477,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 29898,
    "votableId": 14728113,
    "userVoteValue": 0,
    "nickname": "StepBack13",
    "content": "Hi, yes I got the idea from thinking of unary encoding.\nI restricted to < 512 so then its impossible to have a run length > 9.\n2047 for example has a run of 11 1's, but we can't represent it as 11 because that is reserved for 2 (10 in binary).\nI could have gone to a larger space if we encoded the run length in hexadecimal (2047 = b) or with space-separated output (2 = 1 1) (2047 = 11), but I didn't want to overcomplicate it. :)",
    "codingamerHandle": "da2fe4fbf3c0ab008c6dcf304920ec602979743",
    "avatar": 33990586394707,
    "elapsedTime": 172982182000
  },
  {
    "commentId": 29870,
    "codingamerId": 3479792,
    "commentableId": 14626477,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 29864,
    "votableId": 14707491,
    "userVoteValue": 0,
    "nickname": "StepBack13",
    "content": "Sin, I agreed with you at first.\nBut I've realised that it's needed. Also, I had \"non-negative integer\" so I implied 0 needed to be included.\n\nMy own code didn't cover the 0 case until I just updated it, I think it's important to test for it, even it makes the code less elegant.\n\nThanks Gorbit, I've added it now.",
    "codingamerHandle": "da2fe4fbf3c0ab008c6dcf304920ec602979743",
    "avatar": 33990586394707,
    "elapsedTime": 173163978000
  },
  {
    "commentId": 29873,
    "codingamerId": 2387233,
    "commentableId": 14626477,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 29864,
    "votableId": 14707829,
    "userVoteValue": 0,
    "nickname": "SinOfWrath",
    "content": "This made your contribution invalid on many levels.\n\nFirst: \"The first digit can always be assumed to refer to the length of a run of 1's\" which implicitly assumes the first digit in binary is always 1. That holds not to be true. If for some reason we assume that 0 in binary starts with 0 1s then the result for testcase 0 should be \"01\", as in it is zero 1s followed by one 0. But this proves that the result could just be \"0001\" as well. The problem is as soon as you give a notation to mean denote the lack of something, it raises so many edge cases that it's almost impossible to cover all.\n\nPlease don't get me wrong as I really like this CoC, but I'm not approving it until there are logical loopholes in it.",
    "codingamerHandle": "c52068985d3835317974dc0dad47019a3327832",
    "avatar": 41207346605394,
    "elapsedTime": 173160617000
  },
  {
    "commentId": 29875,
    "codingamerId": 1654818,
    "commentableId": 14626477,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 29864,
    "votableId": 14708331,
    "userVoteValue": 0,
    "nickname": "tarapitha",
    "content": "I think that zero problem could be solved by describing the zero exception in the problem statement. The mathematical rings have separate notation for the element that will retain the value of set element under addition. Say: the alien representation of 0 is 0 ?\nThat said, I see other problem with the alien notation, when looking e.g. at '134' in alien. It is not clear, does it represent 143 (1,3,4), 131056 (13,4) , 17179869184 (1,34) or 21778071482940061661655974875633165533183 (132)  in positional decimal system. Could the space separator save the day?",
    "codingamerHandle": "754c79d7d66c58da348477fd63c71f638184561",
    "avatar": 143100389160439,
    "elapsedTime": 173155650000
  },
  {
    "commentId": 29879,
    "codingamerId": 3479792,
    "commentableId": 14626477,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 29864,
    "votableId": 14709228,
    "userVoteValue": 0,
    "nickname": "StepBack13",
    "content": "Hi Sin,\n\nThe 0 case is not as confusing as you make it seem. It's like you say, 0 implies a run of zero 1's - the only binary integer with zero 1's is 0.\n01 would also work, but there is no need for leading zeros so 0 is the natural solution. It's the only edge case. I can make it more explicit as a fixed exception to the standard pattern though. Thanks for feedback.\n\nHi tarapitha,\n\nI will do so for the 0 case.\nAs for the confusions, that's why it's a single-digit encoding, the natural solution is to use other symbols for runs of length > 9, (131056 -> d4, 17179869184 -> 1y) but to keep this challenge clashable I just limited the input to 9-bit so that it's never a concern here.",
    "codingamerHandle": "da2fe4fbf3c0ab008c6dcf304920ec602979743",
    "avatar": 33990586394707,
    "elapsedTime": 173147277000
  },
  {
    "commentId": 29880,
    "codingamerId": 2387233,
    "commentableId": 14626477,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 1,
    "parentCommentId": 29864,
    "votableId": 14709424,
    "userVoteValue": 0,
    "nickname": "SinOfWrath",
    "content": "It's your choice of course. Adding extra statement to cover a completely unnecessary edge case for clash instead if simplifying the whole problem by excluding the edge case is quite contra-productive. Also I'm strongly against having a consistent rule for all cases except for one edge case where you explicitly define the answer is pointless. You could also add for the input chicken you should output egg.",
    "codingamerHandle": "c52068985d3835317974dc0dad47019a3327832",
    "avatar": 41207346605394,
    "elapsedTime": 173145960000
  },
  {
    "commentId": 29892,
    "codingamerId": 3479792,
    "commentableId": 14626477,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 29864,
    "votableId": 14713096,
    "userVoteValue": 0,
    "nickname": "StepBack13",
    "content": "I get what you mean, but without an explicit definition then 0 in this system would be represented as 1, so I think it's natural for there to be an exception in order to remove the ambiguity between 0 and 1. With this small specified definition the system now has an unambiguous representation for every integer 0->1022.\n\nThe problem would be more elegant if I didn't test 0, but I think including 0 makes it a more complete system even if it involves some hard-coding.",
    "codingamerHandle": "da2fe4fbf3c0ab008c6dcf304920ec602979743",
    "avatar": 33990586394707,
    "elapsedTime": 173119551000
  }
]