[
  {
    "commentId": 63314,
    "codingamerId": 464690,
    "commentableId": 21955488,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "votableId": 22528212,
    "userVoteValue": 0,
    "content": "Please test this before upvoting / supporting. OP won't post solutions, and I don't think implementing the problem as desribed passes even the first test case, and due to the nature of what is described it is difficult to troubleshoot.",
    "codingamerHandle": "10c9c4890c3eeec76f5c232ba80b7563096464",
    "elapsedTime": 122930420000
  },
  {
    "commentId": 63295,
    "codingamerId": 1838945,
    "commentableId": 21955488,
    "responseCount": 1,
    "upVotes": 2,
    "downVotes": 0,
    "votableId": 22526534,
    "userVoteValue": 0,
    "nickname": "Antoniossss",
    "content": "Counting number of mines is indeed an easy task, what is hard here is to how to generate mine coordinates the same way author did which is not trivial. For example I am using Java and I am unable to generate the same mine coordinates as here, even using unsigned API to do the generation. Having \"my coordinates\" I can generate mine count tiles without an issue, however getting generator to work in the same way it worked for author is just a pain. \n\nI will try to do the generation in c++ as you say it is easier there so I will at least have some sort of example generation pattern. Otherwise I have no idea where the problem is.",
    "codingamerHandle": "be66ebe66dcf9575331606e4cfd83ee25498381",
    "elapsedTime": 122939614000
  },
  {
    "commentId": 63294,
    "codingamerId": 1569823,
    "commentableId": 21955488,
    "responseCount": 15,
    "upVotes": 4,
    "downVotes": 0,
    "votableId": 22526490,
    "userVoteValue": 0,
    "nickname": "Niako",
    "content": "> \"Generated values must be 32 bit unsigned integers.\"\nThen please write the \"% 2^32\" in the formula and mention that the division is an integer division.\n\nPlease add x and y in the constraints (so that we can easily know/confirm that they are 0-indexed).\n\nAlso note (EDIT: already mentioned below) that a very close puzzle already existed:\nhttps://www.codingame.com/training/easy/reverse-minesweeper\n\nNow that it's accepted, changing the RNG would not be ideal, but as it's not a proper LCG (as explained below), please at least don't use that name.",
    "codingamerHandle": "eb89cbdf69d07106c84edf1d191caaf33289651",
    "avatar": 11911528647474,
    "elapsedTime": 122939954000
  },
  {
    "commentId": 63219,
    "codingamerId": 3513265,
    "commentableId": 21955488,
    "responseCount": 0,
    "upVotes": 1,
    "downVotes": 4,
    "votableId": 22516550,
    "userVoteValue": 0,
    "nickname": "DaNinja",
    "content": "✅ Approved the contribution.\nComment: I liked it",
    "codingamerHandle": "c989a5597d46ef37ec056d273a7975045623153",
    "avatar": 35022107863170,
    "elapsedTime": 123018208000
  },
  {
    "commentId": 63217,
    "codingamerId": 1061242,
    "commentableId": 21955488,
    "responseCount": 0,
    "upVotes": 1,
    "downVotes": 4,
    "votableId": 22516339,
    "userVoteValue": 0,
    "nickname": "Csipcsirip",
    "content": "✅ Approved the contribution.\nComment: its cool",
    "codingamerHandle": "bc23f1ca3f15d4ea8e766f8d3f65557a2421601",
    "avatar": 136123488672706,
    "elapsedTime": 123019219000
  },
  {
    "commentId": 63213,
    "codingamerId": 3354337,
    "commentableId": 21955488,
    "responseCount": 1,
    "upVotes": 1,
    "downVotes": 1,
    "votableId": 22515881,
    "userVoteValue": 0,
    "nickname": "Westicles",
    "content": "✅ Approved the contribution.\nComment: I liked it. Good to see a problem that is easier in C++ and maybe tougher in python for a change.",
    "codingamerHandle": "613b8dd7e3f3f21da489c27a933e15d67334533",
    "avatar": 79146641399080,
    "elapsedTime": 123021234000
  },
  {
    "commentId": 63103,
    "codingamerId": 4533928,
    "commentableId": 21955488,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "votableId": 22504375,
    "userVoteValue": 0,
    "nickname": "CatboyCodes",
    "content": "This looks epic",
    "codingamerHandle": "06b029c85cf0b8a644a5368192d6cadc8293354",
    "elapsedTime": 123101500000
  },
  {
    "commentId": 63100,
    "codingamerId": 4484838,
    "commentableId": 21955488,
    "responseCount": 1,
    "upVotes": 0,
    "downVotes": 0,
    "votableId": 22502548,
    "userVoteValue": 0,
    "nickname": "matlewan7",
    "content": "I think it will be useful to explain, how random generator results in generated positions (X,Y) of mines?",
    "codingamerHandle": "19315a6d70b5677fb10ec57c3b1fd0978384844",
    "avatar": 144853083963212,
    "elapsedTime": 123109346000
  },
  {
    "commentId": 63054,
    "codingamerId": 3401105,
    "commentableId": 21955488,
    "responseCount": 1,
    "upVotes": 2,
    "downVotes": 0,
    "votableId": 22492860,
    "userVoteValue": 0,
    "nickname": "Husoski",
    "content": "It's worse than I originally thought.  Your LCG isn't really an LCG since the integer division by 65536 makes it nonlinear.  Every starting number from 0 to 65536 eventually goes into a loop of period 548 or less.  Many starting values are worse:\n615 starting values enter a loop of length 4\n274 starting values enter a loop of length 36\n31 starting values enter a loop of length 3\nThere are a pair of numbers (13546 and 44274) that form a loop of length 2.\nTwo values (28910 and 57837) loop immediately and 37768 leads directly to 57837; all three of these have period 1!\n\nYou should use a real generator.  The Lehmer generator I mentioned previously is (as Park & Miller said) \"good, but not great\".  It's good enough for most games and much better than even a properly-implemented version of the VC/VC++ generator.  (That particular function was copied from DOS and 16-bit Windows days for compatibility reasons.)",
    "codingamerHandle": "9e91c438b0d2921d4f97b579b5f4b93a5011043",
    "avatar": 30776889241351,
    "elapsedTime": 123152834000
  },
  {
    "commentId": 63019,
    "codingamerId": 3401105,
    "commentableId": 21955488,
    "responseCount": 1,
    "upVotes": 2,
    "downVotes": 0,
    "votableId": 22492250,
    "userVoteValue": 0,
    "nickname": "Husoski",
    "content": "That's *almost* the Microsoft VC/VC++ random number generator.  Same multiplier and offset, but different handling of the product.  That handling limits your \"randoms\" to at most 65536 different random numbers.  The MS version takes bits 16-30 out of the seed but leaves the 32-bit product and sum as the seed for the next random.  You store just bits 15-31 of the product and that's the seed for your next iteration.  There's even a serious possibility of collisions here so the period might be much less than 65536 number before repeating. (I haven't run any tests on that, though.)\n\nIt's also got the same drawback as MS for bulk use, and that's a comparatively tiny RAND_MAX value. Yours (65535) is better than the MS version (32767), but not by much.  The so-called \"ACM Minimal Standard\" generator is simpler and easier to explain:\n\n    seed[0] = 1\n    seed[n+1] = (seed[n] * 7**5) % (2**31 - 1)\n\n*Almost* 31 bits of random from a simpler computation. You could return seed[n]-1 as the nth random to get a 0-based number, if desired.\n\nThe above method was was described by D. H. Lehmer long before Park & Miller wrote their 1988 paper for Communications of the ACM, but people still call it the \"Park-Miller generator\".  It was the generator built into IBM's APL programming language as early as 1970, for example. \n\nIf that's not more than you ever wanted to know about this PRNG, there's much more at Wikipedia:\nhttps://en.wikipedia.org/wiki/Lehmer_random_number_generator\n:)",
    "codingamerHandle": "9e91c438b0d2921d4f97b579b5f4b93a5011043",
    "avatar": 30776889241351,
    "elapsedTime": 123160307000
  },
  {
    "commentId": 62733,
    "codingamerId": 4677090,
    "commentableId": 21955488,
    "responseCount": 1,
    "upVotes": 0,
    "downVotes": 0,
    "votableId": 22464717,
    "userVoteValue": 0,
    "nickname": "Mekare",
    "content": "I have the same remarks as snoyes\n1. Of course, the modulo part is kinda implicit. But R(n)*size/65537 kinda works too no ?\n2. I really think you should explicitly add than unsigned int are supposed to be 32bits",
    "codingamerHandle": "9a07d325ccc7fd9266875df3e0a285dd0907764",
    "elapsedTime": 123295027000
  },
  {
    "commentId": 62550,
    "codingamerId": 836069,
    "commentableId": 21955488,
    "responseCount": 3,
    "upVotes": 3,
    "downVotes": 0,
    "votableId": 22450836,
    "userVoteValue": 0,
    "nickname": "snoyes",
    "content": "1. The problem does not say that the values from the LCG are supposed to be taken modulo the width or height. It could simply be that you're supposed to generate random values until they happen to be low enough.\n\n2. C++ throws away the overflow during the intermediate part of the random number calculation, but Python does not. So Python coders are going to have to know to do something like `(214013 * seed + 2531011) % (2**32-1) // 65536` which is probably a bit much to expect from just a casual comment about unsigned integers.",
    "codingamerHandle": "e8a389c783c308ed66668780d015301a960638",
    "avatar": 60641567171814,
    "elapsedTime": 123369980000
  },
  {
    "commentId": 60966,
    "codingamerId": 4251135,
    "commentableId": 21955488,
    "responseCount": 2,
    "upVotes": 1,
    "downVotes": 0,
    "votableId": 22245161,
    "userVoteValue": 0,
    "nickname": "Tsloa",
    "content": "apart from randomness, it is already a puzzle\nhttps://www.codingame.com/training/easy/reverse-minesweeper",
    "codingamerHandle": "8eb59aacb26544fedaf704b3e310ea395311524",
    "avatar": 61671100699207,
    "elapsedTime": 124581558000
  },
  {
    "commentId": 60162,
    "codingamerId": 2674460,
    "commentableId": 21955488,
    "responseCount": 7,
    "upVotes": 0,
    "downVotes": 0,
    "votableId": 22156761,
    "userVoteValue": 0,
    "nickname": "Malte42",
    "content": "I like this contribution, especially after the event. But I do not understand the LCG. The recursion gives floats. Should I round the values to integers and then take modulo? Or should I take modulo until an integer pops up?",
    "codingamerHandle": "1fe84b85cc84aad62f2581321ef7ecb90644762",
    "avatar": 19389646868040,
    "elapsedTime": 125162724000
  },
  {
    "commentId": 59968,
    "codingamerId": 862919,
    "commentableId": 21955488,
    "responseCount": 1,
    "upVotes": 1,
    "downVotes": 0,
    "votableId": 22136925,
    "userVoteValue": 0,
    "nickname": "Astrobytes",
    "content": "Downvoted for lack of cute retro graphics! (just kidding :D )",
    "codingamerHandle": "f76499818f5cfc3f3fa8c0eb31e13344919268",
    "avatar": 60413902297900,
    "elapsedTime": 125272083000
  },
  {
    "commentId": 59958,
    "codingamerId": 4277276,
    "commentableId": 21955488,
    "responseCount": 1,
    "upVotes": 1,
    "downVotes": 0,
    "votableId": 22133215,
    "userVoteValue": 0,
    "nickname": "jack9104",
    "content": "Wow! Really a nice contribution. \nBut may I ask why the type of the variable \"seed\" should be unsigned int?\n\n(Since when I tested, only by changing the type of \"seed\" makes the solution from wrong to correct, but the stub generator input makes \"seed\" type int, which might be misleading.)",
    "codingamerHandle": "8c4904ce1618d986412326f405643eef6727724",
    "avatar": 66028185668385,
    "elapsedTime": 125288283000
  },
  {
    "commentId": 59438,
    "codingamerId": 3516897,
    "commentableId": 21955488,
    "responseCount": 1,
    "upVotes": 1,
    "downVotes": 0,
    "votableId": 22082498,
    "userVoteValue": 0,
    "nickname": "frenc2203",
    "content": "Hello, looks like an interesting problem and it's very well written and clear. Maybe explain what the \">>\" operator is.",
    "codingamerHandle": "a4aefc23e415a0d19aa1481f3ba756527986153",
    "avatar": 78397649617345,
    "elapsedTime": 125620868000
  },
  {
    "commentId": 59414,
    "codingamerId": 2923506,
    "commentableId": 21955488,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "votableId": 22077917,
    "userVoteValue": 0,
    "nickname": "darkhorse64",
    "content": "My first puzzle building on the \"featured event\" momentum ...",
    "codingamerHandle": "c9ebe76a83b33730956eda0534d6cad86053292",
    "onlineSince": 1770713881813,
    "avatar": 23496414257567,
    "elapsedTime": 125641237000
  },
  {
    "commentId": 59441,
    "codingamerId": 2923506,
    "commentableId": 21955488,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 59438,
    "votableId": 22082763,
    "userVoteValue": 0,
    "nickname": "darkhorse64",
    "content": "Done",
    "codingamerHandle": "c9ebe76a83b33730956eda0534d6cad86053292",
    "onlineSince": 1770713881813,
    "avatar": 23496414257567,
    "elapsedTime": 125620042000
  },
  {
    "commentId": 59959,
    "codingamerId": 2923506,
    "commentableId": 21955488,
    "responseCount": 0,
    "upVotes": 1,
    "downVotes": 0,
    "parentCommentId": 59958,
    "votableId": 22134164,
    "userVoteValue": 0,
    "nickname": "darkhorse64",
    "content": "Actually, seed is unsigned int because the output of the random generator must be unsigned int. This is required because performing a modulo operation on a negative value may fail or behave differently depending on the language. \nI have added that the LCG must use unsigned integers.",
    "codingamerHandle": "c9ebe76a83b33730956eda0534d6cad86053292",
    "onlineSince": 1770713881813,
    "avatar": 23496414257567,
    "elapsedTime": 125283119000
  },
  {
    "commentId": 59969,
    "codingamerId": 2923506,
    "commentableId": 21955488,
    "responseCount": 0,
    "upVotes": 1,
    "downVotes": 0,
    "parentCommentId": 59968,
    "votableId": 22136955,
    "userVoteValue": 0,
    "nickname": "darkhorse64",
    "content": "Sorry, no UTF16 output ;-)",
    "codingamerHandle": "c9ebe76a83b33730956eda0534d6cad86053292",
    "onlineSince": 1770713881813,
    "avatar": 23496414257567,
    "elapsedTime": 125271949000
  },
  {
    "commentId": 60163,
    "codingamerId": 2923506,
    "commentableId": 21955488,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 60162,
    "votableId": 22156842,
    "userVoteValue": 0,
    "nickname": "darkhorse64",
    "content": "The LCG uses integer division. There are no floats",
    "codingamerHandle": "c9ebe76a83b33730956eda0534d6cad86053292",
    "onlineSince": 1770713881813,
    "avatar": 23496414257567,
    "elapsedTime": 125162308000
  },
  {
    "commentId": 60967,
    "codingamerId": 2923506,
    "commentableId": 21955488,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 60966,
    "votableId": 22245288,
    "userVoteValue": 0,
    "nickname": "darkhorse64",
    "content": "My puzzle involves also generating the grid, so it is a superset of this one",
    "codingamerHandle": "c9ebe76a83b33730956eda0534d6cad86053292",
    "onlineSince": 1770713881813,
    "avatar": 23496414257567,
    "elapsedTime": 124581081000
  },
  {
    "commentId": 62562,
    "codingamerId": 2923506,
    "commentableId": 21955488,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 62550,
    "votableId": 22453246,
    "userVoteValue": 0,
    "nickname": "darkhorse64",
    "content": "1 - The statement says \"generate coordinates\" therefore the modulo is implicit. I consider this to be basic knowledge.\n2 - I added a small notice",
    "codingamerHandle": "c9ebe76a83b33730956eda0534d6cad86053292",
    "onlineSince": 1770713881813,
    "avatar": 23496414257567,
    "elapsedTime": 123361682000
  },
  {
    "commentId": 62734,
    "codingamerId": 2923506,
    "commentableId": 21955488,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 62733,
    "votableId": 22464907,
    "userVoteValue": 0,
    "nickname": "darkhorse64",
    "content": "1- It works but it's not the most natural way to proceed.\n2- Done",
    "codingamerHandle": "c9ebe76a83b33730956eda0534d6cad86053292",
    "onlineSince": 1770713881813,
    "avatar": 23496414257567,
    "elapsedTime": 123294369000
  },
  {
    "commentId": 63059,
    "codingamerId": 2923506,
    "commentableId": 21955488,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 63019,
    "votableId": 22493633,
    "userVoteValue": 0,
    "nickname": "darkhorse64",
    "content": "Thanks for these detailed explanations. I'll take notice for a future puzzle. Of course, my RNG is not great (and is even worse than I thought) but it does the job for this simple puzzle. It's not worth redesigning all tests and validators.",
    "codingamerHandle": "c9ebe76a83b33730956eda0534d6cad86053292",
    "onlineSince": 1770713881813,
    "avatar": 23496414257567,
    "elapsedTime": 123143124000
  },
  {
    "commentId": 63301,
    "codingamerId": 1569823,
    "commentableId": 21955488,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 63054,
    "votableId": 22527000,
    "userVoteValue": 0,
    "nickname": "Niako",
    "content": "Thanks for noticing. When one wants the simplest RNG process, BBS (Blum-Blum-Shub) generators are also often used as you only need one constant to describe them (against 3 for a LCG).",
    "codingamerHandle": "eb89cbdf69d07106c84edf1d191caaf33289651",
    "avatar": 11911528647474,
    "elapsedTime": 122936797000
  },
  {
    "commentId": 63101,
    "codingamerId": 2923506,
    "commentableId": 21955488,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 63100,
    "votableId": 22502596,
    "userVoteValue": 0,
    "nickname": "darkhorse64",
    "content": "See my answer to snoyes",
    "codingamerHandle": "c9ebe76a83b33730956eda0534d6cad86053292",
    "onlineSince": 1770713881813,
    "avatar": 23496414257567,
    "elapsedTime": 123109138000
  },
  {
    "commentId": 63216,
    "codingamerId": 2923506,
    "commentableId": 21955488,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 1,
    "parentCommentId": 63213,
    "votableId": 22516293,
    "userVoteValue": 0,
    "nickname": "darkhorse64",
    "content": ":-)",
    "codingamerHandle": "c9ebe76a83b33730956eda0534d6cad86053292",
    "onlineSince": 1770713881813,
    "avatar": 23496414257567,
    "elapsedTime": 123019490000
  },
  {
    "commentId": 63299,
    "codingamerId": 1838945,
    "commentableId": 21955488,
    "responseCount": 0,
    "upVotes": 3,
    "downVotes": 0,
    "parentCommentId": 63294,
    "votableId": 22526854,
    "userVoteValue": 0,
    "nickname": "Antoniossss",
    "content": "Also couple of generated items would come in handy for some seed to easily see if your generator works as intended or not.",
    "codingamerHandle": "be66ebe66dcf9575331606e4cfd83ee25498381",
    "elapsedTime": 122937564000
  },
  {
    "commentId": 63297,
    "codingamerId": 1569823,
    "commentableId": 21955488,
    "responseCount": 0,
    "upVotes": 1,
    "downVotes": 0,
    "parentCommentId": 63295,
    "votableId": 22526606,
    "userVoteValue": 0,
    "nickname": "Niako",
    "content": "Use signed 64-bit long and a modulo operation:\n((214013 * R(n-1) + 2531011) % 2^32) / 65536\n\nAlso, that kind of comment should probably have been posted in the forum, not here.",
    "codingamerHandle": "eb89cbdf69d07106c84edf1d191caaf33289651",
    "avatar": 11911528647474,
    "elapsedTime": 122939181000
  },
  {
    "commentId": 63300,
    "codingamerId": 2923506,
    "commentableId": 21955488,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 63294,
    "votableId": 22526979,
    "userVoteValue": 0,
    "nickname": "darkhorse64",
    "content": "32 bit unsigned integers are already in [0 ... 2^32-1]. A modulo 2^32 does nothing.\nMy puzzle is a superset of the puzzle you mentioned.\nI have removed all references to LCG.",
    "codingamerHandle": "c9ebe76a83b33730956eda0534d6cad86053292",
    "onlineSince": 1770713881813,
    "avatar": 23496414257567,
    "elapsedTime": 122936896000
  },
  {
    "commentId": 63302,
    "codingamerId": 1569823,
    "commentableId": 21955488,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 63294,
    "votableId": 22527059,
    "userVoteValue": 0,
    "nickname": "Niako",
    "content": "> \"32 bit unsigned integers are already in [0 ... 2^32-1]. A modulo 2^32 does nothing.\"\nI know -_- ... You perfectly understand what I mean, there are enough discussions about it here and in the forum...",
    "codingamerHandle": "eb89cbdf69d07106c84edf1d191caaf33289651",
    "avatar": 11911528647474,
    "elapsedTime": 122936368000
  },
  {
    "commentId": 63303,
    "codingamerId": 464690,
    "commentableId": 21955488,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 63294,
    "votableId": 22527062,
    "userVoteValue": 0,
    "content": "I feel like there is something wrong between the description and the test cases, I'm not the smartest but I think I'm ok with this stuff and I can't reproduce the results.\n\nWhat language did you implement this in, do you have a sample solution?",
    "codingamerHandle": "10c9c4890c3eeec76f5c232ba80b7563096464",
    "elapsedTime": 122936335000
  },
  {
    "commentId": 63304,
    "codingamerId": 2923506,
    "commentableId": 21955488,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 63294,
    "votableId": 22527092,
    "userVoteValue": 0,
    "nickname": "darkhorse64",
    "content": "Of course, I solve my own puzzle (in C++)",
    "codingamerHandle": "c9ebe76a83b33730956eda0534d6cad86053292",
    "onlineSince": 1770713881813,
    "avatar": 23496414257567,
    "elapsedTime": 122936202000
  },
  {
    "commentId": 63305,
    "codingamerId": 464690,
    "commentableId": 21955488,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 63294,
    "votableId": 22527132,
    "userVoteValue": 0,
    "content": "Even if there isn't an issue, the problem statement really needs same outputs from the function that makes the values used to place the mines, I don't think you can work backwards from the mine positions on the grid to figure out what might be wrong with an implementation",
    "codingamerHandle": "10c9c4890c3eeec76f5c232ba80b7563096464",
    "elapsedTime": 122935904000
  },
  {
    "commentId": 63306,
    "codingamerId": 2923506,
    "commentableId": 21955488,
    "responseCount": 0,
    "upVotes": 1,
    "downVotes": 2,
    "parentCommentId": 63294,
    "votableId": 22527204,
    "userVoteValue": 0,
    "nickname": "darkhorse64",
    "content": "The PRNG is really nothing complicated if you use exactly the primitive type specified in the statement.\n\nclass PRNG\n{\npublic:\n    PRNG (unsigned int seed):seed(seed) {}\n    unsigned int rand ()\n    {\n        return seed = (214013 * seed + 2531011) >> 16;\n    }\nprivate:\n    unsigned int seed;\n};",
    "codingamerHandle": "c9ebe76a83b33730956eda0534d6cad86053292",
    "onlineSince": 1770713881813,
    "avatar": 23496414257567,
    "elapsedTime": 122935611000
  },
  {
    "commentId": 63308,
    "codingamerId": 464690,
    "commentableId": 21955488,
    "responseCount": 0,
    "upVotes": 1,
    "downVotes": 2,
    "parentCommentId": 63294,
    "votableId": 22527681,
    "userVoteValue": 0,
    "content": "I asked you to post code that reproduces your test cases. I don't need what you posted.\n\n\nHere is what you posted added to code that if you test in the Codingame IDE does not show mines in the \"correct\" position for Test Case 1 (Haven't done the adjacent number stuff for clarity)\n\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nclass PRNG\n{\npublic:\n    PRNG (unsigned int seed):seed(seed) {}\n    unsigned int rand ()\n    {\n        return seed = (214013 * seed + 2531011) >> 16;\n    }\nprivate:\n    unsigned int seed;\n};\n\nint main()\n{\n    unsigned int width;\n    unsigned int height;\n    unsigned int mineCount;\n    unsigned int x;\n    unsigned int y;\n    unsigned int seed;\n    cin >> width >> height >> mineCount >> x >> y >> seed; cin.ignore();\n\n    PRNG *rng = new PRNG(seed);\n    unsigned int mines[mineCount+1];\n    mines[0] = x + (y<<16);\n\n    for(int i=1; i< mineCount+1; i++) {\n\n        bool duplicate = false;\n        do {\n            unsigned int x = rng->rand()%width;\n            unsigned int y = rng->rand()%height;\n            mines[i] = x + (y<<16);\n            \n            for (int j = 0; j<i; j++) {\n                if (mines[j] == mines[i])\n                    duplicate = true;\n            }\n        } while (duplicate);\n    }\n\n\n    for (int y = 0; y < height; y++) {\n        for (int x = 0; x < width; x++) {\n            bool hasMine = false;\n            int pos = x + (y<<16);\n            for (int j = 1; j<mineCount+1; j++) {\n                if (mines[j]==pos) {\n                    hasMine = true;\n                }\n            }\n            cout << (hasMine ? \"#\" : \".\");\n        }\n\n        cout << endl;\n    }\n}\n\n\n\nThis outputs:\n\n.#..#.\n......\n..#...\n.....#\n.###..\n......\n\nThe mine positions your first test Case are given as:\n\n.#.##.\n......\n#.....\n.....#\n##....\n......\n\n\nand before you complain about my code, and not wanting to look at it, I asked you to show me your working code instead. I feel like you are wasting my time.",
    "codingamerHandle": "10c9c4890c3eeec76f5c232ba80b7563096464",
    "elapsedTime": 122933033000
  },
  {
    "commentId": 63310,
    "codingamerId": 2923506,
    "commentableId": 21955488,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 3,
    "parentCommentId": 63294,
    "votableId": 22527874,
    "userVoteValue": 0,
    "nickname": "darkhorse64",
    "content": "Sorry but I will not post my working solution. Being aggressive also does not help.\n\nYour code does not handle the constraint on the first selected cell.",
    "codingamerHandle": "c9ebe76a83b33730956eda0534d6cad86053292",
    "onlineSince": 1770713881813,
    "avatar": 23496414257567,
    "elapsedTime": 122931911000
  },
  {
    "commentId": 63311,
    "codingamerId": 1838945,
    "commentableId": 21955488,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 63294,
    "votableId": 22527924,
    "userVoteValue": 0,
    "nickname": "Antoniossss",
    "content": "This is also why I think that providing example generator output would be usefull as Nat then could verify it it is a problem with gen function or maybe somewere else. Gen function is the hardest bit to debug here.",
    "codingamerHandle": "be66ebe66dcf9575331606e4cfd83ee25498381",
    "elapsedTime": 122931646000
  },
  {
    "commentId": 63313,
    "codingamerId": 2923506,
    "commentableId": 21955488,
    "responseCount": 0,
    "upVotes": 1,
    "downVotes": 1,
    "parentCommentId": 63294,
    "votableId": 22528032,
    "userVoteValue": 0,
    "nickname": "darkhorse64",
    "content": "I have provided an example of the PRNG output in the statement",
    "codingamerHandle": "c9ebe76a83b33730956eda0534d6cad86053292",
    "onlineSince": 1770713881813,
    "avatar": 23496414257567,
    "elapsedTime": 122931191000
  },
  {
    "commentId": 63315,
    "codingamerId": 464690,
    "commentableId": 21955488,
    "responseCount": 0,
    "upVotes": 1,
    "downVotes": 0,
    "parentCommentId": 63294,
    "votableId": 22528241,
    "userVoteValue": 0,
    "content": "Agressive? I tried to be nice, I gave you a chance to defend your problem, and when you didn't I went out of my way to give you every benefit of the doubt and showed all my cards, not sure what more you could expect of me with regards to being nice to you.",
    "codingamerHandle": "10c9c4890c3eeec76f5c232ba80b7563096464",
    "elapsedTime": 122930281000
  },
  {
    "commentId": 63316,
    "codingamerId": 464690,
    "commentableId": 21955488,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 63294,
    "votableId": 22528800,
    "userVoteValue": 0,
    "content": "I believe I showed your \"PRNG output\" doesn't solve the problem, with your logic I can say I proved P==NP and just never tell anyone how.",
    "codingamerHandle": "10c9c4890c3eeec76f5c232ba80b7563096464",
    "elapsedTime": 122927056000
  },
  {
    "commentId": 63590,
    "codingamerId": 1111280,
    "commentableId": 21955488,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 63294,
    "votableId": 22567141,
    "userVoteValue": 0,
    "nickname": "CarlWalsh",
    "content": "The description \"Generated values must be 32 bit unsigned integers.\" needs to instead say something about all calculations must be in 32-bit unsigned numbers. The thread below about python and PHP calls out how the problem is with the intermediate calculation, not the generated value.\n\nOtherwise it should be valid to find the exact RNG value in a larger precision, THEN take the mod:\n    ((214013 * r + 2531011) // 65536) % 2**32\n...but this gives the wrong answer",
    "codingamerHandle": "24dfb41711984503bfbf5230834060f70821111",
    "avatar": 4659997556357,
    "elapsedTime": 122705122000
  },
  {
    "commentId": 63591,
    "codingamerId": 2923506,
    "commentableId": 21955488,
    "responseCount": 0,
    "upVotes": 1,
    "downVotes": 0,
    "parentCommentId": 63294,
    "votableId": 22567413,
    "userVoteValue": 0,
    "nickname": "darkhorse64",
    "content": "Yep, that was implied but this is clearer. I edited the statement.",
    "codingamerHandle": "c9ebe76a83b33730956eda0534d6cad86053292",
    "onlineSince": 1770713881813,
    "avatar": 23496414257567,
    "elapsedTime": 122703525000
  },
  {
    "commentId": 62986,
    "codingamerId": 3401105,
    "commentableId": 21955488,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 62550,
    "votableId": 22491852,
    "userVoteValue": 0,
    "nickname": "Husoski",
    "content": "Your formula for item 2 should be modulo (2**32) rather than (2**32 - 1).  That's the low 32 bits of a sum or product.",
    "codingamerHandle": "9e91c438b0d2921d4f97b579b5f4b93a5011043",
    "avatar": 30776889241351,
    "elapsedTime": 123165171000
  },
  {
    "commentId": 63352,
    "codingamerId": 1412263,
    "commentableId": 21955488,
    "responseCount": 0,
    "upVotes": 1,
    "downVotes": 0,
    "parentCommentId": 62550,
    "votableId": 22533848,
    "userVoteValue": 0,
    "nickname": "PatrickMcGinnisII",
    "content": "yea this really messed me up in php.  had to whack the high order bits then the low order... so 64 to 32, then to 16 bits.  smh. glhf.  ((214013*$seed+2531011)&0xFFFFFFFF)>>16",
    "codingamerHandle": "89c64205eb383cc603b902bdcee2efbd3622141",
    "avatar": 75707267075165,
    "elapsedTime": 122883137000
  },
  {
    "commentId": 62432,
    "codingamerId": 2993741,
    "commentableId": 21955488,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 60966,
    "votableId": 22439466,
    "userVoteValue": 0,
    "nickname": "Saucisse_a_Roulettes",
    "content": "great !",
    "codingamerHandle": "4aae3aa29407f052e051d1ff327e59de1473992",
    "avatar": 43226187151583,
    "elapsedTime": 123432452000
  },
  {
    "commentId": 60164,
    "codingamerId": 2674460,
    "commentableId": 21955488,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 60162,
    "votableId": 22157068,
    "userVoteValue": 0,
    "nickname": "Malte42",
    "content": "Ah ok - thanks. But I'm still confused.\n\nWhen I try it out for the values in the example:\n\nseed = 31\ndef R(n):\n    if n == 0: return seed \n    return ((214013 * R(n-1) + 2531011) // 65536) \n\nTaking the result % 6 gives the first two numbers 1, 5. But there is no mine at (1,5). (Assuming (0,0) is starting point top left.\nWhat do I get wrong?",
    "codingamerHandle": "1fe84b85cc84aad62f2581321ef7ecb90644762",
    "avatar": 19389646868040,
    "elapsedTime": 125160985000
  },
  {
    "commentId": 60165,
    "codingamerId": 2923506,
    "commentableId": 21955488,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 60162,
    "votableId": 22157167,
    "userVoteValue": 0,
    "nickname": "darkhorse64",
    "content": "I guess you are using R(0) and R(1) for the first two random values. Use R(1) and R(2).\n\nYou should not use recursion to generate the values. This is likely to cause timeouts for large levels.",
    "codingamerHandle": "c9ebe76a83b33730956eda0534d6cad86053292",
    "onlineSince": 1770713881813,
    "avatar": 23496414257567,
    "elapsedTime": 125160377000
  },
  {
    "commentId": 60166,
    "codingamerId": 2674460,
    "commentableId": 21955488,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 60162,
    "votableId": 22157393,
    "userVoteValue": 0,
    "nickname": "Malte42",
    "content": "Sorry the reported numbers were not correct (I tried the %6 within the recursive function)  \nIf I try this:\n\nseed = 31\ndef R(n):\n    if n == 0: return seed \n    return ((214013 * R(n-1) + 2531011) // 65536) \n\nfor i in range(10):\n    print(R(i)%6)\n\nThe result is 1 1 0 1 4 5 3 4 4 2  - starting with 0\nBut the problem remains: Neither at 1,1 nor at 1,0 is a mine\n\nRecursion is no problem, since there is only one recursive call in the function (won't work for the Fibonaccis).",
    "codingamerHandle": "1fe84b85cc84aad62f2581321ef7ecb90644762",
    "avatar": 19389646868040,
    "elapsedTime": 125158784000
  },
  {
    "commentId": 60167,
    "codingamerId": 2923506,
    "commentableId": 21955488,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 60162,
    "votableId": 22157496,
    "userVoteValue": 0,
    "nickname": "darkhorse64",
    "content": "Your LCG is correct and there is a mine at (X=1,Y=0).",
    "codingamerHandle": "c9ebe76a83b33730956eda0534d6cad86053292",
    "onlineSince": 1770713881813,
    "avatar": 23496414257567,
    "elapsedTime": 125157985000
  },
  {
    "commentId": 60191,
    "codingamerId": 2674460,
    "commentableId": 21955488,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 60162,
    "votableId": 22160072,
    "userVoteValue": 0,
    "nickname": "Malte42",
    "content": "Oh I see - so perhaps you should clarify coordinates: the text says a grid height x width. So with X first I thought X is associated with height. - Otherwise: I like it a lot (and learned something about (LCG) ).",
    "codingamerHandle": "1fe84b85cc84aad62f2581321ef7ecb90644762",
    "avatar": 19389646868040,
    "elapsedTime": 125128910000
  },
  {
    "commentId": 60193,
    "codingamerId": 2923506,
    "commentableId": 21955488,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 60162,
    "votableId": 22160488,
    "userVoteValue": 0,
    "nickname": "darkhorse64",
    "content": "height and width switched in the statement",
    "codingamerHandle": "c9ebe76a83b33730956eda0534d6cad86053292",
    "onlineSince": 1770713881813,
    "avatar": 23496414257567,
    "elapsedTime": 125125938000
  }
]