[
  {
    "commentId": 15170,
    "codingamerId": 2400928,
    "commentableId": 9085291,
    "responseCount": 2,
    "upVotes": 2,
    "downVotes": 0,
    "votableId": 9155061,
    "userVoteValue": 0,
    "nickname": "Gilsidoo",
    "content": "The \"zeros and nine\" tests both presents trailing zeros and nines but the pattern of the validators is '[1-8]+9+[1-8]0+'  which is completely different, as a result I have accidentely created a solution that passes all the tests but not those two  validators and there's nothing more frustrating than that, I suggest you add a test with this pattern",
    "codingamerHandle": "87ca924758178b4bb2ecc94bca8374628290042",
    "avatar": 16457530734249,
    "elapsedTime": 230346436000
  },
  {
    "commentId": 15169,
    "codingamerId": 1110733,
    "commentableId": 9085291,
    "responseCount": 2,
    "upVotes": 4,
    "downVotes": 0,
    "votableId": 9154043,
    "userVoteValue": 0,
    "nickname": "crashtestdummy",
    "content": "Nice maths problem.\n\nAbout the wording of the problem definition, I would suggest:\n \"*the* smallest number greater than N with the same digit sum as N\"\nApparently \"digit sum\" is an accepted technical term (https://en.wikipedia.org/wiki/Digit_sum)\n\nAnd maybe something more telling than \"Next number\" for the title :)\n\"Constant digit sum successor\" or something like that?\n\nThe \"Need more length\" test checks N=10^9 but the validator checks N=10^10. That means someone using ints instead of longs in C/C++ might pass all the tests and still fail the validator. \nI would rather pick values > 2^32 in both the test and the validator.\n\nOr if the idea is to work on really big numbers so that the values can't fit in 64 bits, you could increase max N to 10^20 or more.\n\nThat would be a shame though. Integer arithmetics can be pretty useful: if you add X=9x10^k to N, the difference of digit sums of N and N+X will always be a multiple of 9, allowing to detect both 0 and 9 carry underflows/overflows. Based on that, I've come up with a solution using long integers instead of strings.\n\nWhat do you think?",
    "codingamerHandle": "c0f03664bd43bf3dcb8bed1b2f0e56803370111",
    "avatar": 2887336002045,
    "elapsedTime": 230354337000
  },
  {
    "commentId": 15185,
    "codingamerId": 837436,
    "commentableId": 9085291,
    "responseCount": 0,
    "upVotes": 1,
    "downVotes": 0,
    "parentCommentId": 15169,
    "votableId": 9159266,
    "userVoteValue": 0,
    "nickname": "aropan",
    "content": "Yep, edited statement.\n\nI think \"Digit sum successor\" is quite suitable.\n\n> I would rather pick values > 2^32 in both the test and the validator.\nAgree. And I do not want to make N more than 64 bits number - enough to brute force solution have TL verdict.",
    "codingamerHandle": "3d2a786d1c0ab7176a18538c7ab8c38f634738",
    "avatar": 68849260530594,
    "elapsedTime": 230316203000
  },
  {
    "commentId": 15176,
    "codingamerId": 1110733,
    "commentableId": 9085291,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 15170,
    "votableId": 9157049,
    "userVoteValue": 0,
    "nickname": "crashtestdummy",
    "content": "I totally agree with that. If a validator proves to be more difficult than a test, I suggest you swap them so that a legit working program should pass the validation without further trouble.\nEspecially for that kind of abstract computations, a small bug can take hours to fix if there are no tests available to pinpoint the source of the problem.",
    "codingamerHandle": "c0f03664bd43bf3dcb8bed1b2f0e56803370111",
    "avatar": 2887336002045,
    "elapsedTime": 230334617000
  },
  {
    "commentId": 15186,
    "codingamerId": 837436,
    "commentableId": 9085291,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 15170,
    "votableId": 9159373,
    "userVoteValue": 0,
    "nickname": "aropan",
    "content": "Fixed.",
    "codingamerHandle": "3d2a786d1c0ab7176a18538c7ab8c38f634738",
    "avatar": 68849260530594,
    "elapsedTime": 230315323000
  },
  {
    "commentId": 15193,
    "codingamerId": 1110733,
    "commentableId": 9085291,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 15169,
    "votableId": 9160731,
    "userVoteValue": 0,
    "nickname": "crashtestdummy",
    "content": "I see no reason why validators should be an issue now that the 2^32 limit and Gilsidoo's problem have been fixed.\nThe numbers seem to present the same difficulty, the digit values change but the algorithm should face the same challenge in both cases. I never ran into trouble with them, at any rate. I tried to put a couple intentional mistakes in my code and both tests and validators failed, as expected.\n\nSounds quite OK to me. Approved :)",
    "codingamerHandle": "c0f03664bd43bf3dcb8bed1b2f0e56803370111",
    "avatar": 2887336002045,
    "elapsedTime": 230295872000
  }
]