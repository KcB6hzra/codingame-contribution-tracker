[
  {
    "commentId": 41543,
    "codingamerId": 4197613,
    "commentableId": 16278804,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "votableId": 17328506,
    "userVoteValue": 0,
    "nickname": "baguettes",
    "content": "Great puzzle! Here's my solution in Ruby:\n\nd={}\ngets.to_i.times{\nn,*r=gets.split\nd[n]=r*' '}\nf=gets\nf.scan(/<\\w+>/){|m|\nf=f.gsub m,d[m[1..-2]]||''}\n$><<f",
    "codingamerHandle": "4b733552373942749c1a2e9cef25f2083167914",
    "avatar": 59267566528817,
    "elapsedTime": 155502638000
  },
  {
    "commentId": 38226,
    "codingamerId": 4027771,
    "commentableId": 16278804,
    "responseCount": 1,
    "upVotes": 1,
    "downVotes": 0,
    "votableId": 16610848,
    "userVoteValue": 0,
    "nickname": "AndreMarasca",
    "content": "I added 1 very important test case, 2 not keys in the same sentence, because I verified that people were using replace (/<.*>/ g, \"\") this way. Now this regex will fail, forcing the person to correct the regex",
    "codingamerHandle": "c9834b27296724795b88dd58e8759b5f1777204",
    "avatar": 52647904853809,
    "elapsedTime": 160697278000
  },
  {
    "commentId": 36836,
    "codingamerId": 4013791,
    "commentableId": 16278804,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "votableId": 16393507,
    "userVoteValue": 0,
    "nickname": "LTNightshade",
    "content": "✅ Approved the contribution.\nComment: i like it\n\nJavascript:\n\nn=+(r=readline)(dict=new Map());[...Array(n)].map(i=>r().split` `).map(([k,...v])=>dict.set(k,v.join` `))\nprint(r().replace(/\\<(.+?)\\>/g,x=>dict.has(x=x.slice(1,-1))?dict.get(x):''))",
    "codingamerHandle": "92bbb711a6b52cbf724f3c364056dc441973104",
    "avatar": 52126062565051,
    "elapsedTime": 162568356000
  },
  {
    "commentId": 36696,
    "codingamerId": 3376384,
    "commentableId": 16278804,
    "responseCount": 0,
    "upVotes": 1,
    "downVotes": 0,
    "votableId": 16368944,
    "userVoteValue": 0,
    "nickname": "tierrarica616",
    "content": "✅ Approved the contribution.\nComment: Approved with changes accepted in my comment below.",
    "codingamerHandle": "10fe39d252d8c6e7dda9384fe0c1b8284836733",
    "avatar": 29892445962458,
    "elapsedTime": 162762602000
  },
  {
    "commentId": 36684,
    "codingamerId": 3376384,
    "commentableId": 16278804,
    "responseCount": 1,
    "upVotes": 1,
    "downVotes": 0,
    "votableId": 16367411,
    "userVoteValue": 0,
    "nickname": "tierrarica616",
    "content": "I enjoyed this challenge. Coming up with a plan to identify the <> inside quotes made this challenge more difficult. Otherwise it would have been very simple.\n\nPython 3:\nimport re\n\nn = int(input())\nd = {}\nfor i in range(n):\n    k, *v = input().split()\n    d[k] = \" \".join(v)\n\ntemplate = input()\nfor k, v in d.items():\n    template = template.replace(f\"<{k}>\", v)\n\nprint(re.sub(\"<(\\w*)>\", \"\", template))\n\n\nI would reword \"The input contains no dangling < or >), but user data pairs might be missing (then just remove the placeholder), redundant, or used more than just once.\"\n\nMaybe this is more clear?\nThe input contains no dangling < or >. If the template contains an unprovided key, remove that placeholder from the template. A key may be unused or used more than once.",
    "codingamerHandle": "10fe39d252d8c6e7dda9384fe0c1b8284836733",
    "avatar": 29892445962458,
    "elapsedTime": 162769473000
  },
  {
    "commentId": 36681,
    "codingamerId": 4027771,
    "commentableId": 16278804,
    "responseCount": 2,
    "upVotes": 0,
    "downVotes": 1,
    "votableId": 16366875,
    "userVoteValue": 0,
    "nickname": "AndreMarasca",
    "content": "✅ Approved the contribution.\nComment: Nice and trick\n\nJS:\n\nconst n = parseInt(readline());\nlet d = {};\nfor (let i = 0; i < n; i++) {\n    let [key, ...value] = readline().split(\" \");\n    d[\"<\"+key+\">\"] = value.join(\" \");\n}\nconst template = readline();\nconsole.log(template.replace(/<[^<>]*>/g,x=>d[x]||\"\"));",
    "codingamerHandle": "c9834b27296724795b88dd58e8759b5f1777204",
    "avatar": 52647904853809,
    "elapsedTime": 162771236000
  },
  {
    "commentId": 36682,
    "codingamerId": 4027771,
    "commentableId": 16278804,
    "responseCount": 0,
    "upVotes": 1,
    "downVotes": 0,
    "parentCommentId": 36681,
    "votableId": 16367054,
    "userVoteValue": 0,
    "nickname": "AndreMarasca",
    "content": "I didn't want to be biased looking at validators, but it is not specified that key only contains \\w (as in your solution Velcoro), so I used [^<>]",
    "codingamerHandle": "c9834b27296724795b88dd58e8759b5f1777204",
    "avatar": 52647904853809,
    "elapsedTime": 162770635000
  },
  {
    "commentId": 36693,
    "codingamerId": 1848459,
    "commentableId": 16278804,
    "responseCount": 0,
    "upVotes": 1,
    "downVotes": 0,
    "parentCommentId": 36684,
    "votableId": 16368022,
    "userVoteValue": 0,
    "nickname": "Velcoro",
    "content": "Thanks a lot, especially for the correction which I happily used :)",
    "codingamerHandle": "d89fa298a6c90c0afd8828c355565ffb9548481",
    "avatar": 48538649860014,
    "elapsedTime": 162767236000
  },
  {
    "commentId": 38231,
    "codingamerId": 1848459,
    "commentableId": 16278804,
    "responseCount": 0,
    "upVotes": 1,
    "downVotes": 0,
    "parentCommentId": 38226,
    "votableId": 16612862,
    "userVoteValue": 0,
    "nickname": "Velcoro",
    "content": "Awesome, thanks a lot!",
    "codingamerHandle": "d89fa298a6c90c0afd8828c355565ffb9548481",
    "avatar": 48538649860014,
    "elapsedTime": 160687326000
  },
  {
    "commentId": 36683,
    "codingamerId": 1848459,
    "commentableId": 16278804,
    "responseCount": 0,
    "upVotes": 1,
    "downVotes": 0,
    "parentCommentId": 36681,
    "votableId": 16367143,
    "userVoteValue": 0,
    "nickname": "Velcoro",
    "content": "Good point, I'll add that, thanks!",
    "codingamerHandle": "d89fa298a6c90c0afd8828c355565ffb9548481",
    "avatar": 48538649860014,
    "elapsedTime": 162770280000
  }
]