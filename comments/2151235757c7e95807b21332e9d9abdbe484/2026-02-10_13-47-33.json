[
  {
    "commentId": 19037,
    "codingamerId": 1569823,
    "commentableId": 10334692,
    "responseCount": 22,
    "upVotes": 0,
    "downVotes": 0,
    "votableId": 10455609,
    "userVoteValue": 0,
    "nickname": "Niako",
    "content": "First of all, to contextualize, I mention that this problem follows from our discussion here https://www.codingame.com/contribute/view/20818c957dbe59c292757e45a6503a3c080d\n\nYou have decided to leave the ECC setting and to write this problem in the (simpler) setting of the modular multiplicative groups instead. Why not, however this problem seriously lacks of a contextualization, in particular the link to cryptography should be made explicit: You are given a public key and you attack to retrieve the private key, etc (+ maybe a link to your previous problem as an example of a key generation in another setting)...\n\nIn my opinion the \"check whether P is prime\" part is lame, all the more as here it is an additional uninteresting and very basic task for a \"hard\" problem. Honestly, just give us a valid P, period.\n\nI also edited to fix a few typos (e.g. ligne -> line).",
    "codingamerHandle": "eb89cbdf69d07106c84edf1d191caaf33289651",
    "avatar": 11911528647474,
    "elapsedTime": 215047935000
  },
  {
    "commentId": 19030,
    "codingamerId": 3118570,
    "commentableId": 10334692,
    "responseCount": 2,
    "upVotes": 0,
    "downVotes": 0,
    "votableId": 10454919,
    "userVoteValue": 0,
    "nickname": "Razovsky",
    "content": "Mate this subject is quite similar to this one:\n\nhttps://www.codingame.com/training/medium/carmichael-numbers\n\nAs the input is not this similar, the way to solve it is quite the same. What do you think ?",
    "codingamerHandle": "6f5a5cd850ab97e204b72fe4513f01150758113",
    "avatar": 24597204966152,
    "elapsedTime": 215053077000
  },
  {
    "commentId": 18928,
    "codingamerId": 837436,
    "commentableId": 10334692,
    "responseCount": 3,
    "upVotes": 0,
    "downVotes": 0,
    "votableId": 10438110,
    "userVoteValue": 0,
    "nickname": "aropan",
    "content": "In this problem determinate prime can more simple:\n```\n        bool is_prime = true;\n        for (long long i = 2; i * i <= p; ++i) {\n            if (p % i == 0) {\n                is_prime = false;\n                break;\n            }\n        }\n```",
    "codingamerHandle": "3d2a786d1c0ab7176a18538c7ab8c38f634738",
    "avatar": 68849260530594,
    "elapsedTime": 215280536000
  },
  {
    "commentId": 18927,
    "codingamerId": 837436,
    "commentableId": 10334692,
    "responseCount": 3,
    "upVotes": 2,
    "downVotes": 0,
    "votableId": 10438087,
    "userVoteValue": 0,
    "nickname": "aropan",
    "content": "I added big test, but add three tests (author solution output 0, but it wrong answer):\n\nZero test\n49999999961 1 49999999967\nValidator\n42 1 49999999967\n\nAntizero test\n49999999957 1 49999999961\nValidator\n25389326444 1 49999999967\n\nOnes test\n1 1 49999999967\nValidator\n1 1 49999999961\n\nOutputs:\n49999999966\n49999999966\n6249999995\n24999999983\n1\n1",
    "codingamerHandle": "3d2a786d1c0ab7176a18538c7ab8c38f634738",
    "avatar": 68849260530594,
    "elapsedTime": 215280818000
  },
  {
    "commentId": 18926,
    "codingamerId": 837436,
    "commentableId": 10334692,
    "responseCount": 1,
    "upVotes": 0,
    "downVotes": 0,
    "votableId": 10437917,
    "userVoteValue": 0,
    "nickname": "aropan",
    "content": "My not optimised solution get TL in Test IDE. C++ solution works 0.271672 sec on test 6. How long does your solution work on python?\n\nUPD on local machine C++ has 0.15 sec time execute versus 1.69 sec your python version. C++ and Python have different limit in Test IDE?",
    "codingamerHandle": "3d2a786d1c0ab7176a18538c7ab8c38f634738",
    "avatar": 68849260530594,
    "elapsedTime": 215282995000
  },
  {
    "commentId": 18925,
    "codingamerId": 837436,
    "commentableId": 10334692,
    "responseCount": 2,
    "upVotes": 0,
    "downVotes": 0,
    "votableId": 10437814,
    "userVoteValue": 0,
    "nickname": "aropan",
    "content": "--May be P < 2 * 10^9 is better? When language without long arithmetic number (eg C++ and Pascal) can use 64 bit number.--\n\nUPD. although this task in such languages is even better - need use mulmod:\n```\nll mulmod(ll a, ll b, ll p) {\n    if (b == 0) {\n        return 0;\n    }\n    ll ret = mulmod(a, b >> 1, p);\n    addmod(ret, ret, p);\n    if (b & 1) {\n        addmod(ret, a, p);\n    }\n    return ret;\n}\n```",
    "codingamerHandle": "3d2a786d1c0ab7176a18538c7ab8c38f634738",
    "avatar": 68849260530594,
    "elapsedTime": 215284285000
  },
  {
    "commentId": 18774,
    "codingamerId": 2416641,
    "commentableId": 10334692,
    "responseCount": 3,
    "upVotes": 1,
    "downVotes": 0,
    "votableId": 10406099,
    "userVoteValue": 0,
    "nickname": "Zenoscave",
    "content": "Are there any similar problems on here yet? I feel I have seen one. If not, this is a puzzle i'd vote for and approve",
    "codingamerHandle": "df4e9a1fb8d928f54db1f30a63dcfa511466142",
    "avatar": 16732569385856,
    "elapsedTime": 215709291000
  },
  {
    "commentId": 18785,
    "codingamerId": 270881,
    "commentableId": 10334692,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 18774,
    "votableId": 10411809,
    "userVoteValue": 0,
    "nickname": "Maurice_Moss",
    "content": "Thanks for your feedback, I haven't done them all. I only did this one but it's not the same algorithm https://www.codingame.com/training/hard/factorial-vs-exponential.\n\nWhen I wrote the puzzle, there were no other puzzle with \"modular calculus\" keywords so I don't think it exists",
    "codingamerHandle": "de015f1a510d60cdcd0551896a34c709188072",
    "avatar": 30069480173944,
    "elapsedTime": 215646393000
  },
  {
    "commentId": 18969,
    "codingamerId": 270881,
    "commentableId": 10334692,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 18925,
    "votableId": 10442616,
    "userVoteValue": 0,
    "nickname": "Maurice_Moss",
    "content": "I wrote this puzzle based on Niako's advices while proposing a previous contribution (https://www.codingame.com/training/hard/elliptic-curve-cryptography). AFAIK, all languages are able to play with integer of at least 53 bits. Hence, I designed it on my computer and try to find a P such as my computation time is lower than 1s (worst case was 0.6s) but big enought to not be able to bruteforce the K. I'm fine to decrease to 2.000.000.000 but I don't think has a benefit but I may miss something?\n\nFor your mulmod, it makes sense. I have to use also a modular power instead of the classic formula to avoid timeout (default function in python btw).",
    "codingamerHandle": "de015f1a510d60cdcd0551896a34c709188072",
    "avatar": 30069480173944,
    "elapsedTime": 215218172000
  },
  {
    "commentId": 18967,
    "codingamerId": 270881,
    "commentableId": 10334692,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 18926,
    "votableId": 10442500,
    "userVoteValue": 0,
    "nickname": "Maurice_Moss",
    "content": "I timed my solution here directly. I'm surprised because:\nTest 6 tooks 1.72s\nVal 6 tooks 1.70s\n\nYour other tests tooks between 1.2 and 1.9 seconds. Is there a time limit changed since few time ? I was thinking about 1s for every language in Community puzzles",
    "codingamerHandle": "de015f1a510d60cdcd0551896a34c709188072",
    "avatar": 30069480173944,
    "elapsedTime": 215218995000
  },
  {
    "commentId": 18968,
    "codingamerId": 270881,
    "commentableId": 10334692,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 18927,
    "votableId": 10442529,
    "userVoteValue": 0,
    "nickname": "Maurice_Moss",
    "content": "That's fine for me ! Thanks for your contribution :)",
    "codingamerHandle": "de015f1a510d60cdcd0551896a34c709188072",
    "avatar": 30069480173944,
    "elapsedTime": 215218797000
  },
  {
    "commentId": 18966,
    "codingamerId": 270881,
    "commentableId": 10334692,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 18928,
    "votableId": 10442478,
    "userVoteValue": 0,
    "nickname": "Maurice_Moss",
    "content": "I haven't tried this implementation in Python. I don't think it will pass w/o timeout for big values. With the sqrt(p) maybe... I'll try that\n\nUPD : Oops I didn't saw that you use also the sqrt implicitely by saying i*i <p. BTW, I tried this implementation and indeed it is faster :(. I'm now below the second for every test except the Big Test which tooks 1.2s",
    "codingamerHandle": "de015f1a510d60cdcd0551896a34c709188072",
    "avatar": 30069480173944,
    "elapsedTime": 215219210000
  },
  {
    "commentId": 19038,
    "codingamerId": 1569823,
    "commentableId": 10334692,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 19030,
    "votableId": 10455741,
    "userVoteValue": 0,
    "nickname": "Niako",
    "content": "I do not think this is actually related.",
    "codingamerHandle": "eb89cbdf69d07106c84edf1d191caaf33289651",
    "avatar": 11911528647474,
    "elapsedTime": 215046952000
  },
  {
    "commentId": 19048,
    "codingamerId": 270881,
    "commentableId": 10334692,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 19037,
    "votableId": 10458172,
    "userVoteValue": 0,
    "nickname": "Maurice_Moss",
    "content": "Hi Niako. Initially I wanted to explain the context/usage in cryptography. However, you saw that some people preferred a short explanation than a long one. As a result, I based the exercise to be similar to https://www.codingame.com/training/hard/factorial-vs-exponential which is also a hard one... Of course, it may be considered simple for you as you know the solution but I think it may be tricky for some other coders already doing difficult puzzles.\n\nDoing it on ECCs, so far I'm not able to extrapolate this. If I succeed, I may propose it as a \"very hard\" being a union of both puzzles.\n\nThe check for P prime is only because in theory, P should be prime. I can mention it in a short context",
    "codingamerHandle": "de015f1a510d60cdcd0551896a34c709188072",
    "avatar": 30069480173944,
    "elapsedTime": 215021990000
  },
  {
    "commentId": 19049,
    "codingamerId": 1569823,
    "commentableId": 10334692,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 19037,
    "votableId": 10458325,
    "userVoteValue": 0,
    "nickname": "Niako",
    "content": "The contextualization does not need to be long (e.g. just a few easily skippable lines at the beginning).\n\nAs for the prime part, P does NOT actually need to be prime in theory, the important point is that A is in the multiplicative group mod P (i.e. on the curve ;-) in the case of ECC), which is the case for all 0 < A < P if P is prime (that's why it's simpler to take P prime).\nHonestly, I think that the problem should only focus on the discrete log part, providing a good setting for each case without asking for the solver to check it. An ideal setting is: P prime and A a generator of the multiplicative group (i.e. A of order P-1, a primitive root https://en.wikipedia.org/wiki/Primitive_root_modulo_n).",
    "codingamerHandle": "eb89cbdf69d07106c84edf1d191caaf33289651",
    "avatar": 11911528647474,
    "elapsedTime": 215020257000
  },
  {
    "commentId": 19059,
    "codingamerId": 270881,
    "commentableId": 10334692,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 19037,
    "votableId": 10461131,
    "userVoteValue": 0,
    "nickname": "Maurice_Moss",
    "content": "I've added the context (I hope it won't  makes the exercice more complex to understand because there is now more variables :s). \n\nRegarding P, I don't get it completely. If A is your encoded message. How can you be sure that A and P will always be coprime (it will depend on your message and the public key) ? Indeed in RSA, P is composed of a product of (Y-1) x (Z-1) with Y ans Z being 2 primes but as a result, P is never prime. Does it have to be B and P which are coprimes ?",
    "codingamerHandle": "de015f1a510d60cdcd0551896a34c709188072",
    "avatar": 30069480173944,
    "elapsedTime": 214969477000
  },
  {
    "commentId": 19060,
    "codingamerId": 1569823,
    "commentableId": 10334692,
    "responseCount": 0,
    "upVotes": 1,
    "downVotes": 0,
    "parentCommentId": 19037,
    "votableId": 10461200,
    "userVoteValue": 0,
    "nickname": "Niako",
    "content": "Well, I'm afraid the discrete log problem has nothing to do with RSA (which is based on the factorization problem instead)... And A has nothing to do with the encoded message.\nRead https://en.wikipedia.org/wiki/ElGamal_encryption to get the full picture. Your discrete log puzzle is an attack on the generated public key.",
    "codingamerHandle": "eb89cbdf69d07106c84edf1d191caaf33289651",
    "avatar": 11911528647474,
    "elapsedTime": 214968629000
  },
  {
    "commentId": 19062,
    "codingamerId": 270881,
    "commentableId": 10334692,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 19037,
    "votableId": 10463123,
    "userVoteValue": 0,
    "nickname": "Maurice_Moss",
    "content": "you are right, I don't know why my brain deviated to this -_-'. I mixed up the symmetrical key creation using Diffie-Hellman key exchange and the RSA... I'll have to think about this offline :D (for now I removed the Context)\n\nUPD : Difficulty reduced to Medium (based on other puzzles difficulty). Context updated also",
    "codingamerHandle": "de015f1a510d60cdcd0551896a34c709188072",
    "avatar": 30069480173944,
    "elapsedTime": 214959806000
  },
  {
    "commentId": 19094,
    "codingamerId": 154906,
    "commentableId": 10334692,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 19037,
    "votableId": 10465900,
    "userVoteValue": 0,
    "nickname": "JBM",
    "content": "I agree with the change to contextualize, but now there's brain overload on my side under the sheer amount of identifiers.\n\nI edited A, B, C out to settle on E, M, Pk everywhere. Please cross-check.\n\n(I also fixed typos, rewrote a sentence of the last paragraph, and \"fixed\" the constraint on B/Pk to a constraint on M/C which makes more sense to me in context.)\n\nI also concur with Niako on the useless painfulness of having potentially invalid inputs. Just make P prime please.\n\n*Re-edited because it's actually Sk we're looking for, not Pk.\n\n*And edited the stub, too.",
    "codingamerHandle": "0d71f9df5da706f9f77c07c34d12480e609451",
    "elapsedTime": 214931472000
  },
  {
    "commentId": 19097,
    "codingamerId": 270881,
    "commentableId": 10334692,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 19037,
    "votableId": 10467424,
    "userVoteValue": 0,
    "nickname": "Maurice_Moss",
    "content": "Thanks for your contribution. by reading it again, I realized that there were some repeated sentences/information. I've updated the context to have it clearer (I hope :) ).\n\nI removed the condition (and the test) to check for primality.\n\nThe solution is updated and still cannot pass by bruteforce (at least in python)",
    "codingamerHandle": "de015f1a510d60cdcd0551896a34c709188072",
    "avatar": 30069480173944,
    "elapsedTime": 214897551000
  },
  {
    "commentId": 19103,
    "codingamerId": 1569823,
    "commentableId": 10334692,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 19037,
    "votableId": 10468176,
    "userVoteValue": 0,
    "nickname": "Niako",
    "content": "The context has changed several times, yet, right now, it still does not make any sense to me! What is your reference for the cryptosystem you describe??\n\nAFAIK, the context is simple:\nTo set up a modular asymmetric cryptosystem, one can generate a pair of public & private keys by picking a prime P, a generator 0<G<P and an exponent E. Then use (P, G, G^E mod P) as public key and keep (P, G, E) as private key. This setting allows to encrypt messages using ElGamal encryption, to sign messages using ElGamal signature or DSA, to establish a shared secret using Diffie-Hellman, etc. But all that is out of scope of this puzzle.\nThe safety relies on the secrecy of the private key knowing the public key, i.e. on the difficulty of computing E knowing G^E mod P, known as the discrete log problem.\nIn this puzzle we attack the discrete log problem: given a (small enough) public key, retrieve the private key.",
    "codingamerHandle": "eb89cbdf69d07106c84edf1d191caaf33289651",
    "avatar": 11911528647474,
    "elapsedTime": 214883449000
  },
  {
    "commentId": 19104,
    "codingamerId": 270881,
    "commentableId": 10334692,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 19037,
    "votableId": 10468252,
    "userVoteValue": 0,
    "nickname": "Maurice_Moss",
    "content": "For me, this is what is explained. An attacker knows the public key. He uses it on his own message to try to find the private key.  Just for info, I used this link https://link.springer.com/chapter/10.1007%2F978-0-387-48742-7_4 and try to explain it to be understandable for most of the players. \n\nThat's also why I skipped the context initially baceause it involves multiple variable to explain it but only few are usefull for the problem",
    "codingamerHandle": "de015f1a510d60cdcd0551896a34c709188072",
    "avatar": 30069480173944,
    "elapsedTime": 214882414000
  },
  {
    "commentId": 19105,
    "codingamerId": 1569823,
    "commentableId": 10334692,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 19037,
    "votableId": 10468310,
    "userVoteValue": 0,
    "nickname": "Niako",
    "content": "No that's definitely not what is explained and the reason is obviously that your reference is a book on RSA that explains how the DLP can also be used to attack RSA! Your keys (which are not defined) are implicitly RSA keys and the encryption you refer to is the RSA encryption process. But this would be a very convoluted way to contextualize the DLP as RSA is not primarily DLP-based.\n\nIn my previous message, the key generation is very directly DLP-based and has nothing to do with the RSA key generation process. It's a much simpler, direct and natural contextualization (and BTW it's also the same as the key generation of your ECC puzzle, that's precisely why I had initialy suggested the reverse puzzle).",
    "codingamerHandle": "eb89cbdf69d07106c84edf1d191caaf33289651",
    "avatar": 11911528647474,
    "elapsedTime": 214881631000
  },
  {
    "commentId": 19108,
    "codingamerId": 270881,
    "commentableId": 10334692,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 19037,
    "votableId": 10468554,
    "userVoteValue": 0,
    "nickname": "Maurice_Moss",
    "content": "I think I get it. You are talking about attacking directly the public key ? In ElGamal, Alice published (G, a, p, h) with h = a^x % p (x being the secret key). G is in this case the multiplicative group but it could be an ECC. As a result, the public key contains all the element to find the secret key. Am I right ?\n\nAt the end, it's very similar to the attack on the RSA. The only difference is that with RSA, you need to generate your own cypher code as you don't know the target message ?",
    "codingamerHandle": "de015f1a510d60cdcd0551896a34c709188072",
    "avatar": 30069480173944,
    "elapsedTime": 214877828000
  },
  {
    "commentId": 19110,
    "codingamerId": 1569823,
    "commentableId": 10334692,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 19037,
    "votableId": 10468710,
    "userVoteValue": 0,
    "nickname": "Niako",
    "content": "Yep, exactly! But the public key I'm talking about is not a RSA public key, it's not the same cryptosystem.\nIt's similar to the attack on RSA basically just because both attacks use DLP (knowing the RSA public key E, compute C = M^E for some arbitrary M, we know that C^D = M for D the private key so this falls down to the DLP). However RSA itself is much more complex to explain (that's why I did not understand your text before you gave the reference as the cryptosystem was not defined) and not directly DLP-based.",
    "codingamerHandle": "eb89cbdf69d07106c84edf1d191caaf33289651",
    "avatar": 11911528647474,
    "elapsedTime": 214875808000
  },
  {
    "commentId": 19112,
    "codingamerId": 270881,
    "commentableId": 10334692,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 19037,
    "votableId": 10469288,
    "userVoteValue": 0,
    "nickname": "Maurice_Moss",
    "content": "Yes, I got that you were not talking about RSA. I didn't understood completely ElGamal  (for me it was identical to Diffie-Hellman but it's slightly different).\n\nIt's now re-edited but I only explained the first part of ElGamal to avoid having to much \"useless\" information.",
    "codingamerHandle": "de015f1a510d60cdcd0551896a34c709188072",
    "avatar": 30069480173944,
    "elapsedTime": 214867517000
  },
  {
    "commentId": 19114,
    "codingamerId": 1569823,
    "commentableId": 10334692,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 19037,
    "votableId": 10469575,
    "userVoteValue": 0,
    "nickname": "Niako",
    "content": "Nice. I edited to fix a few typos / wording pbs.\nI'm still concerned with a few things:\n - I don't really understand the tests about 0. Why should we care about answering order(A) when the answer is 0 (if it's 0, then it's 0, if you are an attacker then whatever, it does not matter)?\n - I still believe that it would be better to always have A of order P-1 (cf. one of my previous messages):\n 1. This gives the most robust setting (otherwise order(A) is a strict divisor of P-1 and can be significantly smaller).\n 2. That way there *always* is a *unique* solution between 0 and P-2 (no more \"-1\", no more \"lowest integer\"). Plus in practical situations, you know there is a solution!\n 3. This simplifies other approaches: BSGS is by far the simplest approach, yet it's not the only one, I tried Pollard's rho for the fun (theoretically the same time complexity, in practice significantly slower yet it uses no memory), it works yet it's more complicated because of that non optimal setting.",
    "codingamerHandle": "eb89cbdf69d07106c84edf1d191caaf33289651",
    "avatar": 11911528647474,
    "elapsedTime": 214863449000
  },
  {
    "commentId": 19115,
    "codingamerId": 154906,
    "commentableId": 10334692,
    "responseCount": 0,
    "upVotes": 1,
    "downVotes": 0,
    "parentCommentId": 19037,
    "votableId": 10469700,
    "userVoteValue": 0,
    "nickname": "JBM",
    "content": "+1 for the zero thing. FWIW Coni's implementation differs from WP on this, and I'm not yet totally convinced he can't miss solutions because of it. (couldn't find a counterexample on small ints, but still)",
    "codingamerHandle": "0d71f9df5da706f9f77c07c34d12480e609451",
    "elapsedTime": 214861838000
  },
  {
    "commentId": 19116,
    "codingamerId": 1569823,
    "commentableId": 10334692,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 19037,
    "votableId": 10470077,
    "userVoteValue": 0,
    "nickname": "Niako",
    "content": "That implementation is wrong indeed (probably precisely to avoid 0, yet it can miss much more because of that). For instance on \"2 1 7\" it gives \"-1\" (missing all solutions).\n\nFor reference, I gave a valid and efficient Python3 implementation below in the comments a few days ago.",
    "codingamerHandle": "eb89cbdf69d07106c84edf1d191caaf33289651",
    "avatar": 11911528647474,
    "elapsedTime": 214857301000
  },
  {
    "commentId": 19117,
    "codingamerId": 270881,
    "commentableId": 10334692,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 19037,
    "votableId": 10470098,
    "userVoteValue": 0,
    "nickname": "Maurice_Moss",
    "content": "For the 0 test, I made a mistake in the function and I didn't know that a^(p-1) % p = 1 for all p primes. The function started at 1 and find only p-1 as answer.\n\nAll the tests I generated (Test 1 to Test 6) were done by increasing only the number of digits (to avoid bruteforce). As a result A is always \"close\" to P. The other ones were proposed by aropan. But now, I understand better this attack and indeed it makes no sense to choose a secret key which is 0 or take a == 1. Test are removed.\n\nFinally, for the Test 6 which is the one having no solution, It also makes no sense due to the construction of the key. I removed it. \n\nContext, Contrains and Solutions, Test cases are updated\n\nRegarding Pollard's rho, I tried it on a notebook at the same time I tried BSGS but I was not able to make it running properly :s. It's the same for Pohlig–Hellman",
    "codingamerHandle": "de015f1a510d60cdcd0551896a34c709188072",
    "avatar": 30069480173944,
    "elapsedTime": 214857034000
  },
  {
    "commentId": 19149,
    "codingamerId": 154906,
    "commentableId": 10334692,
    "responseCount": 0,
    "upVotes": 1,
    "downVotes": 0,
    "parentCommentId": 19037,
    "votableId": 10474593,
    "userVoteValue": 0,
    "nickname": "JBM",
    "content": "I've made a few minor text edits to lighten the wording a bit.\n\nThis puzzle seems almost good to me now. My only peeve for now is the variables' current naming: what do A and C (with no B ) stand for in the current state?\n\nAm I missing anything else?",
    "codingamerHandle": "0d71f9df5da706f9f77c07c34d12480e609451",
    "elapsedTime": 214784515000
  },
  {
    "commentId": 19154,
    "codingamerId": 270881,
    "commentableId": 10334692,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 19037,
    "votableId": 10475138,
    "userVoteValue": 0,
    "nickname": "Maurice_Moss",
    "content": "There is no specific meaning. \n\nOn some cases you can see :\n- P, G or alpha instead of A\n- Q, K, B or beta instead of Sk (I named it Sk for Secret Key).\n- R, H or gamma instead of C\n- P is often named N but I prefer P as it is often a prime number. \n\nThis depend on the source you use. Initially, I wanted to skip the context so I used A, B, C and P such as A^B = C mod P. I can update it to Wikipedia's notation on ElGamal's algorithm",
    "codingamerHandle": "de015f1a510d60cdcd0551896a34c709188072",
    "avatar": 30069480173944,
    "elapsedTime": 214779019000
  },
  {
    "commentId": 19155,
    "codingamerId": 154906,
    "commentableId": 10334692,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 19037,
    "votableId": 10475195,
    "userVoteValue": 0,
    "nickname": "JBM",
    "content": "Yes, please update to some consistent set! Right now A/C is... weird.",
    "codingamerHandle": "0d71f9df5da706f9f77c07c34d12480e609451",
    "elapsedTime": 214778502000
  },
  {
    "commentId": 19156,
    "codingamerId": 270881,
    "commentableId": 10334692,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 19037,
    "votableId": 10475261,
    "userVoteValue": 0,
    "nickname": "Maurice_Moss",
    "content": "it's updated :)",
    "codingamerHandle": "de015f1a510d60cdcd0551896a34c709188072",
    "avatar": 30069480173944,
    "elapsedTime": 214777759000
  },
  {
    "commentId": 19173,
    "codingamerId": 154906,
    "commentableId": 10334692,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 19037,
    "votableId": 10476247,
    "userVoteValue": 0,
    "nickname": "JBM",
    "content": "Ok, let's roll!",
    "codingamerHandle": "0d71f9df5da706f9f77c07c34d12480e609451",
    "elapsedTime": 214769680000
  },
  {
    "commentId": 19039,
    "codingamerId": 878974,
    "commentableId": 10334692,
    "responseCount": 0,
    "upVotes": 2,
    "downVotes": 0,
    "parentCommentId": 19030,
    "votableId": 10455752,
    "userVoteValue": 0,
    "nickname": "nicola",
    "content": "As far as I know, it isn’t the same puzzle, it isn’t the same way to solve it.",
    "codingamerHandle": "21bf42f790de293c3aef398f18cd2627479878",
    "onlineSince": 1770701591260,
    "avatar": 26090852120005,
    "elapsedTime": 215046832000
  },
  {
    "commentId": 19050,
    "codingamerId": 1569823,
    "commentableId": 10334692,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 18928,
    "votableId": 10458669,
    "userVoteValue": 0,
    "nickname": "Niako",
    "content": "Compute powers iteratively instead of repetitively calling pow() to go significantly faster:\ndef bsgs(a, c, P):\n    N = math.ceil(math.sqrt(P - 1))\n    memo = {}\n    ai = 1\n    for i in range(N):\n        memo[ai] = i\n        ai = (ai*a) % P\n    d = pow(a, N * (P - 2), P)\n    y = c\n    for j in range(N):\n        if y in memo:\n            return j * N + memo[y]\n        y = (y*d) % P\n    return None",
    "codingamerHandle": "eb89cbdf69d07106c84edf1d191caaf33289651",
    "avatar": 11911528647474,
    "elapsedTime": 215014867000
  },
  {
    "commentId": 19106,
    "codingamerId": 270881,
    "commentableId": 10334692,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 18928,
    "votableId": 10468468,
    "userVoteValue": 0,
    "nickname": "Maurice_Moss",
    "content": "nice catch, updated :)",
    "codingamerHandle": "de015f1a510d60cdcd0551896a34c709188072",
    "avatar": 30069480173944,
    "elapsedTime": 214879155000
  },
  {
    "commentId": 19001,
    "codingamerId": 837436,
    "commentableId": 10334692,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 18927,
    "votableId": 10448022,
    "userVoteValue": 0,
    "nickname": "aropan",
    "content": "I will clarify that I can’t add the tests described above, because the author’s solution does not work. I think you will need to correct the solution and add these tests.",
    "codingamerHandle": "3d2a786d1c0ab7176a18538c7ab8c38f634738",
    "avatar": 68849260530594,
    "elapsedTime": 215144056000
  },
  {
    "commentId": 19008,
    "codingamerId": 270881,
    "commentableId": 10334692,
    "responseCount": 0,
    "upVotes": 1,
    "downVotes": 0,
    "parentCommentId": 18927,
    "votableId": 10450247,
    "userVoteValue": 0,
    "nickname": "Maurice_Moss",
    "content": "Sorry, I read too fast. I fixed my code but I found other answers than you for the first one :\n\n49999999961 1 49999999967 =>  49999999966\n42 1 49999999967 => 49999999966\n\nand after check 49999999961^49999999966 % 49999999967  = 1 (see last row of my solution)\n\nUPD : Tests are added with previous results",
    "codingamerHandle": "de015f1a510d60cdcd0551896a34c709188072",
    "avatar": 30069480173944,
    "elapsedTime": 215124535000
  },
  {
    "commentId": 19000,
    "codingamerId": 837436,
    "commentableId": 10334692,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 18925,
    "votableId": 10447971,
    "userVoteValue": 0,
    "nickname": "aropan",
    "content": "I think to task with P <= 5 * 10^10  are more interesting.",
    "codingamerHandle": "3d2a786d1c0ab7176a18538c7ab8c38f634738",
    "avatar": 68849260530594,
    "elapsedTime": 215144398000
  },
  {
    "commentId": 19032,
    "codingamerId": 3118570,
    "commentableId": 10334692,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 18774,
    "votableId": 10455071,
    "userVoteValue": 0,
    "nickname": "Razovsky",
    "content": "Zenoscave is right, something does exist, check my comment up.",
    "codingamerHandle": "6f5a5cd850ab97e204b72fe4513f01150758113",
    "avatar": 24597204966152,
    "elapsedTime": 215051895000
  },
  {
    "commentId": 19040,
    "codingamerId": 1569823,
    "commentableId": 10334692,
    "responseCount": 0,
    "upVotes": 1,
    "downVotes": 0,
    "parentCommentId": 18774,
    "votableId": 10455784,
    "userVoteValue": 0,
    "nickname": "Niako",
    "content": "I am pretty sure there is no similar problem on CG yet.",
    "codingamerHandle": "eb89cbdf69d07106c84edf1d191caaf33289651",
    "avatar": 11911528647474,
    "elapsedTime": 215046563000
  }
]