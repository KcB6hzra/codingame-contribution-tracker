[
  {
    "commentId": 309170,
    "codingamerId": 4238671,
    "commentableId": 23793514,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "votableId": 35805457,
    "userVoteValue": 0,
    "nickname": "DavidAugustoVilla",
    "content": "If there are no objections, I'd like to add cover art to this puzzle.",
    "codingamerHandle": "455d71552aef838a0c75b7617e2d22d41768324",
    "avatar": 132419401284681,
    "elapsedTime": 36585026000
  },
  {
    "commentId": 73582,
    "codingamerId": 3354337,
    "commentableId": 23793514,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "votableId": 23988739,
    "userVoteValue": 0,
    "nickname": "Westicles",
    "content": "✅ Approved the contribution.\nComment: Nicely done!",
    "codingamerHandle": "613b8dd7e3f3f21da489c27a933e15d67334533",
    "avatar": 79146641399080,
    "elapsedTime": 116500384000
  },
  {
    "commentId": 73435,
    "codingamerId": 4471038,
    "commentableId": 23793514,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "votableId": 23979511,
    "userVoteValue": 0,
    "nickname": "nguyen.lam",
    "content": "✅ Approved the contribution.\nComment: easy and funny, here is my solution :\n\nfrom collections import namedtuple\n\nUnit = namedtuple('Unit', ['multiplicateur','char','num'])\nexp = input() \norder = (((((5,4)['m'in exp],3)['dm'in exp],2)['cm'in exp],1)['mm'in exp],0)['um'in exp]\nunits = []\nunits.append(Unit(0,'um',1))\nunits.append(Unit(1,'mm',1000))\nunits.append(Unit(2,'cm',10000))\nunits.append(Unit(3,'dm',100000))\nunits.append(Unit(4,'m', 1000000))\nunits.append(Unit(5,'km',1000000000))\n\nexp = exp.replace('mm',f'*{list(filter(lambda u: u.char ==\"mm\" , units))[0].num}')\nexp = exp.replace('cm',f'*{list(filter(lambda u: u.char ==\"cm\" , units))[0].num}')\nexp = exp.replace('dm',f'*{list(filter(lambda u: u.char ==\"dm\" , units))[0].num}')\nexp = exp.replace('km',f'*{list(filter(lambda u: u.char ==\"km\" , units))[0].num}')\nexp = exp.replace('um',f'*{list(filter(lambda u: u.char ==\"um\" , units))[0].num}')\nvaleur = eval(exp.replace('m',f'*{list(filter(lambda u: u.char ==\"m\" , units))[0].num}'))\nvaleur = round((valeur / list(filter(lambda u: u.multiplicateur ==order , units))[0].num),5)\nif int(valeur) == valeur:valeur=int(valeur)\nprint(f'{valeur}{list(filter(lambda u: u.multiplicateur ==order , units))[0].char}')",
    "codingamerHandle": "a9fd64833d93b2840c44b26d9d84493e8301744",
    "avatar": 115730569738380,
    "elapsedTime": 116555763000
  },
  {
    "commentId": 73434,
    "codingamerId": 4471038,
    "commentableId": 23793514,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "votableId": 23979485,
    "userVoteValue": 0,
    "nickname": "nguyen.lam",
    "content": "A little bite too easy for me for a puzzle... That could be a good clash of code instead... But very simple to understand and implement. And very funny.\n\nAn improvement you could do would be to add a litlle bite more complexity like :\n- other operand to deal with ( - , * , / ). \n- and maybe 2 or 3 operands for example:\n\n 2m + 3cm * 4dm\n\nSo we would have to deal with priority... because of course: in that case, we would have to do the multiplication first then the addition. at the end: \n\n2m + 3cm * 4dm = 200cm + 3cm * 40cm = 320cm",
    "codingamerHandle": "a9fd64833d93b2840c44b26d9d84493e8301744",
    "avatar": 115730569738380,
    "elapsedTime": 116555816000
  },
  {
    "commentId": 73089,
    "codingamerId": 4258711,
    "commentableId": 23793514,
    "responseCount": 1,
    "upVotes": 0,
    "downVotes": 0,
    "votableId": 23923952,
    "userVoteValue": 0,
    "nickname": "FredericLocquet",
    "content": "✅ Approved the contribution.\nComment: Interesting easy puzzle with the little challenge which is a very pleasant addition. With python we can remove all ifs ;-)",
    "codingamerHandle": "58dca014c9f36cdec7c376f05a997d681178524",
    "avatar": 125739728070045,
    "elapsedTime": 116886147000
  },
  {
    "commentId": 72913,
    "codingamerId": 2874091,
    "commentableId": 23793514,
    "responseCount": 3,
    "upVotes": 0,
    "downVotes": 0,
    "votableId": 23912383,
    "userVoteValue": 0,
    "nickname": "5DN1L",
    "content": "Please correct me if I am wrong, but there does not seem to be any test case or validator where \"rounded to 0.00001 precision\" is actually necessary. If so, please just remove the wording because it is a bit confusing.",
    "codingamerHandle": "bbb8f47ea4601179303c20acdbf5fb6c1904782",
    "onlineSince": 1770727666105,
    "avatar": 134264063920528,
    "elapsedTime": 116976888000
  },
  {
    "commentId": 72917,
    "codingamerId": 3074238,
    "commentableId": 23793514,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 72913,
    "votableId": 23912638,
    "userVoteValue": 0,
    "nickname": "Grarzyna",
    "content": "It's to be secure from precision errors. I guess depending on your approach and compiler you may encounter it. \nI got error for the validator: 16.0408mm + 11um\nExpected:<16051.8um>. Actual:<16051.800000000001um>",
    "codingamerHandle": "1e09cef1ba0241009076f39ee351ecdf8324703",
    "avatar": 76218624776940,
    "elapsedTime": 116975597000
  },
  {
    "commentId": 73090,
    "codingamerId": 3074238,
    "commentableId": 23793514,
    "responseCount": 0,
    "upVotes": 1,
    "downVotes": 0,
    "parentCommentId": 73089,
    "votableId": 23923980,
    "userVoteValue": 0,
    "nickname": "Grarzyna",
    "content": "Wonderfull :D Thanks!!",
    "codingamerHandle": "1e09cef1ba0241009076f39ee351ecdf8324703",
    "avatar": 76218624776940,
    "elapsedTime": 116886007000
  },
  {
    "commentId": 72920,
    "codingamerId": 2874091,
    "commentableId": 23793514,
    "responseCount": 0,
    "upVotes": 1,
    "downVotes": 0,
    "parentCommentId": 72913,
    "votableId": 23912775,
    "userVoteValue": 0,
    "nickname": "5DN1L",
    "content": "Is that the only case where such an error occurs during your testing? If so, I still suggest you to remove the wording, and switch the test case and the validator instead. This will make sure the clash player will discover it if their code does lead to such an issue. I mean, they will know when they can actually see that the actual output is different from the expected output.\n\nI am suggesting it because precision issues may affect quite a number of puzzles/clashes, and I don't think it needs to be mentioned every time.",
    "codingamerHandle": "bbb8f47ea4601179303c20acdbf5fb6c1904782",
    "onlineSince": 1770727666105,
    "avatar": 134264063920528,
    "elapsedTime": 116974935000
  },
  {
    "commentId": 72921,
    "codingamerId": 3074238,
    "commentableId": 23793514,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 72913,
    "votableId": 23912835,
    "userVoteValue": 0,
    "nickname": "Grarzyna",
    "content": "Ok, sound good. I changed it. Thanks.",
    "codingamerHandle": "1e09cef1ba0241009076f39ee351ecdf8324703",
    "avatar": 76218624776940,
    "elapsedTime": 116974603000
  }
]