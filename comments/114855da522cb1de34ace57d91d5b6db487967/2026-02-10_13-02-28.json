[
  {
    "commentId": 323687,
    "codingamerId": 4238671,
    "commentableId": 35775489,
    "responseCount": 1,
    "upVotes": 1,
    "downVotes": 0,
    "votableId": 36188701,
    "userVoteValue": 0,
    "nickname": "DavidAugustoVilla",
    "content": "✅ Approved the contribution.\nComment: It was a considerable amount of work to identify and resolve all the implications correctly.",
    "codingamerHandle": "455d71552aef838a0c75b7617e2d22d41768324",
    "avatar": 132419401284681,
    "elapsedTime": 33520989000
  },
  {
    "commentId": 321909,
    "codingamerId": 4238671,
    "commentableId": 35775489,
    "responseCount": 5,
    "upVotes": 1,
    "downVotes": 0,
    "votableId": 36156651,
    "userVoteValue": 0,
    "nickname": "DavidAugustoVilla",
    "content": "This definitely feels like a Hard problem. I've optimized my solution as best I know how, and it still only solves 3/4 of the tests, timing out on the rest. I'll have to come back to it.",
    "codingamerHandle": "455d71552aef838a0c75b7617e2d22d41768324",
    "avatar": 132419401284681,
    "elapsedTime": 33858956000
  },
  {
    "commentId": 318112,
    "codingamerId": 5271799,
    "commentableId": 35775489,
    "responseCount": 0,
    "upVotes": 1,
    "downVotes": 0,
    "votableId": 36096179,
    "userVoteValue": 0,
    "nickname": "Eulero314",
    "content": "✅ Approved the contribution.\nComment: Interesting puzzle, deceptively simple in the description",
    "codingamerHandle": "7ed5fd396d11683394bd215ec8f0faf49971725",
    "avatar": 96314909854613,
    "elapsedTime": 34464950000
  },
  {
    "commentId": 316196,
    "codingamerId": 5157042,
    "commentableId": 35775489,
    "responseCount": 0,
    "upVotes": 1,
    "downVotes": 0,
    "votableId": 35985789,
    "userVoteValue": 0,
    "nickname": "ManuelJ",
    "content": "✅ Approved the contribution.\nComment: it's a nice puzzle",
    "codingamerHandle": "217fc91294b41005ed35364d2e52ef372407515",
    "avatar": 133836001028985,
    "elapsedTime": 34863182000
  },
  {
    "commentId": 316129,
    "codingamerId": 5157042,
    "commentableId": 35775489,
    "responseCount": 2,
    "upVotes": 1,
    "downVotes": 0,
    "votableId": 35984614,
    "userVoteValue": 0,
    "nickname": "ManuelJ",
    "content": "In the Goal description, you say f=1, but considering \"a xor c -> f\", with \"a=0\" and \"c=0\", then f must be 0, right?",
    "codingamerHandle": "217fc91294b41005ed35364d2e52ef372407515",
    "avatar": 133836001028985,
    "elapsedTime": 34872074000
  },
  {
    "commentId": 314157,
    "codingamerId": 2874091,
    "commentableId": 35775489,
    "responseCount": 1,
    "upVotes": 2,
    "downVotes": 0,
    "votableId": 35937683,
    "userVoteValue": 0,
    "nickname": "5DN1L",
    "content": "Goal\n* Please change \"deduct\" to \"deduce\" (2 times).\n\n* Please add \"the values of\" after \"deduce\".\n\n* Please add \"and\" before \"(2)\".\n\n* Please change \"By the same logic\" to \"Based on the other dependency rules\".\n\n* Please change \"output of\" to \"output for\".\n\nInput\n* Line 1:\n  • Please change \"of\" to \"for\".\n  \n  • Please change \"format\" to \"formatted as\".\n\n  • Please format \":\" as a {{constant}}.\n\n  • Please add \"a\" before \"space\".\n\n* Line 2:\n  • Please change \"expected output nodes\" to \"names of the nodes to output\".\n  \n  • Please add \"a\" before \"space\".\n\n* Line 3:\n  • Please change \"rules\" to \"dependency rules\".\n\n* Last description:\n  • Please change \"a or b -> d means node d is the result of or operation on a and b\" to \"formatted as [[node_a]] [[operation]] [[node_b]] {{->}} [[node_c]], meaning that [[node_c]] is the result of the [[operation]] on [[node_a]] and [[node_b]]\".\"\n\nOutput\n* Please rewrite as:\n\na single concatenated string containing the values of the specified nodes in the given order.\n\nConstraints\n* Please change \"operations\" to \"operation\" and format it as a [[variable]].\n\n* Please rewrite the third constraint as:\n[[node name]] is alphanumeric and always starts with a letter.\n\n* Please rewrite the fourth constraint as:\nWhile multiple solutions may exist for a given graph, the sequence of values for the output nodes is guaranteed to be unique.\n\nThanks.",
    "codingamerHandle": "bbb8f47ea4601179303c20acdbf5fb6c1904782",
    "onlineSince": 1770727666105,
    "avatar": 134264063920528,
    "elapsedTime": 35328381000
  },
  {
    "commentId": 314158,
    "codingamerId": 1983963,
    "commentableId": 35775489,
    "responseCount": 0,
    "upVotes": 1,
    "downVotes": 0,
    "parentCommentId": 314157,
    "votableId": 35937797,
    "userVoteValue": 0,
    "nickname": "pluieciel",
    "content": "Thanks a lot! nice suggestions as always~",
    "codingamerHandle": "3ae5608cc0aec3a2d51efd34cade51cb3693891",
    "avatar": 12585096610807,
    "elapsedTime": 35327666000
  },
  {
    "commentId": 316195,
    "codingamerId": 5157042,
    "commentableId": 35775489,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 316129,
    "votableId": 35985754,
    "userVoteValue": 0,
    "nickname": "ManuelJ",
    "content": "ooh.... now i get.... condition \"a xor c -> f\" makes f=0, but condition \"f or g -> h\" makes f=1.... furthermore f not in solution and does not affect the values on solution then no matters",
    "codingamerHandle": "217fc91294b41005ed35364d2e52ef372407515",
    "avatar": 133836001028985,
    "elapsedTime": 34863620000
  },
  {
    "commentId": 321938,
    "codingamerId": 1983963,
    "commentableId": 35775489,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 321909,
    "votableId": 36158023,
    "userVoteValue": 0,
    "nickname": "pluieciel",
    "content": "Thanks for feedback, I may need more opinions about the difficulty level.\n\nWhat is your solution idea?",
    "codingamerHandle": "3ae5608cc0aec3a2d51efd34cade51cb3693891",
    "avatar": 12585096610807,
    "elapsedTime": 33848550000
  },
  {
    "commentId": 323785,
    "codingamerId": 1983963,
    "commentableId": 35775489,
    "responseCount": 0,
    "upVotes": 1,
    "downVotes": 0,
    "parentCommentId": 323687,
    "votableId": 36189404,
    "userVoteValue": 0,
    "nickname": "pluieciel",
    "content": "Thanks a lot!\nHope you enjoy it~",
    "codingamerHandle": "3ae5608cc0aec3a2d51efd34cade51cb3693891",
    "avatar": 12585096610807,
    "elapsedTime": 33514622000
  },
  {
    "commentId": 322135,
    "codingamerId": 4238671,
    "commentableId": 35775489,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 321909,
    "votableId": 36159909,
    "userVoteValue": 0,
    "nickname": "DavidAugustoVilla",
    "content": "Partially evaluate and/or gates when possible. Keep track of which gates are unsatisfied, and make guesses until there's a solution with no contradiction. Use efficient structures to only check those gates that could be affected on each guess. Next I'm going to try a better guessing strategy than random.",
    "codingamerHandle": "455d71552aef838a0c75b7617e2d22d41768324",
    "avatar": 132419401284681,
    "elapsedTime": 33828747000
  },
  {
    "commentId": 322201,
    "codingamerId": 1983963,
    "commentableId": 35775489,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 321909,
    "votableId": 36161133,
    "userVoteValue": 0,
    "nickname": "pluieciel",
    "content": "Guessing and try would not be an efficient solution once the graph is big.\nI use idea like async promise and callback function. Like there is listener on each node, whenever one node is updated, check if a further step can be done, and that step could trigger another node to be updated and trigger other listener.",
    "codingamerHandle": "3ae5608cc0aec3a2d51efd34cade51cb3693891",
    "avatar": 12585096610807,
    "elapsedTime": 33804151000
  },
  {
    "commentId": 322234,
    "codingamerId": 5271799,
    "commentableId": 35775489,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 321909,
    "votableId": 36161173,
    "userVoteValue": 0,
    "nickname": "Eulero314",
    "content": "Spoiler alert: for my solution (and the hardest part in my opinion), with pen and paper I built a matrix of all possible deductions on 3 values of the variable for every logical operator, given 1 or 2 known values. i.e. if x and y=1 then x=1 and y=1 etc. I've got 22 rules and the problems are solved with no guessing (I loop until the output set is completed). I'm trying to figure out how I can build the rule matrix by code to have a more general solution (i.e. with more operators like nand etc.)",
    "codingamerHandle": "7ed5fd396d11683394bd215ec8f0faf49971725",
    "avatar": 96314909854613,
    "elapsedTime": 33803517000
  },
  {
    "commentId": 322500,
    "codingamerId": 1983963,
    "commentableId": 35775489,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 321909,
    "votableId": 36165802,
    "userVoteValue": 0,
    "nickname": "pluieciel",
    "content": "I use the same idea, just 'improve' by replacing the loop with event listener.",
    "codingamerHandle": "3ae5608cc0aec3a2d51efd34cade51cb3693891",
    "avatar": 12585096610807,
    "elapsedTime": 33769112000
  },
  {
    "commentId": 316756,
    "codingamerId": 1983963,
    "commentableId": 35775489,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 316129,
    "votableId": 36001856,
    "userVoteValue": 0,
    "nickname": "pluieciel",
    "content": "you are right, i had a typo in f.\nthanks, i fix it.",
    "codingamerHandle": "3ae5608cc0aec3a2d51efd34cade51cb3693891",
    "avatar": 12585096610807,
    "elapsedTime": 34721022000
  }
]