[
  {
    "commentId": 24225,
    "codingamerId": 1473017,
    "commentableId": 12014289,
    "responseCount": 2,
    "upVotes": 0,
    "downVotes": 0,
    "votableId": 12274199,
    "userVoteValue": 0,
    "nickname": "justhalf",
    "content": "Should have a test that has only 1 or 0 bit set as well. I just added the test for 1 bit set. Not sure about 0 bit set, as there is only one case. Maybe make both the test and validator the same \"00000000\"?",
    "codingamerHandle": "5c8ed54d11878ff11f2236a591446b5c7103741",
    "avatar": 5020626234049,
    "elapsedTime": 192788534000
  },
  {
    "commentId": 23864,
    "codingamerId": 1611045,
    "commentableId": 12014289,
    "responseCount": 1,
    "upVotes": 1,
    "downVotes": 0,
    "votableId": 12099533,
    "userVoteValue": 0,
    "nickname": "vulca",
    "content": "62 chars. Should be able to shave off a few more chars.",
    "codingamerHandle": "25f02a1ce0fed05a640145299879351a5401161",
    "avatar": 35463269744021,
    "elapsedTime": 195072394000
  },
  {
    "commentId": 23858,
    "codingamerId": 1611045,
    "commentableId": 12014289,
    "responseCount": 2,
    "upVotes": 1,
    "downVotes": 0,
    "votableId": 12098362,
    "userVoteValue": 0,
    "nickname": "vulca",
    "content": "Nice puzzle for the code-golf category.\nMaking the output to be YES/NO instead of 1/0 might be better",
    "codingamerHandle": "25f02a1ce0fed05a640145299879351a5401161",
    "avatar": 35463269744021,
    "elapsedTime": 195082707000
  },
  {
    "commentId": 23855,
    "codingamerId": 3154694,
    "commentableId": 12014289,
    "responseCount": 0,
    "upVotes": 1,
    "downVotes": 1,
    "votableId": 12096697,
    "userVoteValue": 0,
    "nickname": "TheAristos",
    "content": "Enjoyed it, works in Python.",
    "codingamerHandle": "c5230abf26b5dc9be4932cd09972a92e4964513",
    "avatar": 24978952121057,
    "elapsedTime": 195093115000
  },
  {
    "commentId": 23832,
    "codingamerId": 2065521,
    "commentableId": 12014289,
    "responseCount": 1,
    "upVotes": 1,
    "downVotes": 0,
    "votableId": 12091617,
    "userVoteValue": 0,
    "nickname": "igolus",
    "content": "Works fine with my implementation in JS.\n\nI would expect at least on example.\n\n`|========================================|\n|Hexa    |Binary    |Number of 1|is prime|\n|========|===============================|\n|00000003|11        |2          |true    |\t\n|0000000F|1111      |4          |false   |\n|========================================|`\n\nTo clarify the statement\n\nI agree that outputting 'true/false' is better.\n\nI did update the description....",
    "codingamerHandle": "54583f3963f08a7e4a231ed45eec805e1255602",
    "avatar": 39913769766376,
    "elapsedTime": 195157901000
  },
  {
    "commentId": 23827,
    "codingamerId": 3561816,
    "commentableId": 12014289,
    "responseCount": 7,
    "upVotes": 1,
    "downVotes": 0,
    "votableId": 12090392,
    "userVoteValue": 0,
    "nickname": "noname1477",
    "content": "Why can't you just return booleans?",
    "codingamerHandle": "ddcb54d3bd67c3437a34b08440af11786181653",
    "avatar": 37217963145424,
    "elapsedTime": 195169331000
  },
  {
    "commentId": 23822,
    "codingamerId": 154906,
    "commentableId": 12014289,
    "responseCount": 0,
    "upVotes": 2,
    "downVotes": 0,
    "votableId": 12089298,
    "userVoteValue": 0,
    "nickname": "JBM",
    "content": "Please give your submission a more appropriate title.",
    "codingamerHandle": "0d71f9df5da706f9f77c07c34d12480e609451",
    "elapsedTime": 195177410000
  },
  {
    "commentId": 23834,
    "codingamerId": 154906,
    "commentableId": 12014289,
    "responseCount": 0,
    "upVotes": 1,
    "downVotes": 0,
    "parentCommentId": 23827,
    "votableId": 12092909,
    "userVoteValue": 0,
    "nickname": "JBM",
    "content": "There's no such thing as polyglotly “returning booleans”\n\nThough I'd usually track those down (like \"PRIME\" and \"COMPOSITE\" would be better outputs), 0 and 1 are one of the least bad compromises.",
    "codingamerHandle": "0d71f9df5da706f9f77c07c34d12480e609451",
    "elapsedTime": 195145691000
  },
  {
    "commentId": 23836,
    "codingamerId": 3584109,
    "commentableId": 12014289,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 23832,
    "votableId": 12093056,
    "userVoteValue": 0,
    "nickname": "kikawet",
    "content": "Ty for the help in the last example you had a mistake (it was on false)",
    "codingamerHandle": "75c7ed65a41bcb217217400d8afc5dea9014853",
    "avatar": 37439106068871,
    "elapsedTime": 195143395000
  },
  {
    "commentId": 23860,
    "codingamerId": 3584109,
    "commentableId": 12014289,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 23858,
    "votableId": 12099055,
    "userVoteValue": 0,
    "nickname": "kikawet",
    "content": "I've a discussion about that in other comment below but if people keep asking for it I may change it",
    "codingamerHandle": "75c7ed65a41bcb217217400d8afc5dea9014853",
    "avatar": 37439106068871,
    "elapsedTime": 195077523000
  },
  {
    "commentId": 23868,
    "codingamerId": 3584109,
    "commentableId": 12014289,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 23864,
    "votableId": 12100199,
    "userVoteValue": 0,
    "nickname": "kikawet",
    "content": "I got the idea of making another version where you just check if the number of 1 is ever or odd I like it more because is more tricky",
    "codingamerHandle": "75c7ed65a41bcb217217400d8afc5dea9014853",
    "avatar": 37439106068871,
    "elapsedTime": 195065332000
  },
  {
    "commentId": 24229,
    "codingamerId": 3584109,
    "commentableId": 12014289,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 24225,
    "votableId": 12278144,
    "userVoteValue": 0,
    "nickname": "kikawet",
    "content": "idk about add a test for 0 since to be honest I don't know if consider it as prime or not! some people may or may not so I decided to don't add a test for this reason I added that as a constraint",
    "codingamerHandle": "75c7ed65a41bcb217217400d8afc5dea9014853",
    "avatar": 37439106068871,
    "elapsedTime": 192742574000
  },
  {
    "commentId": 24231,
    "codingamerId": 1473017,
    "commentableId": 12014289,
    "responseCount": 0,
    "upVotes": 1,
    "downVotes": 0,
    "parentCommentId": 24225,
    "votableId": 12280087,
    "userVoteValue": 0,
    "nickname": "justhalf",
    "content": "Based on the generally accepted definition, 0 is not prime. And you have also provided a definition that 0 is not prime, so that should be fine.\n\nA prime number is a number with exactly two positive integer divisors. That's why 0 and 1 are not prime numbers.",
    "codingamerHandle": "5c8ed54d11878ff11f2236a591446b5c7103741",
    "avatar": 5020626234049,
    "elapsedTime": 192716424000
  },
  {
    "commentId": 23862,
    "codingamerId": 1611045,
    "commentableId": 12014289,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 23858,
    "votableId": 12099337,
    "userVoteValue": 0,
    "nickname": "vulca",
    "content": "I would change it because it would not benefit any particular  language runtimes.",
    "codingamerHandle": "25f02a1ce0fed05a640145299879351a5401161",
    "avatar": 35463269744021,
    "elapsedTime": 195074338000
  },
  {
    "commentId": 23835,
    "codingamerId": 3584109,
    "commentableId": 12014289,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 23827,
    "votableId": 12093044,
    "userVoteValue": 0,
    "nickname": "kikawet",
    "content": "Since in python the true keyword is different I wasn't sure how that works so to make sure I just used 0 and 1",
    "codingamerHandle": "75c7ed65a41bcb217217400d8afc5dea9014853",
    "avatar": 37439106068871,
    "elapsedTime": 195143530000
  },
  {
    "commentId": 23838,
    "codingamerId": 154906,
    "commentableId": 12014289,
    "responseCount": 0,
    "upVotes": 1,
    "downVotes": 0,
    "parentCommentId": 23827,
    "votableId": 12093243,
    "userVoteValue": 0,
    "nickname": "JBM",
    "content": "If you want to take my hint: just make the expected output PRIME or COMPOSITE. No language has those words as any kind of shortcut for booleans, so you're covered.",
    "codingamerHandle": "0d71f9df5da706f9f77c07c34d12480e609451",
    "elapsedTime": 195140541000
  },
  {
    "commentId": 23851,
    "codingamerId": 3584109,
    "commentableId": 12014289,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 23827,
    "votableId": 12095176,
    "userVoteValue": 0,
    "nickname": "kikawet",
    "content": "Not going to do it since I think the 0 and 1 fits more with the game mode I choosed but ty for showing interest",
    "codingamerHandle": "75c7ed65a41bcb217217400d8afc5dea9014853",
    "avatar": 37439106068871,
    "elapsedTime": 195106110000
  },
  {
    "commentId": 23856,
    "codingamerId": 154906,
    "commentableId": 12014289,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 23827,
    "votableId": 12098145,
    "userVoteValue": 0,
    "nickname": "JBM",
    "content": "I disagree. 0 and 1 will unduly favor languages whose comparison operators already use that as booleans.\n\nOh hey, what a coincidence, this happens to be the case for the language you wrote your reference code in!",
    "codingamerHandle": "0d71f9df5da706f9f77c07c34d12480e609451",
    "elapsedTime": 195084180000
  },
  {
    "commentId": 23859,
    "codingamerId": 3584109,
    "commentableId": 12014289,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 23827,
    "votableId": 12099048,
    "userVoteValue": 0,
    "nickname": "kikawet",
    "content": "If you have to convert them anyway 0/1 gives you advantage since is shorter than prime/composite",
    "codingamerHandle": "75c7ed65a41bcb217217400d8afc5dea9014853",
    "avatar": 37439106068871,
    "elapsedTime": 195077588000
  },
  {
    "commentId": 23866,
    "codingamerId": 154906,
    "commentableId": 12014289,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 23827,
    "votableId": 12099954,
    "userVoteValue": 0,
    "nickname": "JBM",
    "content": "The unfairness is not that \"0/1\" yields smaller code than words. Clashes don't compete against each other. The unfairness is that it relieves some but not all languages from one conversion.\n\nIn the same way that using capitalized True/False in I/O favors python and haskell; using lowercase true/false favors ruby and javascript; and hypothetically using T/NIL will favor CL the day codingame implements it.\n\nThis is all the more ridiculous that the fix is well-known, easy, and with no downside.",
    "codingamerHandle": "0d71f9df5da706f9f77c07c34d12480e609451",
    "elapsedTime": 195068182000
  }
]