[
  {
    "commentId": 368104,
    "codingamerId": 3479792,
    "commentableId": 24732161,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "votableId": 37028672,
    "userVoteValue": 0,
    "nickname": "StepBack13",
    "content": "This is a nice, difficult clash.\n\nBut I agree with others that this could use some extra hints to help clashers. Such as about modulo arithmetic.\n\nEven more so, it's not clear what \"non-redundant matrix exponentiation\" is here, and Google doesn't give any results for it. It doesn't seem like there are any matrices involved here at all...\n\nThe hint that really needs to be given is that even with the provided formula, you will still time out if you don't memoize previous fib function calls. It seems to me it would be better to remove the \"non-redundant matrix exponentiation\" red herring and just mention memoization somewhere instead.\n\nI was the only one able to solve this in my clash just now, and it took me 9 minutes (admittedly after first trying the naive approach to confirm it wouldn't work):\nhttps://www.codingame.com/clashofcode/clash/report/4136081f1048058854e4845dcd0ef3addb07e89",
    "codingamerHandle": "da2fe4fbf3c0ab008c6dcf304920ec602979743",
    "avatar": 33990586394707,
    "elapsedTime": 24739763000
  },
  {
    "commentId": 83511,
    "codingamerId": 4876171,
    "commentableId": 24732161,
    "responseCount": 0,
    "upVotes": 1,
    "downVotes": 0,
    "votableId": 25110903,
    "userVoteValue": 0,
    "nickname": "j4at",
    "content": "✅ Approved the contribution.\nComment: Nice and challenging puzzle.",
    "codingamerHandle": "4aad50340de97049b501ce2ba6af5deb1716784",
    "avatar": 83445448969831,
    "elapsedTime": 109535198000
  },
  {
    "commentId": 83505,
    "codingamerId": 5023470,
    "commentableId": 24732161,
    "responseCount": 0,
    "upVotes": 1,
    "downVotes": 0,
    "votableId": 25109085,
    "userVoteValue": 0,
    "nickname": "surho",
    "content": "It's nice and we learn a new trick about the Fibonacci sequence",
    "codingamerHandle": "4ac622db311e3273cc6dba37eb437ffb0743205",
    "elapsedTime": 109544630000
  },
  {
    "commentId": 83423,
    "codingamerId": 4908242,
    "commentableId": 24732161,
    "responseCount": 2,
    "upVotes": 1,
    "downVotes": 0,
    "votableId": 25092618,
    "userVoteValue": 0,
    "nickname": "feathrs",
    "content": "This is a great solving-challenge, however I think that the solvability will be vastly improved with a note that under modular arithmetic some standard arithmetic operations are preserved; e.g. (a%x + b%x)%x === (a+b)%x, ditto for multiplication and exponentiation\nWithout this note, I feel that most people will not know (or be able to meaningfully discover) that this can be done, and fib(N) for large numbers of N will quickly surpass the available number precision in most languages rendering it unsolvable without this trick.",
    "codingamerHandle": "609864658985f1fc96caa2347ff1c0f12428094",
    "avatar": 89109042920003,
    "elapsedTime": 109645631000
  },
  {
    "commentId": 83324,
    "codingamerId": 2491616,
    "commentableId": 24732161,
    "responseCount": 0,
    "upVotes": 1,
    "downVotes": 0,
    "votableId": 25082922,
    "userVoteValue": 0,
    "nickname": "abt8601",
    "content": "✅ Approved the contribution.\nComment: Well-written problem. A little bit challenging but the difficulty is still manageable (except perhaps when writing in C).",
    "codingamerHandle": "a82453c7a4a92ac86cba6e27177958186161942",
    "avatar": 113139385453588,
    "elapsedTime": 109728589000
  },
  {
    "commentId": 83265,
    "codingamerId": 534361,
    "commentableId": 24732161,
    "responseCount": 0,
    "upVotes": 1,
    "downVotes": 0,
    "votableId": 25070270,
    "userVoteValue": 0,
    "nickname": "MrPapaya",
    "content": "✅ Approved the contribution.\nComment: Nice and easy with a little trick to apply.",
    "codingamerHandle": "d5a4add07b257c87197b56f1735ffbc8163435",
    "avatar": 60605642423308,
    "elapsedTime": 109817141000
  },
  {
    "commentId": 82375,
    "codingamerId": 4301151,
    "commentableId": 24732161,
    "responseCount": 0,
    "upVotes": 1,
    "downVotes": 0,
    "votableId": 24964515,
    "userVoteValue": 0,
    "nickname": "ChiefChippy2",
    "content": "A tiny bit hard but was definitely fun to solve...",
    "codingamerHandle": "0d6f963e0cc38071f04188a12cb12abf1511034",
    "avatar": 63773324181810,
    "elapsedTime": 110503028000
  },
  {
    "commentId": 81056,
    "codingamerId": 2874091,
    "commentableId": 24732161,
    "responseCount": 1,
    "upVotes": 1,
    "downVotes": 0,
    "votableId": 24852881,
    "userVoteValue": 0,
    "nickname": "5DN1L",
    "content": "Please add a write statement to the stub generator. Thanks.",
    "codingamerHandle": "bbb8f47ea4601179303c20acdbf5fb6c1904782",
    "onlineSince": 1770727666105,
    "avatar": 134264063920528,
    "elapsedTime": 111197568000
  },
  {
    "commentId": 81055,
    "codingamerId": 1232188,
    "commentableId": 24732161,
    "responseCount": 11,
    "upVotes": 1,
    "downVotes": 0,
    "votableId": 24852874,
    "userVoteValue": 0,
    "nickname": "Sylven",
    "content": "Nice problem! I'm just facing issues when trying to solve it in python: I'm running a very similar solution as yours and it doesn't seem to run fast enough for N=5M nor N=15M...\n\nAt first I wanted to try if the \"naïve\" approach would work, but as expected it fails already at N=1M.",
    "codingamerHandle": "fc45ae46025323848641da969cffa60a8812321",
    "avatar": 10866218049042,
    "elapsedTime": 111197611000
  },
  {
    "commentId": 81058,
    "codingamerId": 4180031,
    "commentableId": 24732161,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 81055,
    "votableId": 24853304,
    "userVoteValue": 0,
    "nickname": "RubyBoss",
    "content": "OK, I checked this in JS and Ruby and hit walls around 25M and 50M respectively, could maybe go a bit higher if the memo table was at optimal size.\n\nBut checking now in Python, I am hitting the timeout wall between 2M and 3M regardless of the solution design or optimization, if numpy matrix is used etc.\n\nShame but I guess it might be necessary to limit the test cases to 2M max? As there are quite a few Pythonists in CoC who would be at a systematic disadvantage otherwise.",
    "codingamerHandle": "1fa346ec3feddf09c65c8a66ca2f40651300814",
    "avatar": 125307342358804,
    "elapsedTime": 111196189000
  },
  {
    "commentId": 81057,
    "codingamerId": 4180031,
    "commentableId": 24732161,
    "responseCount": 0,
    "upVotes": 1,
    "downVotes": 0,
    "parentCommentId": 81056,
    "votableId": 24853087,
    "userVoteValue": 0,
    "nickname": "RubyBoss",
    "content": "Done",
    "codingamerHandle": "1fa346ec3feddf09c65c8a66ca2f40651300814",
    "avatar": 125307342358804,
    "elapsedTime": 111196911000
  },
  {
    "commentId": 83555,
    "codingamerId": 4180031,
    "commentableId": 24732161,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 1,
    "parentCommentId": 83423,
    "votableId": 25117263,
    "userVoteValue": 0,
    "nickname": "RubyBoss",
    "content": "Thanks for your comment. I think that the modulo property of addition and multiplication is already known by many, and is at least somewhat intuitive for the rest.\n\nAttempting to solve this without applying the modulo during the calculation will result in a numerical overflow error, not a timeout, so the IDE will also provide indirect guidance to not store the whole number.\n\nI think challenging clashes are important for the platform, so will preserve this as is for now.",
    "codingamerHandle": "1fa346ec3feddf09c65c8a66ca2f40651300814",
    "avatar": 125307342358804,
    "elapsedTime": 109484924000
  },
  {
    "commentId": 83559,
    "codingamerId": 4908242,
    "commentableId": 24732161,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 83423,
    "votableId": 25120707,
    "userVoteValue": 0,
    "nickname": "feathrs",
    "content": "I did not know these properties of modular arithmetic before attempting this puzzle, and would not have known without examining the model solution. Additionally, there was no way in the goal statement for me to reasonably discover this property (e.g. that I would search externally) and therefore this offered me nothing to learn on the matter.\n\nAdditionally, languages with a floating point 'number' type (Lua, JS) will not throw an error in large cases, they will simply fail the tests due to loss of precision. This is useful to nobody, especially when such a caveat is known.\n\nChallenging clashes are important for the platform, because they allow people to learn. Clashes which require people to know something that they can't reasonably find out from the problem, are dreadful. After all - If explaining the modulo trick is pointless, why is the enhanced fibonacci included? Your comment makes no sense.",
    "codingamerHandle": "609864658985f1fc96caa2347ff1c0f12428094",
    "avatar": 89109042920003,
    "elapsedTime": 109469721000
  },
  {
    "commentId": 81059,
    "codingamerId": 1232188,
    "commentableId": 24732161,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 81055,
    "votableId": 24853410,
    "userVoteValue": 0,
    "nickname": "Sylven",
    "content": "Yeah, and in a clash it wouldn't be fair either if we had to try to optimize our code with numpy when it runs \"'out of the box\" in other languages.\n\nI guess 2M would do indeed, we should just test if the brute force fails with this limit in a faster language.",
    "codingamerHandle": "fc45ae46025323848641da969cffa60a8812321",
    "avatar": 10866218049042,
    "elapsedTime": 111195858000
  },
  {
    "commentId": 81060,
    "codingamerId": 4180031,
    "commentableId": 24732161,
    "responseCount": 0,
    "upVotes": 1,
    "downVotes": 0,
    "parentCommentId": 81055,
    "votableId": 24853550,
    "userVoteValue": 0,
    "nickname": "RubyBoss",
    "content": "That's true. OK, updated now, max test case is 2M.",
    "codingamerHandle": "1fa346ec3feddf09c65c8a66ca2f40651300814",
    "avatar": 125307342358804,
    "elapsedTime": 111195332000
  },
  {
    "commentId": 81061,
    "codingamerId": 1232188,
    "commentableId": 24732161,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 81055,
    "votableId": 24853578,
    "userVoteValue": 0,
    "nickname": "Sylven",
    "content": "I was too lazy to write the sum of the digits in C but displaying Fibo(N)%10 for N=2M works with brute force. To be fair, it's also working for N=15M ^^'",
    "codingamerHandle": "fc45ae46025323848641da969cffa60a8812321",
    "avatar": 10866218049042,
    "elapsedTime": 111195262000
  },
  {
    "commentId": 81062,
    "codingamerId": 4180031,
    "commentableId": 24732161,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 81055,
    "votableId": 24853716,
    "userVoteValue": 0,
    "nickname": "RubyBoss",
    "content": "Really, like fib(n-1)+fib(n-2) brute force ?! Well then I guess there won't be an overlap between the upper limit of Python and the lower limit of C. Anyway since this will be on fastest and shortest mode, I wouldn't really say C has much of an edge..",
    "codingamerHandle": "1fa346ec3feddf09c65c8a66ca2f40651300814",
    "avatar": 125307342358804,
    "elapsedTime": 111194796000
  },
  {
    "commentId": 81153,
    "codingamerId": 1232188,
    "commentableId": 24732161,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 81055,
    "votableId": 24866885,
    "userVoteValue": 0,
    "nickname": "Sylven",
    "content": "Actually, not sure, I forgot that in C (and derived) integers have a maximum size ^^'\n\nIt's also why python is struggling, for N>2M, the integers are so big that even performing a simple addition can take a second..\n\nMy knowledge of the types in C/C++/other is not good enough, would people have a way to solve the problem when the integer we want to get the sum of the digits is more than 200,000 digits long?\nI agree that people using C are not so common in clashes but C++ users are..",
    "codingamerHandle": "fc45ae46025323848641da969cffa60a8812321",
    "avatar": 10866218049042,
    "elapsedTime": 111116281000
  },
  {
    "commentId": 81161,
    "codingamerId": 4180031,
    "commentableId": 24732161,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 81055,
    "votableId": 24867473,
    "userVoteValue": 0,
    "nickname": "RubyBoss",
    "content": "I don't know about C++, I guess it would struggle given that it doesn't have a BigInt class.\n\nBut you mentioned brute force methods worked in C to return fib(2M) % 10 and fib(15M) % 10. How is that working? Could it be a viable alternative to solve the problem in those languages?",
    "codingamerHandle": "1fa346ec3feddf09c65c8a66ca2f40651300814",
    "avatar": 125307342358804,
    "elapsedTime": 111113847000
  },
  {
    "commentId": 81163,
    "codingamerId": 1232188,
    "commentableId": 24732161,
    "responseCount": 0,
    "upVotes": 1,
    "downVotes": 0,
    "parentCommentId": 81055,
    "votableId": 24867791,
    "userVoteValue": 0,
    "nickname": "Sylven",
    "content": "I was not exactly doing Fib(2M) % 10 as I was using the int type the whole way and then taking %10 at then end (so I had more or less a random number at the end)...\n\nBut I guess one could take the modulo 10 at each step of the computation and get Fib(n)%10 that way.\n\nI just tested with python and by taking the modulo at each step I can brute force an answer for N=2M as well, so re-writing the problem to have the last digit of the n-th Fibonacci number would require to push the limit further but it could be a way to have something working for all languages\n\n(you could even have modulo 100 instead of 10 if you want more possible outputs)",
    "codingamerHandle": "fc45ae46025323848641da969cffa60a8812321",
    "avatar": 10866218049042,
    "elapsedTime": 111112727000
  },
  {
    "commentId": 81164,
    "codingamerId": 4180031,
    "commentableId": 24732161,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 81055,
    "votableId": 24867841,
    "userVoteValue": 0,
    "nickname": "RubyBoss",
    "content": "Yeah that's a smart idea! I will rework this in a couple hours.",
    "codingamerHandle": "1fa346ec3feddf09c65c8a66ca2f40651300814",
    "avatar": 125307342358804,
    "elapsedTime": 111112536000
  },
  {
    "commentId": 81235,
    "codingamerId": 4180031,
    "commentableId": 24732161,
    "responseCount": 0,
    "upVotes": 1,
    "downVotes": 0,
    "parentCommentId": 81055,
    "votableId": 24870618,
    "userVoteValue": 0,
    "nickname": "RubyBoss",
    "content": "Updated now. Nmax = 1 billion, modulo = 999. The biggest number that needs to be involved anywhere in the calculation is the input, so it should be safe for all languages now.\n\nJS can return answers > 100 trillion (no BigInt used)",
    "codingamerHandle": "1fa346ec3feddf09c65c8a66ca2f40651300814",
    "avatar": 125307342358804,
    "elapsedTime": 111102740000
  },
  {
    "commentId": 81277,
    "codingamerId": 1232188,
    "commentableId": 24732161,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 81055,
    "votableId": 24873261,
    "userVoteValue": 0,
    "nickname": "Sylven",
    "content": "Nice! And I checked, C cannot brute force it either: fails for 100M \"already\"\n\nIt makes it more tricky as you need to realize that you can (and should) apply the modulo at each step and not only at the end, and that it gives the correct result but I guess it's also nice to have more difficult clashes",
    "codingamerHandle": "fc45ae46025323848641da969cffa60a8812321",
    "avatar": 10866218049042,
    "elapsedTime": 111090596000
  }
]