[
  {
    "commentId": 494164,
    "codingamerId": 5829515,
    "commentableId": 38767299,
    "responseCount": 1,
    "upVotes": 1,
    "downVotes": 0,
    "votableId": 39123596,
    "userVoteValue": 0,
    "nickname": "Stef_3",
    "content": "✅ Approved the contribution.\nComment: Fun and several different algorithms to solve it. Although it's easy to make a buggy code that passes all tests except Test 12 but fails on several validators (6, 10, 11, 12). So the validators seem slightly harder than the tests.",
    "codingamerHandle": "9f2646b70e1699fc7b6101dd0b5eb88a5159285",
    "avatar": 135978326596201,
    "elapsedTime": 97572000
  },
  {
    "commentId": 493277,
    "codingamerId": 6602351,
    "commentableId": 38767299,
    "responseCount": 0,
    "upVotes": 1,
    "downVotes": 0,
    "votableId": 39109471,
    "userVoteValue": 0,
    "nickname": "__Matter__",
    "content": "✅ Approved the contribution.\nComment: Great puzzle! Fun to solve",
    "codingamerHandle": "f0df735ea4469a8072807c4f82dfb0e71532066",
    "avatar": 142705385023430,
    "elapsedTime": 337865000
  },
  {
    "commentId": 493141,
    "codingamerId": 5377868,
    "commentableId": 38767299,
    "responseCount": 0,
    "upVotes": 2,
    "downVotes": 0,
    "votableId": 39108006,
    "userVoteValue": 0,
    "nickname": "YALOKGAR",
    "content": "✅ Approved the contribution.\nComment: Fun puzzle! The decompression ambiguity is a clever twist took me a sec to realize you're essentially choosing \"expand or keep\" at each digit sequence to maximize the digit count.\nTests cover the tricky bits well (the 0-repeat edge cases especially).",
    "codingamerHandle": "71ce77dc02b52055debde214148067dc8687735",
    "onlineSince": 1770727536021,
    "avatar": 157535060876255,
    "elapsedTime": 352677000
  },
  {
    "commentId": 479116,
    "codingamerId": 3276896,
    "commentableId": 38767299,
    "responseCount": 1,
    "upVotes": 1,
    "downVotes": 0,
    "votableId": 38938102,
    "userVoteValue": 0,
    "nickname": "kozuechan",
    "content": "If I understand correctly, the expected output for s=104 is 10000. However, the author's solution produces 1111.",
    "codingamerHandle": "00ff9c85fcc84fd753d84c98ec18ca0a6986723",
    "avatar": 26189736775264,
    "elapsedTime": 2842762000
  },
  {
    "commentId": 478984,
    "codingamerId": 2874091,
    "commentableId": 38767299,
    "responseCount": 1,
    "upVotes": 1,
    "downVotes": 0,
    "votableId": 38936844,
    "userVoteValue": 0,
    "nickname": "5DN1L",
    "content": "Goal\n* Consider removing the remark \"(full compression of original string)\" as it's potentially confusing. The same remark could apply to the other decompressed strings in the list, and it also seems to imply the possibility of \"incomplete compression\".\n\nConstraints\n* Consider stating an upper bound on the output length, which may be useful for users of some languages such as C++.\n\n* Please change \"alphabets\" to \"alphabet\" or \"letters\".\n\nThanks.",
    "codingamerHandle": "bbb8f47ea4601179303c20acdbf5fb6c1904782",
    "onlineSince": 1770727666105,
    "avatar": 134264063920528,
    "elapsedTime": 2853326000
  },
  {
    "commentId": 479017,
    "codingamerId": 3232421,
    "commentableId": 38767299,
    "responseCount": 0,
    "upVotes": 1,
    "downVotes": 0,
    "parentCommentId": 478984,
    "votableId": 38936902,
    "userVoteValue": 0,
    "nickname": "User123",
    "content": "Done, thank you.",
    "codingamerHandle": "c3b956997f0e142fcaa109d71c0ecd431242323",
    "avatar": 143871801993425,
    "elapsedTime": 2852771000
  },
  {
    "commentId": 479314,
    "codingamerId": 3232421,
    "commentableId": 38767299,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 479116,
    "votableId": 38941006,
    "userVoteValue": 0,
    "nickname": "User123",
    "content": "Good catch @kozuechan! I have fixed my solution and added a test case accordingly. Thank you!",
    "codingamerHandle": "c3b956997f0e142fcaa109d71c0ecd431242323",
    "avatar": 143871801993425,
    "elapsedTime": 2804238000
  },
  {
    "commentId": 494197,
    "codingamerId": 5829515,
    "commentableId": 38767299,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 494164,
    "votableId": 39123616,
    "userVoteValue": 0,
    "nickname": "Stef_3",
    "content": "Consider for instance the following python code. It works, but if you modify it to introduce a mistake in the indexing,for instance replacing \"max(0, i-1)\" with just \"i-1\", or replacing \"i-1\" with \"i-2\", then it will still pass all tests except test 12, but it will fail 4 validators.\n\nfrom itertools import groupby\nfrom sys import stderr\n\nn = int(input())\ns = input()\ns = [(k=='0',[*g]) for k, g in groupby(s, key=lambda x: '0' if x.isdigit() else x)]\nprint(s, file=stderr)\n\ndef f(g):\n    if len(g) <= 1:\n        return g[0]\n    else:\n        i = next((i for i,x in enumerate(g[1:], start=1) if x!='0'), len(g))\n        n = int(''.join(g[i:]) or 0)\n        if n > 2:\n            print(g, f\"{i:=} {n:=}\", file=stderr)\n            return ''.join(g[:max(0,i-1)]) + g[i-1] * n\n        else:\n            return ''.join(g)\n\ns = [f(g) if k else ''.join(g) for k,g in s]\nprint(''.join(s))",
    "codingamerHandle": "9f2646b70e1699fc7b6101dd0b5eb88a5159285",
    "avatar": 135978326596201,
    "elapsedTime": 97363000
  }
]