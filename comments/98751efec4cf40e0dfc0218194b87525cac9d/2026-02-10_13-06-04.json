[
  {
    "commentId": 230037,
    "codingamerId": 5699984,
    "commentableId": 34033630,
    "responseCount": 0,
    "upVotes": 1,
    "downVotes": 0,
    "votableId": 34425483,
    "userVoteValue": 0,
    "nickname": "savage_floppy",
    "content": "✅ Approved the contribution.\nComment: it is very conceptual in the perspective of arrays/matrix\nwe have basic edge cases like handling out of bounds \nrepeated addition might need some thinking as well for more than 1 stone with colliding liberty (just need to maintain a visited/reference map)",
    "codingamerHandle": "25136d83cb51af6d460d77a81b19393d4899965",
    "avatar": 111999205504985,
    "elapsedTime": 50227574000
  },
  {
    "commentId": 230033,
    "codingamerId": 3479792,
    "commentableId": 34033630,
    "responseCount": 0,
    "upVotes": 1,
    "downVotes": 0,
    "votableId": 34425222,
    "userVoteValue": 0,
    "nickname": "StepBack13",
    "content": "✅ Approved the contribution.\nComment: A little bit tough for Reverse, but solvable under Reverse conditions and definitely solvable with the statement.\nI was able to solve it in around 8 minutes without reading the statement, and would be able to solve it in 5 with the statement.",
    "codingamerHandle": "da2fe4fbf3c0ab008c6dcf304920ec602979743",
    "avatar": 33990586394707,
    "elapsedTime": 50231575000
  },
  {
    "commentId": 229872,
    "codingamerId": 1200044,
    "commentableId": 34033630,
    "responseCount": 0,
    "upVotes": 1,
    "downVotes": 0,
    "votableId": 34419089,
    "userVoteValue": 0,
    "nickname": "Nekomancer60",
    "content": "✅ Approved the contribution.\nComment: Good puzzle. This is definitely solvable in the time limit, since it pretty much boils down to looping through a 2D array.",
    "codingamerHandle": "56c73748b40311049b79acdd66b426984400021",
    "avatar": 36523383873142,
    "elapsedTime": 50282411000
  },
  {
    "commentId": 228729,
    "codingamerId": 5577457,
    "commentableId": 34033630,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "votableId": 34387114,
    "userVoteValue": 0,
    "nickname": "MISELLO",
    "content": "I suggest to do it more complex, for example adding another type of stone, or holes or something else that adds more rules and turn it into a puzzle.\n\nLet's see what other people think.",
    "codingamerHandle": "df3654ea734891d22a47f0908239fd897547755",
    "avatar": 107282080626304,
    "elapsedTime": 50592530000
  },
  {
    "commentId": 228728,
    "codingamerId": 5577457,
    "commentableId": 34033630,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "votableId": 34387097,
    "userVoteValue": 0,
    "nickname": "MISELLO",
    "content": "❌ Rejected the contribution.\nComment: I'm sorry,\nEven I got all tests right at the first try, it took me 30 minutes to do it where it should be done with 5-15 minutes.\nI'm afraid that this should be more an easy puzzle instead of a clash of code.",
    "codingamerHandle": "df3654ea734891d22a47f0908239fd897547755",
    "avatar": 107282080626304,
    "elapsedTime": 50592671000
  },
  {
    "commentId": 228727,
    "codingamerId": 5577457,
    "commentableId": 34033630,
    "responseCount": 4,
    "upVotes": 1,
    "downVotes": 0,
    "votableId": 34386883,
    "userVoteValue": 0,
    "nickname": "MISELLO",
    "content": "Ok, It took me a while to understand, but basically we have to count the cells adjacent to the Xs that are inside the board and are not other Xs. Also, each empty cell can only be counted once.\nI think it's good.",
    "codingamerHandle": "df3654ea734891d22a47f0908239fd897547755",
    "avatar": 107282080626304,
    "elapsedTime": 50595316000
  },
  {
    "commentId": 229537,
    "codingamerId": 5829515,
    "commentableId": 34033630,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 228727,
    "votableId": 34411619,
    "userVoteValue": 0,
    "nickname": "Stef_3",
    "content": "Hi. Thank you for taking the time to review my contribution.\n\nI'm a bit confused, you left three comments, one saying it was not complex enough, one saying it was too complex, and then one saying you finally understand. And you rejected the contribution.\n\n> but basically we have to count the cells adjacent to the Xs that are inside the board and are not other Xs. Also, each empty cell can only be counted once.\n\nYes exactly ! You got it. As said in the Goal section at the very beginning of the Statement:\n\n> A liberty is an empty-cell {{.}} directly adjacent to the chain of {{X}}. Your goal is to count the number of liberties of the chain.\n\nIf you think this sentence is unclear or ambiguous or too complex I am happy to listen to your criticism, and suggestions to rephrase it?",
    "codingamerHandle": "9f2646b70e1699fc7b6101dd0b5eb88a5159285",
    "avatar": 135978326596201,
    "elapsedTime": 50350106000
  },
  {
    "commentId": 229702,
    "codingamerId": 5577457,
    "commentableId": 34033630,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 228727,
    "votableId": 34415963,
    "userVoteValue": 0,
    "nickname": "MISELLO",
    "content": "Hi.\nYou are right, my comments seem to contradict each other.\n\nYour explanation is right, it just took me bit to get used to the new terms of liberty and chain of stones (obviously I'm not familiar with the weiqi game). By any change is it called chain because all Xs are connected?\n\nMy first comment is the one saying I finally understand it and, after the comment, I proceded to try to solve it.\nAfter solving it I realized it took me about 30 minutes (that is the only reason for my rejection), so I changed my mind to consider it a valid puzzle for the clash of code game (or maybe I'm too slow) and I thought it would be fun to have it as an easy puzzle. Maybe with some extra layer of complexity (or maybe not, because it would make no sense in a weiqi game).\n\nHope my reasoning is clearer now.\n\nRegards",
    "codingamerHandle": "df3654ea734891d22a47f0908239fd897547755",
    "avatar": 107282080626304,
    "elapsedTime": 50299372000
  },
  {
    "commentId": 229703,
    "codingamerId": 5829515,
    "commentableId": 34033630,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 228727,
    "votableId": 34416044,
    "userVoteValue": 0,
    "nickname": "Stef_3",
    "content": "Oh, okay.\n\nOut of curiosity, could you show your code?\n\nThis is supposed to be simple, and indeed your observation:\n\n> but basically we have to count the cells adjacent to the Xs that are inside the board and are not other Xs.\n\nCan be translated into code directly: just loop over all cells and increment a counter when the cell is an empty cell adjacent to an X.",
    "codingamerHandle": "9f2646b70e1699fc7b6101dd0b5eb88a5159285",
    "avatar": 135978326596201,
    "elapsedTime": 50298859000
  },
  {
    "commentId": 229735,
    "codingamerId": 5577457,
    "commentableId": 34033630,
    "responseCount": 0,
    "upVotes": 1,
    "downVotes": 0,
    "parentCommentId": 228727,
    "votableId": 34416352,
    "userVoteValue": 0,
    "nickname": "MISELLO",
    "content": "Unfortunatelly the code I wrote was lost (seems it is not saved if it is has not been published yet). But I can try to describe what I did:\n\nI declared an h * w matrix of booleans, I loop all cells searching for Xs and set to true the cells that are up, down, right or left of an X taking into account not to go outbounds. Then I did another loop to count all cells that were true and did not contain an X.\n\nNow I see that it could have been much more faster, clearer and easyer to do it as you say: loop all cells and increment a counter if it is empty and adjacent to an X.",
    "codingamerHandle": "df3654ea734891d22a47f0908239fd897547755",
    "avatar": 107282080626304,
    "elapsedTime": 50297128000
  }
]