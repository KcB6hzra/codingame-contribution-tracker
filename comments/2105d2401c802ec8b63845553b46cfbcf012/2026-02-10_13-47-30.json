[
  {
    "commentId": 346918,
    "codingamerId": 2874091,
    "commentableId": 10223831,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "votableId": 36617949,
    "userVoteValue": 0,
    "nickname": "5DN1L",
    "content": "I've added the tag \"Palindrome\".",
    "codingamerHandle": "bbb8f47ea4601179303c20acdbf5fb6c1904782",
    "onlineSince": 1770727666105,
    "avatar": 134264063920528,
    "elapsedTime": 28769546000
  },
  {
    "commentId": 19595,
    "codingamerId": 2874091,
    "commentableId": 10223831,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "votableId": 10596484,
    "userVoteValue": 0,
    "nickname": "5DN1L",
    "content": "Added \"write answer\" to stub generator so that the initial default code shows the syntax for debugging and outputting the answer.",
    "codingamerHandle": "bbb8f47ea4601179303c20acdbf5fb6c1904782",
    "onlineSince": 1770727666105,
    "avatar": 134264063920528,
    "elapsedTime": 213154968000
  },
  {
    "commentId": 19302,
    "codingamerId": 1734105,
    "commentableId": 10223831,
    "responseCount": 1,
    "upVotes": 0,
    "downVotes": 0,
    "votableId": 10513182,
    "userVoteValue": 0,
    "nickname": "Katia_S",
    "content": "Hello ! Are you sure we can do it with Python ? Have you tested ?\nNice idea of puzzle :)",
    "codingamerHandle": "62318a760610d302620d798354f373b55014371",
    "avatar": 13195589819771,
    "elapsedTime": 214259697000
  },
  {
    "commentId": 19179,
    "codingamerId": 1569823,
    "commentableId": 10223831,
    "responseCount": 5,
    "upVotes": 2,
    "downVotes": 0,
    "votableId": 10476621,
    "userVoteValue": 1,
    "nickname": "Niako",
    "content": "The complexity of your solution is O(|S|^2) because of the counting part. Yet it's more clever than it needs to be as you used Manacher's algorithm in O(|S|) for the palindromic subwords detection part, while a basic O(|S|^2) approach for that would do the job as well here.\nHence I'm not sure about your intentions with this problem. You know that non-trivial insights about palindromic subwords are not required to pass, right?",
    "codingamerHandle": "eb89cbdf69d07106c84edf1d191caaf33289651",
    "avatar": 11911528647474,
    "elapsedTime": 214765456000
  },
  {
    "commentId": 19069,
    "codingamerId": 925695,
    "commentableId": 10223831,
    "responseCount": 5,
    "upVotes": 0,
    "downVotes": 0,
    "votableId": 10464069,
    "userVoteValue": 0,
    "nickname": "Boulet",
    "content": "Why use only lowercase letters and not any kind of printable char ?\nWhy do not treat and use all palindroms (including empty one) which then lead to invalidate most of your examples",
    "codingamerHandle": "dc5be2d951d61e3948cb537119c4c1ff596529",
    "avatar": 29121141951376,
    "elapsedTime": 214954603000
  },
  {
    "commentId": 19095,
    "codingamerId": 3276896,
    "commentableId": 10223831,
    "responseCount": 0,
    "upVotes": 2,
    "downVotes": 0,
    "parentCommentId": 19069,
    "votableId": 10466375,
    "userVoteValue": 0,
    "nickname": "kozuechan",
    "content": "Thank you for questions.\n\n>>> Why use only lowercase letters and not any kind of printable char ?\n\nIt's not an essential part of the puzzle. And, allowing more printable chars may make the puzzle unnecessary complex.\n\n>>> Why do not treat and use all palindroms (including empty one) which then lead to invalidate most of your examples\n\nI thought disallowing empty things is a natural way to define decomposition.\n\nFor example, in mathematics, a partition of a set X is defined as a set of **nonempty** subsets of X such that 〜. In this definition, the empty set is not allowed. ref: https://en.wikipedia.org/wiki/Partition_of_a_set",
    "codingamerHandle": "00ff9c85fcc84fd753d84c98ec18ca0a6986723",
    "avatar": 26189736775264,
    "elapsedTime": 214922352000
  },
  {
    "commentId": 19185,
    "codingamerId": 3276896,
    "commentableId": 10223831,
    "responseCount": 0,
    "upVotes": 1,
    "downVotes": 0,
    "parentCommentId": 19179,
    "votableId": 10477532,
    "userVoteValue": 0,
    "nickname": "kozuechan",
    "content": "As you said, we don't need manacher for |S| <= 5000. Maybe I should make |S| <= 10^5 and set the difficulty to hard.\n\nI will take a look later. Thanks.",
    "codingamerHandle": "00ff9c85fcc84fd753d84c98ec18ca0a6986723",
    "avatar": 26189736775264,
    "elapsedTime": 214751598000
  },
  {
    "commentId": 19324,
    "codingamerId": 3276896,
    "commentableId": 10223831,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 19302,
    "votableId": 10516047,
    "userVoteValue": 0,
    "nickname": "kozuechan",
    "content": "Yes. I have a Python3 solution that can solve the puzzle.",
    "codingamerHandle": "00ff9c85fcc84fd753d84c98ec18ca0a6986723",
    "avatar": 26189736775264,
    "elapsedTime": 214210046000
  },
  {
    "commentId": 19190,
    "codingamerId": 1569823,
    "commentableId": 10223831,
    "responseCount": 0,
    "upVotes": 1,
    "downVotes": 0,
    "parentCommentId": 19179,
    "votableId": 10479587,
    "userVoteValue": 0,
    "nickname": "Niako",
    "content": "Ok, that was just a question, not a suggestion. Anyhow, as it is, the counting part of the algorithm prevents you from increasing the input, all the more so as they are limited to 10^4 chars.",
    "codingamerHandle": "eb89cbdf69d07106c84edf1d191caaf33289651",
    "avatar": 11911528647474,
    "elapsedTime": 214715028000
  },
  {
    "commentId": 19191,
    "codingamerId": 3276896,
    "commentableId": 10223831,
    "responseCount": 0,
    "upVotes": 1,
    "downVotes": 0,
    "parentCommentId": 19179,
    "votableId": 10479600,
    "userVoteValue": 0,
    "nickname": "kozuechan",
    "content": "If I change \"tuple of three strings\" to \"pair of two strings\", the counting part won't be a problem. However, O(N^2) for N=10^4 could be passed in C/C++...",
    "codingamerHandle": "00ff9c85fcc84fd753d84c98ec18ca0a6986723",
    "avatar": 26189736775264,
    "elapsedTime": 214714813000
  },
  {
    "commentId": 19221,
    "codingamerId": 1569823,
    "commentableId": 10223831,
    "responseCount": 0,
    "upVotes": 1,
    "downVotes": 0,
    "parentCommentId": 19179,
    "votableId": 10489455,
    "userVoteValue": 0,
    "nickname": "Niako",
    "content": "One (kinda tedious) way to get round this limitation is to provide a RNG to generate the words (however this problem is not bad as it is, once again I was mostly wondering about your intentions).",
    "codingamerHandle": "eb89cbdf69d07106c84edf1d191caaf33289651",
    "avatar": 11911528647474,
    "elapsedTime": 214602895000
  },
  {
    "commentId": 19227,
    "codingamerId": 3276896,
    "commentableId": 10223831,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 19179,
    "votableId": 10491618,
    "userVoteValue": 0,
    "nickname": "kozuechan",
    "content": "I agree the RNG method is tedious, so I decided that I keep the O(|S|^2) approach can be passed.\n\nI updated the constraints so that O(|S|^2) can be passed for sure. I also updated the solution to the simpler one.",
    "codingamerHandle": "00ff9c85fcc84fd753d84c98ec18ca0a6986723",
    "avatar": 26189736775264,
    "elapsedTime": 214573841000
  },
  {
    "commentId": 19098,
    "codingamerId": 512097,
    "commentableId": 10223831,
    "responseCount": 0,
    "upVotes": 2,
    "downVotes": 1,
    "parentCommentId": 19069,
    "votableId": 10467444,
    "userVoteValue": 1,
    "nickname": "Stilgart",
    "content": "Disallowing the empty string sounds like a bad idea, mathematically speaking. Your input word is a sequence of a letters, not a set of letter. ;)",
    "codingamerHandle": "f6389a8319f07b08072b207feb2572c9790215",
    "avatar": 69893904259383,
    "elapsedTime": 214896990000
  },
  {
    "commentId": 19099,
    "codingamerId": 3276896,
    "commentableId": 10223831,
    "responseCount": 0,
    "upVotes": 1,
    "downVotes": 0,
    "parentCommentId": 19069,
    "votableId": 10467506,
    "userVoteValue": 0,
    "nickname": "kozuechan",
    "content": "I updated the statement. The empty string is now allowed. Thank you.",
    "codingamerHandle": "00ff9c85fcc84fd753d84c98ec18ca0a6986723",
    "avatar": 26189736775264,
    "elapsedTime": 214895243000
  },
  {
    "commentId": 19100,
    "codingamerId": 925695,
    "commentableId": 10223831,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 19069,
    "votableId": 10467530,
    "userVoteValue": 0,
    "nickname": "Boulet",
    "content": "Thank for your answer !",
    "codingamerHandle": "dc5be2d951d61e3948cb537119c4c1ff596529",
    "avatar": 29121141951376,
    "elapsedTime": 214894834000
  },
  {
    "commentId": 19118,
    "codingamerId": 1569823,
    "commentableId": 10223831,
    "responseCount": 0,
    "upVotes": 3,
    "downVotes": 0,
    "parentCommentId": 19069,
    "votableId": 10470378,
    "userVoteValue": 0,
    "nickname": "Niako",
    "content": "Both allowing ε and forbidding it are perfectly acceptable IMO, analogously to integer (weak) compositions for instance https://en.wikipedia.org/wiki/Composition_(combinatorics%29",
    "codingamerHandle": "eb89cbdf69d07106c84edf1d191caaf33289651",
    "avatar": 11911528647474,
    "elapsedTime": 214853601000
  }
]