[
  {
    "commentId": 10922,
    "codingamerId": 1536085,
    "commentableId": 6836736,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "votableId": 6901619,
    "userVoteValue": 0,
    "nickname": "Wladek",
    "content": "Test names could be more descriptive ;-)",
    "codingamerHandle": "8fd7845a80313eea2cb383a1b2ec16155806351",
    "avatar": 7749586185627,
    "elapsedTime": 256560442000
  },
  {
    "commentId": 10915,
    "codingamerId": 2130169,
    "commentableId": 6836736,
    "responseCount": 1,
    "upVotes": 0,
    "downVotes": 0,
    "votableId": 6899546,
    "userVoteValue": 0,
    "nickname": "CyberLemonade",
    "content": "I think reverse is maybe doable too. Up to the community though",
    "codingamerHandle": "d8a0152458f424d53995a613b5abea4f9610312",
    "avatar": 57032502077757,
    "elapsedTime": 256608597000
  },
  {
    "commentId": 10910,
    "codingamerId": 2341447,
    "commentableId": 6836736,
    "responseCount": 4,
    "upVotes": 0,
    "downVotes": 0,
    "votableId": 6898542,
    "userVoteValue": 0,
    "nickname": "algmyr",
    "content": "Isn't this (somewhat) easily solvable for much larger n? Skip all 1 digit numbers, then 2 digit numbers and so on until you're in the right order of magnitude (where if you skip d digit numbers you've gone past your goal). From there you can easily find out what number you're at (basically floored division with d) and consequently you can also find the digit.\n\nEdit: You can indeed do this, and the code is quite short and fast. Scales more or less O(log n), compared to the naive O(n)",
    "codingamerHandle": "86f39b7cda6d832e5c8873e1e905646c7441432",
    "avatar": 16056481834828,
    "elapsedTime": 256632535000
  },
  {
    "commentId": 10914,
    "codingamerId": 2130169,
    "commentableId": 6836736,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 10910,
    "votableId": 6899530,
    "userVoteValue": 0,
    "nickname": "CyberLemonade",
    "content": "yes, a log(n) approach is very clever. but this is a clash¯\\_(ツ)_/¯",
    "codingamerHandle": "d8a0152458f424d53995a613b5abea4f9610312",
    "avatar": 57032502077757,
    "elapsedTime": 256608776000
  },
  {
    "commentId": 10919,
    "codingamerId": 2178794,
    "commentableId": 6836736,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 10915,
    "votableId": 6899560,
    "userVoteValue": 0,
    "nickname": "Unihedron",
    "content": "I don't think it would make a good reverse challenge because it's an obscure non-linear transformation, unless we add test cases for all inputs from 1 to 15",
    "codingamerHandle": "1d1729a2d8c008c6cf728ee88f1faa6d4978712",
    "avatar": 17500773502453,
    "elapsedTime": 256608342000
  },
  {
    "commentId": 10916,
    "codingamerId": 2178794,
    "commentableId": 6836736,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 10910,
    "votableId": 6899551,
    "userVoteValue": 0,
    "nickname": "Unihedron",
    "content": "If we bother with big N's it would invalidate many languages that have rounding problems, like JS which only provides floating points. That would make it a bad candidate for a clash, but still not difficult enough to warrant a community puzzle.",
    "codingamerHandle": "1d1729a2d8c008c6cf728ee88f1faa6d4978712",
    "avatar": 17500773502453,
    "elapsedTime": 256608479000
  },
  {
    "commentId": 10918,
    "codingamerId": 2130169,
    "commentableId": 6836736,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 10910,
    "votableId": 6899559,
    "userVoteValue": 0,
    "nickname": "CyberLemonade",
    "content": "No, no, keep it a clash",
    "codingamerHandle": "d8a0152458f424d53995a613b5abea4f9610312",
    "avatar": 57032502077757,
    "elapsedTime": 256608351000
  },
  {
    "commentId": 10925,
    "codingamerId": 2341447,
    "commentableId": 6836736,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 10910,
    "votableId": 6905018,
    "userVoteValue": 0,
    "nickname": "algmyr",
    "content": "You only need to deal with numbers bounded by N. JS deals with doubles exclusively, so you still have a range up to around 9×10¹⁵ where integers can be represented exactly. So having N up to, say 10¹⁰ would be no issue. I still agree that expecting an O(log n) solution is too much for a clash, but the worry about rounding problems here is unfounded. :)",
    "codingamerHandle": "86f39b7cda6d832e5c8873e1e905646c7441432",
    "avatar": 16056481834828,
    "elapsedTime": 256471483000
  }
]