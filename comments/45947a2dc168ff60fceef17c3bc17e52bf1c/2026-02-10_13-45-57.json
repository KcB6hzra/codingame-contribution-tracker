[
  {
    "commentId": 22687,
    "codingamerId": 2064637,
    "commentableId": 11422204,
    "responseCount": 0,
    "upVotes": 1,
    "downVotes": 0,
    "votableId": 11522820,
    "userVoteValue": 0,
    "nickname": "java_coffee_cup",
    "content": "Level set as Medium as multiple voices say so. Welcome comments.",
    "codingamerHandle": "f4c116cad137a7eee91b727ff6fe53597364602",
    "onlineSince": 1770694927190,
    "avatar": 13281799951852,
    "elapsedTime": 201241728000
  },
  {
    "commentId": 22665,
    "codingamerId": 1569823,
    "commentableId": 11422204,
    "responseCount": 8,
    "upVotes": 2,
    "downVotes": 0,
    "votableId": 11511171,
    "userVoteValue": 0,
    "nickname": "Niako",
    "content": "I have not really dug into it yet (and won't look at your code before doing so), yet it seems that a kinda naive memoized recursive approach https://framabin.org/p/?3d3967a222b95d00#1OS3UjZ+e16D3aH4GEgIYwkTqg48/C2k4r6he+UCkp8= easily passes everything here and can pass cases of size up to ~1000 in ~1s (Python3).\nSo I think either it's not really \"hard\" or there is a calibration issue.\n\nEDIT: I initially added memoization (@lru_cache) in the end only to pass the last case. But to fully benefit from it in general, it is better to also replace the loop by recursion https://framabin.org/p/?186e28b5ecbbfe6e#v5YSrPvCnmJskpQH0HasKN6ITPAHnk+ur6avyiZzTFk=\nThat way the (even simpler) code passes cases of size ~5000 in ~0.1s.",
    "codingamerHandle": "eb89cbdf69d07106c84edf1d191caaf33289651",
    "avatar": 11911528647474,
    "elapsedTime": 201373692000
  },
  {
    "commentId": 22632,
    "codingamerId": 154906,
    "commentableId": 11422204,
    "responseCount": 1,
    "upVotes": 0,
    "downVotes": 0,
    "votableId": 11500863,
    "userVoteValue": 0,
    "nickname": "JBM",
    "content": "https://code.google.com/codejam/contest/433101/dashboard#s=p0",
    "codingamerHandle": "0d71f9df5da706f9f77c07c34d12480e609451",
    "elapsedTime": 201483150000
  },
  {
    "commentId": 22633,
    "codingamerId": 2064637,
    "commentableId": 11422204,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 22632,
    "votableId": 11501031,
    "userVoteValue": 0,
    "nickname": "java_coffee_cup",
    "content": "Haha...an interesting puzzle to electrify oneself. Sort of similarity and yet at first and second glance it is still different enough.",
    "codingamerHandle": "f4c116cad137a7eee91b727ff6fe53597364602",
    "onlineSince": 1770694927190,
    "avatar": 13281799951852,
    "elapsedTime": 201482153000
  },
  {
    "commentId": 22670,
    "codingamerId": 2064637,
    "commentableId": 11422204,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 22665,
    "votableId": 11512443,
    "userVoteValue": 0,
    "nickname": "java_coffee_cup",
    "content": "Using a naive approach (my code in example is using this approach, to cross check another faster approach) the bottleneck happens in checking a row of 0's state, unlike your ref code which checks only one bit/char/byte's state to determine next step. Another complicity is to determine which option to take is nearer to different targets.\n\nDifficulty level is always adjustable and I'm open to adjust it.",
    "codingamerHandle": "f4c116cad137a7eee91b727ff6fe53597364602",
    "onlineSince": 1770694927190,
    "avatar": 13281799951852,
    "elapsedTime": 201354493000
  },
  {
    "commentId": 22672,
    "codingamerId": 154906,
    "commentableId": 11422204,
    "responseCount": 0,
    "upVotes": 2,
    "downVotes": 0,
    "parentCommentId": 22665,
    "votableId": 11513961,
    "userVoteValue": 0,
    "nickname": "JBM",
    "content": "I didn't do any big-N analysis, but I didn't need any memo of any sort to pass the cases, constructing the answer as a sum of ones. (quite suboptimally to boot, thunks all the way)\n\nhttps://framabin.org/p/?a4f366d6dbedf8dc#zrpCd4nubhLP7rLwzkZTz12ofy4Kh0WdiOwK6yhs1rw=\n\nIt seems to me most of that recursion isn't really needed anyway, it can be abstracted away with a bit of arithmetic.\n\nIndeed, this puzzle feels more like Towers of Hanoi than Snapper Chains, now I've read it properly.",
    "codingamerHandle": "0d71f9df5da706f9f77c07c34d12480e609451",
    "elapsedTime": 201329410000
  },
  {
    "commentId": 22674,
    "codingamerId": 2064637,
    "commentableId": 11422204,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 22665,
    "votableId": 11514222,
    "userVoteValue": 0,
    "nickname": "java_coffee_cup",
    "content": "Aha, You stroke at the point. This is ToH's variation. Usually ToH starts with a full stack of disks and final target is to move all disks to another column. Here the starting and ending points are both variables.\nWith a different rule to move disks and no requirement to draw ascii graphics, hopefully it is different enough from another existing ToH puzzle.",
    "codingamerHandle": "f4c116cad137a7eee91b727ff6fe53597364602",
    "onlineSince": 1770694927190,
    "avatar": 13281799951852,
    "elapsedTime": 201327427000
  },
  {
    "commentId": 22680,
    "codingamerId": 1569823,
    "commentableId": 11422204,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 22665,
    "votableId": 11519220,
    "userVoteValue": 0,
    "nickname": "Niako",
    "content": "Ok so, if I get it correctly, the input size was calibrated to be able to pass with a naive approach without memoization (not sure why, since it's meant to be a hard problem anyway). Well, it seems it's still not that easy to pass the last case in Python with this constraint, I had to use bit manipulation https://framabin.org/p/?5b6428a97bcf6e28#8EaP9f24XQ4ZZ7gIVOcA2C5civWTXE4oyIc+KzM9ZEM= for that (or more simply https://framabin.org/p/?c1d053038f464260#P5DGrPavSIM7HOiULxwcKPIAqkrHT7LuSrUQsNheaBQ= which is slower but passes too).",
    "codingamerHandle": "eb89cbdf69d07106c84edf1d191caaf33289651",
    "avatar": 11911528647474,
    "elapsedTime": 201291746000
  },
  {
    "commentId": 22683,
    "codingamerId": 2064637,
    "commentableId": 11422204,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 22665,
    "votableId": 11520768,
    "userVoteValue": 0,
    "nickname": "java_coffee_cup",
    "content": "By an advanced approach I could handle length>60 easily. Yet I hope a puzzle can be solvable by not only one sole approach, so lowering the constraint to allow more varieties of solutions to pass. After passing, coders can learn better approaches from others' source. \nUsing the naive approach does not mean it is easy to design and implement. I still have to struggle a lot to trim down some cycles and reduce repeats. In view of another ToH puzzle (https://www.codingame.com/training/hard/hanoi-tower) in the \"Hard\" class having only about 50% success rate and not many people passed, I feel this even harder one is suitable to be described as \"Hard\".",
    "codingamerHandle": "f4c116cad137a7eee91b727ff6fe53597364602",
    "onlineSince": 1770694927190,
    "avatar": 13281799951852,
    "elapsedTime": 201268066000
  },
  {
    "commentId": 22685,
    "codingamerId": 154906,
    "commentableId": 11422204,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 22665,
    "votableId": 11522482,
    "userVoteValue": 0,
    "nickname": "JBM",
    "content": "My counterpoint is on Niako's side: I thought of a (simple) algorithm, I wrote it, it passed. \"Simple\" because it does a bit too much. It didn't feel hard.",
    "codingamerHandle": "0d71f9df5da706f9f77c07c34d12480e609451",
    "elapsedTime": 201243814000
  },
  {
    "commentId": 22686,
    "codingamerId": 1687754,
    "commentableId": 11422204,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 22665,
    "votableId": 11522620,
    "userVoteValue": 0,
    "nickname": "cg123",
    "content": "Liked this puzzle, but I have the same feeling of \"not a difficult one\".\nToH looks (way) harder for me.",
    "codingamerHandle": "e1503ab4da5481c50ba7dc820e5799324577861",
    "avatar": 11844752916555,
    "elapsedTime": 201242953000
  },
  {
    "commentId": 22688,
    "codingamerId": 1569823,
    "commentableId": 11422204,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 22665,
    "votableId": 11522887,
    "userVoteValue": 0,
    "nickname": "Niako",
    "content": "If a puzzle is actually hard, then it should be tagged as \"hard\" otherwise people expecting something simpler will complain in the forum. The drawback of that seems to be (if you look at the stats) that the puzzle will be read, and a fortiori solved, by way way less codingamers over time. That's why a puzzle that's reasonably solvable as \"medium\" should probably be tagged as such, in its own interest, and I think that's the case of this one.",
    "codingamerHandle": "eb89cbdf69d07106c84edf1d191caaf33289651",
    "avatar": 11911528647474,
    "elapsedTime": 201241341000
  }
]