[
  {
    "commentId": 481987,
    "codingamerId": 6938378,
    "commentableId": 36125384,
    "responseCount": 0,
    "upVotes": 1,
    "downVotes": 0,
    "votableId": 38977315,
    "userVoteValue": 0,
    "nickname": "slsbj",
    "content": "âœ… Approved the contribution.\nComment: I like the idea of reducing few words in one without two sames letters in a row.",
    "codingamerHandle": "0dcf76b341ba2c13a2c07378d05db9a68738396",
    "onlineSince": 1770726649754,
    "avatar": 153697909848912,
    "elapsedTime": 2247118000
  },
  {
    "commentId": 481855,
    "codingamerId": 5829515,
    "commentableId": 36125384,
    "responseCount": 2,
    "upVotes": 1,
    "downVotes": 0,
    "votableId": 38976689,
    "userVoteValue": 0,
    "nickname": "Stef_3",
    "content": "âœ… Approved the contribution.\nComment: Really fun challenge, and actually really easy to solve using bruteforce on the 6 possible orders. Combining two strings (a,b) is actually easy: find maximum k such that a[len(a)-k:len(a)] == b[0:k], then simply return a + b[k:len(b)]",
    "codingamerHandle": "9f2646b70e1699fc7b6101dd0b5eb88a5159285",
    "avatar": 135978326596201,
    "elapsedTime": 2254164000
  },
  {
    "commentId": 481624,
    "codingamerId": 5870063,
    "commentableId": 36125384,
    "responseCount": 1,
    "upVotes": 0,
    "downVotes": 0,
    "votableId": 38974089,
    "userVoteValue": 0,
    "nickname": "MrRidikulous",
    "content": "âŒ Rejected the contribution.\nComment: Ad Sum: This is unsuited for Clash of Code. \n\nThis is an excellent puzzle and challenge for developers to work on, but here are my reasonings: I could not solve it within 5 minutes, and that was with explicit directions. Reverse would be a BAD option for this challenge in the realm of Clash of Code, but would be a fun challenge in the Easy Puzzles section of this site. Shortest mode is plausible, but I don't think it applies nicely, as others have said, the functions to combine the strings are difficult already, much more verbose in some languages than others, and would have strongly skewed results in a Clash of Code no matter what. Fastest is the only mode I would suggest being applied to this for Clash of Code if submitted again.\n\nIt's a fun challenge! Well done on creating it and writing up the directions and tests. I simply don't think it would do well publicly in Clash of Code.",
    "codingamerHandle": "355b0c34f2cad1b95f4853d3d99d90733600785",
    "elapsedTime": 2303673000
  },
  {
    "commentId": 472747,
    "codingamerId": 3232421,
    "commentableId": 36125384,
    "responseCount": 1,
    "upVotes": 1,
    "downVotes": 0,
    "votableId": 38874645,
    "userVoteValue": 0,
    "nickname": "User123",
    "content": "I don't think Shortest mode is suitable for this clash; writing the function to chain words together is difficult enough as is.\n\nAlso, could you add some test cases where the partial overlap is so extensive that the middle word is basically not required? Something like halls, allstar, stardom -> hallstardom; where combining halls and stardom can give the answer, but there is still only one unique way to combine the three words.",
    "codingamerHandle": "c3b956997f0e142fcaa109d71c0ecd431242323",
    "avatar": 143871801993425,
    "elapsedTime": 3879832000
  },
  {
    "commentId": 472518,
    "codingamerId": 6993013,
    "commentableId": 36125384,
    "responseCount": 1,
    "upVotes": 1,
    "downVotes": 0,
    "votableId": 38872978,
    "userVoteValue": 0,
    "nickname": "JiHong",
    "content": "âœ… Approved the contribution.\nComment: he goal is clear and the sample demonstrates that the 3 words may need to be reordered and chained by overlapping a suffix with the next wordâ€™s prefix.\n\nSuggestion: explicitly define partial overlap as an overlap length k where 1 â‰¤ k < min(len(a), len(b)) (no full-word overlap, no zero overlap). If multiple overlap lengths could match, state that the largest overlap must be used, even though tests aim for a unique chaining.",
    "codingamerHandle": "58e384f15f420aa05e828fb4a10d79353103996",
    "onlineSince": 1770693220611,
    "avatar": 154722588805241,
    "elapsedTime": 3907250000
  },
  {
    "commentId": 341242,
    "codingamerId": 2671545,
    "commentableId": 36125384,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "votableId": 36522282,
    "userVoteValue": 0,
    "nickname": "CodinBot",
    "content": "Hey CodinGamer! Your contribution has unfortunately not been moderated on time and will temporarily be removed from the system... But no worries! You can republish it anytime to give it another chance! :)",
    "codingamerHandle": "79ae4f668f3f26561f3408f3de3c13375451762",
    "avatar": 19333912201092,
    "elapsedTime": 29839884000
  },
  {
    "commentId": 331507,
    "codingamerId": 491254,
    "commentableId": 36125384,
    "responseCount": 4,
    "upVotes": 1,
    "downVotes": 0,
    "votableId": 36327757,
    "userVoteValue": 0,
    "nickname": "Cakeisalie5",
    "content": "Nice challenge, but couldn't solve it under 5 minutes unfortunately. Maybe either adding precise instructions for the intersection algorithm or precise conditions for the problem once the intersection is made (but not both) could help speed it up and make it fit?\n\nI also struggled with \"such that they partially overlap\", as it doesn't explicit enough that ALL words must overlap, so for some time I didn't understand why \"portmanteaudiblesport\" wasn't also a valid option (\"audible\" and \"sport\" don't overlap), It may be a good idea to make that explicit, e.g. by adding \"such that they partially overlap, i.e. the first word must overlap with the second *and* the second must overlap with the third\"?",
    "codingamerHandle": "26bc712b959a94dd2cd3c4b55b10484f452194",
    "avatar": 93798463743273,
    "elapsedTime": 31923508000
  },
  {
    "commentId": 329395,
    "codingamerId": 2874091,
    "commentableId": 36125384,
    "responseCount": 6,
    "upVotes": 0,
    "downVotes": 0,
    "votableId": 36283663,
    "userVoteValue": 0,
    "nickname": "5DN1L",
    "content": "Please add a constraint that any two [[words]] do not overlap completely (you've already included an assertion of that in your code). Without the constraint, cases like the one below are possible:\n\ncodingame\nding\ngame\n\nThanks.",
    "codingamerHandle": "bbb8f47ea4601179303c20acdbf5fb6c1904782",
    "onlineSince": 1770727666105,
    "avatar": 134264063920528,
    "elapsedTime": 32416693000
  },
  {
    "commentId": 329791,
    "codingamerId": 4238671,
    "commentableId": 36125384,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 329395,
    "votableId": 36291411,
    "userVoteValue": 0,
    "nickname": "DavidAugustoVilla",
    "content": "Added to the statement.",
    "codingamerHandle": "455d71552aef838a0c75b7617e2d22d41768324",
    "avatar": 132419401284681,
    "elapsedTime": 32341830000
  },
  {
    "commentId": 331640,
    "codingamerId": 4238671,
    "commentableId": 36125384,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 331507,
    "votableId": 36329375,
    "userVoteValue": 0,
    "nickname": "DavidAugustoVilla",
    "content": "Thanks! Expanded the description.",
    "codingamerHandle": "455d71552aef838a0c75b7617e2d22d41768324",
    "avatar": 132419401284681,
    "elapsedTime": 31902110000
  },
  {
    "commentId": 472583,
    "codingamerId": 4238671,
    "commentableId": 36125384,
    "responseCount": 0,
    "upVotes": 1,
    "downVotes": 0,
    "parentCommentId": 472518,
    "votableId": 38873114,
    "userVoteValue": 0,
    "nickname": "DavidAugustoVilla",
    "content": "No null overlap seems to be a common request despite it being common sense. I've extended the text quite a bit, trying to avoid mathy stuff.",
    "codingamerHandle": "455d71552aef838a0c75b7617e2d22d41768324",
    "avatar": 132419401284681,
    "elapsedTime": 3904696000
  },
  {
    "commentId": 492019,
    "codingamerId": 4238671,
    "commentableId": 36125384,
    "responseCount": 0,
    "upVotes": 1,
    "downVotes": 0,
    "parentCommentId": 472747,
    "votableId": 39092393,
    "userVoteValue": 0,
    "nickname": "DavidAugustoVilla",
    "content": "In test/validator 4, \"chess\" is not essential. Overlapping all 3 words on at least one letter, 's' in your example, was something I hadn't considered. I'll have to come back to it when I have a moment.",
    "codingamerHandle": "455d71552aef838a0c75b7617e2d22d41768324",
    "avatar": 132419401284681,
    "elapsedTime": 570928000
  },
  {
    "commentId": 492020,
    "codingamerId": 4238671,
    "commentableId": 36125384,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 481624,
    "votableId": 39092401,
    "userVoteValue": 0,
    "nickname": "DavidAugustoVilla",
    "content": "Following approval, if it gets downvoted in clashes then it could drop some options or entirely. You're welcome to create a puzzle based on the concept, maybe with longer lists of words. If not, I might have a go at it at some point.",
    "codingamerHandle": "455d71552aef838a0c75b7617e2d22d41768324",
    "avatar": 132419401284681,
    "elapsedTime": 570813000
  },
  {
    "commentId": 481890,
    "codingamerId": 5829515,
    "commentableId": 36125384,
    "responseCount": 0,
    "upVotes": 1,
    "downVotes": 0,
    "parentCommentId": 481855,
    "votableId": 38976786,
    "userVoteValue": 0,
    "nickname": "Stef_3",
    "content": "Contrary to other comments I think this is well-suited for Shortest and Reverse too.\n\nFor Reverse it's quite obvious what the goal is. The first testcase \"sportmanteaudible\" makes the goal immediately obvious, and there are 8 testcases that all have exactly 3 words, so it's obvious that there are always 3 words.\n\nThis is well-suited for Shortest mode too: after applying minor golfing to my solution  (removing whitespace and changing variable names to one char) the solution is quite short:\nfrom itertools import*\ndef K(a,b):return next(k for k in range(min(len(a),len(b)))[::-1]if a[len(a)-k:]==b[:k])\nfor a,b,c in permutations(map(input,['']*3)):\n k,l=K(a,b),K(b,c)\n if k*l:input(a+b[k:]+c[l:])",
    "codingamerHandle": "9f2646b70e1699fc7b6101dd0b5eb88a5159285",
    "avatar": 135978326596201,
    "elapsedTime": 2253176000
  },
  {
    "commentId": 481921,
    "codingamerId": 5829515,
    "commentableId": 36125384,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 481855,
    "votableId": 38976814,
    "userVoteValue": 0,
    "nickname": "Stef_3",
    "content": "For languages that don't have a permutations function in their standard library, it can still be bruteforced easily with something like:\n\nfor a in words:\n.   for b in words:\n.       for c in words:\n.           if sorted((a,b,c))==sorted(words):\n.               ...\n\nOr just manually unroll the loop:\n\nfor a,b,c in [(0,1,2),(0,2,1),(1,0,2),(1,2,0),(2,0,1),(2,1,0)]:",
    "codingamerHandle": "9f2646b70e1699fc7b6101dd0b5eb88a5159285",
    "avatar": 135978326596201,
    "elapsedTime": 2252771000
  },
  {
    "commentId": 336133,
    "codingamerId": 2874091,
    "commentableId": 36125384,
    "responseCount": 0,
    "upVotes": 1,
    "downVotes": 0,
    "parentCommentId": 331507,
    "votableId": 36422878,
    "userVoteValue": 0,
    "nickname": "5DN1L",
    "content": "\"partially overlap each other\" sounds wrong to me because the first word in the output may not overlap the third word.",
    "codingamerHandle": "bbb8f47ea4601179303c20acdbf5fb6c1904782",
    "onlineSince": 1770727666105,
    "avatar": 134264063920528,
    "elapsedTime": 30935140000
  },
  {
    "commentId": 336135,
    "codingamerId": 4238671,
    "commentableId": 36125384,
    "responseCount": 0,
    "upVotes": 1,
    "downVotes": 0,
    "parentCommentId": 331507,
    "votableId": 36422909,
    "userVoteValue": 0,
    "nickname": "DavidAugustoVilla",
    "content": "they = adjacent pairs. Better?",
    "codingamerHandle": "455d71552aef838a0c75b7617e2d22d41768324",
    "avatar": 132419401284681,
    "elapsedTime": 30934940000
  },
  {
    "commentId": 336137,
    "codingamerId": 2874091,
    "commentableId": 36125384,
    "responseCount": 0,
    "upVotes": 1,
    "downVotes": 0,
    "parentCommentId": 331507,
    "votableId": 36422919,
    "userVoteValue": 0,
    "nickname": "5DN1L",
    "content": "Yes, thanks.",
    "codingamerHandle": "bbb8f47ea4601179303c20acdbf5fb6c1904782",
    "onlineSince": 1770727666105,
    "avatar": 134264063920528,
    "elapsedTime": 30934867000
  },
  {
    "commentId": 329795,
    "codingamerId": 2874091,
    "commentableId": 36125384,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 329395,
    "votableId": 36291465,
    "userVoteValue": 0,
    "nickname": "5DN1L",
    "content": "I don't see any changesâ€¦? If you mean \"they partially overlap\" is the changed part then it doesn't address my concern, which is to put a restriction on what cases that can appear in the clash, instead of how the words should be overlapped and output.",
    "codingamerHandle": "bbb8f47ea4601179303c20acdbf5fb6c1904782",
    "onlineSince": 1770727666105,
    "avatar": 134264063920528,
    "elapsedTime": 32340903000
  },
  {
    "commentId": 329990,
    "codingamerId": 4238671,
    "commentableId": 36125384,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 329395,
    "votableId": 36293731,
    "userVoteValue": 0,
    "nickname": "DavidAugustoVilla",
    "content": "If the instruction is to partially overlap them, and there is only one way they can overlap, then the only way they can overlap is partially.",
    "codingamerHandle": "455d71552aef838a0c75b7617e2d22d41768324",
    "avatar": 132419401284681,
    "elapsedTime": 32308798000
  },
  {
    "commentId": 329991,
    "codingamerId": 2874091,
    "commentableId": 36125384,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 329395,
    "votableId": 36293822,
    "userVoteValue": 0,
    "nickname": "5DN1L",
    "content": "Instructions are instructions. You may say they imply a certain constraint, but they do not explicitly impose one on the input itself. If the constraint isn't specified, it remains an assumption rather than an actual constraint. I hope you can do the players a favour and make it explicit.",
    "codingamerHandle": "bbb8f47ea4601179303c20acdbf5fb6c1904782",
    "onlineSince": 1770727666105,
    "avatar": 134264063920528,
    "elapsedTime": 32307902000
  },
  {
    "commentId": 330187,
    "codingamerId": 4238671,
    "commentableId": 36125384,
    "responseCount": 0,
    "upVotes": 1,
    "downVotes": 0,
    "parentCommentId": 329395,
    "votableId": 36296525,
    "userVoteValue": 0,
    "nickname": "DavidAugustoVilla",
    "content": "I've added another test case. It's no longer true that \"any two words do not overlap completely\". However, if the programmer follows instructions to partially overlap the words, then the correct solution will be apparent.",
    "codingamerHandle": "455d71552aef838a0c75b7617e2d22d41768324",
    "avatar": 132419401284681,
    "elapsedTime": 32276746000
  },
  {
    "commentId": 330253,
    "codingamerId": 2874091,
    "commentableId": 36125384,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 329395,
    "votableId": 36297867,
    "userVoteValue": 0,
    "nickname": "5DN1L",
    "content": "OK, thank you. ðŸ‘ðŸ»",
    "codingamerHandle": "bbb8f47ea4601179303c20acdbf5fb6c1904782",
    "onlineSince": 1770727666105,
    "avatar": 134264063920528,
    "elapsedTime": 32250173000
  }
]