[
  {
    "commentId": 103106,
    "codingamerId": 4901554,
    "commentableId": 11283739,
    "responseCount": 0,
    "upVotes": 1,
    "downVotes": 0,
    "votableId": 28059002,
    "userVoteValue": 0,
    "nickname": "okzoku",
    "content": "Nice!",
    "codingamerHandle": "b040d69bc20e1405881586a20a3152d04551094",
    "avatar": 90801167677927,
    "elapsedTime": 95092672000
  },
  {
    "commentId": 22511,
    "codingamerId": 3473248,
    "commentableId": 11283739,
    "responseCount": 10,
    "upVotes": 2,
    "downVotes": 1,
    "votableId": 11449939,
    "userVoteValue": 0,
    "nickname": "Alex_tref",
    "content": "Why do you keep republishing the same challenge as a CoC for the third time straight without changing anything?\nI mean, come on, just make it a Puzzle and everybody will be happy about it.",
    "codingamerHandle": "95c49aa17e671394d6758f0f437c44e88423743",
    "avatar": 34032221836049,
    "elapsedTime": 202189920000
  },
  {
    "commentId": 22509,
    "codingamerId": 2928146,
    "commentableId": 11283739,
    "responseCount": 1,
    "upVotes": 3,
    "downVotes": 1,
    "votableId": 11449838,
    "userVoteValue": 0,
    "nickname": "LolCat",
    "content": "Community has already rejected this CoC 2 times",
    "codingamerHandle": "fbed35c7a0ac857f11c63f7535e636a76418292",
    "avatar": 22538133010433,
    "elapsedTime": 202191122000
  },
  {
    "commentId": 22508,
    "codingamerId": 155774,
    "commentableId": 11283739,
    "responseCount": 1,
    "upVotes": 0,
    "downVotes": 0,
    "votableId": 11449818,
    "userVoteValue": 0,
    "nickname": "dwarfie",
    "content": "for the ones who have not read the guidelines ... there are rules for contribution moderation ... no need to tell who is the one i'm thinking ...\nhttps://www.codingame.com/playgrounds/40701/contribute---help/why-contribute",
    "codingamerHandle": "2ad5cc4919ed368f16de4aecd570e21e477551",
    "avatar": 17785582865119,
    "elapsedTime": 202191357000
  },
  {
    "commentId": 22500,
    "codingamerId": 3442915,
    "commentableId": 11283739,
    "responseCount": 3,
    "upVotes": 2,
    "downVotes": 0,
    "votableId": 11449629,
    "userVoteValue": 0,
    "nickname": "such",
    "content": "This challenge is biased towards certain programming language.",
    "codingamerHandle": "f6d776b14fdbb40a3ed6f2a1782f55c55192443",
    "avatar": 32564548083080,
    "elapsedTime": 202194273000
  },
  {
    "commentId": 22498,
    "codingamerId": 2491616,
    "commentableId": 11283739,
    "responseCount": 1,
    "upVotes": 2,
    "downVotes": 0,
    "votableId": 11449550,
    "userVoteValue": 0,
    "nickname": "abt8601",
    "content": "Solving this problem does not require prime factorization, contrary to what many have said.\n\nThe \"factor\" function used in the solution is simply for checking whether a number is a prime or not. And there is a way simpler method for doing so:\n\nx is a prime iff x is not divisible by every integer from 2 to x-1 (inclusive).\n(Actually floor(sqrt(x)) is enough, but the results are identical.)\n\nTo implement this in an imperative programming language, the main constructs you need is just a for loop, a conditional, and an early return. For example, in C:\n\nbool is_prime(int x) {\n    for (int i = 2; i < x; i++) {\n        if (x % i == 0) return false;\n    }\n    return true;\n}\n\nAnd in some languages, it is a one-liner: (x is the number to be checked)\nHaskell: all ((/=0) . (x `mod`)) [2..x-1]\nPython3: all(x % y != 0 for y in range(2, x))\n\nAlthough it is not very efficient, but for problems of this size (x < 1000), it works wonderfully.",
    "codingamerHandle": "a82453c7a4a92ac86cba6e27177958186161942",
    "avatar": 113139385453588,
    "elapsedTime": 202195373000
  },
  {
    "commentId": 22494,
    "codingamerId": 2928146,
    "commentableId": 11283739,
    "responseCount": 2,
    "upVotes": 2,
    "downVotes": 4,
    "votableId": 11449407,
    "userVoteValue": 0,
    "nickname": "LolCat",
    "content": "This contribution already been rejected.\nI am agree with Alex_tref, the solution relies on the \"factor\" function.\nWithout this function in other language, challenge is not fair and can't be done under 5min.\n\nThis contribution make sense as puzzle, not CoC.",
    "codingamerHandle": "fbed35c7a0ac857f11c63f7535e636a76418292",
    "avatar": 22538133010433,
    "elapsedTime": 202197925000
  },
  {
    "commentId": 22489,
    "codingamerId": 3473248,
    "commentableId": 11283739,
    "responseCount": 8,
    "upVotes": 2,
    "downVotes": 2,
    "votableId": 11448310,
    "userVoteValue": 0,
    "nickname": "Alex_tref",
    "content": "The solution relies on the \"factor\" function, which is Bash built-in.\nIt rarely has an equivalent in other programming languages, which makes the challenge unfair towards those who do not code in Bash and will have to rewrite the function by hand, losing time/increasing code length.\nThis challenge would probably make more sense as a separate puzzle, where time and code length are not critical.\nI suggest you make it one :)",
    "codingamerHandle": "95c49aa17e671394d6758f0f437c44e88423743",
    "avatar": 34032221836049,
    "elapsedTime": 202224903000
  },
  {
    "commentId": 22448,
    "codingamerId": 3340505,
    "commentableId": 11283739,
    "responseCount": 3,
    "upVotes": 2,
    "downVotes": 3,
    "votableId": 11433767,
    "userVoteValue": 0,
    "nickname": "dovg",
    "content": "I don't want to mumble my complaints in #Fr chat, so I'm writing here:\n\nTest cases must have explicit names.",
    "codingamerHandle": "4ebaf9a9ae94cf2bb3bdca777df52c895050433",
    "elapsedTime": 202416109000
  },
  {
    "commentId": 22196,
    "codingamerId": 1186885,
    "commentableId": 11283739,
    "responseCount": 11,
    "upVotes": 5,
    "downVotes": 1,
    "votableId": 11360720,
    "userVoteValue": 0,
    "nickname": "miracle",
    "content": "The output of this clash can be way over 2^63, which would cause problems for the languages that do not have a built-in support of big integers. You either specify the possible range of outcome, or adding other operations (e.g., modulo) to keep the outcome below 2^63.",
    "codingamerHandle": "2f1d7531ec1fe2847f2f997b08096dd85886811",
    "elapsedTime": 203364939000
  },
  {
    "commentId": 22197,
    "codingamerId": 155774,
    "commentableId": 11283739,
    "responseCount": 0,
    "upVotes": 1,
    "downVotes": 0,
    "parentCommentId": 22196,
    "votableId": 11360750,
    "userVoteValue": 0,
    "nickname": "dwarfie",
    "content": "none of my tests or validators exceed 2^62 for compatibilty with languages",
    "codingamerHandle": "2ad5cc4919ed368f16de4aecd570e21e477551",
    "avatar": 17785582865119,
    "elapsedTime": 203364650000
  },
  {
    "commentId": 22449,
    "codingamerId": 925695,
    "commentableId": 11283739,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 1,
    "parentCommentId": 22448,
    "votableId": 11433773,
    "userVoteValue": 0,
    "nickname": "Boulet",
    "content": "Common !",
    "codingamerHandle": "dc5be2d951d61e3948cb537119c4c1ff596529",
    "avatar": 29121141951376,
    "elapsedTime": 202416038000
  },
  {
    "commentId": 22490,
    "codingamerId": 155774,
    "commentableId": 11283739,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 1,
    "parentCommentId": 22489,
    "votableId": 11448324,
    "userVoteValue": 0,
    "nickname": "dwarfie",
    "content": "the solution is bash is one of my solutions in differents language. it is used only to validate the tests  and is not a valid reason for refusal ... if i had publish my solution with my own function , would have you used the factor command in bash as pretext ? i think not\n\nbe happy , you and the two others got xp but i do not accept this refusal because none respected the guidelines and i will republish it immediatly",
    "codingamerHandle": "2ad5cc4919ed368f16de4aecd570e21e477551",
    "avatar": 17785582865119,
    "elapsedTime": 202224471000
  },
  {
    "commentId": 22497,
    "codingamerId": 925695,
    "commentableId": 11283739,
    "responseCount": 0,
    "upVotes": 1,
    "downVotes": 0,
    "parentCommentId": 22494,
    "votableId": 11449538,
    "userVoteValue": 0,
    "nickname": "Boulet",
    "content": "All you have to do is to code a prime function and a loop....",
    "codingamerHandle": "dc5be2d951d61e3948cb537119c4c1ff596529",
    "avatar": 29121141951376,
    "elapsedTime": 202195709000
  },
  {
    "commentId": 22523,
    "codingamerId": 1186885,
    "commentableId": 11283739,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 22498,
    "votableId": 11451575,
    "userVoteValue": 0,
    "nickname": "miracle",
    "content": "A side remark: this does not handle 0 and 1 correctly. It would not be a problem for this challenge though.",
    "codingamerHandle": "2f1d7531ec1fe2847f2f997b08096dd85886811",
    "elapsedTime": 202167832000
  },
  {
    "commentId": 22502,
    "codingamerId": 155774,
    "commentableId": 11283739,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 22500,
    "votableId": 11449683,
    "userVoteValue": 0,
    "nickname": "dwarfie",
    "content": "no more than all bullshit you validated which where biaised for python\n\nthat's not a valid reason to refuse",
    "codingamerHandle": "2ad5cc4919ed368f16de4aecd570e21e477551",
    "avatar": 17785582865119,
    "elapsedTime": 202193572000
  },
  {
    "commentId": 22512,
    "codingamerId": 2928146,
    "commentableId": 11283739,
    "responseCount": 0,
    "upVotes": 1,
    "downVotes": 2,
    "parentCommentId": 22508,
    "votableId": 11449953,
    "userVoteValue": 0,
    "nickname": "LolCat",
    "content": "\"CoC puzzles should be solvable in less than 5 minutes.\n\nThe main goal of a CoC battles is to be short (except in the \"Shortest\" mode). CoC players are looking for quick simple puzzles to solve; for more complex problems, they'll dive into the classic puzzles section.\"\n\nYour CoC is not quick or simple puzzle. I deem that CoC should be in the classic puzzles section. That's my reason.",
    "codingamerHandle": "fbed35c7a0ac857f11c63f7535e636a76418292",
    "avatar": 22538133010433,
    "elapsedTime": 202189715000
  },
  {
    "commentId": 22510,
    "codingamerId": 155774,
    "commentableId": 11283739,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 22509,
    "votableId": 11449845,
    "userVoteValue": 0,
    "nickname": "dwarfie",
    "content": "for invalid reasons ... READ THE GUIDELINES\nyour first refusal was not even explained ...",
    "codingamerHandle": "2ad5cc4919ed368f16de4aecd570e21e477551",
    "avatar": 17785582865119,
    "elapsedTime": 202190955000
  },
  {
    "commentId": 22513,
    "codingamerId": 155774,
    "commentableId": 11283739,
    "responseCount": 0,
    "upVotes": 1,
    "downVotes": 0,
    "parentCommentId": 22511,
    "votableId": 11449976,
    "userVoteValue": 0,
    "nickname": "dwarfie",
    "content": "just because your comment about my bash solution was unfair ... \n\nwhen you approve, the criterea are \"statement clear\" \"stub generator valid\" \"good tests case\" (i think it is ok) and \"solvable in 5 minutes\"\n\nyou can tell this is a really too hard problem because :\n- somes don't know how to check primes\n- naives solutions won't work because exceeding 64 bits limit\n\nbut, honestly, this is simple compared to some others... it is solvable in less that 5 minutes",
    "codingamerHandle": "2ad5cc4919ed368f16de4aecd570e21e477551",
    "avatar": 17785582865119,
    "elapsedTime": 202189320000
  },
  {
    "commentId": 22515,
    "codingamerId": 925695,
    "commentableId": 11283739,
    "responseCount": 0,
    "upVotes": 1,
    "downVotes": 0,
    "parentCommentId": 22511,
    "votableId": 11450020,
    "userVoteValue": 0,
    "nickname": "Boulet",
    "content": "Moreover, THIS IS NOT A PUZZLE. Please read the statements before posting any comment. This one is mainly a product of primes !",
    "codingamerHandle": "dc5be2d951d61e3948cb537119c4c1ff596529",
    "avatar": 29121141951376,
    "elapsedTime": 202188778000
  },
  {
    "commentId": 22516,
    "codingamerId": 3473248,
    "commentableId": 11283739,
    "responseCount": 0,
    "upVotes": 1,
    "downVotes": 1,
    "parentCommentId": 22511,
    "votableId": 11450110,
    "userVoteValue": 0,
    "nickname": "Alex_tref",
    "content": "Actually it's not just about guidelines, that's more of a general user experience issue.\nA Bash programmer who may not even know how to manually check if a number is prime might end up doing better at this challenge than guys coding in Python/JS/PHP just because they don't have the \"factorial\" built-in and will spend time/lines of code to rewrite it. I think this is unfair.\n\nTo put it straight:\nTo my mind, the winner of a CoC should be the one who has better coding skills, not the one who has the most built-ins in their programming language.\n\nAfter all, it's called \"Clash of Code\", not \"Clash of Built-ins\" ðŸ™ƒ",
    "codingamerHandle": "95c49aa17e671394d6758f0f437c44e88423743",
    "avatar": 34032221836049,
    "elapsedTime": 202187373000
  },
  {
    "commentId": 22517,
    "codingamerId": 925695,
    "commentableId": 11283739,
    "responseCount": 0,
    "upVotes": 1,
    "downVotes": 3,
    "parentCommentId": 22511,
    "votableId": 11450117,
    "userVoteValue": 0,
    "nickname": "Boulet",
    "content": "(* Auto-generated code below aims at helping you parse *)\n(* the standard input according to the problem statement. *)\n\nlet x = int_of_string (input_line stdin) in\nlet y = int_of_string (input_line stdin) in\nlet is_prime n = \n    let rec aux k = \n        if k*k > n then true \n        else if n mod k = 0 then false \n        else aux (k+1)\n    in \n    n<>1 && (n=2 ||  aux 2)\nin\nlet s = ref 1 in\nfor i = y + 1 to x do \nif is_prime i then \n(\ns:=!s*i ;\nFormat.fprintf Format.err_formatter \"%d@.\" i\n)\ndone;\nFormat.printf \"%d@.\" !s\n\n\nReflexions: 5s\nCoding: 45s:",
    "codingamerHandle": "dc5be2d951d61e3948cb537119c4c1ff596529",
    "avatar": 29121141951376,
    "elapsedTime": 202187298000
  },
  {
    "commentId": 22518,
    "codingamerId": 3473248,
    "commentableId": 11283739,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 2,
    "parentCommentId": 22511,
    "votableId": 11450291,
    "userVoteValue": 0,
    "nickname": "Alex_tref",
    "content": "@Boulet\nYou don't get it.\nYou don't need to write an \"is_prime\" function since Bash has its own built-in \"factorial\" command.\nThat's not the case for most of the other available languages.\n\nAnyway, it probably doesn't matter by now since the challenge ended up getting approved",
    "codingamerHandle": "95c49aa17e671394d6758f0f437c44e88423743",
    "avatar": 34032221836049,
    "elapsedTime": 202184668000
  },
  {
    "commentId": 22519,
    "codingamerId": 925695,
    "commentableId": 11283739,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 1,
    "parentCommentId": 22511,
    "votableId": 11450515,
    "userVoteValue": 0,
    "nickname": "Boulet",
    "content": "Let me laugh please. Can you explain me where is the problem to code a primality test for integer < 1000",
    "codingamerHandle": "dc5be2d951d61e3948cb537119c4c1ff596529",
    "avatar": 29121141951376,
    "elapsedTime": 202180919000
  },
  {
    "commentId": 22520,
    "codingamerId": 3473248,
    "commentableId": 11283739,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 22511,
    "votableId": 11450611,
    "userVoteValue": 0,
    "nickname": "Alex_tref",
    "content": "@Boulet\nWell, if you spent a little less time laughing and a little more time actually reading my previous comments, you might just have noticed that the problem is not in the complexity of the prime finding algorithm, but in the fact that it is ALREADY embedded in Bash.\nConsequently, anyone who is not coding in Bash will have to rewrite it from scratch. I'm not saying it's difficult â€” I'm saying it is going to take additional time and code lines, both of which are critical factors in this type of challenge.\n\nI suggest we leave this discussion. It is clearly leading to nowhere at this point.",
    "codingamerHandle": "95c49aa17e671394d6758f0f437c44e88423743",
    "avatar": 34032221836049,
    "elapsedTime": 202179523000
  },
  {
    "commentId": 22521,
    "codingamerId": 2491616,
    "commentableId": 11283739,
    "responseCount": 0,
    "upVotes": 3,
    "downVotes": 0,
    "parentCommentId": 22511,
    "votableId": 11450698,
    "userVoteValue": 0,
    "nickname": "abt8601",
    "content": "Let me say something about languages and puzzles.\n\nYes, some languages are better for solving a given puzzle. And yes, it is unfair. However, this will be present in almost all problems you'll ever encounter in your programming career. This is just a property of the many different programming languages and their libraries. A different set of language and library features lends itself to a different set of problems a language especially excels at. Bash and prime factorization is an example, as is demonstrated.\n\nLet me share my experience on CoC. I've solved a CoC problem in shortest mode involving rotating a matrix 90Â° clockwise. Haskell has a function called \"transpose\" that transposes a list of lists, so rotating a matrix 90Â° clockwise is simply \"map reverse . transpose\", while other languages require the programmers to manually write loops to accomplish the same thing. It is so broken that I am always ahead of the 2nd place by about 30 characters or even more.\n\nYes, you can say that this puzzle is biased towards Bash programmers and the matrix rotation one is biased towards Haskell programmers. However, the thing is that it is simply almost impossible to create a problem that is completely fair for all programmers of all languages. We can only create problems that are more biased or less biased.\n\nAs for this puzzle, in terms of time, although the presence of the \"factor\" function in Bash will eliminate some mental efforts for Bash programmers, for programmers of other languages this isn't a big deal at all, since all reasonably decent programmers have the naive method in their brain, and for all the others, it isn't prohibitively difficult to figure it out themselves. Also, I would argue that skill level matters more than whether one uses Bash or not. If a person is just starting to learn programming, even though he/she could write out that \"factor | grep\" thing quickly, he/she might struggle a little bit at writing other parts of the code, resulting in a poor performance overall. Meanwhile, a reasonably decent programmer can write out a solution in C within 3 minutes, obviously without the magic prime factorization function.",
    "codingamerHandle": "a82453c7a4a92ac86cba6e27177958186161942",
    "avatar": 113139385453588,
    "elapsedTime": 202178243000
  },
  {
    "commentId": 22522,
    "codingamerId": 3473248,
    "commentableId": 11283739,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 22511,
    "votableId": 11450899,
    "userVoteValue": 0,
    "nickname": "Alex_tref",
    "content": "@abt8601\nRight, it's probably a matter of opinion at some point.\nI personally think that both this challenge and the one you stated kind of over-promote the use of specific languages.\nI don't think it's a particularly good  thing. In fact, it appears to me that CoCs would be funnier without them, but I definitely don't blame you if you think otherwise.\n\nThanks for the constructive comment thought, it's nice to finally get one ðŸ˜ƒ",
    "codingamerHandle": "95c49aa17e671394d6758f0f437c44e88423743",
    "avatar": 34032221836049,
    "elapsedTime": 202175621000
  },
  {
    "commentId": 22524,
    "codingamerId": 925695,
    "commentableId": 11283739,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 22511,
    "votableId": 11451893,
    "userVoteValue": 0,
    "nickname": "Boulet",
    "content": "Just read most of recently accepted CoC and serioulsy tell me that python is not favored !",
    "codingamerHandle": "dc5be2d951d61e3948cb537119c4c1ff596529",
    "avatar": 29121141951376,
    "elapsedTime": 202164058000
  },
  {
    "commentId": 22503,
    "codingamerId": 3442915,
    "commentableId": 11283739,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 22500,
    "votableId": 11449699,
    "userVoteValue": 0,
    "nickname": "such",
    "content": "change your solution to python and see this getting approved . :sleepy:",
    "codingamerHandle": "f6d776b14fdbb40a3ed6f2a1782f55c55192443",
    "avatar": 32564548083080,
    "elapsedTime": 202193369000
  },
  {
    "commentId": 22505,
    "codingamerId": 155774,
    "commentableId": 11283739,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 22500,
    "votableId": 11449738,
    "userVoteValue": 0,
    "nickname": "dwarfie",
    "content": "less than 1 minute to make a solution in python ... language does not matter ...\n\ndef is_prime(a):\n    if a==2: return True\n    for i in range(2,a):\n        if a%i==0: return False\n    return True\n    \nx = int(input())\ny = int(input())\n\nr=1\nfor i in range(y+1,x+1):\n    if is_prime(i): r*=i\n\nprint(r)",
    "codingamerHandle": "2ad5cc4919ed368f16de4aecd570e21e477551",
    "avatar": 17785582865119,
    "elapsedTime": 202192832000
  },
  {
    "commentId": 22504,
    "codingamerId": 2491616,
    "commentableId": 11283739,
    "responseCount": 0,
    "upVotes": 1,
    "downVotes": 0,
    "parentCommentId": 22494,
    "votableId": 11449725,
    "userVoteValue": 0,
    "nickname": "abt8601",
    "content": "Solving this problem does not rely on the \"factor\" function. I have a detailed argument on one of my comments.\n\nIn short, you don't need prime factorization to solve this problem. You just need to check if a number is a prime. In fact, the use of the \"factor\" function is for that purpose. And checking if a number is a prime is very easy: if x is not divisible by all integers from 2 to x-1, then x is a prime. Writing this in most languages is very easy and can definitely be done within 5 minutes.",
    "codingamerHandle": "a82453c7a4a92ac86cba6e27177958186161942",
    "avatar": 113139385453588,
    "elapsedTime": 202193018000
  },
  {
    "commentId": 22491,
    "codingamerId": 1186885,
    "commentableId": 11283739,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 22489,
    "votableId": 11448977,
    "userVoteValue": 0,
    "nickname": "miracle",
    "content": "A side remark on XP: a comment only gets a meagre +1 XP for each upvote it gets (i.e. no upvotes, no XP). Few people really care about that. Many people comment to help improve the clash / puzzle, not for XP. An approval or rejection gets +15 XP only if it is in line with the final outcome (IMHO that is not much either).",
    "codingamerHandle": "2f1d7531ec1fe2847f2f997b08096dd85886811",
    "elapsedTime": 202207658000
  },
  {
    "commentId": 22493,
    "codingamerId": 2491616,
    "commentableId": 11283739,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 22489,
    "votableId": 11449360,
    "userVoteValue": 0,
    "nickname": "abt8601",
    "content": "I think this contribution has been rejected once, because when I checked it yesterday it showed that there were people approving and rejecting it. The author republished this contribution, probably several hours ago, and it had a fresh start.",
    "codingamerHandle": "a82453c7a4a92ac86cba6e27177958186161942",
    "avatar": 113139385453588,
    "elapsedTime": 202198516000
  },
  {
    "commentId": 22495,
    "codingamerId": 1186885,
    "commentableId": 11283739,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 22489,
    "votableId": 11449417,
    "userVoteValue": 0,
    "nickname": "miracle",
    "content": "@abt8601 IC. I didn't know the same contribution can be republished immediately with its status cleared.",
    "codingamerHandle": "2f1d7531ec1fe2847f2f997b08096dd85886811",
    "elapsedTime": 202197800000
  },
  {
    "commentId": 22499,
    "codingamerId": 3473248,
    "commentableId": 11283739,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 22489,
    "votableId": 11449613,
    "userVoteValue": 0,
    "nickname": "Alex_tref",
    "content": "Actually, I would.\nI do believe you can rewrite the factor command in any other language or even in bash itself. It is indeed possible.\nMy point is, when completing your challenge in a CoC, someone who knows bash well would definitely use that built-in in order to save themselves time and lines of code. That makes this challenge unfair towards others, who might even be better at solving it, but because they don't have that \"factor\" command in their language, will lose precious time and code length.\n\nLook, I wasn't particularly happy to reject your contribution. In fact, I find the topic quite interesting and would have been glad to upvote it, but, like I said, only if you republished it as a puzzle, where bash coders would not have that huge advantage over others.\n\nAnd yeah, when I arrived, your contribution already had 2/3 downvotes AND 2/3 upvotes, so I would have had those poor 15xp either way (which is clearly not what I came here for)",
    "codingamerHandle": "95c49aa17e671394d6758f0f437c44e88423743",
    "avatar": 34032221836049,
    "elapsedTime": 202194469000
  },
  {
    "commentId": 22506,
    "codingamerId": 1186885,
    "commentableId": 11283739,
    "responseCount": 0,
    "upVotes": 2,
    "downVotes": 0,
    "parentCommentId": 22489,
    "votableId": 11449755,
    "userVoteValue": 0,
    "nickname": "miracle",
    "content": "Another remark on fairness: a naive approach actually runs well on languages that have built-in support for big integers but not on those that do not have it. In other words, the \"Be smart , don't try with all primes\" test case does not really filter out naive solutions on some languages. In terms of fairness, this problem is more wide-range.",
    "codingamerHandle": "2f1d7531ec1fe2847f2f997b08096dd85886811",
    "elapsedTime": 202192532000
  },
  {
    "commentId": 22507,
    "codingamerId": 155774,
    "commentableId": 11283739,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 22489,
    "votableId": 11449809,
    "userVoteValue": 0,
    "nickname": "dwarfie",
    "content": "@miracle\n\nfirst i am not thinking that the 15 xp they got was a problem ... but refusing without any comment or a valid reason is not acceptable ...\n\nit is boring to see that someones does not seem able to read/follow the contribution guidelines and  take decision as soon as they have the possibilities ... but, after allwhat can we expect from people who have done a little more than 50 CoC\n\nsecond i really considered to change this CoC to a puzzle because big integers as you told which is the only good reason so far (dangerous to tell it because lots will rush to use it ...). but you played almost as much CoC than me to know that in fact clashes are more often choosing the best language to solve than simply solving...",
    "codingamerHandle": "2ad5cc4919ed368f16de4aecd570e21e477551",
    "avatar": 17785582865119,
    "elapsedTime": 202191599000
  },
  {
    "commentId": 22514,
    "codingamerId": 1186885,
    "commentableId": 11283739,
    "responseCount": 0,
    "upVotes": 1,
    "downVotes": 0,
    "parentCommentId": 22489,
    "votableId": 11449994,
    "userVoteValue": 0,
    "nickname": "miracle",
    "content": "@dwarfie\nTo your first point, I think that is also a problem of the entire moderation process. Those who reject a clash should be asked to provide reasons (e.g., choosing from a given list of possible reasons or stating other reasons if they have their own).\n\nTo your second point on language choices, I actually played almost all the clashes using Python 3 and only a couple of times in Ruby / Bash for the shortest mode. So I do not change languages as often as you might do.\n\nAs for the difficulty level, my feel is that this problem seems to be easier than many other puzzles but that may not be a problem. For the naive approach to fail, it needs to have much longer runtime / worse time complexity. Increasing only the size of intermediate results is not reliable, especially for languages that have good built-in support for big integers (c.f. my comment under your \"LAST DIGIT OF POWERED NUMBER\" puzzle).",
    "codingamerHandle": "2f1d7531ec1fe2847f2f997b08096dd85886811",
    "elapsedTime": 202189032000
  },
  {
    "commentId": 22450,
    "codingamerId": 154906,
    "commentableId": 11283739,
    "responseCount": 0,
    "upVotes": 3,
    "downVotes": 0,
    "parentCommentId": 22448,
    "votableId": 11433780,
    "userVoteValue": 0,
    "nickname": "JBM",
    "content": "Would you care to suggest some?",
    "codingamerHandle": "0d71f9df5da706f9f77c07c34d12480e609451",
    "elapsedTime": 202415968000
  },
  {
    "commentId": 22451,
    "codingamerId": 155774,
    "commentableId": 11283739,
    "responseCount": 0,
    "upVotes": 1,
    "downVotes": 1,
    "parentCommentId": 22448,
    "votableId": 11433792,
    "userVoteValue": 0,
    "nickname": "dwarfie",
    "content": "done ... explicit or not ... but how to be explicit ...?",
    "codingamerHandle": "2ad5cc4919ed368f16de4aecd570e21e477551",
    "avatar": 17785582865119,
    "elapsedTime": 202415788000
  },
  {
    "commentId": 22200,
    "codingamerId": 1186885,
    "commentableId": 11283739,
    "responseCount": 0,
    "upVotes": 5,
    "downVotes": 1,
    "parentCommentId": 22196,
    "votableId": 11361538,
    "userVoteValue": 0,
    "nickname": "miracle",
    "content": "If you do not write it explicitly in the constraints, people do not know whether they need to handle it or not.",
    "codingamerHandle": "2f1d7531ec1fe2847f2f997b08096dd85886811",
    "elapsedTime": 203352741000
  },
  {
    "commentId": 22202,
    "codingamerId": 2976964,
    "commentableId": 11283739,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 22196,
    "votableId": 11361787,
    "userVoteValue": 0,
    "nickname": "BenjaminUrquhart",
    "content": "The largest output required for a test case/validator is between 2^59 and 2^60 (813835565706097817)",
    "codingamerHandle": "56db73bce00f9f3bc03e675067ce577a4696792",
    "avatar": 26083283518959,
    "elapsedTime": 203346753000
  },
  {
    "commentId": 22203,
    "codingamerId": 1186885,
    "commentableId": 11283739,
    "responseCount": 0,
    "upVotes": 5,
    "downVotes": 0,
    "parentCommentId": 22196,
    "votableId": 11361797,
    "userVoteValue": 0,
    "nickname": "miracle",
    "content": "Yes. But if I try to solve such a problem, I would not make the assumption that the output would happen to meet that constraint unless it is explicitly specified. Because there are plenty of possible inputs that can make the output go over 2^63.",
    "codingamerHandle": "2f1d7531ec1fe2847f2f997b08096dd85886811",
    "elapsedTime": 203346529000
  },
  {
    "commentId": 22453,
    "codingamerId": 2288263,
    "commentableId": 11283739,
    "responseCount": 0,
    "upVotes": 2,
    "downVotes": 0,
    "parentCommentId": 22196,
    "votableId": 11434035,
    "userVoteValue": 0,
    "nickname": "dbdr",
    "content": "For Javascript the limit is 2^53-1.",
    "codingamerHandle": "a44c2c75eb5da8d5e52184eaa92342813628822",
    "avatar": 43448306132121,
    "elapsedTime": 202413540000
  },
  {
    "commentId": 22462,
    "codingamerId": 154906,
    "commentableId": 11283739,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 1,
    "parentCommentId": 22196,
    "votableId": 11437834,
    "userVoteValue": 0,
    "nickname": "JBM",
    "content": "I'm not quite sure why JS would magically have a problem with 2^53-0.",
    "codingamerHandle": "0d71f9df5da706f9f77c07c34d12480e609451",
    "elapsedTime": 202363159000
  },
  {
    "commentId": 22467,
    "codingamerId": 2288263,
    "commentableId": 11283739,
    "responseCount": 0,
    "upVotes": 4,
    "downVotes": 0,
    "parentCommentId": 22196,
    "votableId": 11438959,
    "userVoteValue": 0,
    "nickname": "dbdr",
    "content": "Because JS stores all numbers as 64 bit floating point numbers, which have 52 bits of precision.",
    "codingamerHandle": "a44c2c75eb5da8d5e52184eaa92342813628822",
    "avatar": 43448306132121,
    "elapsedTime": 202354296000
  },
  {
    "commentId": 22468,
    "codingamerId": 154906,
    "commentableId": 11283739,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 2,
    "parentCommentId": 22196,
    "votableId": 11439110,
    "userVoteValue": 0,
    "nickname": "JBM",
    "content": "2^53 is an exact power of two that fits within 64-bit's usual (and even JS's) exponent. Why would it be out of bounds?",
    "codingamerHandle": "0d71f9df5da706f9f77c07c34d12480e609451",
    "elapsedTime": 202352930000
  },
  {
    "commentId": 22469,
    "codingamerId": 2288263,
    "commentableId": 11283739,
    "responseCount": 0,
    "upVotes": 5,
    "downVotes": 0,
    "parentCommentId": 22196,
    "votableId": 11439146,
    "userVoteValue": 0,
    "nickname": "dbdr",
    "content": "It won't be out of bounds but the representation is not exact:\n\n$ node\n> 2**53\n9007199254740992\n> 2**53+1\n9007199254740992\n> (2**53+1)-(2**53)\n0",
    "codingamerHandle": "a44c2c75eb5da8d5e52184eaa92342813628822",
    "avatar": 43448306132121,
    "elapsedTime": 202352664000
  },
  {
    "commentId": 22471,
    "codingamerId": 154906,
    "commentableId": 11283739,
    "responseCount": 0,
    "upVotes": 1,
    "downVotes": 2,
    "parentCommentId": 22196,
    "votableId": 11439172,
    "userVoteValue": 0,
    "nickname": "JBM",
    "content": "You do realize you're the one exceeding it by adding 1 in 2**53+1.\n2^53+1 *is* out of bounds. (Edit to add: for exact representability, obviously)\n\n> 2**53 - (2**53-1)\n1",
    "codingamerHandle": "0d71f9df5da706f9f77c07c34d12480e609451",
    "elapsedTime": 202352479000
  },
  {
    "commentId": 22485,
    "codingamerId": 154906,
    "commentableId": 11283739,
    "responseCount": 0,
    "upVotes": 2,
    "downVotes": 3,
    "parentCommentId": 22196,
    "votableId": 11445922,
    "userVoteValue": 0,
    "nickname": "JBM",
    "content": "This is garnering a lot more heated downvotes than anything resembling a counterargument, so I'll lay it down more factually so the silent mob at least has something tangible to rail against.\n\nClaim 1: integer 2^53 is exactly representable as a IEEE-754 64-bit \"double-precision\" number.\n\nDemonstration: just build it up?\nSign: 0 (1 bit)\nExponent: 10000110100 (11 bits = 1023+53)\nMantissa: 0 (52 bits)\n(-1)^0 Ã— (1+0)Ã—2^(1076-1023) = 2^53\nNo rounding or loss of precision involved. We're not even close to subnormal range.\n\nQuick demonstration of back-and-forth conversion: http://ideone.com/3hjYpv\n\nClaim 2: JS uses IEEE-754 64-bit \"double-precision\" numbers as its only native numerical type.\n\nUnless you want to bicker about the difference between Live, Java, and ECMA, don't believe *me*, just check the spec: http://www.ecma-international.org/ecma-262/10.0/index.html#sec-ecmascript-language-types-number-type\n\n\n\n...so...\n\nEither prove me wrong, now it's all out in the clear, and I'll join you proclaiming 2^53-1 is the last of the integral JS numerical chain. Else join me in my fight against widescale cargo-cult.\n\nI suppose a lot of the confusion stems from the fact the fp64 mantissa is 52 bits, so indeed *it* cannot go over 2^53-1. But that's not the same thing as the number it represents itself.\n\nI hope at least some of the non-hater bystanders can learn from this.",
    "codingamerHandle": "0d71f9df5da706f9f77c07c34d12480e609451",
    "elapsedTime": 202258689000
  }
]