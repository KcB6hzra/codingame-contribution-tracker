[
  {
    "commentId": 494560,
    "codingamerId": 4640490,
    "commentableId": 38904655,
    "responseCount": 1,
    "upVotes": 0,
    "downVotes": 0,
    "votableId": 39125792,
    "userVoteValue": 0,
    "nickname": "RobbertvZ",
    "content": "Some things are less than intuitive to me.\n1. The additional CPU-instruction is a nice gotcha but does not add anything.\n2. The halt instruction is a bit ambiguous. I would expect it to mean halt - full stop - print the output and exit. Halting 4 times seems redundant. \n\nAlternatively 'H' could mean 'hold', and continue adjusting if another shift occurs. This would be reactive, and thus swap the timing between instruction and shift. As a bonus, this would solve point 1.\n\nIt might be too long reverse mode, but I would like to see what percentage of players can do it in under 15 minutes :)\n\nOther than that; good concept, clear statement, fun puzzle!",
    "codingamerHandle": "dfaa6dfb91ada65add912390ac4e1e020940464",
    "avatar": 154079483648682,
    "elapsedTime": 76221000
  },
  {
    "commentId": 491656,
    "codingamerId": 3276896,
    "commentableId": 38904655,
    "responseCount": 1,
    "upVotes": 1,
    "downVotes": 0,
    "votableId": 39088349,
    "userVoteValue": 0,
    "nickname": "kozuechan",
    "content": "The author's solution fails on the following case. In Python, 0.1 + 0.2 evaluates to 0.30000000000000004.\n\n0.0 0.3\n2\n0.1\n0.2\n\nExpected:\n\nFFH\n0.300 0.300\nSuccess\n\nResult:\n\nFFB\n0.300 0.300\nFailure",
    "codingamerHandle": "00ff9c85fcc84fd753d84c98ec18ca0a6986723",
    "avatar": 26189736775264,
    "elapsedTime": 611496000
  },
  {
    "commentId": 491392,
    "codingamerId": 2874091,
    "commentableId": 38904655,
    "responseCount": 0,
    "upVotes": 1,
    "downVotes": 0,
    "votableId": 39085728,
    "userVoteValue": 0,
    "nickname": "5DN1L",
    "content": "Constraints\n* Please change \"values\" to \"places\".\n\nThanks.",
    "codingamerHandle": "bbb8f47ea4601179303c20acdbf5fb6c1904782",
    "onlineSince": 1770722470459,
    "avatar": 134264063920528,
    "elapsedTime": 661223000
  },
  {
    "commentId": 491689,
    "codingamerId": 3232421,
    "commentableId": 38904655,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 491656,
    "votableId": 39088517,
    "userVoteValue": 0,
    "nickname": "User123",
    "content": "Good catch @kozuechan. I have edited my solution accordingly and modified Test/Validators 6-7 to catch floating point rounding errors.",
    "codingamerHandle": "c3b956997f0e142fcaa109d71c0ecd431242323",
    "avatar": 143871801993425,
    "elapsedTime": 609682000
  },
  {
    "commentId": 494593,
    "codingamerId": 3232421,
    "commentableId": 38904655,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 494560,
    "votableId": 39126031,
    "userVoteValue": 0,
    "nickname": "User123",
    "content": "Hey @RobbertvZ, thanks for the feedback! I included the additional CPU instruction so that the halt instruction becomes intuitive - once the CPU outputs the halt instruction, all movement should cease. I will consider changing the halt instruction to a hold instruction instead and/or only requiring one 'H' instruction if it makes more sense!",
    "codingamerHandle": "c3b956997f0e142fcaa109d71c0ecd431242323",
    "avatar": 143871801993425,
    "elapsedTime": 74219000
  }
]