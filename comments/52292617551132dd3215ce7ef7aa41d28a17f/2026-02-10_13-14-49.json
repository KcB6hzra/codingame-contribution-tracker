[
  {
    "commentId": 121218,
    "codingamerId": 5306174,
    "commentableId": 28706940,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "votableId": 29582687,
    "userVoteValue": 0,
    "nickname": "ntkteam",
    "content": "✅ Approved the contribution.\nComment: All fine",
    "codingamerHandle": "74c6b95714cb18a3c48f5028ae5522eb4716035",
    "avatar": 99355742356980,
    "elapsedTime": 85272125000
  },
  {
    "commentId": 121130,
    "codingamerId": 5456257,
    "commentableId": 28706940,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "votableId": 29564763,
    "userVoteValue": 0,
    "nickname": "vittuun.sinua",
    "content": "✅ Approved the contribution.\nComment: the description is clear and the test cases are well defined",
    "codingamerHandle": "d989f9a04a1c6964a3ca412e4fd18d0b7526545",
    "avatar": 105727786914501,
    "elapsedTime": 85351798000
  },
  {
    "commentId": 120829,
    "codingamerId": 5444472,
    "commentableId": 28706940,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "votableId": 29482547,
    "userVoteValue": 0,
    "nickname": "PatrickGPT",
    "content": "✅ Approved the contribution.\nComment: This clash looks good to me and is actually quite solvable. In fact, I think reverse mode might be viable too.",
    "codingamerHandle": "f8ad6219cd08f7917e2fea30f791f8552744445",
    "avatar": 105170388187193,
    "elapsedTime": 85698078000
  },
  {
    "commentId": 118188,
    "codingamerId": 4257588,
    "commentableId": 28706940,
    "responseCount": 0,
    "upVotes": 1,
    "downVotes": 0,
    "votableId": 29296494,
    "userVoteValue": 0,
    "nickname": "WhoTho",
    "content": "❌ Rejected the contribution.\nComment: I think this problem is a little too hard for a clash. It would be a good puzzle though.",
    "codingamerHandle": "38f5c0b7bfc4d2b868a8a2292fe09ac58857524",
    "avatar": 73384865831537,
    "elapsedTime": 87000039000
  },
  {
    "commentId": 116779,
    "codingamerId": 2671545,
    "commentableId": 28706940,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "votableId": 29202481,
    "userVoteValue": 0,
    "nickname": "CodinBot",
    "content": "I hope you received enough feedback from the community to improve your contribution. Once you have made the necessary updates, publish your contribution!",
    "codingamerHandle": "79ae4f668f3f26561f3408f3de3c13375451762",
    "avatar": 19333912201092,
    "elapsedTime": 87660550000
  },
  {
    "commentId": 115820,
    "codingamerId": 3938011,
    "commentableId": 28706940,
    "responseCount": 2,
    "upVotes": 0,
    "downVotes": 0,
    "votableId": 29141107,
    "userVoteValue": 0,
    "nickname": "[4G]",
    "content": "From my understanding, this is to implement a sorting algorithm with the constraint that you can only relocate the element from the top of the stack.\n\nYour solution doesn't represent that. I don't even understand why your count starts at 1.\n\nExample from test 2 (7 operations while 6 is expected):\n1 43 6 2 7 83 2 6\n6 1 43 6 2 7 83 2 \n6 2 1 43 6 2 7 83\n83 6 2 1 43 6 2 7\n83 7 6 2 1 43 6 2\n83 7 6 2 2 1 43 6\n83 7 6 6 2 2 1 43\n83 43 7 6 6 2 2 1",
    "codingamerHandle": "88bd11f6b10a34695c790826d745257d1108393",
    "avatar": 48721148862145,
    "elapsedTime": 88160014000
  },
  {
    "commentId": 111894,
    "codingamerId": 2874091,
    "commentableId": 28706940,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "votableId": 28848390,
    "userVoteValue": 0,
    "nickname": "5DN1L",
    "content": "Input section\n* Do you mean \"weights\" instead of \"points\" (2 times)?\n\nStub generator\n* Please use loopline instead of read string in Line 2.\n\nThanks.",
    "codingamerHandle": "bbb8f47ea4601179303c20acdbf5fb6c1904782",
    "onlineSince": 1770727666105,
    "avatar": 134264063920528,
    "elapsedTime": 90225382000
  },
  {
    "commentId": 115918,
    "codingamerId": 2464524,
    "commentableId": 28706940,
    "responseCount": 0,
    "upVotes": 1,
    "downVotes": 0,
    "parentCommentId": 115820,
    "votableId": 29150977,
    "userVoteValue": 0,
    "nickname": "GnidGnaw",
    "content": "As per the instructions, \"The weight of the ith block from the top of the tower is a_i.\", so the expected end result should be 1 2 2 6 6 7 43 83. Your solution would be a reverse tower.\nThis can be achieved through 6 operations:\n1 43 6 2 7 83 2 6\n43 6 2 7 83 1 2 6\n6 2 7 83 1 2 6 43\n2 7 83 1 2 6 6 43\n7 83 1 2 2 6 6 43\n83 1 2 2 6 6 7 43\n1 2 2 6 6 7 43 83\nI do agree with your comment on the issue of count starting at 1. I've added a new test case and updated the solution to make things more clear.",
    "codingamerHandle": "c390637e565e7ebd2ad07ae1e2e95aee4254642",
    "avatar": 17138346440330,
    "elapsedTime": 88099004000
  },
  {
    "commentId": 115984,
    "codingamerId": 3938011,
    "commentableId": 28706940,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 115820,
    "votableId": 29152277,
    "userVoteValue": 0,
    "nickname": "[4G]",
    "content": "Fair enough, that works when going the other way around. Usually the top of a stack is the last element in an array tho. I missed the specification in the Input section stating \"from top to bottom\", my bad, sorry.",
    "codingamerHandle": "88bd11f6b10a34695c790826d745257d1108393",
    "avatar": 48721148862145,
    "elapsedTime": 88084000000
  }
]