[
  {
    "commentId": 309044,
    "codingamerId": 4238671,
    "commentableId": 6470148,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "votableId": 35804418,
    "userVoteValue": 0,
    "nickname": "DavidAugustoVilla",
    "content": "Cover art added.",
    "codingamerHandle": "455d71552aef838a0c75b7617e2d22d41768324",
    "avatar": 132419401284681,
    "elapsedTime": 36601049000
  },
  {
    "commentId": 10288,
    "codingamerId": 2255931,
    "commentableId": 6470148,
    "responseCount": 1,
    "upVotes": 0,
    "downVotes": 0,
    "votableId": 6624571,
    "userVoteValue": 0,
    "nickname": "MarcusAndrews",
    "content": "It's a good challenge, but probably tough for a speedy clash because there are many possible edge cases and a lot of the difficulty depends on which errors you encounter first and how you end up dealing with them. \n\nMost people will scan through x and see which letters don't match, and then store rules in a dictionary (while also placing the rules into an output list/stack for later).\n\nSometimes the rules aren't valid if we try to make one letter change into two things. This is easy enough to account for by just checking to see that dict[key] is consistent. If we set dict[\"k\"] = \"b\" but then find that we're trying to make dict[\"k\"] = \"s\" later, it's invalid. I think plenty of people will make it this far.\n\nSo we do this and print the output stack and still hit errors. Why? Because we have test cases such as\n\nTARGET\nTHRONE\n\nIn one case we're leaving T alone, but in the other we change T into E. Since we only tracked dict[\"T\"] = \"E\" we didn't consider that \"T\" might be left unchanged -- because we think of replacement as a sort of \"active\" process -- it's not immediately obvious that we might consider \"T\" -> \"T\" as a valid replacement rule.\n\nDealing with cases like this is where the problem either becomes straightforward or very hard. If we store auto-transformations, i.e. dict[\"T\"] = \"T\", then our earlier logic still works and we pass all the test cases.\n\nBut some people will not go this route, and will instead think, \"Okay, I'll just apply the transformations in my dict to x an ensure that it matches y in the end,\" which is a perfectly reasonable approach if they don't immediately see the shortcut by storing self-transformations. In this scenario, I believe many people would immediately try the first-order approach as follows:\n\n1. Iterative string-replacement:\n\nfor key in replacement_rules:\n    x = x.replace(key, replacement_rules[key])\n\nThis approach works for most cases except for ones like \"Random, all different\" due to overlapping linkages such as s->k and k->d, so we end up with s->d in the event that s->k happens to be processed before k->d. Now we have to retool the replacement as follows:\n\n2. Iterative letter replacement:\n\n        for letter in x:\n            if letter in replacement_rules:\n                new_x+=replacement_rules[letter]\n            else:\n                new_x+=letter\n\nThis is an edge case that is tricky to account for (overlapping transformations), and I imagine by this point most people have already given up anyway. \n\nIf this is to remain a clash, I would eliminate these overlaps so that people can just run string-replace.\n\nOtherwise, I'd add tougher test cases and make it a community puzzle. Right now it's sort of straddling the line between both.",
    "codingamerHandle": "3dd47c94b0e2ab07f85250177cf24cf51395522",
    "avatar": 15207076831245,
    "elapsedTime": 259961119000
  },
  {
    "commentId": 10161,
    "codingamerId": 2130169,
    "commentableId": 6470148,
    "responseCount": 2,
    "upVotes": 0,
    "downVotes": 0,
    "votableId": 6555641,
    "userVoteValue": 0,
    "nickname": "CyberLemonade",
    "content": "I did not understand the CAN'T part",
    "codingamerHandle": "d8a0152458f424d53995a613b5abea4f9610312",
    "avatar": 57032502077757,
    "elapsedTime": 260932582000
  },
  {
    "commentId": 10122,
    "codingamerId": 484004,
    "commentableId": 6470148,
    "responseCount": 5,
    "upVotes": 1,
    "downVotes": 0,
    "votableId": 6540082,
    "userVoteValue": 0,
    "nickname": "aCat",
    "content": "I like it, good idea. \nBut the number of edge cases makes it a little hard clash.",
    "codingamerHandle": "b528dd3b279d7578674a1129305918e0400484",
    "onlineSince": 1770714858158,
    "avatar": 4210501575817,
    "elapsedTime": 261166075000
  },
  {
    "commentId": 10126,
    "codingamerId": 2178794,
    "commentableId": 6470148,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 10122,
    "votableId": 6541053,
    "userVoteValue": 0,
    "nickname": "Unihedron",
    "content": "Yes, I also wondered if it will be too hard for a clash. But as a community puzzle maybe it will be too easy?",
    "codingamerHandle": "1d1729a2d8c008c6cf728ee88f1faa6d4978712",
    "avatar": 17500773502453,
    "elapsedTime": 261152552000
  },
  {
    "commentId": 10162,
    "codingamerId": 2178794,
    "commentableId": 6470148,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 10161,
    "votableId": 6555645,
    "userVoteValue": 0,
    "nickname": "Unihedron",
    "content": "There is no replacement to turn AA into BC, because you would need both A->B and A->C, which conflicts.",
    "codingamerHandle": "1d1729a2d8c008c6cf728ee88f1faa6d4978712",
    "avatar": 17500773502453,
    "elapsedTime": 260932527000
  },
  {
    "commentId": 10327,
    "codingamerId": 2178794,
    "commentableId": 6470148,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 10288,
    "votableId": 6629156,
    "userVoteValue": 0,
    "nickname": "Unihedron",
    "content": "I won't add tougher test cases, the difficulty for this puzzle is just right in my opinion. You can have your own but that doesn't change that an average programmer should be able to solve this in under 15 minutes. If I do make the decision to change this entry into a community puzzle however, it will be copied as is. As for whether I do, I'll decide on the weekends. Thanks for your feedback!",
    "codingamerHandle": "1d1729a2d8c008c6cf728ee88f1faa6d4978712",
    "avatar": 17500773502453,
    "elapsedTime": 259895764000
  },
  {
    "commentId": 10166,
    "codingamerId": 2130169,
    "commentableId": 6470148,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 10161,
    "votableId": 6556214,
    "userVoteValue": 0,
    "nickname": "CyberLemonade",
    "content": "Okay. I guess that makes this problem a lot tougher",
    "codingamerHandle": "d8a0152458f424d53995a613b5abea4f9610312",
    "avatar": 57032502077757,
    "elapsedTime": 260924129000
  },
  {
    "commentId": 10129,
    "codingamerId": 2264391,
    "commentableId": 6470148,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 10122,
    "votableId": 6541637,
    "userVoteValue": 0,
    "nickname": "hrkrx",
    "content": "I don't think this is too hard, maybe reverse mode is a little hard, but for fastest/shortest its fine i think",
    "codingamerHandle": "da8ff2b65e33daf44a48d9bcb062dbb11934622",
    "avatar": 15280318448445,
    "elapsedTime": 261129082000
  },
  {
    "commentId": 10130,
    "codingamerId": 2178794,
    "commentableId": 6470148,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 10122,
    "votableId": 6541715,
    "userVoteValue": 0,
    "nickname": "Unihedron",
    "content": "My voice is mine but the vote is yours.",
    "codingamerHandle": "1d1729a2d8c008c6cf728ee88f1faa6d4978712",
    "avatar": 17500773502453,
    "elapsedTime": 261126916000
  },
  {
    "commentId": 10132,
    "codingamerId": 484004,
    "commentableId": 6470148,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 10122,
    "votableId": 6541825,
    "userVoteValue": 0,
    "nickname": "aCat",
    "content": "I said \"a little\", It's not the hardest clash I've seen ;-).\nAs in many cases  I'm against shortest, but that's simply my prejudice.",
    "codingamerHandle": "b528dd3b279d7578674a1129305918e0400484",
    "onlineSince": 1770714858158,
    "avatar": 4210501575817,
    "elapsedTime": 261124723000
  },
  {
    "commentId": 10133,
    "codingamerId": 2178794,
    "commentableId": 6470148,
    "responseCount": 0,
    "upVotes": 0,
    "downVotes": 0,
    "parentCommentId": 10122,
    "votableId": 6541888,
    "userVoteValue": 0,
    "nickname": "Unihedron",
    "content": "162 bytes in ruby without trying. Fairly doable really.",
    "codingamerHandle": "1d1729a2d8c008c6cf728ee88f1faa6d4978712",
    "avatar": 17500773502453,
    "elapsedTime": 261123304000
  }
]