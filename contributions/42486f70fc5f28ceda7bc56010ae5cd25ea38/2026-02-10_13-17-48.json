{
  "id": 42486,
  "activeVersion": 13,
  "score": 23,
  "votableId": 27048958,
  "codingamerId": 5254038,
  "views": 239,
  "commentableId": 26922573,
  "title": "Autocorrection",
  "status": "ACCEPTED",
  "type": "CLASHOFCODE",
  "nickname": "Gleefre",
  "publicHandle": "42486f70fc5f28ceda7bc56010ae5cd25ea38",
  "codingamerHandle": "c7c2601a9ab13b2de9b06913597042618304525",
  "lastVersion": {
    "version": 13,
    "autocloseTime": 1677956675251,
    "data": {
      "title": "Autocorrection",
      "topics": [],
      "fastest": true,
      "reverse": false,
      "shortest": true,
      "solution": "def hamming_distance(word1, word2):\n    if len(word1) == len(word2):\n        return sum(a != b for (a, b) in zip(word1.upper(), word2.upper()))\n    else:\n        return 1e9\n\ndef copy_case(source, word):\n    res = ''\n    for source_char, word_char in zip(source, word):\n        if source_char.isupper():\n            res += word_char.upper()\n        else:\n            res += word_char.lower()\n    return res\n\ndictionary = [input() for _ in range(int(input()))]\n\ndef correct(word):\n    return copy_case(word, min(dictionary, key=lambda w: hamming_distance(word, w)))\n\nm = int(input())\nmessage = input().split()\nprint(*map(correct, message))",
      "statement": "Alex is very good at making typos, so he wants to develop an autocorrection engine. Help him!\n\nHe will compare words by <<Hamming distance:>> the distance between two words of same length is equal to the number of symbols at corresponding positions that are different, or simply the minimum number of errors he made during typing this word.\n\nExample:\nDistance between <<word>> and <<vort>> is 2:\n`<<v>>ort -> <<w>>ort\nwor<<t>> -> wor<<d>>`\nThen, every time he types in an unknown word he will replace it by the closest known word of the <<same>> length (it is guaranteed that there is always exactly one such word).\n\nGiven a [[dictionary]] of known words and a [[message]], correct all unknown words.\n<<Ignore the case>> while correcting words, but <<keep the original case>> in the output.",
      "testCases": [
        {
          "title": "Cat",
          "isTest": true,
          "testIn": "5\nMY\nI\nLIKE\nCAT\nBAT\n4\nI like my cad",
          "testOut": "I like my cat",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Bat",
          "isTest": false,
          "testIn": "5\nMY\nI\nLIKE\nCAT\nBAT\n4\nI like my bad",
          "testOut": "I like my bat",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "I am Grut!",
          "isTest": true,
          "testIn": "3\nI\nAM\nGRUT\n6\nA am Grud Grud at I",
          "testOut": "I am Grut Grut am I",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "I am cool :)",
          "isTest": false,
          "testIn": "3\nI\nAM\nCOOL\n6\ni tm Cool Cool am B",
          "testOut": "i am Cool Cool am I",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "One letter words",
          "isTest": true,
          "testIn": "1\nA\n10\nb c d e f B C D E F",
          "testOut": "a a a a a A A A A A",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "One letter words",
          "isTest": false,
          "testIn": "1\nB\n12\nQ W E R T Y q w e r t y",
          "testOut": "B B B B B B b b b b b b",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "Not real words?",
          "isTest": true,
          "testIn": "3\nPAPA\nMYL\nPAMY\n3\nPany myl pata",
          "testOut": "Pamy myl papa",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Not real words",
          "isTest": false,
          "testIn": "3\nMAMA\nYMYLA\nRAMY\n3\nRany ymyla mana",
          "testOut": "Ramy ymyla mama",
          "isValidator": true,
          "needValidation": true
        }
      ],
      "constraints": "2 ≤ [[N]],[[M]] ≤ 50\nEach [[word]] in a [[dictionary]] is an <<uppercase>> string with length less or equal to {{10}}.\n[[message]] is [[M]] words separated by spaces.\n\nIt is guaranteed that each unknown word can be corrected in a single way.\n\nEach word (in a [[message]] or in a [[dictionary]]) is string containing only latin letters",
      "stubGenerator": "read N:int\nloop N read word:word(10)\nread M:int\nread message:string(500)\n\nwrite Autocorekt iss brocen",
      "inputDescription": "<<Line 1:>> An integer [[N]] for the number of known words in [[dictionary]].\n<<Next [[N]] lines:>> Each line is a [[word]] in [[dictionary]].\n<<Next line:>> An integer [[M]] for the number of words in [[message]].\n<<Next line:>> Original [[message]].",
      "solutionLanguage": "Python3",
      "outputDescription": "<<Line 1:>> Autocorrected version of [[message]]."
    },
    "draft": false,
    "readyForModeration": true,
    "statementHTML": "<div class=\"statement-body\">\n<div class=\"statement-section statement-goal\">\n   <h2><span class=\"icon icon-goal\">&nbsp;</span><span>Goal </span></h2>\n   <span class=\"question-statement\">Alex is very good at making typos, so he wants to develop an autocorrection engine. Help him!<br><br>He will compare words by <strong>Hamming distance:</strong> the distance between two words of same length is equal to the number of symbols at corresponding positions that are different, or simply the minimum number of errors he made during typing this word.<br><br>Example:<br>Distance between <strong>word</strong> and <strong>vort</strong> is 2:<br><pre style=\"font-family: monospace\"><strong>v</strong>ort -&gt; <strong>w</strong>ort<br>wor<strong>t</strong> -&gt; wor<strong>d</strong></pre><br>Then, every time he types in an unknown word he will replace it by the closest known word of the <strong>same</strong> length (it is guaranteed that there is always exactly one such word).<br><br>Given a <var>dictionary</var> of known words and a <var>message</var>, correct all unknown words.<br><strong>Ignore the case</strong> while correcting words, but <strong>keep the original case</strong> in the output.</span>\n</div>\n<div class=\"statement-section statement-protocol\">\n   <div class=\"blk\">\n      <div class=\"title\">Input</div>\n      <div class=\"question-statement-input\"><strong>Line 1:</strong> An integer <var>N</var> for the number of known words in <var>dictionary</var>.<br><strong>Next <var>N</var> lines:</strong> Each line is a <var>word</var> in <var>dictionary</var>.<br><strong>Next line:</strong> An integer <var>M</var> for the number of words in <var>message</var>.<br><strong>Next line:</strong> Original <var>message</var>.</div>\n   </div>\n   <div class=\"blk\">\n      <div class=\"title\">Output</div>\n      <div class=\"question-statement-output\"><strong>Line 1:</strong> Autocorrected version of <var>message</var>.</div>\n   </div>\n   <div class=\"blk\">\n      <div class=\"title\">Constraints</div>\n      <div class=\"question-statement-constraints\">2 &le; <var>N</var>,<var>M</var> &le; 50<br>Each <var>word</var> in a <var>dictionary</var> is an <strong>uppercase</strong> string with length less or equal to <const>10</const>.<br><var>message</var> is <var>M</var> words separated by spaces.<br><br>It is guaranteed that each unknown word can be corrected in a single way.<br><br>Each word (in a <var>message</var> or in a <var>dictionary</var>) is string containing only latin letters</div>\n   </div>\n   <div class=\"blk\">\n      <div class=\"title\">Example</div>\n      <div class=\"statement-inout\">\n         <div class=\"statement-inout-in\">\n            <div class=\"title\">Input</div>\n            <pre class=\"question-statement-example-in\">5\nMY\nI\nLIKE\nCAT\nBAT\n4\nI like my cad</pre>\n         </div>\n         <div class=\"statement-inout-out\">\n            <div class=\"title\">Output</div>\n            <pre class=\"question-statement-example-out\">I like my cat</pre>\n         </div>\n      </div>\n   </div>\n</div>"
  },
  "validatedFor": 94052238790,
  "avatar": 95827724634155,
  "commentCount": 16,
  "upVotes": 25,
  "downVotes": 2,
  "validateAction": {
    "actionId": 761449,
    "progress": 1,
    "alreadyDone": false
  },
  "statusHistory": [
    {
      "status": "REFUSED",
      "date": 1675350337001,
      "data": {
        "author": "SYSTEM",
        "reason": "INACTIVITY"
      }
    },
    {
      "status": "PENDING",
      "date": 1675364675251,
      "data": {
        "author": "ACTION",
        "reason": "EDIT"
      }
    },
    {
      "status": "ACCEPTED",
      "date": 1676677227961,
      "data": {
        "author": "ACTION"
      }
    }
  ],
  "editable": true,
  "draft": false,
  "readyForModeration": true
}