{
  "id": 510,
  "activeVersion": 13,
  "score": 7,
  "votableId": 4014652,
  "codingamerId": 792813,
  "views": 356,
  "commentableId": 3959262,
  "title": "Hitori solver",
  "status": "ACCEPTED",
  "type": "PUZZLE_INOUT",
  "nickname": "VilBoub",
  "publicHandle": "510dc82c484110e033be54403182c6da16b",
  "codingamerHandle": "bd6706892e49290fb119aa5ddae4238a318297",
  "lastVersion": {
    "version": 13,
    "data": {
      "title": "Hitori solver",
      "topics": [
        {
          "id": 45,
          "handle": "conditions",
          "category": "FUNDAMENTALS",
          "labelMap": {
            "1": "Conditions",
            "2": "Conditions"
          },
          "pageTitle": "Conditions: exercises and theory",
          "puzzleCount": 56,
          "parentTopicId": 39,
          "contentDetailsId": 68
        },
        {
          "id": 46,
          "handle": "loops",
          "category": "FUNDAMENTALS",
          "labelMap": {
            "1": "Boucles",
            "2": "Loops"
          },
          "pageTitle": "Loops: exercises and theory",
          "puzzleCount": 76,
          "parentTopicId": 39,
          "contentDetailsId": 71
        },
        {
          "id": 153,
          "handle": "2d-array",
          "category": "FUNDAMENTALS",
          "labelMap": {
            "1": "2D array",
            "2": "2D array"
          },
          "puzzleCount": 34,
          "parentTopicId": 93
        }
      ],
      "solution": "import sys\nimport math\nimport numpy as np\n\ndef verif(grille) :\n    ok = True\n    # Vérification des lignes\n    for i in range(n) :\n        ligne = [grille[i, j] for j in range(n)]\n        for j, c in enumerate(ligne) :\n            # Doublons ?\n            if (c != 0) and (ligne.count(c) != 1) :\n                new_grille = np.copy(grille)\n                new_grille[i, j] = 0\n                ok_test, grille_test = verif(new_grille)\n                if ok_test :\n                    ok = True\n                    grille = grille_test\n                    break\n                elif j !=  ligne.index(c) :\n                    ok = False\n                    break\n            # Zéros collés ?\n            if (i != 0) and (c == grille[i-1, j] == 0) :\n                return False, grille\n        if not(ok) :\n            break\n    if ok :\n        # Vérification des les colonnes\n        for j in range(n) :\n            colonne = [grille[i, j] for i in range(n)]\n\n            for i, c in enumerate(colonne) :\n                # Doublons ?\n                if c != 0 and colonne.count(c) != 1 :\n                    new_grille = np.copy(grille)\n                    new_grille[i, j] = 0\n                    ok_test, grille_test = verif(new_grille)\n                    if ok_test :\n                        ok = True\n                        grille = grille_test\n                        break\n                    elif i != colonne.index(c) :\n                        ok = False\n                        break\n                # Zéros collés ?\n                if (j != 0) and (c == grille[i, j-1] == 0) :\n                    return False, grille\n            if not(ok) :\n                break\n    if ok :\n        # Vérification d'un seul morceau\n        i = 0\n        j = 0\n        if grille[0, 0] == 0 :\n            j = 1\n        new_grille = colorier(grille, i, j)\n        if np.amax(new_grille) != 0 :\n            ok = False\n    return ok, grille\n\ndef colorier(grille, i, j) :\n    if grille[i, j] == 0 :\n        return grille\n    else :\n        new_grille = np.copy(grille)\n        new_grille[i, j] = 0\n        for d in range(4) :\n            i_ = i + di[d]\n            j_ = j + dj[d]\n            if (0 <= i_ < n) and (0 <= j_ < n) and (new_grille[i_, j_] != 0) :\n                new_grille = colorier(new_grille, i_, j_)\n        return new_grille\n\nn = int(input())\ngrille = np.zeros((n, n), int)\nfor i in range(n):\n    line = input()\n    for j, c in enumerate(line) :\n        grille[i, j] = int(c)\n\ndi = [-1, 1, 0, 0]\ndj = [0, 0, 1, -1]\n\ntrouve, new_grille = verif(grille)\nfor i in range(n):\n    for j, c in enumerate(line) :\n        if new_grille[i,j] == 0 :\n            c = \"*\"\n        else :\n            c = str(new_grille[i,j])\n        print(c, end = '')\n    print()\n",
      "statement": "Each puzzle consists of a square grid with numbers appearing in all squares. The object is to shade squares so:\n\n- No number appears in a row or column more than once.\n- Shaded squares do not touch each other vertically or horizontally.\n- When completed, all un-shaded squares create a single continuous area.\n(use {{*}} for shaded squares)",
      "testCases": [
        {
          "title": "Simple 3x3",
          "isTest": true,
          "testIn": "3\n111\n234\n224",
          "testOut": "*1*\n234\n*2*",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Validator 1",
          "isTest": false,
          "testIn": "3\n223\n143\n113",
          "testOut": "*2*\n143\n*1*",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "Connected 2x2",
          "isTest": true,
          "testIn": "2\n11\n12",
          "testOut": "*1\n12",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Validator 2",
          "isTest": false,
          "testIn": "2\n12\n22",
          "testOut": "12\n2*",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "Bigger",
          "isTest": true,
          "testIn": "4\n1131\n2314\n1122\n3422",
          "testOut": "1*3*\n2314\n*1*2\n342*",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Validator 3",
          "isTest": false,
          "testIn": "5\n42153\n14322\n35422\n15255\n11534",
          "testOut": "42153\n*43*2\n3542*\n1*2*5\n*1534",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "Even bigger",
          "isTest": true,
          "testIn": "5\n22153\n23145\n11135\n13542\n54321",
          "testOut": "*2*53\n2314*\n*1*35\n1*5*2\n54321",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Validator 4",
          "isTest": false,
          "testIn": "6\n125461\n263211\n144145\n516243\n233622\n154322",
          "testOut": "*25461\n263*1*\n*4*1*5\n516243\n*3*6*2\n15432*",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "8x8",
          "isTest": true,
          "testIn": "8\n85611423\n86188337\n13745662\n58776251\n51853753\n37882714\n73361185\n74271572",
          "testOut": "8561*423\n*61*83*7\n13745*62\n58*762*1\n*18*375*\n37*82*14\n7*36*185\n*42*157*",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Validator 5",
          "isTest": false,
          "testIn": "8\n41683765\n22675546\n86417853\n33822677\n68322478\n67185224\n12564135\n14856682",
          "testOut": "41*83765\n2*67*54*\n86417*53\n3*8*26*7\n*832*47*\n671*5*24\n*256413*\n14*56*82",
          "isValidator": true,
          "needValidation": true
        }
      ],
      "difficulty": "hard",
      "constraints": "2 ≤ [[n]] ≤ 8",
      "coverBinaryId": 86354967608894,
      "stubGenerator": "read n:int\n\nloop n read line:string(n)\n\nloop n write *",
      "inputDescription": "Line 1 : The size of the square, [[n]]  .\n[[n]] following lines : Content of the grid made of [[n]] numbers.",
      "solutionLanguage": "Python3",
      "outputDescription": "[[n]] following lines : Content of the solved grid made of [[n]] numbers and {{*}} for shaded squares."
    },
    "draft": false,
    "readyForModeration": true,
    "statementHTML": "<div class=\"statement-body\">\n<div class=\"statement-section statement-goal\">\n   <h2><span class=\"icon icon-goal\">&nbsp;</span><span>Goal </span></h2>\n   <span class=\"question-statement\">Each puzzle consists of a square grid with numbers appearing in all squares. The object is to shade squares so:<br><br>- No number appears in a row or column more than once.<br>- Shaded squares do not touch each other vertically or horizontally.<br>- When completed, all un-shaded squares create a single continuous area.<br>(use <const>*</const> for shaded squares)</span>\n</div>\n<div class=\"statement-section statement-protocol\">\n   <div class=\"blk\">\n      <div class=\"title\">Input</div>\n      <div class=\"question-statement-input\">Line 1 : The size of the square, <var>n</var>  .<br><var>n</var> following lines : Content of the grid made of <var>n</var> numbers.</div>\n   </div>\n   <div class=\"blk\">\n      <div class=\"title\">Output</div>\n      <div class=\"question-statement-output\"><var>n</var> following lines : Content of the solved grid made of <var>n</var> numbers and <const>*</const> for shaded squares.</div>\n   </div>\n   <div class=\"blk\">\n      <div class=\"title\">Constraints</div>\n      <div class=\"question-statement-constraints\">2 &le; <var>n</var> &le; 8</div>\n   </div>\n   <div class=\"blk\">\n      <div class=\"title\">Example</div>\n      <div class=\"statement-inout\">\n         <div class=\"statement-inout-in\">\n            <div class=\"title\">Input</div>\n            <pre class=\"question-statement-example-in\">3\n111\n234\n224</pre>\n         </div>\n         <div class=\"statement-inout-out\">\n            <div class=\"title\">Output</div>\n            <pre class=\"question-statement-example-out\">*1*\n234\n*2*</pre>\n         </div>\n      </div>\n   </div>\n</div>"
  },
  "validatedFor": 271291821707,
  "avatar": 72010225615995,
  "commentCount": 8,
  "upVotes": 7,
  "downVotes": 0,
  "validateAction": {
    "actionId": 135662,
    "progress": 1,
    "alreadyDone": false
  },
  "statusHistory": [],
  "editable": true,
  "draft": false,
  "readyForModeration": true
}