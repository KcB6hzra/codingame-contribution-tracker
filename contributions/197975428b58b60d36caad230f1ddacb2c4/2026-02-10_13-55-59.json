{
  "id": 197,
  "activeVersion": 11,
  "score": 3,
  "votableId": 588,
  "codingamerId": 878974,
  "views": 141,
  "commentableId": 191,
  "title": "Othello",
  "status": "ACCEPTED",
  "type": "PUZZLE_INOUT",
  "nickname": "nicola",
  "publicHandle": "197975428b58b60d36caad230f1ddacb2c4",
  "codingamerHandle": "21bf42f790de293c3aef398f18cd2627479878",
  "lastVersion": {
    "version": 11,
    "data": {
      "title": "Othello",
      "topics": [
        {
          "id": 45,
          "handle": "conditions",
          "labelMap": {
            "1": "Conditions",
            "2": "Conditions"
          },
          "pageTitle": "Conditions: exercises and theory",
          "puzzleCount": 17,
          "parentTopicId": 39,
          "contentDetailsId": 68
        },
        {
          "id": 73,
          "handle": "strings",
          "labelMap": {
            "1": "Chaînes de caractères",
            "2": "Strings"
          },
          "pageTitle": "Strings: exercises and theory",
          "puzzleCount": 8,
          "parentTopicId": 41,
          "contentDetailsId": 73
        },
        {
          "labelMap": {
            "2": "Classic board games"
          }
        }
      ],
      "solution": "import sys\n#import math\n\n# Auto-generated code below aims at helping you parse\n# the standard input according to the problem statement.\n\noppose={\"B\":\"W\",\"W\":\"B\"}\n\njeu=[]\nfor _ in range(8):\n    jeu.append(list(input()))\n\ncoul,pos=input().split()\n\npos=list(pos)[::-1]\npos[0]=int(pos[0])-1\npos[1]=ord(pos[1])-97\n\nif jeu[pos[0]][pos[1]]!=\"-\":\n    print(\"NOPE\")\nelse:\n    sand=False\n    jeu[pos[0]][pos[1]]=coul\n\n    if pos[1]<=5 and jeu[pos[0]][pos[1]+1]==oppose[coul]:\n        i=1\n        while True:\n            if pos[1]+i==8 or jeu[pos[0]][pos[1]+i] in {\"-\",coul}:\n                break\n            i+=1\n        if i<=7 and jeu[pos[0]][pos[1]+i]==coul:\n            sand=True\n            for j in range(1,i):\n                jeu[pos[0]][pos[1]+j]=coul\n\n    if pos[1]>=2 and jeu[pos[0]][pos[1]-1]==oppose[coul]:\n        i=1\n        while True:\n            if pos[1]-i==-1 or jeu[pos[0]][pos[1]-i] in {\"-\",coul}:\n                break\n            i+=1\n        if i>=0 and jeu[pos[0]][pos[1]-i]==coul:\n            sand=True\n            for j in range(1,i):\n                jeu[pos[0]][pos[1]-j]=coul\n\n    if pos[0]<=5 and jeu[pos[0]+1][pos[1]]==oppose[coul]:\n        i=1\n        while True:\n            if pos[0]+i==8 or jeu[pos[0]+i][pos[1]] in {\"-\",coul}:\n                break\n            i+=1\n        if i<=7 and jeu[pos[0]+i][pos[1]]==coul:\n            sand=True\n            for j in range(1,i):\n                jeu[pos[0]+j][pos[1]]=coul\n\n    if pos[1]>=2 and jeu[pos[0]-1][pos[1]]==oppose[coul]:\n        i=1\n        while True:\n            if pos[0]-i==-1 or jeu[pos[0]-i][pos[1]] in {\"-\",coul}:\n                break\n            i+=1\n        if i>=0 and jeu[pos[0]-i][pos[1]]==coul:\n            sand=True\n            for j in range(1,i):\n                jeu[pos[0]-j][pos[1]]=coul\n\n    if pos[1]<=5 and pos[0]<=5 and jeu[pos[0]+1][pos[1]+1]==oppose[coul]:\n        i=1\n        while True:\n            if pos[1]+i==8 or pos[0]+i==8 or jeu[pos[0]+i][pos[1]+i] in {\"-\",coul}:\n                break\n            i+=1\n        if i<=7 and jeu[pos[0]+i][pos[1]+i]==coul:\n            sand=True\n            for j in range(1,i):\n                jeu[pos[0]+j][pos[1]+j]=coul\n\n    if pos[1]>=2 and pos[0]>=2 and jeu[pos[0]-1][pos[1]-1]==oppose[coul]:\n        i=1\n        while True:\n            if pos[1]-i==-1 or pos[0]-i==-1 or jeu[pos[0]-i][pos[1]-i] in {\"-\",coul}:\n                break\n            i+=1\n        if i>=0 and jeu[pos[0]-i][pos[1]-i]==coul:\n            sand=True\n            for j in range(1,i):\n                jeu[pos[0]-j][pos[1]-j]=coul\n\n    if pos[0]<=5 and pos[1]>=2 and jeu[pos[0]+1][pos[1]-1]==oppose[coul]:\n        i=1\n        while True:\n            if pos[0]+i==8 or pos[1]-i==-1 or jeu[pos[0]+i][pos[1]-i] in {\"-\",coul}:\n                break\n            i+=1\n        if i<=7 and jeu[pos[0]+i][pos[1]-i]==coul:\n            sand=True\n            for j in range(1,i):\n                jeu[pos[0]+j][pos[1]-j]=coul\n\n    if pos[1]<=5 and pos[0]>=2 and jeu[pos[0]-1][pos[1]+1]==oppose[coul]:\n        i=1\n        while True:\n            if pos[0]-i==-1 or pos[1]+i==8 or jeu[pos[0]-i][pos[1]+i] in {\"-\",coul}:\n                break\n            i+=1\n        if i>=0 and jeu[pos[0]-i][pos[1]+i]==coul:\n            sand=True\n            for j in range(1,i):\n                jeu[pos[0]-j][pos[1]+j]=coul\n\n    if sand:\n        print(\"%d %d\"%(sum(l.count(\"W\") for l in jeu),sum(l.count(\"B\") for l in jeu)))\n    else:\n        print(\"NULL\")",
      "statement": "You are given an Othello board and the colour and position of the next turn. You must answer if it’s legal or not.\nOthello is a two-player game. Player #1 begins and plays black ({{B}}), and player #2 plays white ({{W}}).\n{{B}} player can only put his token near a {{W}} token in order to make at least one {{BW+B}} \"sandwich\". A sandwich is defined as any number of tokens of one color consecutively in a line (either horizontally, vertically, or diagonally) which are surrounded on both sides by tokens of the opposite color. Once a sandwich is achieved, all the {{W}} tokens in this sandwich are turned into {{B}}. Repeat this as necessary for each valid sandwich in the eight directions (including diagonals).\nExamples (the played token in lower-case):\n* {{--bWWWBW}} yields {{---bBBBBW}}.\n* {{BBWWWwBW}} yieds {{BBWWWwWW}}.\n* {{-WWWw---}} is illegal if there is no sandwich elsewhere.\n* {{WWWbBW--}} is illegal too.\nEach player must play if possible. If not, he passes his turn.",
      "testCases": [
        {
          "title": "Start",
          "isTest": true,
          "testIn": "--------\n--------\n--------\n---WB---\n---BW---\n--------\n--------\n--------\nB c4",
          "testOut": "1 4",
          "isValidator": false,
          "needValidation": false
        },
        {
          "title": "Start",
          "isTest": false,
          "testIn": "--------\n--------\n--------\n--BBB---\n---BW---\n--------\n--------\n--------\nW c3",
          "testOut": "3 3",
          "isValidator": true,
          "needValidation": false
        },
        {
          "title": "Nope",
          "isTest": true,
          "testIn": "--------\n--------\n--------\n---WB---\n---BW---\n--------\n--------\n--------\nB d4",
          "testOut": "NOPE",
          "isValidator": false,
          "needValidation": false
        },
        {
          "title": "Nope",
          "isTest": false,
          "testIn": "--------\n--------\n--------\n--BBB---\n---BW---\n--------\n--------\n--------\nW e5",
          "testOut": "NOPE",
          "isValidator": true,
          "needValidation": false
        },
        {
          "title": "Null",
          "isTest": true,
          "testIn": "--------\n--------\n--------\n---WB---\n---BW---\n--------\n--------\n--------\nB a1",
          "testOut": "NULL",
          "isValidator": false,
          "needValidation": false
        },
        {
          "title": "Null",
          "isTest": false,
          "testIn": "--------\n--------\n--------\n--BBB---\n---BW---\n--------\n--------\n--------\nW f7",
          "testOut": "NULL",
          "isValidator": true,
          "needValidation": false
        },
        {
          "title": "Real game",
          "isTest": true,
          "testIn": "--BB----\n---BWB--\n-WBBWWWB\nBBWWWBWW\nBWWWBBBW\nBW-WW-WB\n---WB---\n----B---\nB c6",
          "testOut": "14 24",
          "isValidator": false,
          "needValidation": false
        },
        {
          "title": "Real game",
          "isTest": false,
          "testIn": "--BB----\n---BWB--\n-WBBWWWB\nBBBWWBWW\nBBBWBBBW\nBBBWW-WB\n---BB---\n----B---\nW f6",
          "testOut": "19 20",
          "isValidator": true,
          "needValidation": false
        }
      ],
      "difficulty": "medium",
      "coverBinaryId": 42875225402001,
      "stubGenerator": "loop 8 read row:string(8)\nread colour:word(1) move:word(2)\nwrite answer",
      "inputDescription": "<<First {{8}} lines:>> {{8}} characters per line, each representing a [[row]] of the board. {{W}} is a white token, {{B}} is a black token, {{-}} is an empty cell.\n<<Line 9:>> The [[colour]] of the token, followed by a space, and then the chess-like coordinates of the next [[move]]. For example, {{a1}} is the top-left corner while {{a8}} is the bottom-left corner.",
      "solutionLanguage": "Python3",
      "outputDescription": "If the move is legal, print the number of {{W}} tokens and of {{B}} tokens.\nIf the cell is already filled by a token, print {{NOPE}}.\nIf the token can’t make a sandwich, print {{NULL}}."
    },
    "draft": false,
    "readyForModeration": true,
    "statementHTML": "<div class=\"statement-body\">\n<div class=\"statement-section statement-goal\">\n   <h2><span class=\"icon icon-goal\">&nbsp;</span><span>Goal </span></h2>\n   <span class=\"question-statement\">You are given an Othello board and the colour and position of the next turn. You must answer if it&rsquo;s legal or not.<br>Othello is a two-player game. Player #1 begins and plays black (<const>B</const>), and player #2 plays white (<const>W</const>).<br><const>B</const> player can only put his token near a <const>W</const> token in order to make at least one <const>BW+B</const> &quot;sandwich&quot;. A sandwich is defined as any number of tokens of one color consecutively in a line (either horizontally, vertically, or diagonally) which are surrounded on both sides by tokens of the opposite color. Once a sandwich is achieved, all the <const>W</const> tokens in this sandwich are turned into <const>B</const>. Repeat this as necessary for each valid sandwich in the eight directions (including diagonals).<br>Examples (the played token in lower-case):<br>* <const>--bWWWBW</const> yields <const>---bBBBBW</const>.<br>* <const>BBWWWwBW</const> yieds <const>BBWWWwWW</const>.<br>* <const>-WWWw---</const> is illegal if there is no sandwich elsewhere.<br>* <const>WWWbBW--</const> is illegal too.<br>Each player must play if possible. If not, he passes his turn.</span>\n</div>\n<div class=\"statement-section statement-protocol\">\n   <div class=\"blk\">\n      <div class=\"title\">Input</div>\n      <div class=\"question-statement-input\"><strong>First <const>8</const> lines:</strong> <const>8</const> characters per line, each representing a <var>row</var> of the board. <const>W</const> is a white token, <const>B</const> is a black token, <const>-</const> is an empty cell.<br><strong>Line 9:</strong> The <var>colour</var> of the token, followed by a space, and then the chess-like coordinates of the next <var>move</var>. For example, <const>a1</const> is the top-left corner while <const>a8</const> is the bottom-left corner.</div>\n   </div>\n   <div class=\"blk\">\n      <div class=\"title\">Output</div>\n      <div class=\"question-statement-output\">If the move is legal, print the number of <const>W</const> tokens and of <const>B</const> tokens.<br>If the cell is already filled by a token, print <const>NOPE</const>.<br>If the token can&rsquo;t make a sandwich, print <const>NULL</const>.</div>\n   </div>\n   <div class=\"blk\">\n      <div class=\"title\">Constraints</div>\n      <div class=\"question-statement-constraints\"></div>\n   </div>\n   <div class=\"blk\">\n      <div class=\"title\">Example</div>\n      <div class=\"statement-inout\">\n         <div class=\"statement-inout-in\">\n            <div class=\"title\">Input</div>\n            <pre class=\"question-statement-example-in\">--------\n--------\n--------\n---WB---\n---BW---\n--------\n--------\n--------\nB c4</pre>\n         </div>\n         <div class=\"statement-inout-out\">\n            <div class=\"title\">Output</div>\n            <pre class=\"question-statement-example-out\">1 4</pre>\n         </div>\n      </div>\n   </div>\n</div>"
  },
  "validatedFor": 311917729031,
  "avatar": 26090852120005,
  "commentCount": 6,
  "upVotes": 3,
  "downVotes": 0,
  "validateAction": {
    "actionId": 193,
    "progress": 1,
    "alreadyDone": false
  },
  "statusHistory": [],
  "editable": true,
  "draft": false,
  "readyForModeration": true
}