{
  "id": 8156,
  "activeVersion": 51,
  "score": 14,
  "votableId": 22065647,
  "codingamerId": 2923506,
  "views": 570,
  "commentableId": 21955488,
  "title": "Minesweeper level generator",
  "status": "ACCEPTED",
  "type": "PUZZLE_INOUT",
  "nickname": "darkhorse64",
  "publicHandle": "81566a21c186431861ee5bef495cf59b3a5c",
  "codingamerHandle": "c9ebe76a83b33730956eda0534d6cad86053292",
  "lastVersion": {
    "version": 51,
    "autocloseTime": 1650268931961,
    "data": {
      "title": "Minesweeper level generator",
      "topics": [
        {
          "id": 46,
          "handle": "loops",
          "category": "FUNDAMENTALS",
          "labelMap": {
            "1": "Boucles",
            "2": "Loops"
          },
          "pageTitle": "Loops: exercises and theory",
          "puzzleCount": 64,
          "parentTopicId": 39,
          "contentDetailsId": 71
        },
        {
          "id": 153,
          "handle": "2d-array",
          "category": "FUNDAMENTALS",
          "labelMap": {
            "1": "2D array",
            "2": "2D array"
          },
          "puzzleCount": 27,
          "parentTopicId": 93
        },
        {
          "id": 210,
          "handle": "coordinates",
          "category": "INTERMEDIATE",
          "labelMap": {
            "1": "Coordinates",
            "2": "Coordinates"
          },
          "puzzleCount": 4,
          "parentTopicId": 93
        }
      ],
      "solution": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nclass LCG\n{\npublic:\n    LCG (unsigned int seed):seed(seed) {}\n    unsigned int rand ()\n    {\n        return seed = (214013 * seed + 2531011) >> 16;\n    }\nprivate:\n    unsigned int seed;\n};\n\nclass Generator\n{\npublic:\n\tfriend std::istream& operator>> (std::istream& stream, Generator& generator);\n    void generate();\n\tfriend std::ostream& operator<< (std::ostream& stream, const Generator& generator);\nprivate:\n    bool isValidCell(int x, int y) { return x >= 0 && x < width && y >= 0 && y < height; }\n\n    int width;\n    int height;\n    int mines;\n    int seed;\n    int x,y;\n\n    struct Cell\n    {\n        int value = 0;\n        bool mine = false;\n        bool forbidden = false;\n        vector<Cell*> neighbours;\n        friend std::ostream& operator<< (std::ostream& stream, const Cell& cell)\n        {\n            if (cell.mine)\n                stream << '#';\n            else\n            {\n                if (cell.value)\n                    stream << cell.value;\n                else\n                    stream << '.';\n            }\n            return stream;\n        }\n    };\n    vector<vector<Cell>> cells;\n};\n\nstd::istream& operator>> (std::istream& stream, Generator& generator)\n{\n    stream >> generator.width >> generator.height >> generator.mines \n        >> generator.x >> generator.y >> generator.seed; \n    stream.ignore();\n    return stream;\n}\n\nvoid Generator::generate()\n{\n    // Build the grid\n    for (int i = 0; i < height; i++) \n        cells.push_back(vector<Cell>(width, Cell()));\n    // Build neighbours\n    for (int i = 0; i < height; i++) \n    {\n        for (int j = 0; j < width; j++) \n        {\n            auto& cell = cells[i][j];\n            if (isValidCell(j-1, i-1)) cell.neighbours.push_back(&cells[i-1][j-1]);\n            if (isValidCell(j  , i-1)) cell.neighbours.push_back(&cells[i-1][j  ]);\n            if (isValidCell(j+1, i-1)) cell.neighbours.push_back(&cells[i-1][j+1]);\n            if (isValidCell(j-1, i  )) cell.neighbours.push_back(&cells[i  ][j-1]);\n            if (isValidCell(j+1, i  )) cell.neighbours.push_back(&cells[i  ][j+1]);\n            if (isValidCell(j-1, i+1)) cell.neighbours.push_back(&cells[i+1][j-1]);\n            if (isValidCell(j  , i+1)) cell.neighbours.push_back(&cells[i+1][j  ]);\n            if (isValidCell(j+1, i+1)) cell.neighbours.push_back(&cells[i+1][j+1]);\n        }\n    }\n    // Compute safe start\n    for (int i = y-1; i <= y+1; i++) \n        for (int j = x-1; j <= x+1; j++) \n            if (isValidCell(j, i)) cells[i][j].forbidden = true;\n    // Generate mines\n    LCG lcg(seed);\n\n    for (int i = 0; i < mines; i++)\n    {\n        while (true)\n        {\n            int x = lcg.rand() % width, y = lcg.rand() % height;\n            auto& cell = cells[y][x];\n            if (!cell.mine && !cell.forbidden)\n            {\n                cell.mine = true;\n                break;\n            }\n        }\n    }\n    // Compute values\n    for (int i = 0; i < height; i++) \n    {\n        for (int j = 0; j < width; j++) \n        {\n            auto& cell = cells[i][j];\n            if (cell.mine) continue;\n            for (auto neighbour:cell.neighbours)\n                if (neighbour->mine) cell.value++;\n        }\n    }\n}\n\nstd::ostream& operator<< (std::ostream& stream, const Generator& generator)\n{\n    for (int i = 0; i < generator.height; i++) \n    {\n        for (int j = 0; j < generator.width; j++)\n            stream << generator.cells[i][j];\n        stream << endl;\n    }\n    return stream;\n}\n\nint main()\n{\n    Generator generator;\n    cin >> generator;\n    generator.generate();\n    cout << generator;\n}",
      "statement": "You like to solve Minesweeper levels ? You will love generating them !\n\n<<How to generate a level>>\n\n* A level is a [[width]] x [[ height]] cells grid. Its origin is the top left corner. It contains [[n]] mines.\n* The level is generated only when the player selects the first cell. The 3x3 cells square centered on this cell is always set free of mines.\n* To generate a mine, X and Y grid coordinates (X first and then Y) are randomly generated until an available position is found. To generate X (resp. Y), use the random value modulo [[width]] (resp. [[height]]).\n\n<<Controlling randomness>>\n\nThe random number generator used to generate the level is a pseudo random number generator (PRNG) initialized with a [[seed]] provided in the inputs. The PRNG works as follows:\n\nThe nth generated value is:\nR(n) = (214013 * R(n-1) + 2531011) / 65536\nwith R(0) = [[seed]]\nR(1) is the first value to use.\n\nWith a seed of 31, the expected five first values produced by the PRNG are 139, 492, 1645, 5410, 17705.\n\nYou must use a single instance of PRNG for the whole generation. All calculations must be in 32-bit unsigned numbers. Beware that some languages (Python for instance) implicitly generate big integers without overflowing.",
      "testCases": [
        {
          "title": "Simple level",
          "isTest": true,
          "testIn": "6 6 7 3 3 31",
          "testOut": "1#2##1\n222221\n#1..11\n331.1#\n##1.11\n221...",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Simple level",
          "isTest": false,
          "testIn": "6 6 6 2 2 13",
          "testOut": "1#1...\n111111\n...1#1\n111111\n2#3111\n2##11#",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "Corner selection",
          "isTest": true,
          "testIn": "6 6 6 0 0 3",
          "testOut": "...111\n...1#1\n11.122\n#1112#\n122#32\n.1#3#1",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Corner selection",
          "isTest": false,
          "testIn": "6 6 6 5 0 3",
          "testOut": "11....\n#1....\n22..11\n#1112#\n122#32\n.1#3#1",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "Edge selection",
          "isTest": true,
          "testIn": "6 6 6 2 0 31",
          "testOut": "...1#1\n.11211\n.1#111\n13432#\n1###21\n12321.",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Edge selection",
          "isTest": false,
          "testIn": "6 6 6 0 2 7",
          "testOut": "..1#1.\n.1332.\n.1##21\n.124#2\n11.2#2\n#1.111",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "Beginner level",
          "isTest": true,
          "testIn": "9 9 10 4 4 1",
          "testOut": "11..11211\n#1..1#2#1\n11..11211\n111....11\n1#1....1#\n111..1121\n.111.1#21\n.1#21223#\n.12#11#21",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Beginner level",
          "isTest": false,
          "testIn": "9 9 10 5 5 2",
          "testOut": ".......11\n..111.12#\n111#1.1#2\n#3221.111\n#4#1.....\n#311.....\n22.....11\n#1.....2#\n11.....2#",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "Intermediate level",
          "isTest": true,
          "testIn": "16 16 40 8 8 17",
          "testOut": ".1#1.1#1....1#1.\n.1111221..11211.\n....1#11222#2221\n....1112##213##1\n......13#31.2#31\n1221..1#21..111.\n2##1..111111111.\n3#41.....1#12#2.\n2#311....1123#31\n223#31.....2#5#1\n#23##2111..2##32\n12#5#33#311134#1\n.12#22##3#211#21\n.122112222#2332.\n.1#1.....112##1.\n.111.......1221.",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Intermediate level",
          "isTest": false,
          "testIn": "16 16 40 8 8 23",
          "testOut": "111.2#311#1.....\n2#2.2##1111...11\n3#3.1221.111..1#\n2#2111...1#1..11\n1111#1...222....\n...1111111#1....\n1111111#1111.122\n1#11#1111.1223##\n111111....1##3#3\n.....1221.122211\n.....1##1..11222\n.....1222111#2##\n122223211#222332\n1##3###333#11#1.\n124#444##223432.\n..2#21#3211###1.",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "Expert level",
          "isTest": true,
          "testIn": "30 16 99 15 8 17",
          "testOut": "112#1....1#2#22##1..112#1.....\n1#322....11223#321.13#311.....\n222#211....13#3211.2##21221122\n#3213#311..1##43#213#311##11##\n##213#4#2..123##22#211.1221133\n233#213#311..2331222..111.112#\n.1#222322#1..1#1.1#21.1#212#43\n.1222##233422221.23#1.112#34##\n..2#544#2###2#1.13#3211.224###\n..2###322343211.1##22#311#3#64\n.12455#213#2....12223##32233##\n.1#2##22#4#2...12333#4##22#34#\n133322112#21...1####3335#32#21\n1##1..12321....1234#32#3#33231\n1221..1##21.......12#2122#3#3#\n......123#1........111..113#31",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Expert level",
          "isTest": false,
          "testIn": "30 16 99 15 8 23",
          "testOut": "##211#11###1...1#22211###11#32\n45#1111123321.1233##334#4222##\n##21.112233#1.2#3#33##212#1122\n332..1#2###3212#3111221.111...\n1#1..1122322#12231222211...111\n22211...1111122#3#3##2#1...2#2\n#22#21112#1..1#23#3223343212#2\n23#5#21#32222211111112####1111\n#22##422#11##21....1#23#421...\n2214##1222123#1...1332111..111\n#423#433#1112221..1##1111..1#1\n###223##421#11#1..12322#1..122\n24321#5##223221211112#2121212#\n.1#1114#42#2#212#11#22211#2#32\n1332..3#311212#3211233#111212#\n1##1..2#2....12#1..1##21....11",
          "isValidator": true,
          "needValidation": true
        }
      ],
      "difficulty": "easy",
      "constraints": "5 ≤ [[width]] ≤ 30\n5 ≤ [[height]] ≤ 16\n5 ≤ [[n]] ≤ 99",
      "coverBinaryId": 78874980617016,
      "stubGenerator": "read width:int height:int mines:int x:int y:int seed:int\nloop height \n    write row",
      "inputDescription": "<<A single line:>> [[width]] the level width, [[height]] the level height, [[n]] the number of mines for the level,  [[x]], [[y]] the coordinates of the first selected cell, [[seed]] the seed for the random number generator",
      "solutionLanguage": "C++",
      "outputDescription": "[[height]] <<lines: >> for each line, a row of cells starting from the top row. Each cell is represented by a single ASCII code without space between chars.\n\n<<Cell format>>\n\n* {{#}} for a cell containing a mine\n* {{.}} for a cell without any mines next to it\n* otherwise {{1-8}} for the number of neighboring cells containing mines"
    },
    "draft": false,
    "readyForModeration": true,
    "statementHTML": "<div class=\"statement-body\">\n<div class=\"statement-section statement-goal\">\n   <h2><span class=\"icon icon-goal\">&nbsp;</span><span>Goal </span></h2>\n   <span class=\"question-statement\">You like to solve Minesweeper levels ? You will love generating them !<br><br><strong>How to generate a level</strong><br><br>* A level is a <var>width</var> x <var> height</var> cells grid. Its origin is the top left corner. It contains <var>n</var> mines.<br>* The level is generated only when the player selects the first cell. The 3x3 cells square centered on this cell is always set free of mines.<br>* To generate a mine, X and Y grid coordinates (X first and then Y) are randomly generated until an available position is found. To generate X (resp. Y), use the random value modulo <var>width</var> (resp. <var>height</var>).<br><br><strong>Controlling randomness</strong><br><br>The random number generator used to generate the level is a pseudo random number generator (PRNG) initialized with a <var>seed</var> provided in the inputs. The PRNG works as follows:<br><br>The nth generated value is:<br>R(n) = (214013 * R(n-1) + 2531011) / 65536<br>with R(0) = <var>seed</var><br>R(1) is the first value to use.<br><br>With a seed of 31, the expected five first values produced by the PRNG are 139, 492, 1645, 5410, 17705.<br><br>You must use a single instance of PRNG for the whole generation. All calculations must be in 32-bit unsigned numbers. Beware that some languages (Python for instance) implicitly generate big integers without overflowing.</span>\n</div>\n<div class=\"statement-section statement-protocol\">\n   <div class=\"blk\">\n      <div class=\"title\">Input</div>\n      <div class=\"question-statement-input\"><strong>A single line:</strong> <var>width</var> the level width, <var>height</var> the level height, <var>n</var> the number of mines for the level,  <var>x</var>, <var>y</var> the coordinates of the first selected cell, <var>seed</var> the seed for the random number generator</div>\n   </div>\n   <div class=\"blk\">\n      <div class=\"title\">Output</div>\n      <div class=\"question-statement-output\"><var>height</var> <strong>lines: </strong> for each line, a row of cells starting from the top row. Each cell is represented by a single ASCII code without space between chars.<br><br><strong>Cell format</strong><br><br>* <const>#</const> for a cell containing a mine<br>* <const>.</const> for a cell without any mines next to it<br>* otherwise <const>1-8</const> for the number of neighboring cells containing mines</div>\n   </div>\n   <div class=\"blk\">\n      <div class=\"title\">Constraints</div>\n      <div class=\"question-statement-constraints\">5 &le; <var>width</var> &le; 30<br>5 &le; <var>height</var> &le; 16<br>5 &le; <var>n</var> &le; 99</div>\n   </div>\n   <div class=\"blk\">\n      <div class=\"title\">Example</div>\n      <div class=\"statement-inout\">\n         <div class=\"statement-inout-in\">\n            <div class=\"title\">Input</div>\n            <pre class=\"question-statement-example-in\">6 6 7 3 3 31</pre>\n         </div>\n         <div class=\"statement-inout-out\">\n            <div class=\"title\">Output</div>\n            <pre class=\"question-statement-example-out\">1#2##1\n222221\n#1..11\n331.1#\n##1.11\n221...</pre>\n         </div>\n      </div>\n   </div>\n</div>"
  },
  "validatedFor": 123018207444,
  "avatar": 23496414257567,
  "commentCount": 54,
  "upVotes": 21,
  "downVotes": 7,
  "validateAction": {
    "actionId": 642111,
    "progress": 1,
    "alreadyDone": false
  },
  "statusHistory": [
    {
      "status": "ACCEPTED",
      "date": 1647711856277,
      "data": {
        "author": "ACTION"
      }
    }
  ],
  "editable": true,
  "draft": false,
  "readyForModeration": true
}