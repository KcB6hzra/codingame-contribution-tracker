{
  "id": 81063,
  "activeVersion": 74,
  "score": 25,
  "votableId": 32246739,
  "codingamerId": 4372857,
  "views": 602,
  "commentableId": 32104071,
  "title": "The flight of birds",
  "status": "ACCEPTED",
  "type": "PUZZLE_INOUT",
  "nickname": "Sirios",
  "publicHandle": "81063fa8ac26f8f149037f3a40921b9800d28",
  "codingamerHandle": "b2b73c356e61190693cc54ac47cb95a97582734",
  "lastVersion": {
    "version": 74,
    "autocloseTime": 1715724412397,
    "data": {
      "title": "The flight of birds",
      "topics": [
        {
          "id": 86,
          "handle": "simulation",
          "category": "INTERMEDIATE",
          "labelMap": {
            "1": "Simulation",
            "2": "Simulation"
          },
          "pageTitle": "Simulation: exercises and theory",
          "puzzleCount": 43,
          "parentTopicId": 42,
          "contentDetailsId": 72
        },
        {
          "id": 154,
          "handle": "physics",
          "category": "INTERMEDIATE",
          "labelMap": {
            "1": "Physics",
            "2": "Physics"
          },
          "puzzleCount": 15,
          "parentTopicId": 93
        },
        {
          "id": 138,
          "handle": "collision-detection",
          "category": "ADVANCED",
          "labelMap": {
            "1": "Collision Detection",
            "2": "Collision Detection"
          },
          "puzzleCount": 2,
          "parentTopicId": 93
        },
        {
          "id": 95,
          "handle": "geometry",
          "category": "INTERMEDIATE",
          "labelMap": {
            "1": "Geometry",
            "2": "Geometry"
          },
          "puzzleCount": 22,
          "parentTopicId": 93
        }
      ],
      "solution": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cfloat>\n#include <chrono>\n\nusing namespace std;\nusing namespace std::chrono;\n\n//===========================================================================\n\nstruct Timeout\n{\n    void start();\n    bool isElapsed(double maxTimeSeconds);\n\n    high_resolution_clock::time_point startTime;\n};\n\nvoid Timeout::start()\n{\n    startTime = high_resolution_clock::now();\n}\n\nbool Timeout::isElapsed(double maxTimeSeconds)\n{\n    duration<double> time_span = duration_cast<duration<double>>(high_resolution_clock::now() - startTime);\n    return time_span.count() >= maxTimeSeconds;\n}\n\n//===========================================================================\n\nenum class WallSide\n{\n    None,\n    Left,\n    Top,\n    Right,\n    Bottom\n};\n\n//===========================================================================\n\nclass Vector2D\n{\nprivate:\n    double m_x;\n    double m_y;\n\npublic:\n    // ctor\n    Vector2D() : m_x(0.0), m_y(0.0) {}\n    Vector2D(double x, double y) : m_x(x), m_y(y) {}\n\n    // Accessors\n    double GetX() const {\n        return m_x;\n    }\n\n    double GetY() const {\n        return m_y;\n    }\n\n    // Functions\n    double Length() const {\n        return sqrt(m_x * m_x + m_y * m_y);\n    }\n\n    Vector2D Normalize() const {\n        double length = Length();\n        if (length == 0)\n            return Vector2D(0, 0);\n        return Vector2D(m_x / length, m_y / length);\n    }\n\n    Vector2D Add(const Vector2D& v) const {\n        return Vector2D(m_x + v.m_x, m_y + v.m_y);\n    }\n\n    Vector2D Mult(double coef) const {\n        return Vector2D(coef * m_x, coef * m_y);\n    }\n\n    Vector2D CentralSymOrtho() const {\n        return Vector2D(-m_x, -m_y);\n    }\n\n    Vector2D HorizSymOrtho() const {\n        return Vector2D(-m_x, m_y);\n    }\n\n    Vector2D VertSymOrtho() const {\n        return Vector2D(m_x, -m_y);\n    }\n\n    double Dot(const Vector2D& v) const\n    {\n        return m_x * v.m_x + m_y * v.m_y;\n    }\n};\n\n//===========================================================================\n\nclass Bird\n{\nprivate:\n    int m_id;\n    Vector2D m_pos;\n    Vector2D m_speed;\n\npublic:\n    // ctor\n    Bird() : m_id(-1), m_pos(Vector2D()), m_speed(Vector2D()) {}\n    Bird(int id, const Vector2D& pos, const Vector2D& speed) : m_id(id), m_pos(pos), m_speed(speed) {}\n\n    // Accessors\n    Vector2D GetPos() const {\n        return m_pos;\n    }\n\n    void SetPos(const Vector2D& pos) {\n        m_pos = pos;\n    }\n\n    Vector2D GetSpeed() const {\n        return m_speed;\n    }\n\n    void SetSpeed(const Vector2D& speed) {\n        m_speed = speed;\n    }\n\n    int GetId() const {\n        return m_id;\n    }\n};\n\n//===========================================================================\n\n// R = I - 2(I.N)N\n// R = reflect vector\n// I = incident vector\n// N = normal vector to mirror\nVector2D GetReflexion(const Vector2D& incident, const Vector2D normal) {\n    double dotProduct = incident.Dot(normal);\n    return Vector2D(incident.GetX() - 2 * dotProduct * normal.GetX(), incident.GetY() - 2 * dotProduct * normal.GetY());\n}\n\ndouble GetTimeBeforeWallCollision(int h, int w, const Vector2D& pos, const Vector2D& speed, double d, WallSide& wallSide)\n{\n    double timeMin = DBL_MAX;\n\n    if (speed.GetX() < 0)\n    {\n        // x + t*vx = 0 -> t = -x/vx\n        double time = (d - pos.GetX()) / speed.GetX();\n        if (time < timeMin)\n        {\n            timeMin = time;\n            wallSide = WallSide::Left;\n        }\n    }\n    if (speed.GetX() > 0)\n    {\n        // x + t*vx = w -> t = (w-x)/vx\n        double time = (w - d - pos.GetX()) / speed.GetX();\n        if (time < timeMin)\n        {\n            timeMin = time;\n            wallSide = WallSide::Right;\n        }\n    }\n    if (speed.GetY() < 0)\n    {\n        // y + t*vy = 0 -> t = -y/vy\n        double time = (d - pos.GetY()) / speed.GetY();\n        if (time < timeMin)\n        {\n            timeMin = time;\n            wallSide = WallSide::Bottom;\n        }\n    }\n    if (speed.GetY() > 0)\n    {\n        // y + t*vy = h -> t = (h-y)/vy\n        double time = (h - d - pos.GetY()) / speed.GetY();\n        if (time < timeMin)\n        {\n            timeMin = time;\n            wallSide = WallSide::Top;\n        }\n    }\n\n    return timeMin;\n}\n\ndouble GetTimeBeforeBirdCollision(int h, int w, const Vector2D& b1Pos, const Vector2D& b1Speed, const Vector2D& b2Pos, const Vector2D& b2Speed, double collisionDist)\n{\n    // xRel(0) = x2 - x1\n    // yRel(0) = y2 - y1\n    // pRel(0) = p2 - p1 = (xRel(0), yRel(0)) = (x2 - x1, y2 - y1)\n    // \n    // vxRel = vx2 - vx1\n    // vyRel = vy2 - vy1\n    // vRel = v2 - v1 = (vxRel, vyRel) = (vx2 - vx1, vy2 - vy1)\n\n    double xRel0 = b2Pos.GetX() - b1Pos.GetX();\n    double yRel0 = b2Pos.GetY() - b1Pos.GetY();\n    double vxRel = b2Speed.GetX() - b1Speed.GetX();\n    double vyRel = b2Speed.GetY() - b1Speed.GetY();\n\n    // xRel(t) = xRel(0) + vxRel*t\n    // yRel(t) = yRel(0) + vyRel*t\n    // pRel(t) = pRel(0) + vRel*t\n    // \n    // distance of 2 points = norm of PRel\n    // norm: |v| = sqrt(a² + b²)\n    // |pRel(t)| = sqrt(xRel(t)² + yRel(t)²) = d\n    // sqrt((xRel(0) + vxRel*t)² + (yRel(0) + vyRel*t)² = d\n    // (vxRel² + vyRel²)t² + 2((xRel(0)*vxRel) + (yRel(0)*vyRel))t + xRel(0)² + yRel(0)² - d² = 0\n    // at² + bt + c = 0\n    // a = vxRel² + vyRel²\n    // b = 2((xRel(0)*vxRel) + (yRel(0)*vyRel))\n    // c = xRel(0)² + yRel(0)² - d²\n\n    double a = vxRel * vxRel + vyRel * vyRel;\n    double b = 2 * (xRel0 * vxRel + yRel0 * vyRel);\n    double c = xRel0 * xRel0 + yRel0 * yRel0 - collisionDist * collisionDist;\n\n    // If a == 0 then division by zero! \n    if (a == 0)\n        return DBL_MAX;\n\n    // delta = b² - 4ac\n    double delta = b * b - 4 * a * c;\n\n    if (delta < 0.0) // \"Complex\" solution -> no real solution\n        return DBL_MAX;\n\n    // t1 = (-b - sqrt(delta)) / 2*a -> first contact between birds in this context (if positive)\n    // t2 = (-b + sqrt(delta)) / 2*a -> second contact at distance \"d\" between birds in this context but requires the birds to cross each other (if positive) -> not interesting\n\n    double t1 = (-b - sqrt(delta)) / (2 * a);\n    double t2 = (-b + sqrt(delta)) / (2 * a); // t2 == 0 if the birds collided in the previous round\n\n    if (t1 < 0.0) // solution in the past, not in the future\n        return DBL_MAX;\n\n    return t1;\n}\n\ndouble GetTimeBeforeNextCollision(int h, int w, const vector<Bird>& birds, double d, vector<int>& birdsInCollision, WallSide& wallSide)\n{\n    double timeMin = DBL_MAX;\n\n    for (int i = 0; i < birds.size(); i++)\n    {\n        WallSide side;\n        double time = GetTimeBeforeWallCollision(h, w, birds[i].GetPos(), birds[i].GetSpeed(), d, side);\n\n        if (time < timeMin)\n        {\n            timeMin = time;\n            birdsInCollision.clear();\n            birdsInCollision.push_back(i);\n            wallSide = side;\n        }\n\n        for (int j = i + 1; j < birds.size(); j++)\n        {\n            double time = GetTimeBeforeBirdCollision(h, w, birds[i].GetPos(), birds[i].GetSpeed(), birds[j].GetPos(), birds[j].GetSpeed(), d);\n\n            if (time < timeMin)\n            {\n                timeMin = time;\n                birdsInCollision.clear();\n                birdsInCollision.push_back(i);\n                birdsInCollision.push_back(j);\n                wallSide = WallSide::None;\n            }\n        }\n    }\n    return timeMin;\n}\n\nint main()\n{\n    Timeout timeout;\n    timeout.start();\n\n    int h, w;\n    cin >> h >> w; cin.ignore();\n\n    double t; // in u\n    cin >> t; cin.ignore();\n\n    double d;\n    cin >> d; cin.ignore();\n\n    vector<Bird> birds;\n    int n;\n    cin >> n; cin.ignore();\n\n    for (int i = 0; i < n; i++) {\n        int id;\n        double x, y, vx, vy;\n        cin >> id >> x >> y >> vx >> vy; cin.ignore();\n        birds.emplace_back(Bird(id, Vector2D(x, y), Vector2D(vx, vy)));\n    }\n\n    // Direction vector inversion\n    for (Bird& bird : birds)\n        bird.SetSpeed(bird.GetSpeed().CentralSymOrtho());\n\n    int nWallCollisions = 0;\n    int nBirdCollisions = 0;\n    double remainingTime = t;\n\n    while (remainingTime > 0.0 && !timeout.isElapsed(0.295))\n    {\n        // Next collision detection\n        vector<int> birdsInCollision;\n        WallSide wallSide = WallSide::None;\n        double time = GetTimeBeforeNextCollision(h, w, birds, d, birdsInCollision, wallSide);\n\n        if (time > remainingTime)\n            time = remainingTime;\n\n        // Advance all birds on time \"time\"\n        for (Bird& bird : birds)\n            bird.SetPos(bird.GetPos().Add(bird.GetSpeed().Mult(time)));\n\n        if (time < remainingTime)\n        {\n            // Modification of colliding bird(s)\n            if (wallSide != WallSide::None)\n            {\n                if (birdsInCollision.size() != 1)\n                    cerr << \"Error L\" << __LINE__ << endl;\n\n                int index = birdsInCollision[0];\n\n                switch (wallSide)\n                {\n                case WallSide::Left: birds[index].SetSpeed(birds[index].GetSpeed().HorizSymOrtho()); break;\n                case WallSide::Top: birds[index].SetSpeed(birds[index].GetSpeed().VertSymOrtho()); break;\n                case WallSide::Right: birds[index].SetSpeed(birds[index].GetSpeed().HorizSymOrtho()); break;\n                case WallSide::Bottom: birds[index].SetSpeed(birds[index].GetSpeed().VertSymOrtho()); break;\n                default: break;\n                }\n\n                nWallCollisions++;\n            }\n            else\n            {\n                if (birdsInCollision.size() != 2)\n                    cerr << \"Error L\" << __LINE__ << endl;\n\n                Bird& b1 = birds[birdsInCollision[0]];\n                Bird& b2 = birds[birdsInCollision[1]];\n\n                Vector2D normalVect(b2.GetPos().GetX() - b1.GetPos().GetX(), b2.GetPos().GetY() - b1.GetPos().GetY());\n                normalVect = normalVect.Normalize();\n                Vector2D reflectB1Vect = GetReflexion(b1.GetSpeed(), normalVect);\n                Vector2D reflectB2Vect = GetReflexion(b2.GetSpeed(), normalVect);\n\n                b1.SetSpeed(reflectB1Vect);\n                b2.SetSpeed(reflectB2Vect);\n\n                nBirdCollisions++;\n            }\n        }\n        remainingTime -= time;\n    }\n\n    cerr << \"Wall collisions: \" << nWallCollisions << endl;\n    cerr << \"Bird collisions: \" << nBirdCollisions << endl;\n\n    if (remainingTime == t)\n        cout << \"No movement possible!\" << endl;\n\n    else\n    {\n        for (const Bird& bird : birds)\n            cout << bird.GetId() << \" [\" << round(bird.GetPos().GetX()) << \",\" << round(bird.GetPos().GetY()) << \"]\" << endl;\n    }\n}",
      "statement": "This puzzle is inspired by the Fall Challenge 2023 and the banner was generated with Microsoft Bing AI.\n\nYou're a wealthy ornithologist with sumptuous aviaries containing many birds, and you're in the process of carrying out a very serious study into how they interact in captivity and a calm environment. \n\nTo carry out your study, every day, with your notebook in hand, you start by going to your aviaries and recording the position of each bird.\n\nEarly in the morning, you leave your house to join them, when suddenly... BAM! a huge rifle shot rang out. You quickly check to see if any of your birds have been hit, and are relieved to discover that they haven't. However, they are completely panicked and you are unable to carry out your study. Fortunately, your intruder surveillance system was automatically triggered some time after the gunshot and began filming the scene. With the help of a deep learning AI, you were able to determine the precise position and speed of each bird at the moment the system started filming. Now you need to determine the position of each bird at the moment of the shot to complete your study.\n\nTo do this, you assume:\n- The size of the aviary is defined by a height ([[h]]) and a width ([[w]]) whose origin is located at {{[0,0]}}. The height positions are therefore between {{0}} and [[h]] inclusive and the width positions are between {{0}} and [[w]] inclusive.\n- The [[x]] and [[y]] position of all birds could be determined a time [[t]] after the shot, thanks to the surveillance system.\n- Between the shot and the start of the surveillance system, each bird moved in a straight line at a constant instantaneous speed corresponding to that deduced from the monitoring system ([[vx]], [[vy]]).\n- Each time a bird approached the edge of the aviary or another bird at a specific distance from [[d]], it changed direction while maintaining its speed and respecting the law of reflection.\n\n\"Law of reflection\"\n- The reflected vector is in the same plane as the incident vector.\n- The angle of reflection is equal to the angle of incidence.\n\nLink:\nhttps://en.wikipedia.org/wiki/Reflection_(physics)#Laws_of_reflection",
      "testCases": [
        {
          "title": "Test 1: 2 birds, 0 wall collision, 0 bird collision",
          "isTest": true,
          "testIn": "100 100\n20\n1\n2\n1 1 1 -1 -2\n2 4 24 -1 -3",
          "testOut": "1 [21,41]\n2 [24,84]",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Validator 1: 2 birds, 0 wall collision, 0 bird collision",
          "isTest": false,
          "testIn": "100 100\n20\n1\n2\n1 51 21 -1 -2\n2 34 24 -1 -3",
          "testOut": "1 [71,61]\n2 [54,84]",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "Test 2: 2 birds, 5 wall collisions, 0 bird collision",
          "isTest": true,
          "testIn": "20 20\n20\n1\n2\n1 1 1 -1 0\n2 5 16 -1 -2",
          "testOut": "1 [17,1]\n2 [13,18]",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Validator 2: 2 birds, 5 wall collisions, 0 bird collision",
          "isTest": false,
          "testIn": "20 20\n20\n1\n2\n1 6 1 -1 0\n2 15 16 -1 -2",
          "testOut": "1 [12,1]\n2 [3,18]",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "Test 3: 2 birds, 0 wall collisions, 1 bird collision",
          "isTest": true,
          "testIn": "20 20\n5\n2\n2\n1 2 7 -1 -1\n2 2 11 -1 1",
          "testOut": "1 [7,4]\n2 [7,14]",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Validator 3: 2 birds, 0 wall collisions, 1 bird collision",
          "isTest": false,
          "testIn": "20 20\n5\n2\n2\n1 2 8 -1 -1\n2 2 12 -1 1",
          "testOut": "1 [7,5]\n2 [7,15]",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "Test 4: 4 birds, 4 wall collisions, 3 bird collisions",
          "isTest": true,
          "testIn": "20 40\n4\n5\n4\n0 34 6 1.4 0.1\n1 15 7 0.7 0.2\n2 14 13 4.3 2.1\n3 6 7 0.4 3",
          "testOut": "0 [28,6]\n1 [14,7]\n2 [9,14]\n3 [6,7]",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Validator 4: 4 birds, 4 wall collisions, 5 bird collisions",
          "isTest": false,
          "testIn": "20 40\n4\n5\n4\n0 34 13 2.5 2.6\n1 10 10 3.9 2.1\n2 19 8 0.7 0.4\n3 24 11 3.9 0.2",
          "testOut": "0 [23,5]\n1 [14,8]\n2 [20,9]\n3 [23,14]",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "Test 5: 4 birds, 9 wall collisions, 5 bird collisions",
          "isTest": true,
          "testIn": "20 40\n4\n5\n4\n0 21 16 4.4 4.6\n1 26 16 -4.8 3.1\n2 12 10 4.3 1.9\n3 7 10 -3.4 3.9",
          "testOut": "0 [29,12]\n1 [26,8]\n2 [22,11]\n3 [15,14]",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Validator 5: 4 birds, 12 wall collisions, 14 bird collisions",
          "isTest": false,
          "testIn": "20 40\n4\n5\n4\n0 7 9 2.1 -4.3\n1 7 14 4 3.5\n2 19 14 4.3 4\n3 19 9 0.8 -1",
          "testOut": "0 [6,12]\n1 [20,14]\n2 [12,5]\n3 [17,5]",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "Test 6: 10 birds, 20 wall collisions, 12 bird collisions",
          "isTest": true,
          "testIn": "100 100\n50\n5\n10\n1 5 7 -1 -3\n2 6 22 3 1\n3 42 42 2 2\n4 61 78 0 3\n5 88 11 3 0\n6 33 12 1 -1\n7 72 20 -1 2\n8 33 85 0 1\n9 16 55 2 2\n10 91 38 3 2",
          "testOut": "1 [47,49]\n2 [31,62]\n3 [89,72]\n4 [71,78]\n5 [72,56]\n6 [22,32]\n7 [21,72]\n8 [37,42]\n9 [45,85]\n10 [35,55]",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Validator 6: 10 birds, 14 wall collisions, 15 bird collisions",
          "isTest": false,
          "testIn": "100 100\n50\n5\n10\n1 5 8 -1 -3\n2 6 25 3 1\n3 42 42 3 1\n4 61 79 0 3\n5 82 11 3 0\n6 33 12 1 1\n7 72 20 -1 -2\n8 33 84 0 1\n9 16 55 1 2\n10 93 38 3 2",
          "testOut": "1 [84,83]\n2 [78,19]\n3 [39,66]\n4 [24,66]\n5 [92,50]\n6 [23,50]\n7 [90,84]\n8 [33,34]\n9 [57,28]\n10 [30,68]",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "Test 7: 80 birds, 89 wall collisions, 203 bird collisions",
          "isTest": true,
          "testIn": "100 100\n20\n2.5\n80\n0 73 80 0.9 1.9\n1 32 8 2.2 4.4\n2 13 77 4.1 2.4\n3 26 33 2.6 1.7\n4 48 12 2 0.6\n5 71 34 1.3 1.2\n6 9 49 3.9 3.8\n7 22 47 3 1.4\n8 16 94 0.9 3.3\n9 59 84 3.5 3.7\n10 58 51 1.2 3.1\n11 15 39 0.5 4.6\n12 19 6 3.5 3.5\n13 39 66 0.4 0.1\n14 37 44 2.5 3.8\n15 13 8 2.3 2.2\n16 75 49 4.5 3.6\n17 78 53 3.1 2\n18 15 74 1 2.4\n19 73 14 4.9 4.4\n20 45 64 3.7 0.1\n21 81 3 3.2 4.5\n22 16 83 2.6 1.9\n23 48 61 4.9 0.7\n24 82 37 2.7 3.6\n25 30 66 0.5 0.4\n26 77 18 3 3\n27 81 41 4.7 3.1\n28 80 33 4.4 2\n29 44 56 2.7 4.6\n30 23 42 0.3 3.4\n31 16 5 0.7 3.1\n32 44 24 4.6 0.6\n33 31 46 2 2.8\n34 40 95 1.8 0.9\n35 9 28 1 3.3\n36 37 81 0.4 3.3\n37 40 82 4.4 2.1\n38 86 16 0.4 1.3\n39 50 54 1.8 0.8\n40 35 37 0.5 0\n41 43 91 1.5 2.5\n42 55 3 4.6 0.9\n43 24 90 2.1 1.8\n44 71 83 0.1 3.2\n45 85 27 3.4 1.5\n46 47 16 1.3 3.5\n47 11 66 0 2.4\n48 51 18 3.6 0.4\n49 52 5 0.1 1.3\n50 60 75 0.8 0.7\n51 66 30 1.1 1.2\n52 11 96 1.4 0\n53 27 64 3.6 1.9\n54 38 26 3.6 1.2\n55 53 38 2.2 1.9\n56 44 6 0.9 1.8\n57 26 45 0.4 2.3\n58 22 77 3.1 3.4\n59 95 88 1.4 0.4\n60 64 71 2.7 1\n61 84 93 4.1 2.3\n62 4 76 0.6 4.2\n63 59 65 4.1 1.8\n64 92 36 3.6 2.4\n65 73 31 3.3 1.9\n66 67 47 2.8 2.8\n67 34 61 3.6 2.2\n68 69 73 1.2 3.5\n69 25 14 3.3 2.4\n70 42 43 3.1 4\n71 80 89 3.5 2.5\n72 12 41 1 1.1\n73 9 35 2.9 2.2\n74 10 81 0.5 4.3\n75 39 55 1.6 4.3\n76 58 43 2.7 2.6\n77 83 20 2.4 1.8\n78 67 3 0.1 3.8\n79 91 27 2.3 3.6",
          "testOut": "0 [53,72]\n1 [97,25]\n2 [24,56]\n3 [4,11]\n4 [31,15]\n5 [60,50]\n6 [12,5]\n7 [27,20]\n8 [39,67]\n9 [83,78]\n10 [54,67]\n11 [13,7]\n12 [67,55]\n13 [42,67]\n14 [13,72]\n15 [3,15]\n16 [49,15]\n17 [92,52]\n18 [29,71]\n19 [89,4]\n20 [19,49]\n21 [71,26]\n22 [13,43]\n23 [46,77]\n24 [77,81]\n25 [28,57]\n26 [93,47]\n27 [79,64]\n28 [34,14]\n29 [82,58]\n30 [30,18]\n31 [3,6]\n32 [54,10]\n33 [19,5]\n34 [22,66]\n35 [9,51]\n36 [62,76]\n37 [89,86]\n38 [81,21]\n39 [52,57]\n40 [30,40]\n41 [16,88]\n42 [57,19]\n43 [30,51]\n44 [37,80]\n45 [88,24]\n46 [51,8]\n47 [25,45]\n48 [96,50]\n49 [49,6]\n50 [49,63]\n51 [69,33]\n52 [4,77]\n53 [15,69]\n54 [78,3]\n55 [43,39]\n56 [39,21]\n57 [26,25]\n58 [27,76]\n59 [97,86]\n60 [45,56]\n61 [45,71]\n62 [9,41]\n63 [42,10]\n64 [92,39]\n65 [85,70]\n66 [81,44]\n67 [35,7]\n68 [38,47]\n69 [12,39]\n70 [28,4]\n71 [82,84]\n72 [22,34]\n73 [10,20]\n74 [10,95]\n75 [42,84]\n76 [28,38]\n77 [71,3]\n78 [29,31]\n79 [85,42]",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Validator 7: 80 birds, 70 wall collisions, 203 bird collisions",
          "isTest": false,
          "testIn": "100 100\n20\n2.5\n80\n0 55 78 0 4.4\n1 53 26 0.8 0\n2 33 84 3.7 4.1\n3 93 40 3.5 1.5\n4 46 63 0.5 2.6\n5 29 95 2 3.4\n6 36 68 2.7 2.2\n7 65 64 2.7 1\n8 62 37 3 3.2\n9 36 86 4.9 0.3\n10 49 55 1 2.6\n11 30 91 1 0.1\n12 90 15 4.9 2.3\n13 93 69 4.7 0.7\n14 38 47 2.1 2.4\n15 8 44 1.7 4.6\n16 68 74 4.2 1.1\n17 67 34 1.1 0.2\n18 62 93 4.2 2.9\n19 22 67 4.1 1\n20 8 94 4.9 2.1\n21 49 45 0.6 2.4\n22 5 9 0.4 1.8\n23 82 96 0.9 3.2\n24 40 8 4.5 1.9\n25 88 85 1.6 0\n26 55 55 2.4 0.3\n27 81 57 4.8 2.7\n28 32 24 3.1 0.6\n29 37 79 0.8 2.5\n30 26 10 0.6 2.4\n31 93 79 1.3 0.9\n32 62 45 4.3 3.3\n33 56 38 4 3.1\n34 33 20 2.7 4.8\n35 45 81 1.1 1\n36 23 33 3.1 2.1\n37 96 16 3.1 4.8\n38 20 24 3.8 4.7\n39 19 81 2.8 1.7\n40 24 60 3.6 2.1\n41 88 21 4.7 1.2\n42 9 69 4.2 1.7\n43 93 19 3.5 4.2\n44 87 26 0.5 2.8\n45 12 18 0.4 0.1\n46 66 78 2.4 3.9\n47 87 10 0.4 3.5\n48 23 79 4.3 0.6\n49 28 29 2.4 1.7\n50 56 48 3.3 3.2\n51 93 8 3.7 0.5\n52 9 80 0.1 2.8\n53 80 35 4.7 4.6\n54 88 71 4 2.1\n55 7 60 2.4 3.5\n56 51 18 0.4 4.6\n57 11 27 4.8 0.8\n58 61 24 4.7 4\n59 81 53 2.4 1.7\n60 69 61 1.3 4.3\n61 40 30 1.1 4.7\n62 94 65 1.7 1.2\n63 43 14 0.6 0\n64 26 35 0.6 0.2\n65 61 59 2.7 3.2\n66 81 49 3.2 0.9\n67 66 39 3.8 4.1\n68 80 7 2 1.4\n69 57 95 4.1 1\n70 79 3 2 1.4\n71 81 78 3.8 2.3\n72 94 22 1.3 1\n73 3 54 4.8 3.1\n74 76 46 3.7 4.3\n75 78 28 2 0.5\n76 35 37 1.9 2.6\n77 19 88 0.8 2.8\n78 23 89 3.8 3.2\n79 93 58 1 1.6",
          "testOut": "0 [67,96]\n1 [44,25]\n2 [94,6]\n3 [83,16]\n4 [21,29]\n5 [3,66]\n6 [25,37]\n7 [51,61]\n8 [46,28]\n9 [93,91]\n10 [62,15]\n11 [21,80]\n12 [73,10]\n13 [52,70]\n14 [8,46]\n15 [14,8]\n16 [51,45]\n17 [64,34]\n18 [23,70]\n19 [17,57]\n20 [14,53]\n21 [31,33]\n22 [5,10]\n23 [69,58]\n24 [40,26]\n25 [69,81]\n26 [66,43]\n27 [77,67]\n28 [13,16]\n29 [24,61]\n30 [8,7]\n31 [72,66]\n32 [13,41]\n33 [59,15]\n34 [18,68]\n35 [31,75]\n36 [22,52]\n37 [66,9]\n38 [16,50]\n39 [18,72]\n40 [15,29]\n41 [62,19]\n42 [32,56]\n43 [43,42]\n44 [92,17]\n45 [9,14]\n46 [65,76]\n47 [71,23]\n48 [44,47]\n49 [6,29]\n50 [81,89]\n51 [40,6]\n52 [33,46]\n53 [90,38]\n54 [33,21]\n55 [46,62]\n56 [87,7]\n57 [10,80]\n58 [91,14]\n59 [73,39]\n60 [72,48]\n61 [18,21]\n62 [73,57]\n63 [41,21]\n64 [22,33]\n65 [10,69]\n66 [96,3]\n67 [91,21]\n68 [56,16]\n69 [45,89]\n70 [51,15]\n71 [64,68]\n72 [74,3]\n73 [47,70]\n74 [58,58]\n75 [61,27]\n76 [49,29]\n77 [45,76]\n78 [57,81]\n79 [75,49]",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "Test 8: No movement",
          "isTest": true,
          "testIn": "9 9\n1\n3\n4\n1 3 3 -1 -3\n2 6 3 3 1\n3 3 6 3 1\n4 6 6 0 3",
          "testOut": "No movement possible!",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Validator 8: No movement",
          "isTest": false,
          "testIn": "12 12\n1\n4\n4\n1 4 4 -1 -3\n2 8 4 3 1\n3 4 8 3 1\n4 8 8 0 3",
          "testOut": "No movement possible!",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "Test 9: Return to initial position",
          "isTest": true,
          "testIn": "16 16\n14500\n3\n9\n1 4 4 1 0\n2 8 4 1 0\n3 12 4 1 0\n4 4 8 1 0\n5 8 8 1 0\n6 12 8 1 0\n7 4 12 1 0\n8 8 12 1 0\n9 12 12 1 0",
          "testOut": "1 [4,4]\n2 [8,4]\n3 [12,4]\n4 [4,8]\n5 [8,8]\n6 [12,8]\n7 [4,12]\n8 [8,12]\n9 [12,12]",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Validator 9: Return to initial position",
          "isTest": false,
          "testIn": "19 19\n10000\n4\n9\n1 5 5 0 1\n2 10 5 0 1\n3 15 5 0 1\n4 5 10 0 1\n5 10 10 0 1\n6 15 10 0 1\n7 5 15 0 1\n8 10 15 0 1\n9 15 15 0 1",
          "testOut": "1 [5,5]\n2 [10,5]\n3 [15,5]\n4 [5,10]\n5 [10,10]\n6 [15,10]\n7 [5,15]\n8 [10,15]\n9 [15,15]",
          "isValidator": true,
          "needValidation": true
        }
      ],
      "difficulty": "hard",
      "constraints": "{{9}} ≤ [[w]] ≤ {{100}}\n{{9}} ≤ [[h]] ≤ {{100}}\n{{1}} ≤ [[t]] ≤ {{14500}}\n{{1}} ≤ [[d]] ≤ {{5}}\n{{2}} ≤ [[n]] ≤ {{80}}\n[[d]] ≤ [[x]] ≤ [[w]] - [[d]]\n[[d]] ≤ [[y]] ≤ [[h]] - [[d]]\n{{-5}} ≤ [[vx]] ≤ {{5}}\n{{-5}} ≤ [[vy]] ≤ {{5}}",
      "coverBinaryId": 117628921509292,
      "stubGenerator": "read h:int w:int\nread t:float\nread d:float\nread n:int\nloop n read id:int x:float y:float vx:float vy:float\n\nwrite {id} [{x},{y}] ",
      "inputDescription": "<<Line 1:>> 2 integers: [[h]] [[w]] space-separated where [[h]] is the height of the aviary and [[w]] its width.\n<<Line 2:>> 1 float [[t]] indicating the time elapsed in arbitrary units between the shot and the bird data readout.\n<<Line 3:>> 1 float [[d]] which represents the distance between the bird and an edge of the aviary or another bird at which it will change direction.\n<<Line 4:>> 1 integer [[n]] which represents the number of birds in the aviary.\n<<Next [[n]] lines:>> (5 space-separated integer or float)\n[[id]]: the id of the bird.\n[[x]] and [[y]]: the position of the bird at time [[t]].\n[[vx]] and [[vy]]: the speed of the bird at time [[t]].",
      "solutionLanguage": "C++",
      "outputDescription": "If no movement is possible, print {{No movement possible!}}.\nElse <<[[n]] lines>>: bird id and position in format [[id]] {{[}}[[x]]{{,}}[[y]]{{]}} at the moment of the shot sorted by [[id]] where [[x]] and [[y]] are rounded to the unit."
    },
    "draft": false,
    "readyForModeration": true,
    "statementHTML": "<div class=\"statement-body\">\n<div class=\"statement-section statement-goal\">\n   <h2><span class=\"icon icon-goal\">&nbsp;</span><span>Goal </span></h2>\n   <span class=\"question-statement\">This puzzle is inspired by the Fall Challenge 2023 and the banner was generated with Microsoft Bing AI.<br><br>You're a wealthy ornithologist with sumptuous aviaries containing many birds, and you're in the process of carrying out a very serious study into how they interact in captivity and a calm environment. <br><br>To carry out your study, every day, with your notebook in hand, you start by going to your aviaries and recording the position of each bird.<br><br>Early in the morning, you leave your house to join them, when suddenly... BAM! a huge rifle shot rang out. You quickly check to see if any of your birds have been hit, and are relieved to discover that they haven't. However, they are completely panicked and you are unable to carry out your study. Fortunately, your intruder surveillance system was automatically triggered some time after the gunshot and began filming the scene. With the help of a deep learning AI, you were able to determine the precise position and speed of each bird at the moment the system started filming. Now you need to determine the position of each bird at the moment of the shot to complete your study.<br><br>To do this, you assume:<br>- The size of the aviary is defined by a height (<var>h</var>) and a width (<var>w</var>) whose origin is located at <const>[0,0]</const>. The height positions are therefore between <const>0</const> and <var>h</var> inclusive and the width positions are between <const>0</const> and <var>w</var> inclusive.<br>- The <var>x</var> and <var>y</var> position of all birds could be determined a time <var>t</var> after the shot, thanks to the surveillance system.<br>- Between the shot and the start of the surveillance system, each bird moved in a straight line at a constant instantaneous speed corresponding to that deduced from the monitoring system (<var>vx</var>, <var>vy</var>).<br>- Each time a bird approached the edge of the aviary or another bird at a specific distance from <var>d</var>, it changed direction while maintaining its speed and respecting the law of reflection.<br><br>&quot;Law of reflection&quot;<br>- The reflected vector is in the same plane as the incident vector.<br>- The angle of reflection is equal to the angle of incidence.<br><br>Link:<br>https://en.wikipedia.org/wiki/Reflection_(physics)#Laws_of_reflection</span>\n</div>\n<div class=\"statement-section statement-protocol\">\n   <div class=\"blk\">\n      <div class=\"title\">Input</div>\n      <div class=\"question-statement-input\"><strong>Line 1:</strong> 2 integers: <var>h</var> <var>w</var> space-separated where <var>h</var> is the height of the aviary and <var>w</var> its width.<br><strong>Line 2:</strong> 1 float <var>t</var> indicating the time elapsed in arbitrary units between the shot and the bird data readout.<br><strong>Line 3:</strong> 1 float <var>d</var> which represents the distance between the bird and an edge of the aviary or another bird at which it will change direction.<br><strong>Line 4:</strong> 1 integer <var>n</var> which represents the number of birds in the aviary.<br><strong>Next <var>n</var> lines:</strong> (5 space-separated integer or float)<br><var>id</var>: the id of the bird.<br><var>x</var> and <var>y</var>: the position of the bird at time <var>t</var>.<br><var>vx</var> and <var>vy</var>: the speed of the bird at time <var>t</var>.</div>\n   </div>\n   <div class=\"blk\">\n      <div class=\"title\">Output</div>\n      <div class=\"question-statement-output\">If no movement is possible, print <const>No movement possible!</const>.<br>Else <strong><var>n</var> lines</strong>: bird id and position in format <var>id</var> <const>[</const><var>x</var><const>,</const><var>y</var><const>]</const> at the moment of the shot sorted by <var>id</var> where <var>x</var> and <var>y</var> are rounded to the unit.</div>\n   </div>\n   <div class=\"blk\">\n      <div class=\"title\">Constraints</div>\n      <div class=\"question-statement-constraints\"><const>9</const> &le; <var>w</var> &le; <const>100</const><br><const>9</const> &le; <var>h</var> &le; <const>100</const><br><const>1</const> &le; <var>t</var> &le; <const>14500</const><br><const>1</const> &le; <var>d</var> &le; <const>5</const><br><const>2</const> &le; <var>n</var> &le; <const>80</const><br><var>d</var> &le; <var>x</var> &le; <var>w</var> - <var>d</var><br><var>d</var> &le; <var>y</var> &le; <var>h</var> - <var>d</var><br><const>-5</const> &le; <var>vx</var> &le; <const>5</const><br><const>-5</const> &le; <var>vy</var> &le; <const>5</const></div>\n   </div>\n   <div class=\"blk\">\n      <div class=\"title\">Example</div>\n      <div class=\"statement-inout\">\n         <div class=\"statement-inout-in\">\n            <div class=\"title\">Input</div>\n            <pre class=\"question-statement-example-in\">100 100\n20\n1\n2\n1 1 1 -1 -2\n2 4 24 -1 -3</pre>\n         </div>\n         <div class=\"statement-inout-out\">\n            <div class=\"title\">Output</div>\n            <pre class=\"question-statement-example-out\">1 [21,41]\n2 [24,84]</pre>\n         </div>\n      </div>\n   </div>\n</div>"
  },
  "validatedFor": 57356011040,
  "avatar": 67205527942183,
  "commentCount": 78,
  "upVotes": 26,
  "downVotes": 1,
  "validateAction": {
    "actionId": 942912,
    "progress": 1,
    "alreadyDone": false
  },
  "statusHistory": [
    {
      "status": "REFUSED",
      "date": 1707606337000,
      "data": {
        "author": "SYSTEM",
        "reason": "INACTIVITY"
      }
    },
    {
      "status": "PENDING",
      "date": 1707651037905,
      "data": {
        "author": "ACTION",
        "reason": "EDIT"
      }
    },
    {
      "status": "REFUSED",
      "date": 1710533137000,
      "data": {
        "author": "SYSTEM",
        "reason": "INACTIVITY"
      }
    },
    {
      "status": "PENDING",
      "date": 1710539066610,
      "data": {
        "author": "ACTION",
        "reason": "EDIT"
      }
    },
    {
      "status": "REFUSED",
      "date": 1713132337001,
      "data": {
        "author": "SYSTEM",
        "reason": "INACTIVITY"
      }
    },
    {
      "status": "PENDING",
      "date": 1713132412397,
      "data": {
        "author": "ACTION",
        "reason": "EDIT"
      }
    },
    {
      "status": "ACCEPTED",
      "date": 1713372888475,
      "data": {
        "author": "ACTION"
      }
    }
  ],
  "editable": true,
  "draft": false,
  "readyForModeration": true
}