{
  "id": 45489,
  "activeVersion": 12,
  "score": 4,
  "votableId": 28050425,
  "codingamerId": 4702825,
  "views": 138,
  "commentableId": 27922582,
  "title": "Enumeration",
  "status": "ACCEPTED",
  "type": "CLASHOFCODE",
  "nickname": "[joshua]",
  "publicHandle": "4548904820bea7facf9564d9a51e62283c642",
  "codingamerHandle": "a0637ac691d9361e05d3f31c174cc1f15282074",
  "lastVersion": {
    "version": 12,
    "autocloseTime": 1678163119839,
    "data": {
      "title": "Enumeration",
      "topics": [],
      "fastest": true,
      "reverse": false,
      "shortest": false,
      "solution": "#pragma region template\n#pragma clang diagnostic ignored \"-Wno-deprecated\"\n#pragma clang diagnostic ignored \"-Werror\"\n// c#.cpp : This file contains the 'main' function. Program execution begins and ends there.\n#include <iomanip>\n#include <iostream>\n#include <cctype>\n#include <string>\n#include <math.h> \n#include <cmath>\n#include <sstream>\n#include <vector>\n#include <algorithm>\n#include <fstream>\n#include <exception>\n#include <limits>\n#include <new>\n#include <typeinfo>\n#include <bitset>\n#include <deque>\n#include <iterator>\n#include <numeric>\n#include <iosfwd>\n#include <ios>\n#include <istream>\n#include <streambuf>\n#include <strstream>\n#include <array>\n#include <regex>\n#include <cassert>\n#include <cerrno>\n#include <climits>\n#include <cfenv>\n#include <type_traits>\n#include <chrono>\n#include <functional>\n#include <memory>\n#include <memory.h>\n#include <stdio.h>\n#include <math.h>\n#include <time.h>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <utility>\n#include <cwctype>\n#include <cwchar>\n#include <unordered_map>\n#include <unordered_set>\nusing namespace std;\nusing std::cout; using std::cin;\nusing std::endl; using std::string;\nusing std::vector; using std::istringstream;\nusing std::ios;\nusing std::stringstream;\nusing ll = long long; using ld = long double;\nusing ull = unsigned long long; using str = string;\nusing bl = bool; using ch = char;\ntypedef vector<ll> vl;\ntypedef vector<ld> vd;\ntypedef set<ll> sl;\ntypedef unordered_set<ll> usl;\ntypedef unordered_set<str> uss;\ntypedef vector<vector<ll>> vl2;\ntypedef vector<str> vs;\ntypedef vector<ch> vc;\ntypedef vector<pair<ll, ll>> vp;\ntypedef vector<bl> vb;\ntypedef map<ll, str> mls;\ntypedef map<str, str> mss;\ntypedef map<ll, ll> mll;\ntypedef map<str, ll> msl;\ntypedef map<ch, ll> mcl;\ntypedef stack<ll> stl;\ntypedef queue<ll> ql;\ntypedef deque<ll> dq;\ntypedef priority_queue<ll> pq;\n#define _USE_MATH_DEFINES\n#define M_PI 3.14159265358979323846\n#define INT_MAX 2147483647\n#define LLONG_MAX 9223372036854775807\n#define ULLONG_MAX 18446744073709551615\n#define LL_MAX LLONG_MAX\n#define up(initial, n, step) for(ll i = (ll)(initial);i < (ll)(n);i+=(ll)(step))\n#define up2(initial, n, step) for(ll j = (ll)(initial);j < (ll)(n);j+=(ll)(step))\n#define up3(initial, n, step) for(ll k = (ll)(initial);k < (ll)(n);k+=(ll)(step))\n#define down(initial, n, step) for(ll i = (ll)(initial) - 1;i >= (ll)(n);i-=(ll)(step))\n#define forCond(initial, cond, step) for(ll i = (initial);cond;i+=(step))\n#define all(x) (x).begin(), (x).end()\n#define floor(a) (ll)a\n#define vget(v) for(auto& element : v) element = get();\n#define vcin(v) for(auto& element : v)cin >> (element);\n#define YES(a) ((a)?\"YES\":\"NO\")\n#define Yes(a) ((a)?\"Yes\":\"No\")\n#define yes(a) ((a)?\"yes\":\"no\")\n#define stop return EXIT_SUCCESS;\n#define rev(s) reverse((s).begin(), (s).end());\n#define sortCol(v, v2, col) sort(v, v[(col)] < v2[(col)])\n#define vsort(v) sort(v.begin(), v.end())\n#define pb(a) push_back((a));\n#define vpushf(v, a) (v).insert((v).begin(), (a))\n#define vsum(v) accumulate(v.begin(), v.end(), 0)\n#define vavg(v) accumulate(v.begin(), v.end(), 0) / v.size()\n#define vremoveDupe(v) (v).erase(unique((v).begin(), (v).end()), (v).end());\n#define vrand(v) (v).random_shuffle(v.begin(), v.end());\n#define vfind(v, val) find(all((v)), val)\n#define vprint(v, spacing) foreach(x, v)cout << (x) << (spacing);\n#define spush(s, a) (s).insert((a));\n#define stTop(s) (s).top();\n#define toStr(s) to_string((s))\n#define throwErr(s) throw invalid_argument(s);\n#define setdecimal(n) cout << fixed << setprecision((n))\n#define fillAsc(v, start) iota((v).begin(), (v).end(), (start));\n#define isPerm is_permutation\n#define nextPerm next_permutation\n#define prevPerm prev_permutation\n#define tc \\\n  ll testcase = get();  \\\n  while (testcase--)\n#define tcin \\\n  ll testcase;\\\n  cin >> testcase;\\\n  while(testcase--)\n#define varConcat(a, b) a##b\n#define setup std::ios::sync_with_stdio(EXIT_SUCCESS); std::cin.tie(EXIT_SUCCESS); std::cout.tie(EXIT_SUCCESS);\n#define foreach(a, v) for(auto& a : v)\n#define skip continue\n#define stc static\n#define longlonglonglonglonglonglonglonglonglonglong ll\nauto _ = NULL;//Shame that C++ does not have Discards like C#.\nconst str alphabet = \"abcdefghijklmnopqrstuvwxyz\";\nconst str upAlphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\nconst ll Mod = 998244353;\nconst ll Mod2 = pow(10, 9) + 7;\nconst ll Mod3 = pow(10, 9);\nconst ld EPS = 1e-9;\nconst ld PI = 2 * acos(0.0);\nconst ll pow5Len = pow(10, 5) + 1;\nconst ll pow11Len = pow(10, 10) + 1;\nstr toLower(str s)\n{\n    str result = \"\";\n    for (auto& c : s)result += tolower(c);\n    return result;\n}\nstr toUpper(str s) {\n    str result = \"\";\n    for (auto& c : s)result += toupper(c);\n    return result;\n}\nld TAN(ld degree) { return tan(degree * PI / 180.0); }; ld SIN(ld degree) { return sin(degree * PI / 180.0); }; ld COS(ld degree) { return cos(degree * PI / 180.0); };\nld ATAN(ld len) { return atan(len) * 180 / PI; }ld ASIN(ld len) { return asin(len) * 180 / PI; }ld ACOS(ld len) { return acos(len) * 180 / PI; }\nll lexOrder(str s, str s2) { if (s == s2) { return 0; stop; } if (s.length() <= s2.length()) { for (int i = 0; i < s.length(); i++) { if (s[i] < s2[i]) { return -1; stop; } else if (s[i] > s2[i]) { return 1; stop; } } return -1; } else { for (int i = 0; i < s2.length(); i++) { if (s[i] > s2[i]) { return -1; stop; } else if (s[i] < s2[i]) { return 1; stop; } } return 1; } }\nll binarySearch(vl v, ll val) { ll l = 0, m, h = v.size() - 1; while (l <= h && val != -1) { m = (l + h) / 2; if (val < v[m]) h = m - 1; else if (val > v[m]) l = m + 1; else return m; }return -1; }\nll binarySearch2(int arr[], int l, int r, int x) { while (l <= r) { int m = l + (r - l) / 2; if (arr[m] == x) return m; else if (arr[m] < x) l = m + 1; else r = m - 1; }return -1; }\nll revBinarySearch(vector<int> v, int X) { int start = 0, end = v.size() - 1; while (start <= end) { int mid = start + (end - start) / 2; if (X == v[mid]) return mid; else if (X < v[mid]) start = mid + 1; else end = mid - 1; } return -1; }\nbl isNumber(const str& st) { for (ch const& c : st) if (isdigit(c) == 0) return false; return true; }\nll getMonth(str m) { m = toLower(m); if (m == \"january\") return 1; else if (m == \"february\") return 2; else if (m == \"March\") return 3; else if (m == \"April\") return 4; else if (m == \"May\") return 5; else if (m == \"June\") return 6; else if (m == \"July\") return 7; else if (m == \"August\") return 8; else if (m == \"Sepember\") return 9; else if (m == \"October\") return 10; else if (m == \"November\") return 11; return 12; }\nbl isLeapYear(int n) { return (n % 4 == 0 ? n % 100 == 0 && n % 400 == 0 ? true : n % 100 != 0 ? true : false : false); }\nbl sortcol(const vector<int>& v, const vector<int>& v2, int col) { return v[col] < v2[col]; }\nbl cmp(pair<str, ll>& a, pair<str, ll>& b) { if (a.second == b.second) { for (ll i = 0; i < min(a.first.length(), b.first.length()); i++) { if (a.first[i] < b.first[i])return 0; else if (a.first[i] > b.first[i])return 1; } } return a.second < b.second; }\nll getIndex(vl v, ll K) { auto it = find(v.begin(), v.end(), K); if (it != v.end()) return it - v.begin(); return -1; }\nll getIndexArr(int arr[], int n) { size_t Size = sizeof(arr) / sizeof(int); int* end = arr + Size; int* result = find(arr, end, n); if (result != end) return distance(arr, result); return -1; }\nll gcd(ll a, ll b) {\n    while (b) b ^= a ^= b ^= a %= b;\n    return a;\n}\nll lcm(ll a, ll b) { return (a / gcd(a, b)) * b; }\nll search(ll x, ll t[], ll len) {\n    ll* base = t;\n    while (len > 1) {\n        int half = len / 2;\n        base = (base[half] < x ? &base[half] : base);\n        len -= half;\n    }\n    return *(base + (*base < x));\n}\nbl islower(str s) { for (const auto& c : s) { if (c > 'z' || c < 'a') return false; } return true; }\nbl ishigher(str s) { for (const auto& c : s) { if (c > 'Z' || c < 'A') return false; } return true; }\nll ascSum(ll n) { return n * (n + 1) / 2; }\nll len(str s) { return s.length(); }\nll fib(ll num) { const ld f = sqrt(5); return (pow(1 + f, num) - pow(1 - f, num)) / (pow(2, num) * f); }//1,1,2,3,5,8,13,21,34,55,...\nll vColSum(vl2 v, ll col) { ll sum = 0; for (const auto& x : v)sum += x[col]; return sum; }\n//vl vobtain() { ll n = get(); vl v(n); vget(v); return v; }\nll mapMaxElement(mll x) { mll::iterator best = max_element(x.begin(), x.end(), [](const pair<ll, ll>& a, const pair<ll, ll>& b)->bool { return a.second < b.second; }); return best->second; }\nll mapMaxElement(msl x) { msl::iterator best = max_element(x.begin(), x.end(), [](const pair<str, ll>& a, const pair<str, ll>& b)->bool { return a.second < b.second; }); return best->second; }\nbl isPrime(ll n) { if (n == 1)return 0; for (ll i = 2; i * i <= n; i++) if (!(n % i))return 0; return 1; }\nvl eratosthenesSieve(ll limit) { vl prime(limit + 1); for (ll i = 2; i <= limit; i++)prime[i] = 1; for (ll p = 2; p * p <= limit; p++)if (prime[p])for (ll i = p * p; i <= limit; i += p)prime[i] = 0; return prime; }\nbl ispow2(ll i) { return i && (i & -i) == i; }\nbl isPal(str s) { str s2 = s; rev(s2); return s2 == s; }\nbl isParenthesis(str s) { ll p = 0; for (const auto& t : s) { if (t == '(')p++; else if (t == ')') { p--; if (p < 0)  return false; } }return p == 0; }\nll mul(ll x, ll res[], ll res_size);\nstr factorial(ll n) { str result = \"\"; ll res[1000]; res[0] = 1; ll res_size = 1; for (ll x = 2; x <= n; x++) res_size = mul(x, res, res_size); for (ll i = res_size - 1; i >= 0; i--)result += toStr(res[i]); return result; }\nll mul(ll x, ll res[], ll res_size) { ll carry = 0; for (ll i = 0; i < res_size; i++) { ll prod = res[i] * x + carry; res[i] = prod % 10; carry = prod / 10; }while (carry) { res[res_size] = carry % 10; carry = carry / 10; res_size++; }return res_size; }\nld squareRoot(ld n) {\n    ld x = 1;\n    while (abs(x * x - n) > EPS) x = (x + n / x) / 2;\n    return x;\n}\nvoid factor(vl v, ll n)\n{\n    up(1, sqrt(n) + 1, 1) if (!(n % i)) { v.push_back(i); v.push_back(n / i); }\n}\n\nauto vmin = [](vl v) {return *min_element(all(v)); };\nauto vmax = [](vl v) {return *max_element(all(v)); };\nauto multiply = [](ll n, ll n2) {ll result = 0; while (n2 > 0) { if (n2 & 1)  result += n; n = n << 1; n2 = n2 >> 1; } return result; };\nstruct ListNode {\n    int val;\n    ListNode* next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode* next) : val(x), next(next) {}\n};\n//Unity Engine based Vector2\nclass Vector2 {\npublic:\n    ld x, y;\n    friend Vector2 operator-(const Vector2&, const Vector2&);\n};\nVector2 operator-(const Vector2& a, const Vector2& b) {\n    Vector2 v;\n    v.x = a.x - b.x, v.y - a.y - b.y;\n    return v;\n}\nld Distance(Vector2& a, Vector2& b) {\n    return sqrtl(powl(a.x - b.x, 2) + powl(a.y - b.y, 2));\n}\nld magnitude(Vector2* a) {\n    return sqrtl(powl(a->x, 2) + powl(a->y, 2));\n}\nld manhattanDistance(Vector2& a, Vector2& b) {\n    return fabsl(a.x - b.x) + fabsl(a.y - b.y);\n}\n\n//fastInput, fastOutput and BigInt provided by GeeksForGeeks\ninline ll get(void) { ch t = getchar(); ll x = 0, neg = 0; while ((t < 48 || t>57) && t != '-') t = getchar(); if (t == '-') { neg = 1; t = getchar(); } while (t >= 48 && t <= 57) { x = (x << 3) + (x << 1) + t - 48; t = getchar(); } if (neg) x = -x; return x; }\ninline void out(ll x, ll mode = 1) { ch a[20]; a[0] = '0'; ll i = 0, j; if (x < 0) { putchar('-'); x = -x; }if (x == 0) putchar('0'); while (x) { a[i++] = x % 10 + 48; x /= 10; } for (j = i - 1; j >= 0; j--) putchar(a[j]); putchar(mode ? '\\n' : ' '); }\nclass BigInt {\n    string digits;\npublic:\n    BigInt(unsigned long long n = 0);\n    BigInt(string&);\n    BigInt(const char*);\n    BigInt(BigInt&);\n\n    //Helper Functions:\n    friend void divide_by_2(BigInt& a);\n    friend bool Null(const BigInt&);\n    friend int Length(const BigInt&);\n    int operator[](const int)const;\n    BigInt& operator=(const BigInt&);\n    BigInt& operator++();\n    BigInt operator++(int temp);\n    BigInt& operator--();\n    BigInt operator--(int temp);\n    friend BigInt& operator+=(BigInt&, const BigInt&);\n    friend BigInt operator+(const BigInt&, const BigInt&);\n    friend BigInt operator-(const BigInt&, const BigInt&);\n    friend BigInt& operator-=(BigInt&, const BigInt&);\n    friend bool operator==(const BigInt&, const BigInt&);\n    friend bool operator!=(const BigInt&, const BigInt&);\n    friend bool operator>(const BigInt&, const BigInt&);\n    friend bool operator>=(const BigInt&, const BigInt&);\n    friend bool operator<(const BigInt&, const BigInt&);\n    friend bool operator<=(const BigInt&, const BigInt&);\n    friend BigInt& operator*=(BigInt&, const BigInt&);\n    friend BigInt operator*(const BigInt&, const BigInt&);\n    friend BigInt& operator/=(BigInt&, const BigInt&);\n    friend BigInt operator/(const BigInt&, const BigInt&);\n    friend BigInt operator%(const BigInt&, const BigInt&);\n    friend BigInt& operator%=(BigInt&, const BigInt&);\n    friend BigInt& operator^=(BigInt&, const BigInt&);\n    friend BigInt operator^(BigInt&, const BigInt&);\n    friend BigInt sqrt(BigInt& a);\n    friend ostream& operator<<(ostream&, const BigInt&);\n    friend istream& operator>>(istream&, BigInt&);\n    friend BigInt NthCatalan(int n);\n    friend BigInt NthFibonacci(int n);\n    friend BigInt Factorial(int n);\n};\nBigInt::BigInt(string& s) {\n    digits = \"\";\n    ll n = s.size();\n    down(n - 1, 0, 1) {\n        if (!isdigit(s[i])) throw(\"ERROR\");\n        digits.push_back(s[i] - '0');\n    }\n}\nBigInt::BigInt(unsigned long long nr) {\n    do {\n        digits.push_back(nr % 10);\n        nr /= 10;\n    } while (nr);\n}\nBigInt::BigInt(const char* s) {\n    digits = \"\";\n    for (int i = strlen(s) - 1; i >= 0; i--)\n    {\n        if (!isdigit(s[i])) throw(\"ERROR\");\n        digits.push_back(s[i] - '0');\n    }\n}\nBigInt::BigInt(BigInt& a) { digits = a.digits; }\nbl Null(const BigInt& a) { return (a.digits.size() == 1 && a.digits[0] == 0); }\nint Length(const BigInt& a) { return a.digits.size(); }\nint BigInt::operator[](const int index)const {\n    if (digits.size() <= index || index < 0) throw(\"ERROR\");\n    return digits[index];\n}\nbl operator==(const BigInt& a, const BigInt& b) { return a.digits == b.digits; }\nbl operator!=(const BigInt& a, const BigInt& b) { return !(a == b); }\nbl operator<(const BigInt& a, const BigInt& b) {\n    int n = Length(a), m = Length(b);\n    if (n != m) return n < m;\n    while (n--) if (a.digits[n] != b.digits[n]) return a.digits[n] < b.digits[n];\n    return false;\n}\nbool operator>(const BigInt& a, const BigInt& b) { return b < a; }\nbool operator>=(const BigInt& a, const BigInt& b) { return !(a < b); }\nbool operator<=(const BigInt& a, const BigInt& b) { return !(a > b); }\n\nBigInt& BigInt::operator=(const BigInt& a) {\n    digits = a.digits;\n    return *this;\n}\nBigInt& BigInt::operator++() {\n    int i, n = digits.size();\n    for (i = 0; i < n && digits[i] == 9; i++)\n        digits[i] = 0;\n    if (i == n)\n        digits.push_back(1);\n    else\n        digits[i]++;\n    return *this;\n}\nBigInt BigInt::operator++(int temp) {\n    BigInt aux;\n    aux = *this;\n    ++(*this);\n    return aux;\n}\n\nBigInt& BigInt::operator--() {\n    if (digits[0] == 0 && digits.size() == 1)\n        throw(\"UNDERFLOW\");\n    int i, n = digits.size();\n    for (i = 0; digits[i] == 0 && i < n; i++)\n        digits[i] = 9;\n    digits[i]--;\n    if (n > 1 && digits[n - 1] == 0)\n        digits.pop_back();\n    return *this;\n}\nBigInt BigInt::operator--(int temp) {\n    BigInt aux;\n    aux = *this;\n    --(*this);\n    return aux;\n}\n\nBigInt& operator+=(BigInt& a, const BigInt& b) {\n    int t = 0, s, i;\n    int n = Length(a), m = Length(b);\n    if (m > n)\n        a.digits.append(m - n, 0);\n    n = Length(a);\n    for (i = 0; i < n; i++) {\n        if (i < m)\n            s = (a.digits[i] + b.digits[i]) + t;\n        else\n            s = a.digits[i] + t;\n        t = s / 10;\n        a.digits[i] = (s % 10);\n    }\n    if (t)\n        a.digits.push_back(t);\n    return a;\n}\nBigInt operator+(const BigInt& a, const BigInt& b) {\n    BigInt temp;\n    temp = a;\n    temp += b;\n    return temp;\n}\n\nBigInt& operator-=(BigInt& a, const BigInt& b) {\n    if (a < b) throw(\"UNDERFLOW\");\n    int n = Length(a), m = Length(b), i, t = 0, s;\n    for (i = 0; i < n; i++) {\n        if (i < m) s = a.digits[i] - b.digits[i] + t;\n        else s = a.digits[i] + t;\n        if (s < 0) s += 10, t = -1;\n        else t = 0;\n        a.digits[i] = s;\n    }\n    while (n > 1 && a.digits[n - 1] == 0)\n        a.digits.pop_back(),\n        n--;\n    return a;\n}\nBigInt operator-(const BigInt& a, const BigInt& b) {\n    BigInt temp;\n    temp = a;\n    temp -= b;\n    return temp;\n}\n\nBigInt& operator*=(BigInt& a, const BigInt& b)\n{\n    if (Null(a) || Null(b)) {\n        a = BigInt();\n        return a;\n    }\n    int n = a.digits.size(), m = b.digits.size();\n    vector<int> v(n + m, 0);\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < m; j++) {\n            v[i + j] += (a.digits[i]) * (b.digits[j]);\n        }\n    n += m;\n    a.digits.resize(v.size());\n    for (int s, i = 0, t = 0; i < n; i++)\n    {\n        s = t + v[i];\n        v[i] = s % 10;\n        t = s / 10;\n        a.digits[i] = v[i];\n    }\n    for (int i = n - 1; i >= 1 && !v[i]; i--)\n        a.digits.pop_back();\n    return a;\n}\nBigInt operator*(const BigInt& a, const BigInt& b) {\n    BigInt temp;\n    temp = a;\n    temp *= b;\n    return temp;\n}\n\nBigInt& operator/=(BigInt& a, const BigInt& b) {\n    if (Null(b)) throw(\"Arithmetic Error: Division By 0\");\n    if (a < b) {\n        a = BigInt();\n        return a;\n    }\n    if (a == b) {\n        a = BigInt(1);\n        return a;\n    }\n    int i, lgcat = 0, cc;\n    int n = Length(a), m = Length(b);\n    vector<int> cat(n, 0);\n    BigInt t;\n    for (i = n - 1; t * 10 + a.digits[i] < b; i--) {\n        t *= 10;\n        t += a.digits[i];\n    }\n    for (; i >= 0; i--) {\n        t = t * 10 + a.digits[i];\n        for (cc = 9; cc * b > t; cc--);\n        t -= cc * b;\n        cat[lgcat++] = cc;\n    }\n    a.digits.resize(cat.size());\n    for (i = 0; i < lgcat; i++)\n        a.digits[i] = cat[lgcat - i - 1];\n    a.digits.resize(lgcat);\n    return a;\n}\nBigInt operator/(const BigInt& a, const BigInt& b) {\n    BigInt temp;\n    temp = a;\n    temp /= b;\n    return temp;\n}\n\nBigInt& operator%=(BigInt& a, const BigInt& b) {\n    if (Null(b)) throw(\"Arithmetic Error: Division By 0\");\n    if (a < b) {\n        a = BigInt();\n        return a;\n    }\n    if (a == b) {\n        a = BigInt(1);\n        return a;\n    }\n    int i, lgcat = 0, cc;\n    int n = Length(a), m = Length(b);\n    vector<int> cat(n, 0);\n    BigInt t;\n    for (i = n - 1; t * 10 + a.digits[i] < b; i--) {\n        t *= 10;\n        t += a.digits[i];\n    }\n    for (; i >= 0; i--) {\n        t = t * 10 + a.digits[i];\n        for (cc = 9; cc * b > t; cc--);\n        t -= cc * b;\n        cat[lgcat++] = cc;\n    }\n    a = t;\n    return a;\n}\nBigInt operator%(const BigInt& a, BigInt& b) {\n    BigInt temp;\n    temp = a;\n    temp %= b;\n    return temp;\n}\n\nBigInt& operator^=(BigInt& a, const BigInt& b) {\n    BigInt Exponent, Base(a);\n    Exponent = b;\n    a = 1;\n    while (!Null(Exponent)) {\n        if (Exponent[0] & 1)\n            a *= Base;\n        Base *= Base;\n        divide_by_2(Exponent);\n    }\n    return a;\n}\nBigInt operator^(BigInt& a, BigInt& b) {\n    BigInt temp(a);\n    temp ^= b;\n    return temp;\n}\n\nvoid divide_by_2(BigInt& a) {\n    int add = 0;\n    for (int i = a.digits.size() - 1; i >= 0; i--) {\n        int digit = (a.digits[i] >> 1) + add;\n        add = ((a.digits[i] & 1) * 5);\n        a.digits[i] = digit;\n    }\n    while (a.digits.size() > 1 && !a.digits.back()) a.digits.pop_back();\n}\nBigInt sqrt(BigInt& a) {\n    BigInt left(1), right(a), v(1), mid, prod;\n    divide_by_2(right);\n    while (left <= right) {\n        mid += left;\n        mid += right;\n        divide_by_2(mid);\n        prod = (mid * mid);\n        if (prod <= a) {\n            v = mid;\n            ++mid;\n            left = mid;\n        }\n        else {\n            --mid;\n            right = mid;\n        }\n        mid = BigInt();\n    }\n    return v;\n}\nBigInt NthCatalan(int n) {\n    BigInt a(1), b;\n    for (int i = 2; i <= n; i++) a *= i;\n    b = a;\n    for (int i = n + 1; i <= 2 * n; i++) b *= i;\n    a *= a;\n    a *= (n + 1);\n    b /= a;\n    return b;\n}\n\nBigInt NthFibonacci(int n) {\n    BigInt a(1), b(1), c;\n    if (!n)\n        return c;\n    n--;\n    while (n--) {\n        c = a + b;\n        b = a;\n        a = c;\n    }\n    return b;\n}\nBigInt Factorial(int n) {\n    BigInt f(1);\n    for (int i = 2; i <= n; i++) f *= i;\n    return f;\n}\nistream& operator>>(istream& in, BigInt& a) {\n    string s;\n    in >> s;\n    int n = s.size();\n    for (int i = n - 1; i >= 0; i--) {\n        if (!isdigit(s[i])) throw(\"INVALID NUMBER\");\n        a.digits[n - i - 1] = s[i];\n    }\n    return in;\n}\n\nostream& operator<<(ostream& out, const BigInt& a) {\n    for (int i = a.digits.size() - 1; i >= 0; i--) cout << (short)a.digits[i];\n    return cout;\n}\n//https://www.geeksforgeeks.org/create-a-tree-in-level-order\nstruct Node {\n    int key;\n    Node* left;\n    Node* right;\n};\nstruct Node* newNode(int value)\n{\n    Node* n = new Node;\n    n->key = value;\n    n->left = NULL;\n    n->right = NULL;\n    return n;\n}\n\nstruct Node* insertValue(struct Node* root, int value,\n    queue<Node*>& q)\n{\n    Node* node = newNode(value);\n    if (root == NULL)\n        root = node;\n    else if (q.front()->left == NULL)\n        q.front()->left = node;\n    else {\n        q.front()->right = node;\n        q.pop();\n    }\n    q.push(node);\n    return root;\n}\nNode* createTree(int arr[], int n)\n{\n    Node* root = NULL;\n    queue<Node*> q;\n    for (int i = 0; i < n; i++)\n        root = insertValue(root, arr[i], q);\n    return root;\n}\nvoid levelOrder(struct Node* root)\n{\n    if (root == NULL)\n        return;\n    queue<Node*> n;\n    n.push(root);\n    while (!n.empty()) {\n        cout << n.front()->key << \" \";\n        if (n.front()->left != NULL)\n            n.push(n.front()->left);\n        if (n.front()->right != NULL)\n            n.push(n.front()->right);\n        n.pop();\n    }\n}\n//fastPow provided by rookiesLab\null fastPow(ull b, ull power) {\n    ull result = 1;\n    while (power > 0) {\n        if (power % 2 == 1) result = (result * b);\n        b = (b * b);\n        power /= 2;\n    }\n    return result;\n}\null fastPowMod(ull b, ull power, ull mod) {\n    b %= mod;\n    ull result = 1;\n    while (power > 0) {\n        if (power % 2 == 1) result = (result * b) % mod;\n        b = (b * b) % mod;\n        power /= 2;\n    }\n    return result;\n}\nbl isInt(ld n) {\n    return n - (ll)n <= EPS;\n}/*\ntypedef struct {\n    void WriteLine(ll s) {\n        cout << s << '\\n';\n    }\n    void WriteLine(string s) {\n        cout << s << '\\n';\n    }\n    void WriteLine(int s) {\n        cout << s << '\\n';\n    }\n    void WriteLine(ld s) {\n        cout << s << '\\n';\n    }\n    void WriteLine(float s) {\n        cout << s << '\\n';\n    }\n    string ReadLine() {\n        str s; cin.ignore(); getline(cin, s);\n        return s;\n    }\n\n}Console;\ntypedef struct{\n    ld ToDouble(string s) {\n\n    }\n}Convert;*/\n#pragma endregion\nint main(void) {\n    setup;\n    ll n = get();\n    up(1, n + 1, 1) {\n        ll num = i * i;\n        for (ll j = 0; j < n - 1; j++, num += i) cout << num << ' ';\n        cout << num << '\\n';\n    }\n    stop;\n}\n\n// Run program: Ctrl + F5 or Debug > Start Without Debugging menu\n// Debug program: F5 or Debug > Start Debugging menu\n// Tips for Getting Started: \n//   1. Use the Solution Explorer window to add/manage files\n//   2. Use the Team Explorer window to connect to source control\n//   3. Use the Output window to see build output and other messages\n//   4. Use the Error List window to view errors\n//   5. Go to Project > Add New Item to create new code files, or Project > Add Existing Item to add existing code files to the project\n//   6. In the future, to open this project again, go to File > Open > Project and select the .sln file",
      "statement": "Write a program to read an integer [[N]] and output [[N]]^2 integers in the table format as follows:\n\n• The table should consist of [[N]] lines, i.e. line 1 to line [[N]].\n\n• Every line should contain [[N]] multiples of the line number, starting with <<line number squared>>, \ne.g.\n\n---- Line 1 should start with 1 * 1 = 1, and the subsequent multiples of 1 i.e. 2, 3, ... up to [[N]].\n\n---- Line 2 should start with 2 * 2 = 4, and the subsequent multiples of 2 i.e. 6, 8, ... up until there are [[N]] numbers in this line.\n\n• All numbers on the same line should be space-separated.",
      "testCases": [
        {
          "title": "1",
          "isTest": true,
          "testIn": "5",
          "testOut": "1 2 3 4 5\n4 6 8 10 12\n9 12 15 18 21\n16 20 24 28 32\n25 30 35 40 45",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Validator 1",
          "isTest": false,
          "testIn": "11",
          "testOut": "1 2 3 4 5 6 7 8 9 10 11\n4 6 8 10 12 14 16 18 20 22 24\n9 12 15 18 21 24 27 30 33 36 39\n16 20 24 28 32 36 40 44 48 52 56\n25 30 35 40 45 50 55 60 65 70 75\n36 42 48 54 60 66 72 78 84 90 96\n49 56 63 70 77 84 91 98 105 112 119\n64 72 80 88 96 104 112 120 128 136 144\n81 90 99 108 117 126 135 144 153 162 171\n100 110 120 130 140 150 160 170 180 190 200\n121 132 143 154 165 176 187 198 209 220 231",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "Test 2",
          "isTest": true,
          "testIn": "2",
          "testOut": "1 2\n4 6",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Validator 2",
          "isTest": false,
          "testIn": "12",
          "testOut": "1 2 3 4 5 6 7 8 9 10 11 12\n4 6 8 10 12 14 16 18 20 22 24 26\n9 12 15 18 21 24 27 30 33 36 39 42\n16 20 24 28 32 36 40 44 48 52 56 60\n25 30 35 40 45 50 55 60 65 70 75 80\n36 42 48 54 60 66 72 78 84 90 96 102\n49 56 63 70 77 84 91 98 105 112 119 126\n64 72 80 88 96 104 112 120 128 136 144 152\n81 90 99 108 117 126 135 144 153 162 171 180\n100 110 120 130 140 150 160 170 180 190 200 210\n121 132 143 154 165 176 187 198 209 220 231 242\n144 156 168 180 192 204 216 228 240 252 264 276",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "Test 3",
          "isTest": true,
          "testIn": "3",
          "testOut": "1 2 3\n4 6 8\n9 12 15",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Validator 3",
          "isTest": false,
          "testIn": "13",
          "testOut": "1 2 3 4 5 6 7 8 9 10 11 12 13\n4 6 8 10 12 14 16 18 20 22 24 26 28\n9 12 15 18 21 24 27 30 33 36 39 42 45\n16 20 24 28 32 36 40 44 48 52 56 60 64\n25 30 35 40 45 50 55 60 65 70 75 80 85\n36 42 48 54 60 66 72 78 84 90 96 102 108\n49 56 63 70 77 84 91 98 105 112 119 126 133\n64 72 80 88 96 104 112 120 128 136 144 152 160\n81 90 99 108 117 126 135 144 153 162 171 180 189\n100 110 120 130 140 150 160 170 180 190 200 210 220\n121 132 143 154 165 176 187 198 209 220 231 242 253\n144 156 168 180 192 204 216 228 240 252 264 276 288\n169 182 195 208 221 234 247 260 273 286 299 312 325",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "Test 4",
          "isTest": true,
          "testIn": "4",
          "testOut": "1 2 3 4\n4 6 8 10\n9 12 15 18\n16 20 24 28",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Validator 4",
          "isTest": false,
          "testIn": "14",
          "testOut": "1 2 3 4 5 6 7 8 9 10 11 12 13 14\n4 6 8 10 12 14 16 18 20 22 24 26 28 30\n9 12 15 18 21 24 27 30 33 36 39 42 45 48\n16 20 24 28 32 36 40 44 48 52 56 60 64 68\n25 30 35 40 45 50 55 60 65 70 75 80 85 90\n36 42 48 54 60 66 72 78 84 90 96 102 108 114\n49 56 63 70 77 84 91 98 105 112 119 126 133 140\n64 72 80 88 96 104 112 120 128 136 144 152 160 168\n81 90 99 108 117 126 135 144 153 162 171 180 189 198\n100 110 120 130 140 150 160 170 180 190 200 210 220 230\n121 132 143 154 165 176 187 198 209 220 231 242 253 264\n144 156 168 180 192 204 216 228 240 252 264 276 288 300\n169 182 195 208 221 234 247 260 273 286 299 312 325 338\n196 210 224 238 252 266 280 294 308 322 336 350 364 378",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "Test 5",
          "isTest": true,
          "testIn": "16",
          "testOut": "1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16\n4 6 8 10 12 14 16 18 20 22 24 26 28 30 32 34\n9 12 15 18 21 24 27 30 33 36 39 42 45 48 51 54\n16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76\n25 30 35 40 45 50 55 60 65 70 75 80 85 90 95 100\n36 42 48 54 60 66 72 78 84 90 96 102 108 114 120 126\n49 56 63 70 77 84 91 98 105 112 119 126 133 140 147 154\n64 72 80 88 96 104 112 120 128 136 144 152 160 168 176 184\n81 90 99 108 117 126 135 144 153 162 171 180 189 198 207 216\n100 110 120 130 140 150 160 170 180 190 200 210 220 230 240 250\n121 132 143 154 165 176 187 198 209 220 231 242 253 264 275 286\n144 156 168 180 192 204 216 228 240 252 264 276 288 300 312 324\n169 182 195 208 221 234 247 260 273 286 299 312 325 338 351 364\n196 210 224 238 252 266 280 294 308 322 336 350 364 378 392 406\n225 240 255 270 285 300 315 330 345 360 375 390 405 420 435 450\n256 272 288 304 320 336 352 368 384 400 416 432 448 464 480 496",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Validator 5",
          "isTest": false,
          "testIn": "15",
          "testOut": "1 2 3 4 5 6 7 8 9 10 11 12 13 14 15\n4 6 8 10 12 14 16 18 20 22 24 26 28 30 32\n9 12 15 18 21 24 27 30 33 36 39 42 45 48 51\n16 20 24 28 32 36 40 44 48 52 56 60 64 68 72\n25 30 35 40 45 50 55 60 65 70 75 80 85 90 95\n36 42 48 54 60 66 72 78 84 90 96 102 108 114 120\n49 56 63 70 77 84 91 98 105 112 119 126 133 140 147\n64 72 80 88 96 104 112 120 128 136 144 152 160 168 176\n81 90 99 108 117 126 135 144 153 162 171 180 189 198 207\n100 110 120 130 140 150 160 170 180 190 200 210 220 230 240\n121 132 143 154 165 176 187 198 209 220 231 242 253 264 275\n144 156 168 180 192 204 216 228 240 252 264 276 288 300 312\n169 182 195 208 221 234 247 260 273 286 299 312 325 338 351\n196 210 224 238 252 266 280 294 308 322 336 350 364 378 392\n225 240 255 270 285 300 315 330 345 360 375 390 405 420 435",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "Test 7",
          "isTest": true,
          "testIn": "7",
          "testOut": "1 2 3 4 5 6 7\n4 6 8 10 12 14 16\n9 12 15 18 21 24 27\n16 20 24 28 32 36 40\n25 30 35 40 45 50 55\n36 42 48 54 60 66 72\n49 56 63 70 77 84 91",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Validator 7",
          "isTest": false,
          "testIn": "8",
          "testOut": "1 2 3 4 5 6 7 8\n4 6 8 10 12 14 16 18\n9 12 15 18 21 24 27 30\n16 20 24 28 32 36 40 44\n25 30 35 40 45 50 55 60\n36 42 48 54 60 66 72 78\n49 56 63 70 77 84 91 98\n64 72 80 88 96 104 112 120",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "Test 8",
          "isTest": true,
          "testIn": "9",
          "testOut": "1 2 3 4 5 6 7 8 9\n4 6 8 10 12 14 16 18 20\n9 12 15 18 21 24 27 30 33\n16 20 24 28 32 36 40 44 48\n25 30 35 40 45 50 55 60 65\n36 42 48 54 60 66 72 78 84\n49 56 63 70 77 84 91 98 105\n64 72 80 88 96 104 112 120 128\n81 90 99 108 117 126 135 144 153",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Validator 8",
          "isTest": false,
          "testIn": "10",
          "testOut": "1 2 3 4 5 6 7 8 9 10\n4 6 8 10 12 14 16 18 20 22\n9 12 15 18 21 24 27 30 33 36\n16 20 24 28 32 36 40 44 48 52\n25 30 35 40 45 50 55 60 65 70\n36 42 48 54 60 66 72 78 84 90\n49 56 63 70 77 84 91 98 105 112\n64 72 80 88 96 104 112 120 128 136\n81 90 99 108 117 126 135 144 153 162\n100 110 120 130 140 150 160 170 180 190",
          "isValidator": true,
          "needValidation": true
        }
      ],
      "constraints": "1 <= [[N]] <= 100",
      "stubGenerator": "read n:int\nwrite answer",
      "inputDescription": "The input contains an integer [[N]].",
      "solutionLanguage": "C++",
      "outputDescription": "Print [[N]] lines: The table as specified in Goal section."
    },
    "draft": false,
    "readyForModeration": true,
    "statementHTML": "<div class=\"statement-body\">\n<div class=\"statement-section statement-goal\">\n   <h2><span class=\"icon icon-goal\">&nbsp;</span><span>Goal </span></h2>\n   <span class=\"question-statement\">Write a program to read an integer <var>N</var> and output <var>N</var>^2 integers in the table format as follows:<br><br>&bull; The table should consist of <var>N</var> lines, i.e. line 1 to line <var>N</var>.<br><br>&bull; Every line should contain <var>N</var> multiples of the line number, starting with <strong>line number squared</strong>, <br>e.g.<br><br>---- Line 1 should start with 1 * 1 = 1, and the subsequent multiples of 1 i.e. 2, 3, ... up to <var>N</var>.<br><br>---- Line 2 should start with 2 * 2 = 4, and the subsequent multiples of 2 i.e. 6, 8, ... up until there are <var>N</var> numbers in this line.<br><br>&bull; All numbers on the same line should be space-separated.</span>\n</div>\n<div class=\"statement-section statement-protocol\">\n   <div class=\"blk\">\n      <div class=\"title\">Input</div>\n      <div class=\"question-statement-input\">The input contains an integer <var>N</var>.</div>\n   </div>\n   <div class=\"blk\">\n      <div class=\"title\">Output</div>\n      <div class=\"question-statement-output\">Print <var>N</var> lines: The table as specified in Goal section.</div>\n   </div>\n   <div class=\"blk\">\n      <div class=\"title\">Constraints</div>\n      <div class=\"question-statement-constraints\">1 &lt;= <var>N</var> &lt;= 100</div>\n   </div>\n   <div class=\"blk\">\n      <div class=\"title\">Example</div>\n      <div class=\"statement-inout\">\n         <div class=\"statement-inout-in\">\n            <div class=\"title\">Input</div>\n            <pre class=\"question-statement-example-in\">5</pre>\n         </div>\n         <div class=\"statement-inout-out\">\n            <div class=\"title\">Output</div>\n            <pre class=\"question-statement-example-out\">1 2 3 4 5\n4 6 8 10 12\n9 12 15 18 21\n16 20 24 28 32\n25 30 35 40 45</pre>\n         </div>\n      </div>\n   </div>\n</div>"
  },
  "validatedFor": 94003790051,
  "avatar": 98078103304122,
  "commentCount": 12,
  "upVotes": 4,
  "downVotes": 0,
  "validateAction": {
    "actionId": 761548,
    "progress": 1,
    "alreadyDone": false
  },
  "statusHistory": [
    {
      "status": "ACCEPTED",
      "date": 1676725675449,
      "data": {
        "author": "ACTION"
      }
    }
  ],
  "editable": true,
  "draft": false,
  "readyForModeration": true
}