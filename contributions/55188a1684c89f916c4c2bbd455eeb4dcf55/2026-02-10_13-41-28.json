{
  "id": 5518,
  "activeVersion": 7,
  "score": 5,
  "votableId": 15243129,
  "codingamerId": 3933323,
  "views": 225,
  "commentableId": 15159555,
  "title": "Tree Paths",
  "status": "ACCEPTED",
  "type": "PUZZLE_INOUT",
  "nickname": "gareve",
  "publicHandle": "55188a1684c89f916c4c2bbd455eeb4dcf55",
  "codingamerHandle": "9e5366ccb595bcfa6ec33ec8128b3edb3233393",
  "lastVersion": {
    "version": 7,
    "autocloseTime": 1604372722630,
    "data": {
      "title": "Tree Paths",
      "topics": [
        {
          "id": 215,
          "handle": "binary-tree",
          "labelMap": {
            "1": "Binary Tree",
            "2": "Binary Tree"
          },
          "puzzleCount": 2,
          "parentTopicId": 93
        },
        {
          "id": 48,
          "handle": "graphs",
          "labelMap": {
            "1": "Graphes",
            "2": "Graphs"
          },
          "pageTitle": "Graphs: exercises and theory",
          "puzzleCount": 18,
          "parentTopicId": 40,
          "contentDetailsId": 75
        }
      ],
      "solution": "N = gets.to_i\nV = gets.to_i\nM = gets.to_i\n\nT = {}\nparent_count = [0]*(N+1)\nM.times do\n    x, l, r = gets.split.map(&:to_i)\n    T[x] = [l,r]\n    parent_count[l] += 1\n    parent_count[r] += 1\nend\n\nraise 'Broken Invariant' if parent_count.count(0) != 2 # Dummy Index 0 & root should be the only 0 values.\nraise 'Broken Invariant' if parent_count.count(0) + parent_count.count(1) != parent_count.size # No index should have more than 1 parent\nroot = parent_count.rindex(0) # Only node with 0 parents\nraise 'Broken Invariant' if root.nil? or root <= 0 or root > N\n\n# Basic tree traversal\nq = Queue.new\nq << [root, []] # index, path\nanswer = nil\nwhile !q.empty?\n    x,path = q.pop\n    raise 'Broken Invariant' if x <= 0 or x > N\n\n    if x == V\n        raise 'Broken Invariant' unless answer.nil?\n        answer = path\n    end\n\n    children = T[x]\n    next if children.nil? # No children\n    raise 'Broken invariant' if children.size != 2\n\n    q << [children[0], path + ['Left']]\n    q << [children[1], path + ['Right']]\nend\n\nraise 'Broken Invariant' if answer.nil?\nputs answer.empty? ? 'Root' : answer.join(' ')",
      "statement": "You are given a binary tree, where each node in the tree has two or zero children. If a node <<X>> has two children, they are called [[L]] Left &  [[R]] Right children respectively. <<X>> is a <<Parent>> of [[L]] and [[R]].\n\nAll trees have one root node, which is the only node without <<parent>>. All the other nodes have exactly one <<parent>>.\n\nAll tree nodes have assigned a unique number called <<index>>.\nGiven a tree and an index [[V]], <<print the path from the root to the tree node with index [[V]]>>\n\nA <<tree path>> starts at the root node, and it goes down by choosing the left or the right children until it arrives to the target value. Print the {{Left}} & {{Right}} elements from the path in a single line.\n\nFor instance, if we have the following tree.\n`\n     1\n    / \\\n   /   \\\n  2     \\\n / \\     3\n4   5   / \\\n       9   \\\n            8\n           / \\\n          6   7\n`\nFor this sample tree, <<Node 1>> is the root, the only one without parents.\nif [[V]] = 5, the Tree Path is {{Left Right}}\nif [[V]] = 7, the Tree Path is {{Right Right Right}}\nif [[V]] = 6, the Tree Path is {{Right Right Left}}",
      "testCases": [
        {
          "title": "Test 1",
          "isTest": true,
          "testIn": "3\n2\n1\n1 2 3",
          "testOut": "Left",
          "isValidator": false,
          "needValidation": false
        },
        {
          "title": "Validator 1",
          "isTest": false,
          "testIn": "3\n3\n1\n2 3 1",
          "testOut": "Left",
          "isValidator": true,
          "needValidation": false
        },
        {
          "title": "Test 2",
          "isTest": true,
          "testIn": "3\n3\n1\n1 2 3",
          "testOut": "Right",
          "isValidator": false,
          "needValidation": false
        },
        {
          "title": "Validator 2",
          "isTest": false,
          "testIn": "3\n1\n1\n3 2 1",
          "testOut": "Right",
          "isValidator": true,
          "needValidation": false
        },
        {
          "title": "Test 3",
          "isTest": true,
          "testIn": "3\n3\n1\n3 2 1",
          "testOut": "Root",
          "isValidator": false,
          "needValidation": false
        },
        {
          "title": "Validator 3",
          "isTest": false,
          "testIn": "3\n1\n1\n1 2 3",
          "testOut": "Root",
          "isValidator": true,
          "needValidation": false
        },
        {
          "title": "Test 4",
          "isTest": true,
          "testIn": "9\n9\n4\n1 2 3\n2 4 5\n3 9 8\n8 6 7",
          "testOut": "Right Left",
          "isValidator": false,
          "needValidation": false
        },
        {
          "title": "Validator 4",
          "isTest": false,
          "testIn": "9\n6\n4\n1 2 3\n2 4 5\n3 9 8\n8 6 7",
          "testOut": "Right Right Left",
          "isValidator": true,
          "needValidation": false
        },
        {
          "title": "Test 5",
          "isTest": true,
          "testIn": "63\n56\n31\n1 2 3\n2 4 5\n3 6 7\n4 8 9\n5 10 11\n6 12 13\n7 14 15\n8 16 17\n9 18 19\n10 20 21\n11 22 23\n12 24 25\n13 26 27\n14 28 29\n15 30 31\n16 32 33\n17 34 35\n18 36 37\n19 38 39\n20 40 41\n21 42 43\n22 44 45\n23 46 47\n24 48 49\n25 50 51\n26 52 53\n27 54 55\n28 56 57\n29 58 59\n30 60 61\n31 62 63",
          "testOut": "Right Right Left Left Left",
          "isValidator": false,
          "needValidation": false
        },
        {
          "title": "Validator 5",
          "isTest": false,
          "testIn": "127\n114\n63\n1 2 3\n2 4 5\n3 6 7\n4 8 9\n5 10 11\n6 12 13\n7 14 15\n8 16 17\n9 18 19\n10 20 21\n11 22 23\n12 24 25\n13 26 27\n14 28 29\n15 30 31\n16 32 33\n17 34 35\n18 36 37\n19 38 39\n20 40 41\n21 42 43\n22 44 45\n23 46 47\n24 48 49\n25 50 51\n26 52 53\n27 54 55\n28 56 57\n29 58 59\n30 60 61\n31 62 63\n32 64 65\n33 66 67\n34 68 69\n35 70 71\n36 72 73\n37 74 75\n38 76 77\n39 78 79\n40 80 81\n41 82 83\n42 84 85\n43 86 87\n44 88 89\n45 90 91\n46 92 93\n47 94 95\n48 96 97\n49 98 99\n50 100 101\n51 102 103\n52 104 105\n53 106 107\n54 108 109\n55 110 111\n56 112 113\n57 114 115\n58 116 117\n59 118 119\n60 120 121\n61 122 123\n62 124 125\n63 126 127",
          "testOut": "Right Right Left Left Right Left",
          "isValidator": true,
          "needValidation": false
        }
      ],
      "difficulty": "easy",
      "constraints": "All [[N]] node indexes are unique and go from 1 to [[N]].\nAll tree nodes belong to a single tree.\n\n0 < [[N]] < 128\n1 ≤ [[V]], [[P]], [[L]], [[R]] ≤ [[N]]",
      "coverBinaryId": 51198002761072,
      "stubGenerator": "read N:int\nread V:int\nread M:int\n\nloop M read P:int L:int R:int\n\nwrite tree_path",
      "inputDescription": "<<Line 1: >> Integer [[N]], the number of nodes in the tree.\n<<Line 2: >> Integer [[V]], the index of the target node.\n<<Line 3: >> Integer [[M]], the number of nodes with two children.\n<<Followed by [[M]] lines>> containing three numbers [[P]] [[L]] [[R]] each:\n[[P]] is the node index\n[[L]] is the left children of [[P]]\n[[R]] is the right children of [[P]]",
      "solutionLanguage": "Ruby",
      "outputDescription": "A sequence of {{Left}} and {{Right}} commands in a single line, representing the tree path from the root node, to the target node [[V]].\n\nIf the target node [[V]] is the root, print {{Root}}."
    },
    "draft": false,
    "readyForModeration": true,
    "statementHTML": "<div class=\"statement-body\">\n<div class=\"statement-section statement-goal\">\n   <h2><span class=\"icon icon-goal\">&nbsp;</span><span>Goal </span></h2>\n   <span class=\"question-statement\">You are given a binary tree, where each node in the tree has two or zero children. If a node <strong>X</strong> has two children, they are called <var>L</var> Left &amp;  <var>R</var> Right children respectively. <strong>X</strong> is a <strong>Parent</strong> of <var>L</var> and <var>R</var>.<br><br>All trees have one root node, which is the only node without <strong>parent</strong>. All the other nodes have exactly one <strong>parent</strong>.<br><br>All tree nodes have assigned a unique number called <strong>index</strong>.<br>Given a tree and an index <var>V</var>, <strong>print the path from the root to the tree node with index <var>V</var></strong><br><br>A <strong>tree path</strong> starts at the root node, and it goes down by choosing the left or the right children until it arrives to the target value. Print the <const>Left</const> &amp; <const>Right</const> elements from the path in a single line.<br><br>For instance, if we have the following tree.<br><pre style=\"font-family: monospace\"><br>     1<br>    / \\<br>   /   \\<br>  2     \\<br> / \\     3<br>4   5   / \\<br>       9   \\<br>            8<br>           / \\<br>          6   7<br></pre><br>For this sample tree, <strong>Node 1</strong> is the root, the only one without parents.<br>if <var>V</var> = 5, the Tree Path is <const>Left Right</const><br>if <var>V</var> = 7, the Tree Path is <const>Right Right Right</const><br>if <var>V</var> = 6, the Tree Path is <const>Right Right Left</const></span>\n</div>\n<div class=\"statement-section statement-protocol\">\n   <div class=\"blk\">\n      <div class=\"title\">Input</div>\n      <div class=\"question-statement-input\"><strong>Line 1: </strong> Integer <var>N</var>, the number of nodes in the tree.<br><strong>Line 2: </strong> Integer <var>V</var>, the index of the target node.<br><strong>Line 3: </strong> Integer <var>M</var>, the number of nodes with two children.<br><strong>Followed by <var>M</var> lines</strong> containing three numbers <var>P</var> <var>L</var> <var>R</var> each:<br><var>P</var> is the node index<br><var>L</var> is the left children of <var>P</var><br><var>R</var> is the right children of <var>P</var></div>\n   </div>\n   <div class=\"blk\">\n      <div class=\"title\">Output</div>\n      <div class=\"question-statement-output\">A sequence of <const>Left</const> and <const>Right</const> commands in a single line, representing the tree path from the root node, to the target node <var>V</var>.<br><br>If the target node <var>V</var> is the root, print <const>Root</const>.</div>\n   </div>\n   <div class=\"blk\">\n      <div class=\"title\">Constraints</div>\n      <div class=\"question-statement-constraints\">All <var>N</var> node indexes are unique and go from 1 to <var>N</var>.<br>All tree nodes belong to a single tree.<br><br>0 &lt; <var>N</var> &lt; 128<br>1 &le; <var>V</var>, <var>P</var>, <var>L</var>, <var>R</var> &le; <var>N</var></div>\n   </div>\n   <div class=\"blk\">\n      <div class=\"title\">Example</div>\n      <div class=\"statement-inout\">\n         <div class=\"statement-inout-in\">\n            <div class=\"title\">Input</div>\n            <pre class=\"question-statement-example-in\">3\n2\n1\n1 2 3</pre>\n         </div>\n         <div class=\"statement-inout-out\">\n            <div class=\"title\">Output</div>\n            <pre class=\"question-statement-example-out\">Left</pre>\n         </div>\n      </div>\n   </div>\n</div>"
  },
  "validatedFor": 167433504478,
  "avatar": 48508700385008,
  "commentCount": 11,
  "upVotes": 6,
  "downVotes": 1,
  "validateAction": {
    "actionId": 499609,
    "progress": 1,
    "alreadyDone": false
  },
  "statusHistory": [
    {
      "status": "ACCEPTED",
      "date": 1603297382609,
      "data": {
        "author": "ACTION"
      }
    }
  ],
  "editable": true,
  "draft": false,
  "readyForModeration": true
}