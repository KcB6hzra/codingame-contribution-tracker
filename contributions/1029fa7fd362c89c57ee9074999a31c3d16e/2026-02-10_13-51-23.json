{
  "id": 1029,
  "activeVersion": 5,
  "score": 3,
  "votableId": 6843979,
  "codingamerId": 2178794,
  "views": 283,
  "commentableId": 6782869,
  "title": "Format string validation",
  "status": "ACCEPTED",
  "type": "PUZZLE_INOUT",
  "nickname": "Unihedron",
  "publicHandle": "1029fa7fd362c89c57ee9074999a31c3d16e",
  "codingamerHandle": "1d1729a2d8c008c6cf728ee88f1faa6d4978712",
  "lastVersion": {
    "version": 5,
    "data": {
      "title": "Format string validation",
      "topics": [],
      "solution": "var text = readline();\nvar format = readline();\n\nconst cols = text.length;\nconst rows = format.length;\n\nvar dp = Array(cols+1).fill(0).map(_ => []);\n\ndp[0][0] = true;\nfor (var i = 0; i <= cols; i++)\n    for (var j = 0; j < rows; j++)\n        if (dp[i][j])\n            if (format[j] == '~') \n                for (var k = 0; k <= cols - i; k++)\n                    dp[i + k][j + 1] = true;\n            else if (i < cols && `${text[i]}?`.includes(format[j]))\n                dp[i + 1][j + 1] = true;\n\nprint(dp[cols][rows] ? 'MATCH' : 'FAIL');",
      "statement": "You are given a line of [[text]] and a \"string format\". The [[format]] seems to be heavily inspired from <<LIKE clauses from SQL>> and uses two special characters, {{?}} and {{~}}:\n\n{{?}}: Matches exactly one character.\n{{~}}: Matches any number of characters, from zero (none) to the entire string.\n<<Any other characters:>> Matches exactly that character.\n\nIt seems that the format <<does not include escaping special characters>> (good for you!) so {{?}} and {{~}} in [[text]] may only be matched by {{?}} and {{~}} under the right circumstances. The backslash character will match only the backslash character itself.\n\nThe [[text]] is considered to {{MATCH}} if the [[format]] describes the [[text]] <<from start to end>> with no characters rejected by the pattern. If it does not match, write {{FAIL}} instead.",
      "testCases": [
        {
          "title": "Any word",
          "isTest": true,
          "testIn": "Clash of Code\n~ of ~",
          "testOut": "MATCH",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Any word",
          "isTest": false,
          "testIn": "Around the Horn\n~ the ~",
          "testOut": "MATCH",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "Any letter",
          "isTest": true,
          "testIn": "CARAMEL\n~R?ME?~",
          "testOut": "MATCH",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Any letter",
          "isTest": false,
          "testIn": "DATABASE\n~T?BA?~",
          "testOut": "MATCH",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "Wrong letter",
          "isTest": true,
          "testIn": "Candy\n?a?a?",
          "testOut": "FAIL",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Wrong letter",
          "isTest": false,
          "testIn": "Power\n?o?o?",
          "testOut": "FAIL",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "Wrong part",
          "isTest": true,
          "testIn": "Amazing\n~bing",
          "testOut": "FAIL",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Wrong part",
          "isTest": false,
          "testIn": "Carnival\n~eval",
          "testOut": "FAIL",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "Technically correct",
          "isTest": true,
          "testIn": "~?~\n?~?",
          "testOut": "MATCH",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Also correct",
          "isTest": false,
          "testIn": "?~?\n~?~",
          "testOut": "MATCH",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "Upping the Ante",
          "isTest": true,
          "testIn": "J8EA_^?RoU=t\\dZ\"<S\"gkJfS\nJ?EA_^~=t\\d~k?f~",
          "testOut": "MATCH",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Ante Upped",
          "isTest": false,
          "testIn": "BH9*$7D+~1r\\nMz *b*jV\nB?9*$~1r\\n?z ~",
          "testOut": "MATCH",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "Out of bounds",
          "isTest": true,
          "testIn": ";Z8Rx3u4)i~ax;20*7:B|3^\n~u4)i?a?;?*~",
          "testOut": "FAIL",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Fail this",
          "isTest": false,
          "testIn": "}`b3Cq=lKl)qhps`h(2=1<%!\n~q=l?l?q?s?h~",
          "testOut": "FAIL",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "Let's not jump to hasty conclusions",
          "isTest": true,
          "testIn": "IboJSRam>|6&V17T_M|pw`w)m,<ns8{%9G5%%WT\"S=f}k`ztLQ^eP-T/P-u@?LGbWjnmE/JB<cGY4a)hPIX.oVb,V>k#vMQ5pL=iqISz8\"QqXe_:3^;!Y#JnQ?RS^E$8>[$I !=:MHz;;hBX;pbh> q93fNuKHK8j1kQzT0WxQ54BcKC22(&`\\39Ti/J\"A;I+GYLO1HqvWJF0';8-Y6Wb8YU]Qf}*^5z2]MsbYB!,=RSq+1g)[z&[]kZ<T,>X!?z/_e].N<yEuo\nIbo~>|6&~pw~)m~{~-u@?LGbWjnm?/JB<c~q?~>[$I !=:M~X;p~K?j~0~2~\\39T?/?\"A;I+~v~W~[z&[]kZ<~>X!?z/_~u?",
          "testOut": "MATCH",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Big case",
          "isTest": false,
          "testIn": "IboJSRam>|6&V17T_M|pw`w)m,<ns8{%9G5%%WT\"S=f}k`ztLQ^eP-T/P-u@?LGbWjnmE/JB<cGY4a)hPIX.oVb,V>k#vMQ5pL=iqISz8\"QqXe_:3^;!Y#JnQ?RS^E$8>[$I !=:MHz;;hBX;pbh> q93fNuKHK8j1kQzT0WxQ54BcKC22(&`\\39Ti/J\"A;I+GYLO1HqvWJF0';8-Y6Wb8YU]Qf}*^5z2]MsbYB!,=RSq+1g)[z&[]kZ<T,>X!?z/_e].N<yEuo\nIbo~>|6&~pw~@?LG~m?/JB<c~.oVb,V>k#vMQ~>[$I !=:M~X;p~K8j~0~2~T~Wb8YU~5z~?+1g)[z&[]kZ<~>X!?z/_e~uo",
          "testOut": "MATCH",
          "isValidator": true,
          "needValidation": true
        }
      ],
      "difficulty": "medium",
      "constraints": "[[Text]], [[Format]] are both composed of ASCII characters only\n0 < Length of [[Text]] < 1000\n0 < Length of [[Format]] < 100",
      "coverBinaryId": 31765148722444,
      "stubGenerator": "read text:string(1000)\nread format:string(100)\nwrite MATCH OR FAIL",
      "inputDescription": "<<Line 1:>> [[Text]], a String\n<<Line 2:>> [[Format]], a String",
      "solutionLanguage": "Javascript",
      "outputDescription": "One of either {{MATCH}} or {{FAIL}}, depending on whether [[Format]] describes [[Text]] fully."
    },
    "draft": false,
    "readyForModeration": true,
    "statementHTML": "<div class=\"statement-body\">\n<div class=\"statement-section statement-goal\">\n   <h2><span class=\"icon icon-goal\">&nbsp;</span><span>Goal </span></h2>\n   <span class=\"question-statement\">You are given a line of <var>text</var> and a &quot;string format&quot;. The <var>format</var> seems to be heavily inspired from <strong>LIKE clauses from SQL</strong> and uses two special characters, <const>?</const> and <const>~</const>:<br><br><const>?</const>: Matches exactly one character.<br><const>~</const>: Matches any number of characters, from zero (none) to the entire string.<br><strong>Any other characters:</strong> Matches exactly that character.<br><br>It seems that the format <strong>does not include escaping special characters</strong> (good for you!) so <const>?</const> and <const>~</const> in <var>text</var> may only be matched by <const>?</const> and <const>~</const> under the right circumstances. The backslash character will match only the backslash character itself.<br><br>The <var>text</var> is considered to <const>MATCH</const> if the <var>format</var> describes the <var>text</var> <strong>from start to end</strong> with no characters rejected by the pattern. If it does not match, write <const>FAIL</const> instead.</span>\n</div>\n<div class=\"statement-section statement-protocol\">\n   <div class=\"blk\">\n      <div class=\"title\">Input</div>\n      <div class=\"question-statement-input\"><strong>Line 1:</strong> <var>Text</var>, a String<br><strong>Line 2:</strong> <var>Format</var>, a String</div>\n   </div>\n   <div class=\"blk\">\n      <div class=\"title\">Output</div>\n      <div class=\"question-statement-output\">One of either <const>MATCH</const> or <const>FAIL</const>, depending on whether <var>Format</var> describes <var>Text</var> fully.</div>\n   </div>\n   <div class=\"blk\">\n      <div class=\"title\">Constraints</div>\n      <div class=\"question-statement-constraints\"><var>Text</var>, <var>Format</var> are both composed of ASCII characters only<br>0 &lt; Length of <var>Text</var> &lt; 1000<br>0 &lt; Length of <var>Format</var> &lt; 100</div>\n   </div>\n   <div class=\"blk\">\n      <div class=\"title\">Example</div>\n      <div class=\"statement-inout\">\n         <div class=\"statement-inout-in\">\n            <div class=\"title\">Input</div>\n            <pre class=\"question-statement-example-in\">Clash of Code\n~ of ~</pre>\n         </div>\n         <div class=\"statement-inout-out\">\n            <div class=\"title\">Output</div>\n            <pre class=\"question-statement-example-out\">MATCH</pre>\n         </div>\n      </div>\n   </div>\n</div>"
  },
  "validatedFor": 254177665178,
  "avatar": 17500773502453,
  "commentCount": 15,
  "upVotes": 4,
  "downVotes": 1,
  "validateAction": {
    "actionId": 180019,
    "progress": 1,
    "alreadyDone": false
  },
  "statusHistory": [],
  "editable": true,
  "draft": false,
  "readyForModeration": true
}