{
  "id": 44400,
  "activeVersion": 22,
  "score": 25,
  "votableId": 27492127,
  "codingamerId": 3882482,
  "views": 325,
  "commentableId": 27364781,
  "title": "Duo combinations",
  "status": "ACCEPTED",
  "type": "PUZZLE_INOUT",
  "nickname": "Harshit_Gupta",
  "publicHandle": "444003c378ae1693cd64fa0ee55052d59e9b9",
  "codingamerHandle": "2e8c4a0117c99cbda49c7a2b38d690052842883",
  "lastVersion": {
    "version": 22,
    "autocloseTime": 1680144030297,
    "data": {
      "title": "Duo combinations",
      "topics": [
        {
          "id": 182,
          "handle": "combinatorics",
          "category": "ADVANCED",
          "labelMap": {
            "1": "Combinatoire",
            "2": "Combinatorics"
          },
          "puzzleCount": 9,
          "parentTopicId": 93
        },
        {
          "id": 73,
          "handle": "strings",
          "category": "FUNDAMENTALS",
          "labelMap": {
            "1": "Chaînes de caractères",
            "2": "Strings"
          },
          "pageTitle": "Strings: exercises and theory",
          "puzzleCount": 41,
          "parentTopicId": 41,
          "contentDetailsId": 73
        },
        {
          "id": 69,
          "handle": "pattern-recognition",
          "category": "ADVANCED",
          "labelMap": {
            "1": "Reconnaissance de motifs",
            "2": "Pattern recognition"
          },
          "pageTitle": "Pattern recognition: exercises and theory",
          "puzzleCount": 14,
          "parentTopicId": 41,
          "contentDetailsId": 88
        },
        {
          "id": 78,
          "handle": "radix",
          "category": "INTERMEDIATE",
          "labelMap": {
            "1": "Base arithmétique",
            "2": "Radix"
          },
          "pageTitle": "Radix: exercises and theory",
          "puzzleCount": 7,
          "parentTopicId": 43,
          "contentDetailsId": 107
        }
      ],
      "solution": "# Capturing input\ntotal_characters = int(input())\ncharacters = [ input() for character in range(total_characters) ]\n\n# Using binary_sequence of total_characters bits\nbinary_sequence = [ f\"{number:0{total_characters}b}\" for number in range(2**total_characters) ]\n\n# One way of generating combinations\ncombinations = []\nfor index in range(1, total_characters):\n  pseudo0, pseudo1 = characters[index-1], characters[index]\n  for binary in binary_sequence:\n    combinations.append(binary.replace('0', pseudo0).replace('1',pseudo1))\n  if index==1: binary_sequence = binary_sequence[1:]     # Eliminating all zeroes after first iteration to prevent combination duplication\n\n# Output\nfor combination in combinations:print(combination)",
      "statement": "We as programmers know about the binary, which machine understands. A Binary combination of 0 and 1 for <<n>> bits holds 2<<ⁿ>> combinations. For example, 3-bit combinations will be: {{ 000, 001, 010, 011, 100, 101, 110, 111 }}.\n\nNow, what if the bits change? It would still be a binary or a duo combination of the symbols used. To get over the usual 0-1 as digits or symbols, let's attempt using several distinct special character symbols for the sake of modification. With various symbols provided, use every character in place of {{0}} bit with its following character as bit {{1}}. As last character would not have any character following it, do not try to have its circular pairing with first one.\n\nAs a quick clarification, refer to the following examples:\n- If characters are {{@}}, {{$}}, pair up {{@}} with {{$}}.\n- If characters are {{@}}, {{$}}, {{#}}, pair up {{@}} with {{$}}, followed by {{$}} with {{#}}.\n- If characters are {{@}}, {{$}}, {{#}}, {{%}}, pair up {{@}} as <<0>> with {{$}} for <<1>>, followed by {{$}} as <<0>> with {{#}} for <<1>> and then {{#}} as <<0>> with {{%}} as <<1>>.\nand so on ...\nNote: In case you just receive a single character, just use the same character instead of empty output.\n\nGiven some distinct symbols as input, try to output all the unique combinations of all the two adjacent symbols as bits. Feel free to make use of any binary sequences generation techniques or come up with your own edition to match the order of desired output.",
      "testCases": [
        {
          "title": "Test 1: Basic",
          "isTest": true,
          "testIn": "2\n*\n#",
          "testOut": "**\n*#\n#*\n##",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Validator 1: Another simple one",
          "isTest": false,
          "testIn": "2\n#\n*",
          "testOut": "##\n#*\n*#\n**",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "Test 2: Couple of pairs",
          "isTest": true,
          "testIn": "3\n^\n@\n$",
          "testOut": "^^^\n^^@\n^@^\n^@@\n@^^\n@^@\n@@^\n@@@\n@@$\n@$@\n@$$\n$@@\n$@$\n$$@\n$$$",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Validator 2: Symbol Group",
          "isTest": false,
          "testIn": "3\n!\n@\n#",
          "testOut": "!!!\n!!@\n!@!\n!@@\n@!!\n@!@\n@@!\n@@@\n@@#\n@#@\n@##\n#@@\n#@#\n##@\n###",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "Test 3: New symbols",
          "isTest": true,
          "testIn": "3\n%\n()\n[]",
          "testOut": "%%%\n%%()\n%()%\n%()()\n()%%\n()%()\n()()%\n()()()\n()()[]\n()[]()\n()[][]\n[]()()\n[]()[]\n[][]()\n[][][]",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Validator 3: Similar symbols",
          "isTest": false,
          "testIn": "3\n\\\n()\n[]",
          "testOut": "\\\\\\\n\\\\()\n\\()\\\n\\()()\n()\\\\\n()\\()\n()()\\\n()()()\n()()[]\n()[]()\n()[][]\n[]()()\n[]()[]\n[][]()\n[][][]",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "Test 4: Other symbols",
          "isTest": true,
          "testIn": "3\n*\n&\n^",
          "testOut": "***\n**&\n*&*\n*&&\n&**\n&*&\n&&*\n&&&\n&&^\n&^&\n&^^\n^&&\n^&^\n^^&\n^^^",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Validator 4: Matching other symbols",
          "isTest": false,
          "testIn": "3\n^\n&\n*",
          "testOut": "^^^\n^^&\n^&^\n^&&\n&^^\n&^&\n&&^\n&&&\n&&*\n&*&\n&**\n*&&\n*&*\n**&\n***",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "Test 5: More symbols",
          "isTest": true,
          "testIn": "4\n*\n&\n^\n%",
          "testOut": "****\n***&\n**&*\n**&&\n*&**\n*&*&\n*&&*\n*&&&\n&***\n&**&\n&*&*\n&*&&\n&&**\n&&*&\n&&&*\n&&&&\n&&&^\n&&^&\n&&^^\n&^&&\n&^&^\n&^^&\n&^^^\n^&&&\n^&&^\n^&^&\n^&^^\n^^&&\n^^&^\n^^^&\n^^^^\n^^^%\n^^%^\n^^%%\n^%^^\n^%^%\n^%%^\n^%%%\n%^^^\n%^^%\n%^%^\n%^%%\n%%^^\n%%^%\n%%%^\n%%%%",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Validator 5: More symbols",
          "isTest": false,
          "testIn": "5\n*\n&\n^\n%\n@",
          "testOut": "*****\n****&\n***&*\n***&&\n**&**\n**&*&\n**&&*\n**&&&\n*&***\n*&**&\n*&*&*\n*&*&&\n*&&**\n*&&*&\n*&&&*\n*&&&&\n&****\n&***&\n&**&*\n&**&&\n&*&**\n&*&*&\n&*&&*\n&*&&&\n&&***\n&&**&\n&&*&*\n&&*&&\n&&&**\n&&&*&\n&&&&*\n&&&&&\n&&&&^\n&&&^&\n&&&^^\n&&^&&\n&&^&^\n&&^^&\n&&^^^\n&^&&&\n&^&&^\n&^&^&\n&^&^^\n&^^&&\n&^^&^\n&^^^&\n&^^^^\n^&&&&\n^&&&^\n^&&^&\n^&&^^\n^&^&&\n^&^&^\n^&^^&\n^&^^^\n^^&&&\n^^&&^\n^^&^&\n^^&^^\n^^^&&\n^^^&^\n^^^^&\n^^^^^\n^^^^%\n^^^%^\n^^^%%\n^^%^^\n^^%^%\n^^%%^\n^^%%%\n^%^^^\n^%^^%\n^%^%^\n^%^%%\n^%%^^\n^%%^%\n^%%%^\n^%%%%\n%^^^^\n%^^^%\n%^^%^\n%^^%%\n%^%^^\n%^%^%\n%^%%^\n%^%%%\n%%^^^\n%%^^%\n%%^%^\n%%^%%\n%%%^^\n%%%^%\n%%%%^\n%%%%%\n%%%%@\n%%%@%\n%%%@@\n%%@%%\n%%@%@\n%%@@%\n%%@@@\n%@%%%\n%@%%@\n%@%@%\n%@%@@\n%@@%%\n%@@%@\n%@@@%\n%@@@@\n@%%%%\n@%%%@\n@%%@%\n@%%@@\n@%@%%\n@%@%@\n@%@@%\n@%@@@\n@@%%%\n@@%%@\n@@%@%\n@@%@@\n@@@%%\n@@@%@\n@@@@%\n@@@@@",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "Test 6: Extended output",
          "isTest": true,
          "testIn": "5\n.\n:\n/\n!\n\\",
          "testOut": ".....\n....:\n...:.\n...::\n..:..\n..:.:\n..::.\n..:::\n.:...\n.:..:\n.:.:.\n.:.::\n.::..\n.::.:\n.:::.\n.::::\n:....\n:...:\n:..:.\n:..::\n:.:..\n:.:.:\n:.::.\n:.:::\n::...\n::..:\n::.:.\n::.::\n:::..\n:::.:\n::::.\n:::::\n::::/\n:::/:\n::://\n::/::\n::/:/\n:://:\n::///\n:/:::\n:/::/\n:/:/:\n:/://\n://::\n://:/\n:///:\n:////\n/::::\n/:::/\n/::/:\n/:://\n/:/::\n/:/:/\n/://:\n/:///\n//:::\n//::/\n//:/:\n//://\n///::\n///:/\n////:\n/////\n////!\n///!/\n///!!\n//!//\n//!/!\n//!!/\n//!!!\n/!///\n/!//!\n/!/!/\n/!/!!\n/!!//\n/!!/!\n/!!!/\n/!!!!\n!////\n!///!\n!//!/\n!//!!\n!/!//\n!/!/!\n!/!!/\n!/!!!\n!!///\n!!//!\n!!/!/\n!!/!!\n!!!//\n!!!/!\n!!!!/\n!!!!!\n!!!!\\\n!!!\\!\n!!!\\\\\n!!\\!!\n!!\\!\\\n!!\\\\!\n!!\\\\\\\n!\\!!!\n!\\!!\\\n!\\!\\!\n!\\!\\\\\n!\\\\!!\n!\\\\!\\\n!\\\\\\!\n!\\\\\\\\\n\\!!!!\n\\!!!\\\n\\!!\\!\n\\!!\\\\\n\\!\\!!\n\\!\\!\\\n\\!\\\\!\n\\!\\\\\\\n\\\\!!!\n\\\\!!\\\n\\\\!\\!\n\\\\!\\\\\n\\\\\\!!\n\\\\\\!\\\n\\\\\\\\!\n\\\\\\\\\\",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Validator 6: Large output",
          "isTest": false,
          "testIn": "5\n:\n.\n%\n\\\n!",
          "testOut": ":::::\n::::.\n:::.:\n:::..\n::.::\n::.:.\n::..:\n::...\n:.:::\n:.::.\n:.:.:\n:.:..\n:..::\n:..:.\n:...:\n:....\n.::::\n.:::.\n.::.:\n.::..\n.:.::\n.:.:.\n.:..:\n.:...\n..:::\n..::.\n..:.:\n..:..\n...::\n...:.\n....:\n.....\n....%\n...%.\n...%%\n..%..\n..%.%\n..%%.\n..%%%\n.%...\n.%..%\n.%.%.\n.%.%%\n.%%..\n.%%.%\n.%%%.\n.%%%%\n%....\n%...%\n%..%.\n%..%%\n%.%..\n%.%.%\n%.%%.\n%.%%%\n%%...\n%%..%\n%%.%.\n%%.%%\n%%%..\n%%%.%\n%%%%.\n%%%%%\n%%%%\\\n%%%\\%\n%%%\\\\\n%%\\%%\n%%\\%\\\n%%\\\\%\n%%\\\\\\\n%\\%%%\n%\\%%\\\n%\\%\\%\n%\\%\\\\\n%\\\\%%\n%\\\\%\\\n%\\\\\\%\n%\\\\\\\\\n\\%%%%\n\\%%%\\\n\\%%\\%\n\\%%\\\\\n\\%\\%%\n\\%\\%\\\n\\%\\\\%\n\\%\\\\\\\n\\\\%%%\n\\\\%%\\\n\\\\%\\%\n\\\\%\\\\\n\\\\\\%%\n\\\\\\%\\\n\\\\\\\\%\n\\\\\\\\\\\n\\\\\\\\!\n\\\\\\!\\\n\\\\\\!!\n\\\\!\\\\\n\\\\!\\!\n\\\\!!\\\n\\\\!!!\n\\!\\\\\\\n\\!\\\\!\n\\!\\!\\\n\\!\\!!\n\\!!\\\\\n\\!!\\!\n\\!!!\\\n\\!!!!\n!\\\\\\\\\n!\\\\\\!\n!\\\\!\\\n!\\\\!!\n!\\!\\\\\n!\\!\\!\n!\\!!\\\n!\\!!!\n!!\\\\\\\n!!\\\\!\n!!\\!\\\n!!\\!!\n!!!\\\\\n!!!\\!\n!!!!\\\n!!!!!",
          "isValidator": true,
          "needValidation": true
        }
      ],
      "difficulty": "easy",
      "constraints": "[[character]] symbols belong to { {{!}}, {{@}}, {{#}}, {{$}}, {{%}}, {{^}}, {{&}}, {{*}}, {{()}}, {{[]}}, {{:}}, {{.}}, {{\\}}, {{/}} }\n1 < [[total]] count of symbols (per testcase) < 10",
      "coverBinaryId": 97464304264141,
      "stubGenerator": "read total:int\nloop total read symbol:string(2)\n\nwrite combination(s)",
      "inputDescription": "<<Line 1>> contains an integer [[total]]\n<<Next [[total]] lines>> contain one [[character]] symbol to be used as a bit with its adjacent symbols.",
      "solutionLanguage": "Python3",
      "outputDescription": "Various possible combinations with each combination in a separate line, having same length as the total number of given symbols, and formed with characters in adjacent rows of a given symbol."
    },
    "draft": false,
    "readyForModeration": true,
    "statementHTML": "<div class=\"statement-body\">\n<div class=\"statement-section statement-goal\">\n   <h2><span class=\"icon icon-goal\">&nbsp;</span><span>Goal </span></h2>\n   <span class=\"question-statement\">We as programmers know about the binary, which machine understands. A Binary combination of 0 and 1 for <strong>n</strong> bits holds 2<strong>ⁿ</strong> combinations. For example, 3-bit combinations will be: <const> 000, 001, 010, 011, 100, 101, 110, 111 </const>.<br><br>Now, what if the bits change? It would still be a binary or a duo combination of the symbols used. To get over the usual 0-1 as digits or symbols, let's attempt using several distinct special character symbols for the sake of modification. With various symbols provided, use every character in place of <const>0</const> bit with its following character as bit <const>1</const>. As last character would not have any character following it, do not try to have its circular pairing with first one.<br><br>As a quick clarification, refer to the following examples:<br>- If characters are <const>@</const>, <const>$</const>, pair up <const>@</const> with <const>$</const>.<br>- If characters are <const>@</const>, <const>$</const>, <const>#</const>, pair up <const>@</const> with <const>$</const>, followed by <const>$</const> with <const>#</const>.<br>- If characters are <const>@</const>, <const>$</const>, <const>#</const>, <const>%</const>, pair up <const>@</const> as <strong>0</strong> with <const>$</const> for <strong>1</strong>, followed by <const>$</const> as <strong>0</strong> with <const>#</const> for <strong>1</strong> and then <const>#</const> as <strong>0</strong> with <const>%</const> as <strong>1</strong>.<br>and so on ...<br>Note: In case you just receive a single character, just use the same character instead of empty output.<br><br>Given some distinct symbols as input, try to output all the unique combinations of all the two adjacent symbols as bits. Feel free to make use of any binary sequences generation techniques or come up with your own edition to match the order of desired output.</span>\n</div>\n<div class=\"statement-section statement-protocol\">\n   <div class=\"blk\">\n      <div class=\"title\">Input</div>\n      <div class=\"question-statement-input\"><strong>Line 1</strong> contains an integer <var>total</var><br><strong>Next <var>total</var> lines</strong> contain one <var>character</var> symbol to be used as a bit with its adjacent symbols.</div>\n   </div>\n   <div class=\"blk\">\n      <div class=\"title\">Output</div>\n      <div class=\"question-statement-output\">Various possible combinations with each combination in a separate line, having same length as the total number of given symbols, and formed with characters in adjacent rows of a given symbol.</div>\n   </div>\n   <div class=\"blk\">\n      <div class=\"title\">Constraints</div>\n      <div class=\"question-statement-constraints\"><var>character</var> symbols belong to { <const>!</const>, <const>@</const>, <const>#</const>, <const>$</const>, <const>%</const>, <const>^</const>, <const>&amp;</const>, <const>*</const>, <const>()</const>, <const>[]</const>, <const>:</const>, <const>.</const>, <const>\\</const>, <const>/</const> }<br>1 &lt; <var>total</var> count of symbols (per testcase) &lt; 10</div>\n   </div>\n   <div class=\"blk\">\n      <div class=\"title\">Example</div>\n      <div class=\"statement-inout\">\n         <div class=\"statement-inout-in\">\n            <div class=\"title\">Input</div>\n            <pre class=\"question-statement-example-in\">2\n*\n#</pre>\n         </div>\n         <div class=\"statement-inout-out\">\n            <div class=\"title\">Output</div>\n            <pre class=\"question-statement-example-out\">**\n*#\n#*\n##</pre>\n         </div>\n      </div>\n   </div>\n</div>"
  },
  "validatedFor": 90926221304,
  "commentCount": 43,
  "upVotes": 27,
  "downVotes": 2,
  "validateAction": {
    "actionId": 774883,
    "progress": 1,
    "alreadyDone": false
  },
  "statusHistory": [
    {
      "status": "REFUSED",
      "date": 1677510337003,
      "data": {
        "author": "SYSTEM",
        "reason": "INACTIVITY"
      }
    },
    {
      "status": "PENDING",
      "date": 1677552030297,
      "data": {
        "author": "ACTION",
        "reason": "EDIT"
      }
    },
    {
      "status": "ACCEPTED",
      "date": 1679803183692,
      "data": {
        "author": "ACTION"
      }
    }
  ],
  "editable": true,
  "draft": false,
  "readyForModeration": true
}