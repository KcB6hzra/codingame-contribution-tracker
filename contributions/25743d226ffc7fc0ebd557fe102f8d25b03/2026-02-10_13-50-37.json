{
  "id": 257,
  "activeVersion": 10,
  "score": 2,
  "votableId": 2100323,
  "codingamerId": 552776,
  "views": 363,
  "commentableId": 2049673,
  "title": "Breakout",
  "status": "ACCEPTED",
  "type": "PUZZLE_INOUT",
  "nickname": "player_one",
  "publicHandle": "25743d226ffc7fc0ebd557fe102f8d25b03",
  "codingamerHandle": "fefb3b0a360d9451bde5553900470e2d677255",
  "lastVersion": {
    "version": 10,
    "autocloseTime": 1532016703560,
    "data": {
      "title": "Breakout",
      "topics": [],
      "solution": "using System;\nusing System.IO;\nusing System.Collections.Generic;\nusing System.Linq;\n\ninternal class Solution\n{\n    private static PointD _ballPosition;\n    private static PointD _ballVector;\n    private static List<PointD> _paddlePositions = new List<PointD>();\n    private static int _paddlePosition = 0;\n    private static List<Brick> _bricks = new List<Brick>();\n\n    private static int _score = 0;\n\n    static void Main(string[] args)\n    {\n        ParseInput();\n\n        while (_ballPosition.Y < 2400)\n        {\n            MoveBall();\n        }\n\n        Console.WriteLine(_score);\n    }\n\n    public static int Test(PointD ballPosition, PointD ballVector, List<PointD> paddlePositions, List<Brick> bricks)\n    {\n        _score = 0;\n        _ballPosition = ballPosition;\n        _ballVector = ballVector;\n        _paddlePositions = paddlePositions;\n        _bricks = bricks;\n\n        while (_ballPosition.Y < 2400)\n        {\n            MoveBall();\n        }\n\n        return _score;\n    }\n\n    private static void ParseInput()\n    {\n        var ballCoords = ParseLineToList();\n        _ballPosition = new PointD(ballCoords[0], ballCoords[1]);\n\n        var ballVectorArray = ParseLineToList();\n        _ballVector = new PointD(ballVectorArray[0] / 10D, ballVectorArray[1] / 10D);\n\n        var pN = int.Parse(Console.ReadLine());\n        var kN = int.Parse(Console.ReadLine());\n\n        for (var i = 0; i < pN; i++)\n        {\n            var paddleCoords = ParseLineToList();\n            _paddlePositions.Add(new PointD(paddleCoords[0], paddleCoords[1]));\n        }\n\n        for (var i = 0; i < kN; i++)\n        {\n            var brickData = ParseLineToList();\n            _bricks.Add(new Brick(brickData));\n        }\n    }\n\n    private static List<int> ParseLineToList()\n    {\n        return Console.ReadLine().Split(' ').Select(int.Parse).ToList();\n    }\n\n    private static void MoveBall()\n    {\n        var prevPos = new PointD(_ballPosition.X, _ballPosition.Y);\n        var nextPosition =\n            new PointD(_ballPosition.X + _ballVector.X,\n                       _ballPosition.Y + _ballVector.Y);\n\n        ResetBricks();\n\n        do\n        {\n            var hitInfo = PickHit(CheckWalls(nextPosition), CheckBricks(nextPosition));\n            hitInfo = PickHit(hitInfo, CheckPaddle(nextPosition));\n            nextPosition = hitInfo.NextPosition;\n            if (!hitInfo.Hit) break;\n\n            _ballVector = hitInfo.NewVector;\n            _ballPosition = hitInfo.Intersection;\n            if (hitInfo.HasBrick) HitBrick(hitInfo.Brick);\n            if (hitInfo.HasNeighbor) HitBrick(hitInfo.Neighbor);\n            if (hitInfo.IsPaddle && _paddlePosition < _paddlePositions.Count - 1) _paddlePosition++;\n        } while (true);\n        \n        _ballPosition = nextPosition;\n        //if (prevPos.Y <= 2200 && _ballPosition.Y > 2200) Console.Error.WriteLine(prevPos + \",\" + _ballPosition);\n        //if (prevPos.Y <= 2300 && _ballPosition.Y > 2300) Console.Error.WriteLine(prevPos + \",\" + _ballPosition);\n    }\n\n    private static HitInfo PickHit(HitInfo a, HitInfo b)\n    {\n        if (!a.Hit) return b;\n        if (!b.Hit) return a;\n\n        var dxa = _ballPosition.X - a.Intersection.X;\n        var dya = _ballPosition.Y - a.Intersection.Y;\n        var dista = dxa * dxa + dya * dya;\n        var dxb = _ballPosition.X - b.Intersection.X;\n        var dyb = _ballPosition.Y - b.Intersection.Y;\n        var distb = dxb * dxb + dyb * dyb;\n        if (DEquals(dista, distb)) throw new NotImplementedException();\n        if (dista > distb) return b;\n        return a;\n    }\n\n    private static void ResetBricks()\n    {\n        foreach (var brick in _bricks)\n        {\n            brick.HitThisRound = false;\n        }\n    }\n\n    private static HitInfo CheckBricks(PointD nextPosition)\n    {\n        var dist = _ballVector.X * _ballVector.X + _ballVector.Y * _ballVector.Y + 1;\n        HitInfo info = new NoHitInfo(nextPosition);\n        foreach (var brick in new List<Brick>(_bricks))\n        {\n            if (brick.HitThisRound) continue;\n            var hitInfo = CheckBrick(brick, nextPosition);\n            if (hitInfo.Hit)\n            {\n                var dx = _ballPosition.X - hitInfo.Intersection.X;\n                var dy = _ballPosition.Y - hitInfo.Intersection.Y;\n                var thisDist = dx * dx + dy * dy;\n                if (thisDist < dist)\n                {\n                    dist = thisDist;\n                    info = hitInfo;\n                }\n            }\n        }\n\n        return info;\n    }\n\n    private static void HitBrick(Brick brick)\n    {\n        brick.Hit();\n        if (brick.Strength != 0) return;\n        _bricks.Remove(brick);\n        _score += brick.Points;\n        Console.Error.WriteLine(\"S \" + _score);\n    }\n\n    private static HitInfo CheckBrick(Brick brick, PointD nextPosition)\n    {\n        HitInfo hitHorizontal = new NoHitInfo(nextPosition);\n        HitInfo hitVertical = new NoHitInfo(nextPosition);\n\n        var checkV = true;\n\n        // top of brick\n        if (_ballVector.Y > 0 &&\n            HIntersect(_ballPosition, nextPosition, brick.TopLeftCorner, brick.TopRightCorner))\n        {\n            var yMovement = _ballPosition.Y - brick.TopLeftCorner.Y;\n            var newNext = new PointD(_ballPosition.X + _ballVector.X, brick.TopLeftCorner.Y - _ballVector.Y - yMovement);\n            hitHorizontal = new BrickHitInfo(newNext, brick)\n            {\n                Intersection =\n                    new PointD(_ballPosition.X + _ballVector.X * Math.Abs(yMovement / _ballVector.Y), brick.TopLeftCorner.Y),\n                NewVector = new PointD(_ballVector.X, -_ballVector.Y)\n            };\n            Console.Error.WriteLine(\"T\" + hitHorizontal.Intersection + brick.TopLeftCorner);\n\n            // CHECK CORNERS\n\n            // TOP LEFT\n            if (DEquals(hitHorizontal.Intersection, brick.TopLeftCorner))\n            {\n                throw new NotImplementedException();\n            }\n\n            // TOP RIGHT\n            else if (DEquals(hitHorizontal.Intersection, brick.TopRightCorner))\n            {\n                var bX = brick.TopLeftCorner.X;\n                var bY = brick.TopLeftCorner.Y;\n                var adjacentBrick =\n                    _bricks.FirstOrDefault(\n                        b => DEquals(b.TopLeftCorner.X, bX + 100) && DEquals(b.TopLeftCorner.Y, bY - 30));\n                if (adjacentBrick != null)\n                {\n                    checkV = false;\n                    var xMovement = _ballPosition.X - brick.TopRightCorner.X;\n                    hitHorizontal.NextPosition.Y = _ballPosition.Y + _ballVector.Y * Math.Abs(_ballVector.X / xMovement);\n                    hitHorizontal.Neighbor = adjacentBrick;\n                    hitHorizontal.NewVector.X = -_ballVector.X;\n                    Console.Error.WriteLine(\"D\" + adjacentBrick.TopLeftCorner);\n                }\n                else\n                {\n                    adjacentBrick =\n                        _bricks.FirstOrDefault(\n                            b => DEquals(b.TopLeftCorner.X, bX + 100) && DEquals(b.TopLeftCorner.Y, bY));\n                    if (adjacentBrick != null)\n                    {\n                        checkV = false;\n                        hitHorizontal.Neighbor = adjacentBrick;\n                        Console.Error.WriteLine(\"D\" + adjacentBrick.TopLeftCorner);\n                    }\n                }\n            }\n        }\n\n        // bottom of brick\n        if (_ballVector.Y < 0 && HIntersect(_ballPosition, nextPosition, brick.BottomLeftCorner, brick.BottomRightCorner))\n        {\n            var yMovement = _ballPosition.Y - brick.BottomLeftCorner.Y;\n            PointD newNext = new PointD(_ballPosition.X + _ballVector.X, brick.BottomLeftCorner.Y - _ballVector.Y - yMovement);\n            hitHorizontal = new BrickHitInfo(newNext, brick)\n            {\n                Intersection =\n                    new PointD(_ballPosition.X + _ballVector.X * Math.Abs(yMovement / _ballVector.Y), brick.BottomLeftCorner.Y),\n                NewVector = new PointD(_ballVector.X, -_ballVector.Y)\n            };\n            Console.Error.WriteLine(\"B\" + hitHorizontal.Intersection + brick.TopLeftCorner);\n\n            // CHECK CORNERS\n\n            // BOTTOM LEFT\n            if (DEquals(hitHorizontal.Intersection, brick.BottomLeftCorner))\n            {\n                throw new NotImplementedException();\n            }\n\n            // BOTTOM RIGHT\n            else if (DEquals(hitHorizontal.Intersection, brick.BottomRightCorner))\n            {\n                var bX = brick.TopLeftCorner.X;\n                var bY = brick.TopLeftCorner.Y;\n                var adjacentBrick = _bricks.FirstOrDefault(b => DEquals(b.TopLeftCorner.X, bX + 100) && DEquals(b.TopLeftCorner.Y, bY + 30));\n                if (adjacentBrick != null)\n                {\n                    checkV = false;\n                    var xMovement = _ballPosition.X - brick.BottomRightCorner.X;\n                    hitHorizontal.NextPosition.Y = _ballPosition.Y + _ballVector.Y * Math.Abs(_ballVector.X / xMovement);\n                    hitHorizontal.Neighbor = adjacentBrick;\n                    hitHorizontal.NewVector.X = -_ballVector.X;\n                    Console.Error.WriteLine(\"D\" + adjacentBrick.TopLeftCorner);\n                }\n                else {\n                    adjacentBrick = _bricks.FirstOrDefault(b => DEquals(b.TopLeftCorner.X, bX + 100) && DEquals(b.TopLeftCorner.Y, bY));\n                    if (adjacentBrick != null)\n                    {\n                        checkV = false;\n                        hitHorizontal.Neighbor = adjacentBrick;\n                        Console.Error.WriteLine(\"D\" + adjacentBrick.TopLeftCorner);\n                    }\n                }\n            }\n        }\n\n        // left of brick\n        if (checkV && _ballVector.X > 0 && VIntersect(_ballPosition, nextPosition, brick.TopLeftCorner, brick.BottomLeftCorner))\n        {\n            var xMovement = _ballPosition.X - brick.TopLeftCorner.X;\n            PointD newNext = new PointD(brick.TopLeftCorner.X - _ballVector.X - xMovement, _ballPosition.Y + _ballVector.Y);\n            hitVertical = new BrickHitInfo(newNext, brick)\n            {\n                Intersection =\n                    new PointD(brick.TopLeftCorner.X, _ballPosition.Y + _ballVector.Y * Math.Abs(xMovement / _ballVector.X)),\n                NewVector = new PointD(-_ballVector.X, _ballVector.Y)\n            };\n            checkV = false;\n            Console.Error.WriteLine(\"L\" + hitVertical.Intersection + brick.TopLeftCorner);\n        }\n\n        // right of brick\n        if (checkV && _ballVector.X < 0 && VIntersect(_ballPosition, nextPosition, brick.TopRightCorner, brick.BottomRightCorner))\n        {\n            var xMovement = _ballPosition.X - brick.TopRightCorner.X;\n            PointD newNext = new PointD(brick.TopRightCorner.X - _ballVector.X - xMovement, _ballPosition.Y + _ballVector.Y);\n            hitVertical = new BrickHitInfo(newNext, brick)\n            {\n                Intersection =\n                    new PointD(brick.TopRightCorner.X, _ballPosition.Y + _ballVector.Y * Math.Abs(xMovement / _ballVector.X)),\n                NewVector = new PointD(-_ballVector.X, _ballVector.Y)\n            };\n            Console.Error.WriteLine(\"R\" + hitVertical.Intersection + brick.TopLeftCorner);\n        }\n\n        // CHECK CORNERS\n        if (hitVertical.Hit)\n        {\n            // TOP\n            if (DEquals(hitVertical.Intersection, brick.TopLeftCorner) || DEquals(hitVertical.Intersection, brick.TopRightCorner))\n            {\n                throw new NotImplementedException();\n            }\n\n            // BOTTOM\n            else if (DEquals(hitVertical.Intersection, brick.BottomLeftCorner) || DEquals(hitVertical.Intersection, brick.BottomRightCorner))\n            {\n                throw new NotImplementedException();\n            }\n        }\n\n        if (hitHorizontal.Hit && hitVertical.Hit)\n        {\n            if (Math.Abs(_ballVector.Y) > Math.Abs(_ballVector.X))\n            {\n                return hitVertical;\n            }\n            return hitHorizontal;\n        }\n        else if (hitHorizontal.Hit)\n        {\n            return hitHorizontal;\n        }\n\n        return hitVertical;\n    }\n\n    private static HitInfo CheckWalls(PointD nextPosition)\n    {\n        HitInfo hitHorizontal = new NoHitInfo(nextPosition);\n        HitInfo hitVertical = new NoHitInfo(nextPosition);\n\n        // top wall\n        if (_ballVector.Y < 0 &&\n            HIntersect(_ballPosition, nextPosition,\n                        new PointD(-100, 0), new PointD(1700, 0)))\n        {\n            hitHorizontal = new WallHitInfo(new PointD(_ballPosition.X + _ballVector.X, - _ballVector.Y - _ballPosition.Y))\n            {\n                Intersection =\n                    new PointD(_ballPosition.X + _ballVector.X * Math.Abs(_ballPosition.Y / _ballVector.Y), 0),\n                NewVector = new PointD(_ballVector.X, -_ballVector.Y)\n            };\n            Console.Error.WriteLine(\"T\");\n        }\n\n        // left wall\n        if (_ballVector.X < 0 &&\n            VIntersect(_ballPosition, nextPosition,\n                        new PointD(0, -100), new PointD(0, 2500)))\n        {\n           hitVertical = new WallHitInfo(new PointD(- _ballVector.X - _ballPosition.X, _ballPosition.Y + _ballVector.Y))\n            {\n                Intersection =\n                    new PointD(0, _ballPosition.Y + _ballVector.Y * Math.Abs(_ballPosition.X / _ballVector.X)),\n                NewVector = new PointD(-_ballVector.X, _ballVector.Y)\n            };\n            Console.Error.WriteLine(\"L\");\n        }\n\n\n        // right wall\n        if (_ballVector.X > 0 &&\n            VIntersect(_ballPosition, nextPosition,\n                        new PointD(1600, -100), new PointD(1600, 2500)))\n        {\n            hitVertical = new WallHitInfo(new PointD(1600 - _ballVector.X + (1600 - _ballPosition.X), _ballPosition.Y + _ballVector.Y))\n            {\n                Intersection =\n                    new PointD(1600, _ballPosition.Y + _ballVector.Y * Math.Abs((1600 - _ballPosition.X) / _ballVector.X)),\n                NewVector = new PointD(-_ballVector.X, _ballVector.Y)\n            };\n            Console.Error.WriteLine(\"R\");\n        }\n\n        if (hitHorizontal.Hit && hitVertical.Hit)\n        {\n            if (Math.Abs(_ballVector.Y) > Math.Abs(_ballVector.X))\n            {\n                return hitVertical;\n            }\n            return hitHorizontal;\n        }\n        else if (hitHorizontal.Hit)\n        {\n            return hitHorizontal;\n        }\n\n        return hitVertical;\n    }\n\n\n    private static HitInfo CheckPaddle(PointD nextPosition)\n    {\n        HitInfo hitInfo = new NoHitInfo(nextPosition);\n\n        var paddle = _paddlePositions[_paddlePosition];\n\n        if (_ballVector.Y > 0 && HIntersect(_ballPosition, nextPosition, paddle, new PointD(paddle.X + 200, paddle.Y)))\n        {\n            hitInfo = new PaddleHitInfo(new PointD(_ballPosition.X + _ballVector.X,\n                                                   paddle.Y - _ballVector.Y + (paddle.Y - _ballPosition.Y)))\n            {\n                Intersection =\n                    new PointD(_ballPosition.X + _ballVector.X * Math.Abs((paddle.Y - _ballPosition.Y) / _ballVector.Y), paddle.Y),\n                NewVector = new PointD(_ballVector.X, -_ballVector.Y)\n            };\n            Console.Error.WriteLine(\"P\" + paddle);\n        }\n\n        return hitInfo;\n    }\n\n    private static bool HIntersect(PointD p1, PointD q1, PointD p2, PointD q2)\n    {\n        if (Between(p1.X, p2.X, q2.X) && DEquals(p1.Y, p2.Y)) return false;\n        if (DEquals(p1.Y, q1.Y)) return DEquals(q1.Y, p2.Y) && Between(q1.X, p2.X, q2.X);\n\n        var x = p1.X;\n        if (DEquals(p1.X, q1.X)) return Between(x, p2.X, q2.X) && Between(p2.Y, p1.Y, q1.Y);\n        var m = (p1.Y - q1.Y) / (p1.X - q1.X);\n        var b = p1.Y - m * p1.X;\n        x = (p2.Y - b) / m;\n        return Between(x, p2.X, q2.X) && Between(p2.Y, p1.Y, q1.Y);\n    }\n\n    private static bool Between(double q, double a, double b)\n    {\n        if (DEquals(q, a) || DEquals(q, b)) return true;\n        if (a < b) return q > a && q < b;\n        return q > b && q < a;\n    }\n\n    private static bool VIntersect(PointD p1, PointD q1, PointD p2, PointD q2)\n    {\n        if (Between(p1.Y, p2.Y, q2.Y) && DEquals(p1.X, p2.X)) return false;\n        if (DEquals(p1.X, q1.X)) return DEquals(q1.X, p2.X) && Between(q1.Y, p2.Y, q2.Y);\n\n        var y = p1.Y;\n        if (DEquals(p1.Y, q1.Y)) return Between(y, p2.Y, q2.Y) && Between(p2.X, p1.X, q1.X);\n        var m = (p1.Y - q1.Y) / (p1.X - q1.X);\n        var b = p1.Y - m * p1.X;\n        y = m * p2.X + b;\n\n        return Between(y, p2.Y, q2.Y) && Between(p2.X, p1.X, q1.X);\n    }\n\n    private static bool DEquals(double a, double b)\n    {\n        return Math.Abs(a - b) < 0.001;\n    }\n\n    private static bool DEquals(PointD a, PointD b)\n    {\n        return DEquals(a.X, b.X) && DEquals(a.Y, b.Y);\n    }\n\n    internal class Brick\n    {\n        public PointD TopLeftCorner { get; private set; }\n        public PointD BottomLeftCorner { get; set; }\n        public PointD BottomRightCorner { get; set; }\n        public PointD TopRightCorner { get; set; }\n        public int Strength { get; private set; }\n        public int Points { get; private set; }\n        public bool HitThisRound { get; set; }\n\n        public Brick(IReadOnlyList<int> data)\n        {\n            TopLeftCorner = new PointD(data[0], data[1]);\n            TopRightCorner = new PointD(TopLeftCorner.X + 100, TopLeftCorner.Y);\n            BottomRightCorner = new PointD(TopLeftCorner.X + 100, TopLeftCorner.Y + 30);\n            BottomLeftCorner = new PointD(TopLeftCorner.X, TopLeftCorner.Y + 30);\n            Strength = data[2];\n            Points = data[3];\n        }\n\n        public void Hit()\n        {\n            Strength -= 1;\n            HitThisRound = true;\n        }\n    }\n\n    private abstract class HitInfo\n    {\n        public PointD NextPosition { get; private set; }\n        public bool Hit { get; private set; }\n        public Brick Brick { get; protected set; }\n        public Brick Neighbor { get; set; }\n        public PointD Intersection { get; set; }\n        public PointD NewVector { get; set; }\n        public bool HasBrick { get { return Brick != null; } }\n        public bool HasNeighbor { get { return Neighbor != null; } }\n        public bool IsPaddle { get; protected set; }\n\n        protected HitInfo(PointD nextPosition, bool hit)\n        {\n            NextPosition = nextPosition;\n            Hit = hit;\n        }\n    }\n\n    private class BrickHitInfo : HitInfo\n    {\n        public BrickHitInfo(PointD nextPosition, Brick brick) :\n            base(nextPosition, true)\n        {\n            Brick = brick;\n        }\n    }\n\n    private class NoHitInfo : HitInfo\n    {\n        public NoHitInfo(PointD nextPosition) :\n            base(nextPosition, false)\n        {\n\n        }\n    }\n\n    private class WallHitInfo : HitInfo\n    {\n        public WallHitInfo(PointD nextPosition) :\n            base(nextPosition, true)\n        {\n        }\n    }\n\n    private class PaddleHitInfo : HitInfo\n    {\n        public PaddleHitInfo(PointD nextPosition) :\n            base(nextPosition, true)\n        {\n            IsPaddle = true;\n        }\n    }\n\n    internal class PointD\n    {\n        public double X { get; set; }\n        public double Y { get; set; }\n\n        public PointD(double x, double y)\n        {\n            X = x;\n            Y = y;\n        }\n\n        public override string ToString()\n        {\n            return \"{\" + X + \",\" + Y + \"}\";\n        }\n    }\n}",
      "statement": "Bricks of {{100}} x {{30}} pixels are arranged in a playfield of {{1600}} x {{2400}} pixels (origin at the top-left). A dimensionless point (the ball) bounces around the playfield, breaking bricks as it hits them. Each broken brick scores points.\n\nThe ball will bounce off of:\n\n- The left, right, and top of the playfield\n- Any side of any brick\n- The top of a {{200}} x {{3}} pixel mobile paddle\n\nAll bounces are treated classically. The accidental angle is equal to the incidental angle. So, for example, if the ball's vector is ([[vX]], [[vY]]) = ({{10}}, {{10}}) (moving down and right), and the ball hits the top of a brick, then the resulting ball vector will be ({{10}}, {{-10}}), and if the ball then hits the right-hand wall, then the resulting vector would be ({{-10}}, {{-10}}).\n\n You don't need to worry about what happens if the ball hits the corner of something. The tests are engineered to avoid this situation.\n\nEach brick has an associated [[kStrength]] value, indicating the \"strength\" of the brick. A brick with a strength of {{1}} will break and disappear after a single hit from the ball. A brick with a strength of {{2}} requires 2 hits before it breaks. No points are awarded for hitting a brick until it breaks and disappears.\n\nFor many of the tests, the paddle is stationary, but in some of the latter tests, the paddle can move around the playfield to keep the ball in play. Multiple coordinate sets are provided to specify the various locations of the paddle throughout the test. The paddle \"moves\" to the next coordinate set after being hit by the ball. If there are no other coordinate sets provided in the input, then the paddle doesn't move for the rest of the test, and remains at the last specified position.\n\nThe ball is lost if it goes off the bottom of the playfield. Your program must calculate and report points acquired by breaking bricks before the ball is lost.",
      "testCases": [
        {
          "title": "Straight out",
          "isTest": true,
          "testIn": "100 100\n0 100\n1\n1\n1400 2300\n1500 0 1 1",
          "testOut": "0",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Straight out",
          "isTest": false,
          "testIn": "1500 100\n0 100\n1\n1\n0 2300\n0 0 1 1",
          "testOut": "0",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "One brick",
          "isTest": true,
          "testIn": "100 100\n0 -100\n1\n1\n1400 2300\n50 50 1 1",
          "testOut": "1",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "One brick",
          "isTest": false,
          "testIn": "1500 100\n0 -100\n1\n1\n0 2300\n1450 50 1 1",
          "testOut": "1",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "Off the walls",
          "isTest": true,
          "testIn": "100 150\n-100 -100\n1\n1\n1400 2300\n50 50 1 1",
          "testOut": "1",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Off the walls",
          "isTest": false,
          "testIn": "1500 150\n100 -100\n1\n1\n0 2300\n1450 50 1 1",
          "testOut": "1",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "Escape",
          "isTest": true,
          "testIn": "800 800\n32 100\n1\n48\n0 2300\n550 725 5 13\n650 725 5 13\n750 725 5 13\n850 725 5 13\n950 725 5 13\n550 755 5 13\n950 755 5 13\n550 785 5 13\n950 785 5 13\n550 815 5 13\n950 815 5 13\n550 845 5 13\n650 845 5 13\n750 845 5 13\n850 845 5 13\n950 845 5 13\n350 665 4 8\n450 665 4 8\n550 665 4 8\n650 665 4 8\n750 665 4 8\n850 665 4 8\n950 665 4 8\n1050 665 4 8\n1150 665 4 8\n350 695 4 8\n1150 695 4 8\n350 725 4 8\n1150 725 4 8\n350 755 4 8\n1150 755 4 8\n350 785 4 8\n1150 785 4 8\n350 815 4 8\n1150 815 4 8\n350 845 4 8\n1150 845 4 8\n350 875 4 8\n1150 875 4 8\n350 905 4 8\n450 905 4 8\n550 905 4 8\n650 905 4 8\n750 905 4 8\n850 905 4 8\n950 905 4 8\n1050 905 4 8\n1150 905 4 8",
          "testOut": "99",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Escape",
          "isTest": false,
          "testIn": "800 800\n58 100\n1\n48\n0 2300\n550 725 1 1\n650 725 1 1\n750 725 1 1\n850 725 1 1\n950 725 1 1\n550 755 1 1\n950 755 1 1\n550 785 1 1\n950 785 1 1\n550 815 1 1\n950 815 1 1\n550 845 1 1\n650 845 1 1\n750 845 1 1\n850 845 1 1\n950 845 1 1\n350 665 4 8\n450 665 4 8\n550 665 4 8\n650 665 4 8\n750 665 4 8\n850 665 4 8\n950 665 4 8\n1050 665 4 8\n1150 665 4 8\n350 695 4 8\n1150 695 4 8\n350 725 4 8\n1150 725 4 8\n350 755 4 8\n1150 755 4 8\n350 785 4 8\n1150 785 4 8\n350 815 4 8\n1150 815 4 8\n350 845 4 8\n1150 845 4 8\n350 875 4 8\n1150 875 4 8\n350 905 4 8\n450 905 4 8\n550 905 4 8\n650 905 4 8\n750 905 4 8\n850 905 4 8\n950 905 4 8\n1050 905 4 8\n1150 905 4 8",
          "testOut": "47",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "Off the paddle",
          "isTest": true,
          "testIn": "800 2250\n100 100\n1\n1\n700 2300\n900 2170 1 1",
          "testOut": "1",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Off the paddle",
          "isTest": false,
          "testIn": "1000 2250\n-100 100\n1\n1\n900 2300\n800 2170 1 1",
          "testOut": "1",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "Good game",
          "isTest": true,
          "testIn": "800 2200\n83 -59\n36\n48\n370 2300\n180 2300\n0 2300\n646 2300\n457 2300\n267 2300\n78 2300\n0 2300\n628 2300\n523 2300\n418 2300\n313 2300\n208 2300\n103 2300\n0 2300\n8 2300\n0 2300\n0 2300\n6 2300\n123 2300\n144 2300\n164 2300\n269 2300\n375 2300\n480 2300\n585 2300\n605 2300\n589 2300\n660 2300\n869 2300\n1058 2300\n1248 2300\n1400 2300\n782 2300\n887 2300\n992 2300\n100 1200 1 10\n200 1200 1 10\n300 1200 1 10\n400 1200 1 10\n500 1200 1 10\n600 1200 1 10\n900 1200 1 10\n1000 1200 1 10\n1100 1200 1 10\n1200 1200 1 10\n1300 1200 1 10\n1400 1200 1 10\n100 1170 2 20\n200 1170 2 20\n300 1170 2 20\n400 1170 2 20\n500 1170 2 20\n600 1170 2 20\n900 1170 2 20\n1000 1170 2 20\n1100 1170 2 20\n1200 1170 2 20\n1300 1170 2 20\n1400 1170 2 20\n100 1140 3 40\n200 1140 3 40\n300 1140 3 40\n400 1140 3 40\n500 1140 3 40\n600 1140 3 40\n900 1140 3 40\n1000 1140 3 40\n1100 1140 3 40\n1200 1140 3 40\n1300 1140 3 40\n1400 1140 3 40\n100 1110 4 80\n200 1110 4 80\n300 1110 4 80\n400 1110 4 80\n500 1110 4 80\n600 1110 4 80\n900 1110 4 80\n1000 1110 4 80\n1100 1110 4 80\n1200 1110 4 80\n1300 1110 4 80\n1400 1110 4 80",
          "testOut": "470",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Good game",
          "isTest": false,
          "testIn": "800 2200\n91 -27\n27\n48\n1176 2300\n961 2300\n53 2300\n560 2300\n1373 2300\n815 2300\n1000 2300\n96 2300\n519 2300\n467 2300\n1319 2300\n1266 2300\n251 2300\n564 2300\n1400 2300\n407 2300\n1400 2300\n601 2300\n1384 2300\n167 2300\n647 2300\n1338 2300\n1400 2300\n504 2300\n564 2300\n619 2300\n399 2300\n100 1200 1 10\n200 1200 1 10\n300 1200 1 10\n400 1200 1 10\n500 1200 1 10\n700 1200 1 10\n800 1200 1 10\n1000 1200 1 10\n1100 1200 1 10\n1200 1200 1 10\n1300 1200 1 10\n1400 1200 1 10\n100 1170 2 20\n200 1170 2 20\n300 1170 2 20\n400 1170 2 20\n500 1170 2 20\n700 1170 2 20\n800 1170 2 20\n1000 1170 2 20\n1100 1170 2 20\n1200 1170 2 20\n1300 1170 2 20\n1400 1170 2 20\n100 1140 3 40\n200 1140 3 40\n300 1140 3 40\n400 1140 3 40\n500 1140 3 40\n700 1140 3 40\n800 1140 3 40\n1000 1140 3 40\n1100 1140 3 40\n1200 1140 3 40\n1300 1140 3 40\n1400 1140 3 40\n100 1110 4 80\n200 1110 4 80\n300 1110 4 80\n400 1110 4 80\n500 1110 4 80\n700 1110 4 80\n800 1110 4 80\n1000 1110 4 80\n1100 1110 4 80\n1200 1110 4 80\n1300 1110 4 80\n1400 1110 4 80",
          "testOut": "460",
          "isValidator": true,
          "needValidation": true
        }
      ],
      "difficulty": "hard",
      "constraints": "0≤[[bX]]<1600\n0≤[[bY]]<2400\n-100≤[[vX]]≤100\n-100≤[[vY]]≤100\n1≤[[pN]]≤32\n1≤[[kN]]≤64\n0≤[[pX]]≤1400\n2200≤[[pY]]≤2300\n0≤[[kX]]≤1500\n0≤[[kY]]≤1500\n1≤[[kStrength]]≤5",
      "coverBinaryId": 135668421361397,
      "stubGenerator": "read bX:int bY:int\nread vX:int vY:int\nread pN:int\nread kN:int\nloop pN read pX:int pY:int\nloop kN read kX:int kY:int kStrength:int kPoints:int\nwrite points",
      "inputDescription": "<<Line 1:>> Two space-separated integers [[bX]] and [[bY]] indicating the starting position of the ball.\n<<Line 2:>> Two space-separated integers [[vX]] and [[vY]] indicating the starting vector of the ball.\n<<Line 3:>> An integer [[pN]] indicating the number of positions that will be occupied by the paddle during the game.\n<<Line 4:>> An integer [[kN]] indicating the number of bricks initially on the playfield.\n<<Next [[pN]] lines:>> Two space-separated integers [[pX]] and [[pY]] for the coordinates of the top-left-hand pixel of the paddle.\n<<Next [[kN]] lines:>> Four space-separated integers [[kX]], [[kY]], [[kStrength]], [[kPoints]] for the coordinates of the top-left corner of the brick, the strength of the brick, and the number of points earned for breaking the brick.",
      "solutionLanguage": "C#",
      "outputDescription": "The number of points earned before the ball is lost."
    },
    "draft": false,
    "readyForModeration": true,
    "statementHTML": "<div class=\"statement-body\">\n<div class=\"statement-section statement-goal\">\n   <h2><span class=\"icon icon-goal\">&nbsp;</span><span>Goal </span></h2>\n   <span class=\"question-statement\">Bricks of <const>100</const> x <const>30</const> pixels are arranged in a playfield of <const>1600</const> x <const>2400</const> pixels (origin at the top-left). A dimensionless point (the ball) bounces around the playfield, breaking bricks as it hits them. Each broken brick scores points.<br><br>The ball will bounce off of:<br><br>- The left, right, and top of the playfield<br>- Any side of any brick<br>- The top of a <const>200</const> x <const>3</const> pixel mobile paddle<br><br>All bounces are treated classically. The accidental angle is equal to the incidental angle. So, for example, if the ball's vector is (<var>vX</var>, <var>vY</var>) = (<const>10</const>, <const>10</const>) (moving down and right), and the ball hits the top of a brick, then the resulting ball vector will be (<const>10</const>, <const>-10</const>), and if the ball then hits the right-hand wall, then the resulting vector would be (<const>-10</const>, <const>-10</const>).<br><br> You don't need to worry about what happens if the ball hits the corner of something. The tests are engineered to avoid this situation.<br><br>Each brick has an associated <var>kStrength</var> value, indicating the &quot;strength&quot; of the brick. A brick with a strength of <const>1</const> will break and disappear after a single hit from the ball. A brick with a strength of <const>2</const> requires 2 hits before it breaks. No points are awarded for hitting a brick until it breaks and disappears.<br><br>For many of the tests, the paddle is stationary, but in some of the latter tests, the paddle can move around the playfield to keep the ball in play. Multiple coordinate sets are provided to specify the various locations of the paddle throughout the test. The paddle &quot;moves&quot; to the next coordinate set after being hit by the ball. If there are no other coordinate sets provided in the input, then the paddle doesn't move for the rest of the test, and remains at the last specified position.<br><br>The ball is lost if it goes off the bottom of the playfield. Your program must calculate and report points acquired by breaking bricks before the ball is lost.</span>\n</div>\n<div class=\"statement-section statement-protocol\">\n   <div class=\"blk\">\n      <div class=\"title\">Input</div>\n      <div class=\"question-statement-input\"><strong>Line 1:</strong> Two space-separated integers <var>bX</var> and <var>bY</var> indicating the starting position of the ball.<br><strong>Line 2:</strong> Two space-separated integers <var>vX</var> and <var>vY</var> indicating the starting vector of the ball.<br><strong>Line 3:</strong> An integer <var>pN</var> indicating the number of positions that will be occupied by the paddle during the game.<br><strong>Line 4:</strong> An integer <var>kN</var> indicating the number of bricks initially on the playfield.<br><strong>Next <var>pN</var> lines:</strong> Two space-separated integers <var>pX</var> and <var>pY</var> for the coordinates of the top-left-hand pixel of the paddle.<br><strong>Next <var>kN</var> lines:</strong> Four space-separated integers <var>kX</var>, <var>kY</var>, <var>kStrength</var>, <var>kPoints</var> for the coordinates of the top-left corner of the brick, the strength of the brick, and the number of points earned for breaking the brick.</div>\n   </div>\n   <div class=\"blk\">\n      <div class=\"title\">Output</div>\n      <div class=\"question-statement-output\">The number of points earned before the ball is lost.</div>\n   </div>\n   <div class=\"blk\">\n      <div class=\"title\">Constraints</div>\n      <div class=\"question-statement-constraints\">0&le;<var>bX</var>&lt;1600<br>0&le;<var>bY</var>&lt;2400<br>-100&le;<var>vX</var>&le;100<br>-100&le;<var>vY</var>&le;100<br>1&le;<var>pN</var>&le;32<br>1&le;<var>kN</var>&le;64<br>0&le;<var>pX</var>&le;1400<br>2200&le;<var>pY</var>&le;2300<br>0&le;<var>kX</var>&le;1500<br>0&le;<var>kY</var>&le;1500<br>1&le;<var>kStrength</var>&le;5</div>\n   </div>\n   <div class=\"blk\">\n      <div class=\"title\">Example</div>\n      <div class=\"statement-inout\">\n         <div class=\"statement-inout-in\">\n            <div class=\"title\">Input</div>\n            <pre class=\"question-statement-example-in\">100 100\n0 100\n1\n1\n1400 2300\n1500 0 1 1</pre>\n         </div>\n         <div class=\"statement-inout-out\">\n            <div class=\"title\">Output</div>\n            <pre class=\"question-statement-example-out\">0</pre>\n         </div>\n      </div>\n   </div>\n</div>"
  },
  "validatedFor": 238972855190,
  "avatar": 52487021619351,
  "commentCount": 11,
  "upVotes": 2,
  "downVotes": 0,
  "validateAction": {
    "actionId": 243484,
    "progress": 1,
    "alreadyDone": false
  },
  "statusHistory": [],
  "editable": true,
  "draft": false,
  "readyForModeration": true
}