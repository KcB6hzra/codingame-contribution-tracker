{
  "id": 4786,
  "activeVersion": 16,
  "score": 8,
  "votableId": 12279298,
  "codingamerId": 1753077,
  "views": 261,
  "commentableId": 12204361,
  "title": "Binary Search Tree Traversal",
  "status": "ACCEPTED",
  "type": "PUZZLE_INOUT",
  "nickname": "codingWhale",
  "publicHandle": "47863e92a656792f1074ca66fd684363109e",
  "codingamerHandle": "1bb3f198061576d25313257356d8c7937703571",
  "lastVersion": {
    "version": 16,
    "autocloseTime": 1583255535430,
    "data": {
      "title": "Binary Search Tree Traversal",
      "topics": [
        {
          "id": 215,
          "handle": "binary-tree",
          "labelMap": {
            "1": "Binary Tree",
            "2": "Binary Tree"
          },
          "puzzleCount": 1,
          "parentTopicId": 93
        },
        {
          "id": 150,
          "handle": "graph-traversal",
          "labelMap": {
            "1": "graph traversal",
            "2": "graph traversal"
          },
          "puzzleCount": 1,
          "parentTopicId": 93
        }
      ],
      "solution": "import java.util.*;\n\nclass BinaryNode {\n    private Integer value;\n    private BinaryNode left, right;\n    \n    public BinaryNode() {}\n    \n    public BinaryNode(Integer value) {\n        this.value = value;\n    }\n    \n    public Integer getValue() {\n        return value;\n    }\n    \n    public void setValue(Integer value) {\n        this.value = value;\n    }\n    \n    public void setLeft(BinaryNode node) {\n        left = node;\n    }\n    \n    public BinaryNode getLeft() {\n        return left;\n    }\n    \n    public void setRight(BinaryNode node) {\n        right = node;\n    }    \n    \n    public BinaryNode getRight() {\n        return right;\n    }\n}\n\nenum Order {\n    IN_ORDER, PRE_ORDER, POST_ORDER, LEVEL_ORDER\n}\n\nclass BinarySearchTree {\n    protected BinaryNode root;\n\n    public BinarySearchTree() {\n        root = new BinaryNode();\n    }\n\n    public BinarySearchTree(Integer value) {\n        root = new BinaryNode(value);\n        root.setLeft(new BinaryNode());\n        root.setRight(new BinaryNode());\n    }\n    \n    public void addValue(Integer value) {\n        BinaryNode current = root;\n        while (current.getValue() != null) {\n            current = value.compareTo(current.getValue()) < 0 ? current.getLeft() : current.getRight();\n        }\n        current.setValue(value);\n        current.setLeft(new BinaryNode());\n        current.setRight(new BinaryNode());\n    }\n\n    public List<Integer> traverse(Order order) {\n        List<Integer> result = new ArrayList<>();\n        if (order == Order.PRE_ORDER) {\n            Stack<BinaryNode> s = new Stack<>();\n            s.push(this.root);\n            while (!s.isEmpty()) {\n                BinaryNode p = s.pop();\n                if (p.getValue() != null) {\n                    result.add(p.getValue());\n                    s.push(p.getRight());\n                    s.push(p.getLeft());\n                }\n            }\n        } else if (order == Order.IN_ORDER) {\n            Stack<BinaryNode> s = new Stack<>();\n            BinaryNode node = this.root;\n            while (true) {\n                while (node.getValue() != null) {\n                    s.push(node);\n                    node = node.getLeft();\n                }\n                if (s.isEmpty()) {\n                    break;\n                }\n                BinaryNode p = s.pop();\n                result.add(p.getValue());\n                node = p.getRight();\n            }\n        } else if (order == Order.POST_ORDER) {\n            Stack<BinaryNode> s = new Stack<>(), s2 = new Stack<>();\n            s.push(this.root);\n            while (!s.isEmpty()) {\n                BinaryNode p = s.pop();\n                if (p.getValue() != null) {\n                    s2.push(p);\n                    s.push(p.getLeft());\n                    s.push(p.getRight());\n                }\n            }\n            while (!s2.isEmpty()) {\n                result.add(s2.pop().getValue());\n            }\n        } else if (order == Order.LEVEL_ORDER) {\n            Queue<BinaryNode> q = new LinkedList<>();\n            q.add(root);\n            while (!q.isEmpty()) {\n                BinaryNode p = q.poll();\n                if (p.getValue() != null) {\n                    result.add(p.getValue());\n                    q.add(p.getLeft());\n                    q.add(p.getRight());\n                }\n            }\n        }\n        return result;\n    }\n}\n\nclass Solution {\n    public static void main(String args[]) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        \n        BinarySearchTree bst = new BinarySearchTree();\n        for (int i = 0; i < n; ++i) {\n            bst.addValue(in.nextInt());\n        }\n\n        List<Integer> preOrder = bst.traverse(Order.PRE_ORDER);\n        List<Integer> inOrder = bst.traverse(Order.IN_ORDER);\n        List<Integer> postOrder = bst.traverse(Order.POST_ORDER);\n        List<Integer> levelOrder = bst.traverse(Order.LEVEL_ORDER);\n        \n        System.out.print(preOrder.get(0));\n        for (int i = 1; i < n; ++i) {\n            System.out.print(\" \" + preOrder.get(i));\n        }\n        \n        System.out.print(\"\\n\" + inOrder.get(0));\n        for (int i = 1; i < n; ++i) {\n            System.out.print(\" \" + inOrder.get(i));\n        }\n        \n        System.out.print(\"\\n\" + postOrder.get(0));\n        for (int i = 1; i < n; ++i) {\n            System.out.print(\" \" + postOrder.get(i));\n        }\n        \n        System.out.print(\"\\n\" + levelOrder.get(0));\n        for (int i = 1; i < n; ++i) {\n            System.out.print(\" \" + levelOrder.get(i));\n        }\n    }\n}",
      "statement": "<<Insert [[n]] values in a given order one after the other into an initially empty binary seach tree. Then, output all values in Pre-Order, In-Order, Post-Order and Level-Order.>>\n\nA binary search tree is a tree-like data structure. Values are represented as nodes and every node can have at most 2 child nodes (leaves), one left and one right. The firstly inserted node is called root node. It is usually the upmost node (the tree is visualized upside down compared to an actual tree in the real world).\n\nWhen inserting a new value into a binary search tree, start by comparing the new value to the root node's value. If it's smaller, continue to the left. Else, continue to the right. Repeat the process with the appropriate root child (left or right) and continue until there is no more child to compare the value to. At this position in the tree, actually insert the value as a new node.\n\nThe example test case of inserting [8, 6, 13, 10, 5] can be visualized like this:\n\n........8..........\n....../....\\.......\n....6.....13....\n../........./......\n5........10......\n\nThere are different ways to run through (\"traverse\") all nodes of a binary search tree, always starting at the root node:\n* Pre-Order: output current value, consider left subtree, consider right subtree\n* In-Order: consider left subtree, output current value, consider right subtree\n* Post-Order: consider left subtree, consider right subtree, output current value\n* Level-Order: output all values from top to bottom level and from left to right within each level\n\nNeed more context? https://en.wikipedia.org/wiki/Tree_traversal",
      "testCases": [
        {
          "title": "example",
          "isTest": true,
          "testIn": "5\n8 6 13 10 5",
          "testOut": "8 6 5 13 10\n5 6 8 10 13\n5 6 10 13 8\n8 6 13 5 10",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "example",
          "isTest": false,
          "testIn": "6\n6 10 11 17 13 7",
          "testOut": "6 10 7 11 17 13\n6 7 10 11 13 17\n7 13 17 11 10 6\n6 10 7 11 17 13",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "positive values only",
          "isTest": true,
          "testIn": "8\n135 151 128 13 201 260 158 195",
          "testOut": "135 128 13 151 201 158 195 260\n13 128 135 151 158 195 201 260\n13 128 195 158 260 201 151 135\n135 128 151 13 201 158 260 195",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "positive values only",
          "isTest": false,
          "testIn": "7\n13 15 6 2 17 16 14",
          "testOut": "13 6 2 15 14 17 16\n2 6 13 14 15 16 17\n2 6 14 16 17 15 13\n13 6 15 2 14 17 16",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "small random values",
          "isTest": true,
          "testIn": "10\n-4 2 17 -15 -17 15 -12 11 30 29",
          "testOut": "-4 -15 -17 -12 2 17 15 11 30 29\n-17 -15 -12 -4 2 11 15 17 29 30\n-17 -12 -15 11 15 29 30 17 2 -4\n-4 -15 2 -17 -12 17 15 30 11 29",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "small random values",
          "isTest": false,
          "testIn": "10\n8 -5 -12 11 -6 -18 -7 -1 0 -30",
          "testOut": "8 -5 -12 -18 -30 -6 -7 -1 0 11\n-30 -18 -12 -7 -6 -5 -1 0 8 11\n-30 -18 -7 -6 -12 0 -1 -5 11 8\n8 -5 11 -12 -1 -18 -6 0 -30 -7",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "large random values",
          "isTest": true,
          "testIn": "14\n80549 235191 118837 -498143 -185405 -475495 428331 -146618 -479044 -173808 417544 204945 -479692 -70525",
          "testOut": "80549 -498143 -185405 -475495 -479044 -479692 -146618 -173808 -70525 235191 118837 204945 428331 417544\n-498143 -479692 -479044 -475495 -185405 -173808 -146618 -70525 80549 118837 204945 235191 417544 428331\n-479692 -479044 -475495 -173808 -70525 -146618 -185405 -498143 204945 118837 417544 428331 235191 80549\n80549 -498143 235191 -185405 118837 428331 -475495 -146618 204945 417544 -479044 -173808 -70525 -479692",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "large random values",
          "isTest": false,
          "testIn": "10\n-289549 -495177 -441337 590701 -431273 243893 -128682 282445 -123211 -214194",
          "testOut": "-289549 -495177 -441337 -431273 590701 243893 -128682 -214194 -123211 282445\n-495177 -441337 -431273 -289549 -214194 -128682 -123211 243893 282445 590701\n-431273 -441337 -495177 -214194 -123211 -128682 282445 243893 590701 -289549\n-289549 -495177 590701 -441337 243893 -431273 -128682 282445 -214194 -123211",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "more random values",
          "isTest": true,
          "testIn": "30\n-364052 -781443 796022 298864 295887 -614308 -296991 -1129497 838567 22573 40801 273590 1033779 715337 -38508 356628 514888 386934 930494 -907064 -916571 762755 -657230 -293721 822425 -314334 -862634 -146274 228429 1042357",
          "testOut": "-364052 -781443 -1129497 -907064 -916571 -862634 -614308 -657230 796022 298864 295887 -296991 -314334 22573 -38508 -293721 -146274 40801 273590 228429 715337 356628 514888 386934 762755 838567 822425 1033779 930494 1042357\n-1129497 -916571 -907064 -862634 -781443 -657230 -614308 -364052 -314334 -296991 -293721 -146274 -38508 22573 40801 228429 273590 295887 298864 356628 386934 514888 715337 762755 796022 822425 838567 930494 1033779 1042357\n-916571 -862634 -907064 -1129497 -657230 -614308 -781443 -314334 -146274 -293721 -38508 228429 273590 40801 22573 -296991 295887 386934 514888 356628 762755 715337 298864 822425 930494 1042357 1033779 838567 796022 -364052\n-364052 -781443 796022 -1129497 -614308 298864 838567 -907064 -657230 295887 715337 822425 1033779 -916571 -862634 -296991 356628 762755 930494 1042357 -314334 22573 514888 -38508 40801 386934 -293721 273590 -146274 228429",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "more random values",
          "isTest": false,
          "testIn": "29\n-988728 -587520 1257487 -1058576 -506241 -845952 976901 -689247 1210570 585001 824867 -1001917 20709 1238217 396284 -1123612 892491 859537 -965595 -1210324 501029 -555671 -780472 867284 -99137 -847734 -1282232 992224 279788",
          "testOut": "-988728 -1058576 -1123612 -1210324 -1282232 -1001917 -587520 -845952 -965595 -847734 -689247 -780472 1257487 -506241 -555671 976901 585001 20709 -99137 396284 279788 501029 824867 892491 859537 867284 1210570 992224 1238217\n-1282232 -1210324 -1123612 -1058576 -1001917 -988728 -965595 -847734 -845952 -780472 -689247 -587520 -555671 -506241 -99137 20709 279788 396284 501029 585001 824867 859537 867284 892491 976901 992224 1210570 1238217 1257487\n-1282232 -1210324 -1123612 -1001917 -1058576 -847734 -965595 -780472 -689247 -845952 -555671 -99137 279788 501029 396284 20709 867284 859537 892491 824867 585001 992224 1238217 1210570 976901 -506241 1257487 -587520 -988728\n-988728 -1058576 -587520 -1123612 -1001917 -845952 1257487 -1210324 -965595 -689247 -506241 -1282232 -847734 -780472 -555671 976901 585001 1210570 20709 824867 992224 1238217 -99137 396284 892491 279788 501029 859537 867284",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "ordered values",
          "isTest": true,
          "testIn": "50\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50",
          "testOut": "1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50\n50 49 48 47 46 45 44 43 42 41 40 39 38 37 36 35 34 33 32 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "ordered values",
          "isTest": false,
          "testIn": "45\n96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140",
          "testOut": "96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140\n96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140\n140 139 138 137 136 135 134 133 132 131 130 129 128 127 126 125 124 123 122 121 120 119 118 117 116 115 114 113 112 111 110 109 108 107 106 105 104 103 102 101 100 99 98 97 96\n96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140",
          "isValidator": true,
          "needValidation": true
        }
      ],
      "difficulty": "medium",
      "constraints": "1 ≤ [[N]] ≤ 50\n-10^9 < [[vi]] < 10^9\nAll values [[vi]] are distinct.",
      "coverBinaryId": 38883466360001,
      "stubGenerator": "read n:int\nloopline n vi:int\nloop 4 write answer",
      "inputDescription": "<<Line 1:>> An integer [[N]] for the number of values.\n<<Line 2:>> [[N]] space-separated values [[vi]] for the values to be inserted into a binary search tree.",
      "solutionLanguage": "Java",
      "outputDescription": "4 lines of [[N]] space-separated values each.\n<<Line 1:>> Pre-Order-Traversal.\n<<Line 2:>> In-Order-Traversal.\n<<Line 3:>> Post-Order-Traversal.\n<<Line 4:>> Level-Order-Traversal."
    },
    "draft": false,
    "readyForModeration": true,
    "statementHTML": "<div class=\"statement-body\">\n<div class=\"statement-section statement-goal\">\n   <h2><span class=\"icon icon-goal\">&nbsp;</span><span>Goal </span></h2>\n   <span class=\"question-statement\"><strong>Insert <var>n</var> values in a given order one after the other into an initially empty binary seach tree. Then, output all values in Pre-Order, In-Order, Post-Order and Level-Order.</strong><br><br>A binary search tree is a tree-like data structure. Values are represented as nodes and every node can have at most 2 child nodes (leaves), one left and one right. The firstly inserted node is called root node. It is usually the upmost node (the tree is visualized upside down compared to an actual tree in the real world).<br><br>When inserting a new value into a binary search tree, start by comparing the new value to the root node's value. If it's smaller, continue to the left. Else, continue to the right. Repeat the process with the appropriate root child (left or right) and continue until there is no more child to compare the value to. At this position in the tree, actually insert the value as a new node.<br><br>The example test case of inserting [8, 6, 13, 10, 5] can be visualized like this:<br><br>........8..........<br>....../....\\.......<br>....6.....13....<br>../........./......<br>5........10......<br><br>There are different ways to run through (&quot;traverse&quot;) all nodes of a binary search tree, always starting at the root node:<br>* Pre-Order: output current value, consider left subtree, consider right subtree<br>* In-Order: consider left subtree, output current value, consider right subtree<br>* Post-Order: consider left subtree, consider right subtree, output current value<br>* Level-Order: output all values from top to bottom level and from left to right within each level<br><br>Need more context? https://en.wikipedia.org/wiki/Tree_traversal</span>\n</div>\n<div class=\"statement-section statement-protocol\">\n   <div class=\"blk\">\n      <div class=\"title\">Input</div>\n      <div class=\"question-statement-input\"><strong>Line 1:</strong> An integer <var>N</var> for the number of values.<br><strong>Line 2:</strong> <var>N</var> space-separated values <var>vi</var> for the values to be inserted into a binary search tree.</div>\n   </div>\n   <div class=\"blk\">\n      <div class=\"title\">Output</div>\n      <div class=\"question-statement-output\">4 lines of <var>N</var> space-separated values each.<br><strong>Line 1:</strong> Pre-Order-Traversal.<br><strong>Line 2:</strong> In-Order-Traversal.<br><strong>Line 3:</strong> Post-Order-Traversal.<br><strong>Line 4:</strong> Level-Order-Traversal.</div>\n   </div>\n   <div class=\"blk\">\n      <div class=\"title\">Constraints</div>\n      <div class=\"question-statement-constraints\">1 &le; <var>N</var> &le; 50<br>-10^9 &lt; <var>vi</var> &lt; 10^9<br>All values <var>vi</var> are distinct.</div>\n   </div>\n   <div class=\"blk\">\n      <div class=\"title\">Example</div>\n      <div class=\"statement-inout\">\n         <div class=\"statement-inout-in\">\n            <div class=\"title\">Input</div>\n            <pre class=\"question-statement-example-in\">5\n8 6 13 10 5</pre>\n         </div>\n         <div class=\"statement-inout-out\">\n            <div class=\"title\">Output</div>\n            <pre class=\"question-statement-example-out\">8 6 5 13 10\n5 6 8 10 13\n5 6 10 13 8\n8 6 13 5 10</pre>\n         </div>\n      </div>\n   </div>\n</div>"
  },
  "validatedFor": 189704178990,
  "avatar": 44660101966182,
  "commentCount": 6,
  "upVotes": 9,
  "downVotes": 1,
  "validateAction": {
    "actionId": 426862,
    "progress": 1,
    "alreadyDone": false
  },
  "statusHistory": [
    {
      "status": "REFUSED",
      "date": 1580663137001,
      "data": {
        "author": "SYSTEM",
        "reason": "INACTIVITY"
      }
    },
    {
      "status": "PENDING",
      "date": 1580663535429,
      "data": {
        "author": "ACTION",
        "reason": "EDIT"
      }
    },
    {
      "status": "ACCEPTED",
      "date": 1581026930614,
      "data": {
        "author": "ACTION"
      }
    }
  ],
  "editable": true,
  "draft": false,
  "readyForModeration": true
}