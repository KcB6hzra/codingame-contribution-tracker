{
  "id": 24601,
  "activeVersion": 43,
  "score": 23,
  "votableId": 24551061,
  "codingamerId": 893541,
  "views": 678,
  "commentableId": 24433120,
  "title": "Isola",
  "status": "ACCEPTED",
  "type": "PUZZLE_MULTI",
  "nickname": "wala",
  "publicHandle": "24601b511702e38a736608ef369e652c0b1d7",
  "codingamerHandle": "71512db8a79a7c0d029a7df4657314b4145398",
  "lastVersion": {
    "version": 43,
    "autocloseTime": 1663871365217,
    "data": {
      "title": "Isola",
      "topics": [
        {
          "labelMap": {
            "2": "Board Game"
          }
        },
        {
          "id": 83,
          "handle": "minimax",
          "category": "ADVANCED",
          "labelMap": {
            "1": "Minimax",
            "2": "Minimax"
          },
          "pageTitle": "Minimax: exercises and theory",
          "puzzleCount": 29,
          "parentTopicId": 42,
          "contentDetailsId": 93
        },
        {
          "id": 92,
          "handle": "MCTS",
          "category": "ADVANCED",
          "labelMap": {
            "1": "Monte Carlo tree search",
            "2": "Monte Carlo tree search"
          },
          "puzzleCount": 17,
          "parentTopicId": 41
        }
      ],
      "refereeMd5": "893541/2d966aac923c222261668ac1a4ab0b8f",
      "testHandle": "9418773781a88013f50fe36e69332a8fc3d3bc",
      "viewerCode": "var Drawer=function(t){var e={};function r(n){var o;return(e[n]||(o=e[n]={i:n,l:!1,exports:{}},t[n].call(o.exports,o,o.exports,r),o.l=!0,o)).exports}return r.m=t,r.c=e,r.d=function(t,e,n){r.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:n})},r.r=function(t){\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(t,\"__esModule\",{value:!0})},r.t=function(t,e){if(1&e&&(t=r(t)),8&e)return t;if(4&e&&\"object\"==typeof t&&t&&t.__esModule)return t;var n=Object.create(null);if(r.r(n),Object.defineProperty(n,\"default\",{enumerable:!0,value:t}),2&e&&\"string\"!=typeof t)for(var o in t)r.d(n,o,function(e){return t[e]}.bind(null,o));return n},r.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return r.d(e,\"a\",e),e},r.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},r.p=\"\",r(r.s=0)}([function(t,e,r){\"use strict\";r.r(e),r.d(e,\"Drawer\",(function(){return tn}));var n={baseUrl:\"https://cdn-games.codingame.com/community/893541-1657559291523/\",images:{\"logo.png\":\"27cf766aa6432b185fcdd4c55ce6201c175ea15a2e165ddbdae4bd47beef34a9.png\"},sprites:[],fonts:[]};function o(t,e,r){return t<=e?t+(e-t)*r:e+(t-e)*(1-r)}function i(t,e,r){return Math.min(1,Math.max(0,(r-t)/(e-t)))}function a(t,e,r,n,o){return o=o||0,Math.min(r/(t+o),n/(e+o))}function c(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}var u=[],s=[],l=function(){function t(){if(!(this instanceof t))throw new TypeError(\"Cannot call a class as a function\")}var e,r;return e=t,r=[{key:\"listen\",value:function(t){if(\"function\"!=typeof t)throw new TypeError(t+\" is not a function\");s.push(t)}},{key:\"push\",value:function(t){u.push(t),s.forEach((function(e){return e(t)}))}}],null&&c(e.prototype,null),r&&c(e,r),Object.defineProperty(e,\"prototype\",{writable:!1}),t}();function f(t){return(f=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&\"function\"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?\"symbol\":typeof t})(t)}function p(t){var e=y();return function(){var r,n=b(t);r=e?(r=b(this).constructor,Reflect.construct(n,arguments,r)):n.apply(this,arguments),n=this;if(r&&(\"object\"===f(r)||\"function\"==typeof r))return r;if(void 0!==r)throw new TypeError(\"Derived constructors may only return object or undefined\");if(void 0!==n)return n;throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\")}}function h(t,e,r){return(h=y()?Reflect.construct.bind():function(t,e,r){var n=[null];return n.push.apply(n,e),e=new(Function.bind.apply(t,n)),r&&d(e,r.prototype),e}).apply(null,arguments)}function y(){if(\"undefined\"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if(\"function\"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}function d(t,e){return(d=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t})(t,e)}function b(t){return(b=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}var v=function(t){var e=n;if(\"function\"!=typeof t&&null!==t)throw new TypeError(\"Super expression must either be null or a function\");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),Object.defineProperty(e,\"prototype\",{writable:!1}),t&&d(e,t);var r=p(n);function n(t,e){var o;if(this instanceof n)return(o=r.call(this,\"Invalid color token: there is no player at index \".concat(t,\". Make sure to use getColorToken() if you want the color of a specific player.\"))).playerIdx=t,o.cause=e,o.name=\"InvalidPlayerColorTokenError\",o;throw new TypeError(\"Cannot call a class as a function\")}return e=n,Object.defineProperty(e,\"prototype\",{writable:!1}),e}(function(t){var e=\"function\"==typeof Map?new Map:void 0;return function(t){if(null===t||-1===Function.toString.call(t).indexOf(\"[native code]\"))return t;if(\"function\"!=typeof t)throw new TypeError(\"Super expression must either be null or a function\");if(void 0!==e){if(e.has(t))return e.get(t);e.set(t,r)}function r(){return h(t,arguments,b(this).constructor)}return r.prototype=Object.create(t.prototype,{constructor:{value:r,enumerable:!1,writable:!0,configurable:!0}}),d(r,t)}(t)}(Error));function m(t,e){var r,n=Object.keys(t);return Object.getOwnPropertySymbols&&(r=Object.getOwnPropertySymbols(t),e&&(r=r.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,r)),n}function g(t){for(var e=1;e<arguments.length;e++){var r=null!=arguments[e]?arguments[e]:{};e%2?m(Object(r),!0).forEach((function(e){var n,o;n=t,o=r[e=e],e in n?Object.defineProperty(n,e,{value:o,enumerable:!0,configurable:!0,writable:!0}):n[e]=o})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(r)):m(Object(r)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(r,e))}))}return t}function w(t,e,r){return r<1?t:e}r={type:Number,lerpMethod:function(t,e,r){return null===e?null:o((t={r:(16711680&t)>>16,g:(65280&t)>>8,b:255&t}).r,(e={r:(16711680&e)>>16,g:(65280&e)>>8,b:255&e}).r,r)<<16|o(t.g,e.g,r)<<8|o(t.b,e.b,r)},convert:function(t,e){var r=-(t+1);try{return t<0?e.players[r].color:t}catch(t){return l.push(new v(r)),16777215}}},e={type:String,lerpMethod:w,convert:T};var O={type:Number,lerpMethod:function(t,e,r,n){for(;e>t+Math.PI;)e-=2*Math.PI;for(;e<t-Math.PI;)e+=2*Math.PI;return(n=void 0!==n&&Math.abs(e-t)>n?e:t+(e-t)*r)%(2*Math.PI)},convert:function(t){return t*Math.PI/180}},P={type:Number,lerpMethod:w},j={type:function(t){return\"1\"===t},lerpMethod:w},S={type:Number,lerpMethod:function(t,e,r){return e<t?e:o(t,e,r)}},x={default:{type:Number,lerpMethod:o},visible:j,rotation:O,skewX:O,skewY:O,fillColor:r,lineColor:r,strokeColor:r,tint:r,animationProgressTime:S,maxWidth:P,mask:P,baseWidth:P,baseHeight:P,image:e,images:e,scaleMode:e,restarted:{type:String,convert:function(t,e,r,n){return t?{date:r.date+n*r.frameDuration}:null},lerpMethod:w},playing:j,duration:P,blendMode:P,loop:j,text:g(g({},e),{},{convert:function(t,e){t=T(t);for(var r=/\\$(\\d)/g,n=r.exec(t),o=\"\",i=0;n;)n[1]<e.players.length&&(o=(o+=t.substring(i,n.index))+e.players[+n[1]].name),i=n.index+n[0].length,n=r.exec(t);return o+t.substring(i)}}),textAlign:g(g({},e),{},{convert:function(t){return{0:\"left\",1:\"center\",2:\"right\"}[t]}}),fontFamily:e,fontWeight:e,children:g(g({},e),{},{convert:function(t){return t?t.split(\",\").map((function(t){return+t})):[]}}),points:g(g({},e),{},{convert:function(t){return t?t.split(\",\").map((function(t){return parseInt(t)})):[]},lerpMethod:function(t,e,r){return t.length===e.length?t.map((function(t,n){return o(t,e[n],r)})):w(t,e,r)}})};function T(t){return(t=t.split(\"\\\\'\").join(\"'\")).includes(\" \")||t.includes(\";\")||t.includes(\"\\n\")?t.slice(1,t.length-1):t}function R(t,e){var r,n=Object.keys(t);return Object.getOwnPropertySymbols&&(r=Object.getOwnPropertySymbols(t),e&&(r=r.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,r)),n}function E(t){for(var e=1;e<arguments.length;e++){var r=null!=arguments[e]?arguments[e]:{};e%2?R(Object(r),!0).forEach((function(e){var n,o;n=t,o=r[e=e],e in n?Object.defineProperty(n,e,{value:o,enumerable:!0,configurable:!0,writable:!0}):n[e]=o})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(r)):R(Object(r)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(r,e))}))}return t}function k(t,e){(null==e||e>t.length)&&(e=t.length);for(var r=0,n=new Array(e);r<e;r++)n[r]=t[r];return n}function _(t){return(_=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&\"function\"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?\"symbol\":typeof t})(t)}function I(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}var C=function(){function t(){if(!(this instanceof t))throw new TypeError(\"Cannot call a class as a function\");this.defaultState={x:0,y:0,scaleX:1,scaleY:1,skewX:0,skewY:0,zIndex:0,alpha:1,visible:!1,rotation:0,mask:-1},this.states={}}var e,r,n;return e=t,n=[{key:\"createState\",value:function(){var t=0<arguments.length&&void 0!==arguments[0]?arguments[0]:1,e=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{},r=2<arguments.length&&void 0!==arguments[2]?arguments[2]:{};return E(E({t:t},e),{},{curve:r})}}],(r=[{key:\"init\",value:function(){this.properties=Object.keys(this.defaultState),this.initDisplay(),this.currentState=Object.assign({},this.defaultState),\"object\"===_(this.graphics)&&this.container.addChild(this.graphics)}},{key:\"setHidden\",value:function(t){this.hide=t,this.container.visible=this.currentState.visible&&!this.hide}},{key:\"addState\",value:function(e,r,n){this.states[n]||(this.states[n]=[]);r=t.createState(e,r.values,r.curve);var o=this.states[n].find((function(t){return t.t===e}));o&&0===Object.keys(r.curve).length&&(r.curve=o.curve),o?(D(r)||D(o)||l.push(new Error(\"Different updates for same t \"+e)),Object.assign(o,r)):this.states[n].push(r)}},{key:\"set\",value:function(t,e,r){this.addState(t,e,r)}},{key:\"render\",value:function(t,e,r){var n,o=this.states[e.number],a=(this.container.visible=!1,null),c=1;if(o&&o.length){for(var u=0;u<o.length-1&&o[u].t<t;)u++;if(a=o[u-1],n=o[u],a)c=i(a.t,n.t,t);else{var s=Object.keys(this.states),l=s.indexOf(e.number.toString())-1;for(-1===l&&(l=s.length-1);0<=l&&s[l]>=e.number;)l--;var f=this.states[s[l]]||[];c=!(a=f[f.length-1])&&t>=n.t?(a=n,1):i(0,n.t,t)}}else{for(var p=Object.keys(this.states),h=p.length-1;0<=h&&p[h]>e.number;)h--;null!=(f=this.states[p[h]])?n=a=f[f.length-1]:Object.assign(this.currentState,this.defaultState)}if(a){var y,d={},b=Object.assign({},this.currentState),v=function(t,e){var r,n,o,i,a=\"undefined\"!=typeof Symbol&&t[Symbol.iterator]||t[\"@@iterator\"];if(a)return n=!(r=!0),{s:function(){a=a.call(t)},n:function(){var t=a.next();return r=t.done,t},e:function(t){n=!0,o=t},f:function(){try{r||null==a.return||a.return()}finally{if(n)throw o}}};if(Array.isArray(t)||(a=function(t,e){var r;if(t)return\"string\"==typeof t?k(t,e):\"Map\"===(r=\"Object\"===(r=Object.prototype.toString.call(t).slice(8,-1))&&t.constructor?t.constructor.name:r)||\"Set\"===r?Array.from(t):\"Arguments\"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)?k(t,e):void 0}(t))||e&&t&&\"number\"==typeof t.length)return a&&(t=a),i=0,{s:e=function(){},n:function(){return i>=t.length?{done:!0}:{done:!1,value:t[i++]}},e:function(t){throw t},f:e};throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\")}(this.properties);try{for(v.s();!(y=v.n()).done;){var m=y.value,g=(x[m]||x.default).lerpMethod,w=n.curve[m]||function(t){return t},O=g(a[m],n[m],w(c));O!==this.currentState[m]&&(d[m]=!0,b[m]=O)}}catch(t){v.e(t)}finally{v.f()}this.updateDisplay(b,d,r,e,t),Object.assign(this.currentState,b),this.container.visible=this.container._visible,d.children&&(r.mustResetTree=!0,\"function\"==typeof this.postUpdate)&&r.updatedBuffers.push(this),d.mask&&(r.maskUpdates[this.id]=b.mask),0!==Object.keys(d).length&&this.parent&&this.parent.notifyChange()}}},{key:\"notifyChange\",value:function(){this.parent&&this.parent.notifyChange()}},{key:\"initDisplay\",value:function(){this.container=new PIXI.Container,this.container.zIndex=this.defaultState.zIndex,this.container.id=this.id,this.container._visible=this.defaultState.visible}},{key:\"updateDisplay\",value:function(t,e,r){this.container.zIndex=t.zIndex,this.container.alpha=t.alpha,(e.x||e.y)&&this.container.position.set(t.x*r.toWorldUnits,t.y*r.toWorldUnits),(e.scaleX||e.scaleY)&&this.container.scale.set(t.scaleX||1e-8,t.scaleY||1e-8),this.container.rotation=t.rotation,this.container._visible=t.visible&&!this.hide,this.container.skew.set(t.skewX,t.skewY)}}])&&I(e.prototype,r),n&&I(e,n),Object.defineProperty(e,\"prototype\",{writable:!1}),t}();function D(t){return Object.keys(t).length===Object.keys(C.createState()).length}function F(t){return(F=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&\"function\"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?\"symbol\":typeof t})(t)}function A(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}function M(){return(M=\"undefined\"!=typeof Reflect&&Reflect.get?Reflect.get.bind():function(t,e,r){var n=function(t,e){for(;!Object.prototype.hasOwnProperty.call(t,e)&&null!==(t=K(t)););return t}(t,e);if(n)return(n=Object.getOwnPropertyDescriptor(n,e)).get?n.get.call(arguments.length<3?t:r):n.value}).apply(this,arguments)}function W(t,e){return(W=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t})(t,e)}function K(t){return(K=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}var X=function(){var t=o,e=C;if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function\");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,\"prototype\",{writable:!1}),e&&W(t,e);var r,n=function(t){var e=function(){if(\"undefined\"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if(\"function\"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var r,n=K(t);r=e?(r=K(this).constructor,Reflect.construct(n,arguments,r)):n.apply(this,arguments),n=this;if(r&&(\"object\"===F(r)||\"function\"==typeof r))return r;if(void 0!==r)throw new TypeError(\"Derived constructors may only return object or undefined\");if(void 0!==n)return n;throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\")}}(o);function o(){var t;if(this instanceof o)return t=n.call(this),Object.assign(t.defaultState,{fillColor:o.defaultFillColor(),lineWidth:o.defaultLineWidth(),lineColor:o.defaultLineColor(),fillAlpha:o.defaultFillAlpha(),lineAlpha:o.defaultLineAlpha(),blendMode:PIXI.BLEND_MODES.NORMAL}),t;throw new TypeError(\"Cannot call a class as a function\")}return t=o,e=[{key:\"defaultLineWidth\",value:function(){return 0}},{key:\"defaultFillColor\",value:function(){return 16777215}},{key:\"defaultLineColor\",value:function(){return 0}},{key:\"defaultLineAlpha\",value:function(){return 1}},{key:\"defaultFillAlpha\",value:function(){return 1}}],(r=[{key:\"initDisplay\",value:function(){M(K(o.prototype),\"initDisplay\",this).call(this),this.graphics=new PIXI.Graphics,this.graphics.lineStyle(this.defaultState.lineWidth,this.defaultState.lineColor,this.defaultState.lineAlpha),null!==this.defaultState.fillColor&&this.graphics.beginFill(this.defaultState.fillColor,this.defaultState.fillAlpha)}},{key:\"updateDisplay\",value:function(t,e,r){M(K(o.prototype),\"updateDisplay\",this).call(this,t,e,r),this.graphics.blendMode=t.blendMode}}])&&A(t.prototype,r),e&&A(t,e),Object.defineProperty(t,\"prototype\",{writable:!1}),o}();function B(t){return(B=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&\"function\"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?\"symbol\":typeof t})(t)}function U(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}function L(){return(L=\"undefined\"!=typeof Reflect&&Reflect.get?Reflect.get.bind():function(t,e,r){var n=function(t,e){for(;!Object.prototype.hasOwnProperty.call(t,e)&&null!==(t=H(t)););return t}(t,e);if(n)return(n=Object.getOwnPropertyDescriptor(n,e)).get?n.get.call(arguments.length<3?t:r):n.value}).apply(this,arguments)}function Y(t,e){return(Y=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t})(t,e)}function H(t){return(H=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}var V=function(){var t=o,e=X;if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function\");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,\"prototype\",{writable:!1}),e&&Y(t,e);var r,n=function(t){var e=function(){if(\"undefined\"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if(\"function\"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var r,n=H(t);r=e?(r=H(this).constructor,Reflect.construct(n,arguments,r)):n.apply(this,arguments),n=this;if(r&&(\"object\"===B(r)||\"function\"==typeof r))return r;if(void 0!==r)throw new TypeError(\"Derived constructors may only return object or undefined\");if(void 0!==n)return n;throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\")}}(o);function o(){var t;if(this instanceof o)return(t=n.call(this)).defaultState.radius=o.defaultRadius(),t;throw new TypeError(\"Cannot call a class as a function\")}return t=o,e=[{key:\"defaultRadius\",value:function(){return 100}}],(r=[{key:\"initDisplay\",value:function(){L(H(o.prototype),\"initDisplay\",this).call(this),this.graphics.drawCircle(0,0,this.defaultState.radius),null!==this.defaultState.fillColor&&this.graphics.endFill()}},{key:\"updateDisplay\",value:function(t,e,r){L(H(o.prototype),\"updateDisplay\",this).call(this,t,e,r),(e.radius||e.lineColor||e.lineWidth||e.fillColor||e.fillAlpha||e.lineAlpha)&&(this.graphics.clear(),null!==t.fillColor&&this.graphics.beginFill(t.fillColor,t.fillAlpha),this.graphics.lineStyle(t.lineWidth,t.lineColor),this.graphics.drawCircle(0,0,t.radius*r.toWorldUnits),null!==t.fillColor)&&this.graphics.endFill()}}])&&U(t.prototype,r),e&&U(t,e),Object.defineProperty(t,\"prototype\",{writable:!1}),o}();function G(t){return(G=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&\"function\"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?\"symbol\":typeof t})(t)}function z(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}function N(){return(N=\"undefined\"!=typeof Reflect&&Reflect.get?Reflect.get.bind():function(t,e,r){var n=function(t,e){for(;!Object.prototype.hasOwnProperty.call(t,e)&&null!==(t=J(t)););return t}(t,e);if(n)return(n=Object.getOwnPropertyDescriptor(n,e)).get?n.get.call(arguments.length<3?t:r):n.value}).apply(this,arguments)}function q(t,e){return(q=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t})(t,e)}function J(t){return(J=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}var Q=function(){var t=o,e=X;if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function\");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,\"prototype\",{writable:!1}),e&&q(t,e);var r,n=function(t){var e=function(){if(\"undefined\"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if(\"function\"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var r,n=J(t);r=e?(r=J(this).constructor,Reflect.construct(n,arguments,r)):n.apply(this,arguments),n=this;if(r&&(\"object\"===G(r)||\"function\"==typeof r))return r;if(void 0!==r)throw new TypeError(\"Derived constructors may only return object or undefined\");if(void 0!==n)return n;throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\")}}(o);function o(){var t;if(this instanceof o)return(t=n.call(this)).defaultState.x2=o.defaultPosition(),t.defaultState.y2=o.defaultPosition(),t;throw new TypeError(\"Cannot call a class as a function\")}return t=o,e=[{key:\"defaultPosition\",value:function(){return 100}}],(r=[{key:\"initDisplay\",value:function(){N(J(o.prototype),\"initDisplay\",this).call(this)}},{key:\"updateDisplay\",value:function(t,e,r){N(J(o.prototype),\"updateDisplay\",this).call(this,t,e,r),(e.lineWidth||e.lineColor||e.lineAlpha||e.x2||e.y2||e.x||e.y)&&(this.graphics.clear(),this.graphics.lineStyle(t.lineWidth,t.lineColor,t.lineAlpha),this.graphics.moveTo(0,0),this.graphics.lineTo(-this.container.x+t.x2*r.toWorldUnits,-this.container.y+t.y2*r.toWorldUnits))}}])&&z(t.prototype,r),e&&z(t,e),Object.defineProperty(t,\"prototype\",{writable:!1}),o}();function Z(t){return(Z=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&\"function\"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?\"symbol\":typeof t})(t)}function tt(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}function et(){return(et=\"undefined\"!=typeof Reflect&&Reflect.get?Reflect.get.bind():function(t,e,r){var n=function(t,e){for(;!Object.prototype.hasOwnProperty.call(t,e)&&null!==(t=nt(t)););return t}(t,e);if(n)return(n=Object.getOwnPropertyDescriptor(n,e)).get?n.get.call(arguments.length<3?t:r):n.value}).apply(this,arguments)}function rt(t,e){return(rt=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t})(t,e)}function nt(t){return(nt=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}var ot=function(){var t=o,e=X;if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function\");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,\"prototype\",{writable:!1}),e&&rt(t,e);var r,n=function(t){var e=function(){if(\"undefined\"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if(\"function\"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var r,n=nt(t);r=e?(r=nt(this).constructor,Reflect.construct(n,arguments,r)):n.apply(this,arguments),n=this;if(r&&(\"object\"===Z(r)||\"function\"==typeof r))return r;if(void 0!==r)throw new TypeError(\"Derived constructors may only return object or undefined\");if(void 0!==n)return n;throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\")}}(o);function o(){var t;if(this instanceof o)return t=n.call(this),Object.assign(t.defaultState,{width:o.defaultSideLength(),height:o.defaultSideLength()}),t;throw new TypeError(\"Cannot call a class as a function\")}return t=o,e=[{key:\"defaultSideLength\",value:function(){return 100}}],(r=[{key:\"initDisplay\",value:function(){et(nt(o.prototype),\"initDisplay\",this).call(this),this.graphics.drawRect(0,0,this.defaultState.width,this.defaultState.height),this.graphics.endFill()}},{key:\"updateDisplay\",value:function(t,e,r){et(nt(o.prototype),\"updateDisplay\",this).call(this,t,e,r),(e.lineWidth||e.lineColor||e.width||e.height||e.lineAlpha||e.fillColor)&&(this.graphics.clear(),null!==t.fillColor&&this.graphics.beginFill(t.fillColor,t.fillAlpha),this.graphics.lineStyle(t.lineWidth,t.lineColor,t.lineAlpha),this.graphics.drawRect(0,0,t.width*r.toWorldUnits,t.height*r.toWorldUnits),null!==t.fillColor)&&this.graphics.endFill()}}])&&tt(t.prototype,r),e&&tt(t,e),Object.defineProperty(t,\"prototype\",{writable:!1}),o}();function it(t){return(it=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&\"function\"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?\"symbol\":typeof t})(t)}function at(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}function ct(){return(ct=\"undefined\"!=typeof Reflect&&Reflect.get?Reflect.get.bind():function(t,e,r){var n=function(t,e){for(;!Object.prototype.hasOwnProperty.call(t,e)&&null!==(t=st(t)););return t}(t,e);if(n)return(n=Object.getOwnPropertyDescriptor(n,e)).get?n.get.call(arguments.length<3?t:r):n.value}).apply(this,arguments)}function ut(t,e){return(ut=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t})(t,e)}function st(t){return(st=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}var lt=function(){var t=o,e=C;if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function\");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,\"prototype\",{writable:!1}),e&&ut(t,e);var r,n=function(t){var e=function(){if(\"undefined\"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if(\"function\"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var r,n=st(t);r=e?(r=st(this).constructor,Reflect.construct(n,arguments,r)):n.apply(this,arguments),n=this;if(r&&(\"object\"===it(r)||\"function\"==typeof r))return r;if(void 0!==r)throw new TypeError(\"Derived constructors may only return object or undefined\");if(void 0!==n)return n;throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\")}}(o);function o(){var t;if(this instanceof o)return t=n.call(this),Object.assign(t.defaultState,{anchorX:o.defaultAnchor(),anchorY:o.defaultAnchor(),blendMode:PIXI.BLEND_MODES.NORMAL,tint:16777215}),t;throw new TypeError(\"Cannot call a class as a function\")}return t=o,e=[{key:\"defaultAnchor\",value:function(){return 0}}],(r=[{key:\"initDisplay\",value:function(){ct(st(o.prototype),\"initDisplay\",this).call(this)}},{key:\"updateDisplay\",value:function(t,e,r){ct(st(o.prototype),\"updateDisplay\",this).call(this,t,e,r),this.graphics.anchor.set(t.anchorX,t.anchorY),this.graphics.blendMode=t.blendMode,this.graphics.tint=t.tint}}])&&at(t.prototype,r),e&&at(t,e),Object.defineProperty(t,\"prototype\",{writable:!1}),o}();function ft(t){return(ft=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&\"function\"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?\"symbol\":typeof t})(t)}function pt(t,e,r){return(pt=ht()?Reflect.construct.bind():function(t,e,r){var n=[null];return n.push.apply(n,e),e=new(Function.bind.apply(t,n)),r&&yt(e,r.prototype),e}).apply(null,arguments)}function ht(){if(\"undefined\"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if(\"function\"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}function yt(t,e){return(yt=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t})(t,e)}function dt(t){return(dt=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}var bt=function(t){var e=n;if(\"function\"!=typeof t&&null!==t)throw new TypeError(\"Super expression must either be null or a function\");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),Object.defineProperty(e,\"prototype\",{writable:!1}),t&&yt(e,t);var r=function(t){var e=ht();return function(){var r,n=dt(t);r=e?(r=dt(this).constructor,Reflect.construct(n,arguments,r)):n.apply(this,arguments),n=this;if(r&&(\"object\"===ft(r)||\"function\"==typeof r))return r;if(void 0!==r)throw new TypeError(\"Derived constructors may only return object or undefined\");if(void 0!==n)return n;throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\")}}(n);function n(t,e){var o;if(this instanceof n)return(o=r.call(this,'Could not find image: \"'+t+'\". Make sure it is in your assets folder and is spelled correctly.')).image=t,o.cause=e,o.name=\"MissingImageError\",o;throw new TypeError(\"Cannot call a class as a function\")}return e=n,Object.defineProperty(e,\"prototype\",{writable:!1}),e}(function(t){var e=\"function\"==typeof Map?new Map:void 0;return function(t){if(null===t||-1===Function.toString.call(t).indexOf(\"[native code]\"))return t;if(\"function\"!=typeof t)throw new TypeError(\"Super expression must either be null or a function\");if(void 0!==e){if(e.has(t))return e.get(t);e.set(t,r)}function r(){return pt(t,arguments,dt(this).constructor)}return r.prototype=Object.create(t.prototype,{constructor:{value:r,enumerable:!1,writable:!0,configurable:!0}}),yt(r,t)}(t)}(Error));function vt(t){return(vt=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&\"function\"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?\"symbol\":typeof t})(t)}function mt(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}function gt(){return(gt=\"undefined\"!=typeof Reflect&&Reflect.get?Reflect.get.bind():function(t,e,r){var n=function(t,e){for(;!Object.prototype.hasOwnProperty.call(t,e)&&null!==(t=Ot(t)););return t}(t,e);if(n)return(n=Object.getOwnPropertyDescriptor(n,e)).get?n.get.call(arguments.length<3?t:r):n.value}).apply(this,arguments)}function wt(t,e){return(wt=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t})(t,e)}function Ot(t){return(Ot=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}var Pt=function(){var t=n,e=lt;if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function\");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,\"prototype\",{writable:!1}),e&&wt(t,e);var r=function(t){var e=function(){if(\"undefined\"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if(\"function\"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var r,n=Ot(t);r=e?(r=Ot(this).constructor,Reflect.construct(n,arguments,r)):n.apply(this,arguments),n=this;if(r&&(\"object\"===vt(r)||\"function\"==typeof r))return r;if(void 0!==r)throw new TypeError(\"Derived constructors may only return object or undefined\");if(void 0!==n)return n;throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\")}}(n);function n(){var t;if(this instanceof n)return t=r.call(this),Object.assign(t.defaultState,{image:null,baseWidth:null,baseHeight:null,scaleMode:\"LINEAR\"}),t.missingTextures={},t;throw new TypeError(\"Cannot call a class as a function\")}return t=n,(e=[{key:\"updateDisplay\",value:function(t,e,r){if(gt(Ot(n.prototype),\"updateDisplay\",this).call(this,t,e,r),e.image)try{null!==t.image?this.graphics.texture=PIXI.Texture.from(t.image):this.graphics.texture=PIXI.Texture.EMPTY,this.graphics.texture.baseTexture.scaleMode=PIXI.SCALE_MODES[t.scaleMode]}catch(e){this.missingTextures[t.image]||(this.missingTextures[t.image]=!0,l.push(new bt(t.image,e)))}e.baseWidth&&(this.graphics.width=t.baseWidth),e.baseHeight&&(this.graphics.height=t.baseHeight)}}])&&mt(t.prototype,e),Object.defineProperty(t,\"prototype\",{writable:!1}),n}();function jt(t){return(jt=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&\"function\"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?\"symbol\":typeof t})(t)}function St(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}function xt(){return(xt=\"undefined\"!=typeof Reflect&&Reflect.get?Reflect.get.bind():function(t,e,r){var n=function(t,e){for(;!Object.prototype.hasOwnProperty.call(t,e)&&null!==(t=Rt(t)););return t}(t,e);if(n)return(n=Object.getOwnPropertyDescriptor(n,e)).get?n.get.call(arguments.length<3?t:r):n.value}).apply(this,arguments)}function Tt(t,e){return(Tt=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t})(t,e)}function Rt(t){return(Rt=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}var Et=function(){var t=n,e=Pt;if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function\");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,\"prototype\",{writable:!1}),e&&Tt(t,e);var r=function(t){var e=function(){if(\"undefined\"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if(\"function\"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var r,n=Rt(t);r=e?(r=Rt(this).constructor,Reflect.construct(n,arguments,r)):n.apply(this,arguments),n=this;if(r&&(\"object\"===jt(r)||\"function\"==typeof r))return r;if(void 0!==r)throw new TypeError(\"Derived constructors may only return object or undefined\");if(void 0!==n)return n;throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\")}}(n);function n(){var t=this,e=n;if(t instanceof e)return r.apply(this,arguments);throw new TypeError(\"Cannot call a class as a function\")}return t=n,(e=[{key:\"initDisplay\",value:function(){xt(Rt(n.prototype),\"initDisplay\",this).call(this),null===this.defaultState.image?this.graphics=new PIXI.Sprite(PIXI.Texture.EMPTY):this.graphics=PIXI.Sprite.from(this.defaultState.image)}}])&&St(t.prototype,e),Object.defineProperty(t,\"prototype\",{writable:!1}),n}();function kt(t,e){if(t.width>e)for(;3<t.text.length&&t.width>e;)t.text=t.text.slice(0,-4)+\"...\"}function _t(t){return(_t=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&\"function\"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?\"symbol\":typeof t})(t)}function It(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}function Ct(){return(Ct=\"undefined\"!=typeof Reflect&&Reflect.get?Reflect.get.bind():function(t,e,r){var n=function(t,e){for(;!Object.prototype.hasOwnProperty.call(t,e)&&null!==(t=Ft(t)););return t}(t,e);if(n)return(n=Object.getOwnPropertyDescriptor(n,e)).get?n.get.call(arguments.length<3?t:r):n.value}).apply(this,arguments)}function Dt(t,e){return(Dt=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t})(t,e)}function Ft(t){return(Ft=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}var At=function(){var t=n,e=lt;if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function\");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,\"prototype\",{writable:!1}),e&&Dt(t,e);var r=function(t){var e=function(){if(\"undefined\"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if(\"function\"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var r,n=Ft(t);r=e?(r=Ft(this).constructor,Reflect.construct(n,arguments,r)):n.apply(this,arguments),n=this;if(r&&(\"object\"===_t(r)||\"function\"==typeof r))return r;if(void 0!==r)throw new TypeError(\"Derived constructors may only return object or undefined\");if(void 0!==n)return n;throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\")}}(n);function n(){var t;if(this instanceof n)return t=r.call(this),Object.assign(t.defaultState,{text:\"\",textAlign:\"left\",strokeColor:0,strokeThickness:0,fillColor:0,fontSize:26,fontFamily:\"Lato\",fontWeight:\"normal\",maxWidth:0}),t;throw new TypeError(\"Cannot call a class as a function\")}return t=n,(e=[{key:\"initDisplay\",value:function(){Ct(Ft(n.prototype),\"initDisplay\",this).call(this),this.graphics=new PIXI.Text(this.defaultState.text,{align:this.defaultState.textAlign,fontSize:this.defaultState.fontSize+\"px\",fontFamily:this.defaultState.fontFamily,fill:this.defaultState.fillColor})}},{key:\"updateDisplay\",value:function(t,e,r){Ct(Ft(n.prototype),\"updateDisplay\",this).call(this,t,e,r),this.graphics.style.align=t.textAlign,this.graphics.style.stroke=t.strokeColor,this.graphics.style.strokeThickness=t.strokeThickness,this.graphics.style.fill=t.fillColor,this.graphics.style.fontSize=t.fontSize||1,this.graphics.style.fontFamily=t.fontFamily,this.graphics.style.fontWeight=t.fontWeight,(e.text||e.strokeThickness||e.fontSize||e.fontFamily||e.fontWeight||e.maxWidth||e.maxWidth)&&(this.graphics.text=t.text,t.maxWidth)&&kt(this.graphics,t.maxWidth)}}])&&It(t.prototype,e),Object.defineProperty(t,\"prototype\",{writable:!1}),n}();function Mt(t){return(Mt=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&\"function\"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?\"symbol\":typeof t})(t)}function Wt(t,e,r){return(Wt=Kt()?Reflect.construct.bind():function(t,e,r){var n=[null];return n.push.apply(n,e),e=new(Function.bind.apply(t,n)),r&&Xt(e,r.prototype),e}).apply(null,arguments)}function Kt(){if(\"undefined\"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if(\"function\"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}function Xt(t,e){return(Xt=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t})(t,e)}function Bt(t){return(Bt=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}var Ut=function(t){var e=n;if(\"function\"!=typeof t&&null!==t)throw new TypeError(\"Super expression must either be null or a function\");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),Object.defineProperty(e,\"prototype\",{writable:!1}),t&&Xt(e,t);var r=function(t){var e=Kt();return function(){var r,n=Bt(t);r=e?(r=Bt(this).constructor,Reflect.construct(n,arguments,r)):n.apply(this,arguments),n=this;if(r&&(\"object\"===Mt(r)||\"function\"==typeof r))return r;if(void 0!==r)throw new TypeError(\"Derived constructors may only return object or undefined\");if(void 0!==n)return n;throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\")}}(n);function n(t,e){var o;if(this instanceof n)return(o=r.call(this,'Could not find font: \"'+t+'\". Make sure it is in your assets folder and is spelled correctly.')).font=t,o.cause=e,o.name=\"MissingBitmapFontError\",o;throw new TypeError(\"Cannot call a class as a function\")}return e=n,Object.defineProperty(e,\"prototype\",{writable:!1}),e}(function(t){var e=\"function\"==typeof Map?new Map:void 0;return function(t){if(null===t||-1===Function.toString.call(t).indexOf(\"[native code]\"))return t;if(\"function\"!=typeof t)throw new TypeError(\"Super expression must either be null or a function\");if(void 0!==e){if(e.has(t))return e.get(t);e.set(t,r)}function r(){return Wt(t,arguments,Bt(this).constructor)}return r.prototype=Object.create(t.prototype,{constructor:{value:r,enumerable:!1,writable:!0,configurable:!0}}),Xt(r,t)}(t)}(Error));function Lt(t){return(Lt=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&\"function\"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?\"symbol\":typeof t})(t)}function Yt(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}function Ht(){return(Ht=\"undefined\"!=typeof Reflect&&Reflect.get?Reflect.get.bind():function(t,e,r){var n=function(t,e){for(;!Object.prototype.hasOwnProperty.call(t,e)&&null!==(t=Gt(t)););return t}(t,e);if(n)return(n=Object.getOwnPropertyDescriptor(n,e)).get?n.get.call(arguments.length<3?t:r):n.value}).apply(this,arguments)}function Vt(t,e){return(Vt=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t})(t,e)}function Gt(t){return(Gt=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}var zt=function(){var t=n,e=C;if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function\");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,\"prototype\",{writable:!1}),e&&Vt(t,e);var r=function(t){var e=function(){if(\"undefined\"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if(\"function\"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var r,n=Gt(t);r=e?(r=Gt(this).constructor,Reflect.construct(n,arguments,r)):n.apply(this,arguments),n=this;if(r&&(\"object\"===Lt(r)||\"function\"==typeof r))return r;if(void 0!==r)throw new TypeError(\"Derived constructors may only return object or undefined\");if(void 0!==n)return n;throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\")}}(n);function n(){var t;if(this instanceof n)return t=r.call(this),Object.assign(t.defaultState,{text:\"\",textAlign:\"left\",fontSize:26,fontFamily:null,anchorX:lt.defaultAnchor(),anchorY:lt.defaultAnchor(),blendMode:PIXI.BLEND_MODES.NORMAL,tint:16777215,maxWidth:0}),t.missingFonts={},t;throw new TypeError(\"Cannot call a class as a function\")}return t=n,(e=[{key:\"initDisplay\",value:function(){Ht(Gt(n.prototype),\"initDisplay\",this).call(this),this.graphics=new PIXI.Container}},{key:\"updateDisplay\",value:function(t,e,r){Ht(Gt(n.prototype),\"updateDisplay\",this).call(this,t,e,r),null!==t.fontFamily?PIXI.BitmapFont.available[t.fontFamily]?(0===this.graphics.children.length?(this.displayed=new PIXI.BitmapText(\"\",{fontSize:t.fontSize||1,fontName:t.fontFamily}),this.graphics.addChild(this.displayed)):(this.displayed.fontName=t.fontFamily,this.displayed.fontSize=t.fontSize||1),this.displayed.anchor.set(t.anchorX,t.anchorY),this.displayed.blendMode=t.blendMode,this.displayed.tint=t.tint,this.displayed.align=t.textAlign,(e.text||e.maxWidth||e.fontSize||e.fontFamily)&&(this.displayed.text=t.text,t.maxWidth)&&kt(this.displayed,t.maxWidth)):(this.missingFonts[t.fontFamily]||(this.missingFonts[t.fontFamily]=!0,l.push(new Ut(t.fontFamily))),this.graphics.removeChildren()):this.graphics.removeChildren()}}])&&Yt(t.prototype,e),Object.defineProperty(t,\"prototype\",{writable:!1}),n}();function Nt(t){return(Nt=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&\"function\"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?\"symbol\":typeof t})(t)}function $t(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}function qt(){return(qt=\"undefined\"!=typeof Reflect&&Reflect.get?Reflect.get.bind():function(t,e,r){var n=function(t,e){for(;!Object.prototype.hasOwnProperty.call(t,e)&&null!==(t=Qt(t)););return t}(t,e);if(n)return(n=Object.getOwnPropertyDescriptor(n,e)).get?n.get.call(arguments.length<3?t:r):n.value}).apply(this,arguments)}function Jt(t,e){return(Jt=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t})(t,e)}function Qt(t){return(Qt=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}var Zt=function(){var t=n,e=C;if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function\");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,\"prototype\",{writable:!1}),e&&Jt(t,e);var r=function(t){var e=function(){if(\"undefined\"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if(\"function\"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var r,n=Qt(t);r=e?(r=Qt(this).constructor,Reflect.construct(n,arguments,r)):n.apply(this,arguments),n=this;if(r&&(\"object\"===Nt(r)||\"function\"==typeof r))return r;if(void 0!==r)throw new TypeError(\"Derived constructors may only return object or undefined\");if(void 0!==n)return n;throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\")}}(n);function n(){var t;if(this instanceof n)return t=r.call(this),Object.assign(t.defaultState,{children:[]}),t;throw new TypeError(\"Cannot call a class as a function\")}return t=n,(e=[{key:\"initDisplay\",value:function(){qt(Qt(n.prototype),\"initDisplay\",this).call(this),this.graphics=new PIXI.Container}},{key:\"updateDisplay\",value:function(t,e,r){qt(Qt(n.prototype),\"updateDisplay\",this).call(this,t,e,r)}},{key:\"childrenContainer\",get:function(){return this.graphics}}])&&$t(t.prototype,e),Object.defineProperty(t,\"prototype\",{writable:!1}),n}();function te(t){return(te=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&\"function\"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?\"symbol\":typeof t})(t)}function ee(t,e){return(ee=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t})(t,e)}function re(t){return(re=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}var ne=function(){var t=n,e=Zt;if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function\");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,\"prototype\",{writable:!1}),e&&ee(t,e);var r=function(t){var e=function(){if(\"undefined\"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if(\"function\"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var r,n=re(t);r=e?(r=re(this).constructor,Reflect.construct(n,arguments,r)):n.apply(this,arguments),n=this;if(r&&(\"object\"===te(r)||\"function\"==typeof r))return r;if(void 0!==r)throw new TypeError(\"Derived constructors may only return object or undefined\");if(void 0!==n)return n;throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\")}}(n);function n(){var t=this,e=n;if(t instanceof e)return r.apply(this,arguments);throw new TypeError(\"Cannot call a class as a function\")}return t=n,Object.defineProperty(t,\"prototype\",{writable:!1}),t}(),oe=null,ie=[];function ae(t){return(ae=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&\"function\"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?\"symbol\":typeof t})(t)}function ce(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}function ue(){return(ue=\"undefined\"!=typeof Reflect&&Reflect.get?Reflect.get.bind():function(t,e,r){var n=function(t,e){for(;!Object.prototype.hasOwnProperty.call(t,e)&&null!==(t=le(t)););return t}(t,e);if(n)return(n=Object.getOwnPropertyDescriptor(n,e)).get?n.get.call(arguments.length<3?t:r):n.value}).apply(this,arguments)}function se(t,e){return(se=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t})(t,e)}function le(t){return(le=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}var fe=function(){var t=n,e=Zt;if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function\");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,\"prototype\",{writable:!1}),e&&se(t,e);var r=function(t){var e=function(){if(\"undefined\"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if(\"function\"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var r,n=le(t);r=e?(r=le(this).constructor,Reflect.construct(n,arguments,r)):n.apply(this,arguments),n=this;if(r&&(\"object\"===ae(r)||\"function\"==typeof r))return r;if(void 0!==r)throw new TypeError(\"Derived constructors may only return object or undefined\");if(void 0!==n)return n;throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\")}}(n);function n(){var t=this,e=n;if(t instanceof e)return r.apply(this,arguments);throw new TypeError(\"Cannot call a class as a function\")}return t=n,(e=[{key:\"initDisplay\",value:function(){ue(le(n.prototype),\"initDisplay\",this).call(this),this.buffer=new PIXI.Container,this.gameTexture=null,this.graphics=new PIXI.Sprite,this.needsRender=!0}},{key:\"postUpdate\",value:function(){var t,e;this.needsRender&&(e=this.buffer.getBounds().width,t=this.buffer.getBounds().height,(null==this.gameTexture||this.gameTexture.width<e||this.gameTexture.height<t)&&(e=Math.min(Math.max(e,512),4096),t=Math.min(Math.max(t,512),4096),this.gameTexture=PIXI.RenderTexture.create(e,t),e=this.gameTexture,ie.push(e),this.graphics.texture=this.gameTexture),oe.render(this.buffer,this.gameTexture),this.needsRender=!1)}},{key:\"childrenContainer\",get:function(){return this.buffer}},{key:\"notifyChange\",value:function(){this.needsRender=!0,this.parent&&this.parent.notifyChange()}}])&&ce(t.prototype,e),Object.defineProperty(t,\"prototype\",{writable:!1}),n}();function pe(t){return(pe=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&\"function\"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?\"symbol\":typeof t})(t)}function he(t,e){var r,n=Object.keys(t);return Object.getOwnPropertySymbols&&(r=Object.getOwnPropertySymbols(t),e&&(r=r.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,r)),n}function ye(t){for(var e=1;e<arguments.length;e++){var r=null!=arguments[e]?arguments[e]:{};e%2?he(Object(r),!0).forEach((function(e){var n,o;n=t,o=r[e=e],e in n?Object.defineProperty(n,e,{value:o,enumerable:!0,configurable:!0,writable:!0}):n[e]=o})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(r)):he(Object(r)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(r,e))}))}return t}function de(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}function be(){return(be=\"undefined\"!=typeof Reflect&&Reflect.get?Reflect.get.bind():function(t,e,r){var n=function(t,e){for(;!Object.prototype.hasOwnProperty.call(t,e)&&null!==(t=me(t)););return t}(t,e);if(n)return(n=Object.getOwnPropertyDescriptor(n,e)).get?n.get.call(arguments.length<3?t:r):n.value}).apply(this,arguments)}function ve(t,e){return(ve=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t})(t,e)}function me(t){return(me=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}var ge=function(){var t=n,e=lt;if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function\");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,\"prototype\",{writable:!1}),e&&ve(t,e);var r=function(t){var e=function(){if(\"undefined\"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if(\"function\"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var r,n=me(t);r=e?(r=me(this).constructor,Reflect.construct(n,arguments,r)):n.apply(this,arguments),n=this;if(r&&(\"object\"===pe(r)||\"function\"==typeof r))return r;if(void 0!==r)throw new TypeError(\"Derived constructors may only return object or undefined\");if(void 0!==n)return n;throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\")}}(n);function n(){var t;if(this instanceof n)return t=r.call(this),Object.assign(t.defaultState,{images:\"\",loop:!1,duration:1e3,playing:!0,restarted:null,animationProgress:0,date:0}),t;throw new TypeError(\"Cannot call a class as a function\")}return t=n,(e=[{key:\"initDisplay\",value:function(){be(me(n.prototype),\"initDisplay\",this).call(this),this.graphics=new PIXI.Sprite(PIXI.Texture.EMPTY)}},{key:\"addState\",value:function(t,e,r,o){be(me(n.prototype),\"addState\",this).call(this,t,e,r),e=this.states[r].find((function(e){return e.t===t})),r=o.date+o.frameDuration*t,e.date=r}},{key:\"updateDisplay\",value:function(t,e,r,o,i){if(be(me(n.prototype),\"updateDisplay\",this).call(this,t,e,r),t.images){if(e=t.images.split(\",\"),0<=t.animationProgress){r=o.date+o.frameDuration*i,o=ye(ye({},t),{},{date:r}),this.computeAnimationProgressTime(t,o),i=Math.floor(e.length*o.animationProgress),r=t.loop?e[i%e.length]:e[i]||e[e.length-1];try{this.graphics.texture=PIXI.Texture.from(r)}catch(t){l.push(new bt(r,t))}}}else this.graphics.texture=PIXI.Texture.EMPTY}},{key:\"computeAnimationProgressTime\",value:function(t,e){e.restarted&&e.restarted.date===e.date?e.animationProgress=0:(e.animationProgress=t.animationProgress,t.playing&&(e.animationProgress+=(e.date-t.date)/t.duration))}}])&&de(t.prototype,e),Object.defineProperty(t,\"prototype\",{writable:!1}),n}();function we(t){return(we=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&\"function\"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?\"symbol\":typeof t})(t)}function Oe(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}function Pe(){return(Pe=\"undefined\"!=typeof Reflect&&Reflect.get?Reflect.get.bind():function(t,e,r){var n=function(t,e){for(;!Object.prototype.hasOwnProperty.call(t,e)&&null!==(t=Se(t)););return t}(t,e);if(n)return(n=Object.getOwnPropertyDescriptor(n,e)).get?n.get.call(arguments.length<3?t:r):n.value}).apply(this,arguments)}function je(t,e){return(je=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t})(t,e)}function Se(t){return(Se=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}var xe=function(){var t=o,e=X;if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function\");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,\"prototype\",{writable:!1}),e&&je(t,e);var r,n=function(t){var e=function(){if(\"undefined\"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if(\"function\"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var r,n=Se(t);r=e?(r=Se(this).constructor,Reflect.construct(n,arguments,r)):n.apply(this,arguments),n=this;if(r&&(\"object\"===we(r)||\"function\"==typeof r))return r;if(void 0!==r)throw new TypeError(\"Derived constructors may only return object or undefined\");if(void 0!==n)return n;throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\")}}(o);function o(){var t;if(this instanceof o)return t=n.call(this),Object.assign(t.defaultState,{width:o.defaultSideLength(),height:o.defaultSideLength(),radius:o.defaultRadius()}),t;throw new TypeError(\"Cannot call a class as a function\")}return t=o,e=[{key:\"defaultSideLength\",value:function(){return 100}},{key:\"defaultRadius\",value:function(){return 20}}],(r=[{key:\"initDisplay\",value:function(){Pe(Se(o.prototype),\"initDisplay\",this).call(this),this.graphics.drawRoundedRect(0,0,this.defaultState.width,this.defaultState.height,this.defaultState.radius),this.graphics.endFill()}},{key:\"updateDisplay\",value:function(t,e,r){Pe(Se(o.prototype),\"updateDisplay\",this).call(this,t,e,r),(e.lineWidth||e.lineColor||e.lineAlpha||e.fillColor||e.radius||e.height||e.width)&&(this.graphics.clear(),null!==t.fillColor&&this.graphics.beginFill(t.fillColor,t.fillAlpha),this.graphics.lineStyle(t.lineWidth,t.lineColor,t.lineAlpha),this.graphics.drawRoundedRect(0,0,t.width*r.toWorldUnits,t.height*r.toWorldUnits,t.radius*r.toWorldUnits),null!==t.fillColor)&&this.graphics.endFill()}}])&&Oe(t.prototype,r),e&&Oe(t,e),Object.defineProperty(t,\"prototype\",{writable:!1}),o}();function Te(t){return(Te=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&\"function\"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?\"symbol\":typeof t})(t)}function Re(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}function Ee(){return(Ee=\"undefined\"!=typeof Reflect&&Reflect.get?Reflect.get.bind():function(t,e,r){var n=function(t,e){for(;!Object.prototype.hasOwnProperty.call(t,e)&&null!==(t=_e(t)););return t}(t,e);if(n)return(n=Object.getOwnPropertyDescriptor(n,e)).get?n.get.call(arguments.length<3?t:r):n.value}).apply(this,arguments)}function ke(t,e){return(ke=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t})(t,e)}function _e(t){return(_e=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}var Ie=function(){var t=n,e=X;if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function\");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,\"prototype\",{writable:!1}),e&&ke(t,e);var r=function(t){var e=function(){if(\"undefined\"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if(\"function\"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var r,n=_e(t);r=e?(r=_e(this).constructor,Reflect.construct(n,arguments,r)):n.apply(this,arguments),n=this;if(r&&(\"object\"===Te(r)||\"function\"==typeof r))return r;if(void 0!==r)throw new TypeError(\"Derived constructors may only return object or undefined\");if(void 0!==n)return n;throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\")}}(n);function n(){var t;if(this instanceof n)return t=r.call(this),Object.assign(t.defaultState,{points:[]}),t;throw new TypeError(\"Cannot call a class as a function\")}return t=n,(e=[{key:\"initDisplay\",value:function(){Ee(_e(n.prototype),\"initDisplay\",this).call(this),this.graphics.endFill()}},{key:\"updateDisplay\",value:function(t,e,r){Ee(_e(n.prototype),\"updateDisplay\",this).call(this,t,e,r),(e.lineWidth||e.lineColor||e.lineAlpha||e.fillColor||e.points)&&(this.graphics.clear(),null!==t.fillColor&&this.graphics.beginFill(t.fillColor,t.fillAlpha),this.graphics.lineStyle(t.lineWidth,t.lineColor,t.lineAlpha),this.graphics.drawPolygon(t.points.map((function(t){return t*r.toWorldUnits}))),null!==t.fillColor)&&this.graphics.endFill()}}])&&Re(t.prototype,e),Object.defineProperty(t,\"prototype\",{writable:!1}),n}();function Ce(t){return(Ce=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&\"function\"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?\"symbol\":typeof t})(t)}function De(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}function Fe(){return(Fe=\"undefined\"!=typeof Reflect&&Reflect.get?Reflect.get.bind():function(t,e,r){var n=function(t,e){for(;!Object.prototype.hasOwnProperty.call(t,e)&&null!==(t=Me(t)););return t}(t,e);if(n)return(n=Object.getOwnPropertyDescriptor(n,e)).get?n.get.call(arguments.length<3?t:r):n.value}).apply(this,arguments)}function Ae(t,e){return(Ae=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t})(t,e)}function Me(t){return(Me=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}var We=function(){var t=n,e=Pt;if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function\");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,\"prototype\",{writable:!1}),e&&Ae(t,e);var r=function(t){var e=function(){if(\"undefined\"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if(\"function\"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var r,n=Me(t);r=e?(r=Me(this).constructor,Reflect.construct(n,arguments,r)):n.apply(this,arguments),n=this;if(r&&(\"object\"===Ce(r)||\"function\"==typeof r))return r;if(void 0!==r)throw new TypeError(\"Derived constructors may only return object or undefined\");if(void 0!==n)return n;throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\")}}(n);function n(){var t;if(this instanceof n)return t=r.call(this),Object.assign(t.defaultState,{tileX:0,tileY:0,tileScaleX:1,tileScaleY:1}),t;throw new TypeError(\"Cannot call a class as a function\")}return t=n,(e=[{key:\"initDisplay\",value:function(){Fe(Me(n.prototype),\"initDisplay\",this).call(this),this.graphics=new PIXI.TilingSprite(PIXI.Texture.EMPTY)}},{key:\"updateDisplay\",value:function(t,e,r){Fe(Me(n.prototype),\"updateDisplay\",this).call(this,t,e,r),this.graphics.tilePosition.x=t.tileX,this.graphics.tilePosition.y=t.tileY,this.graphics.tileScale.x=t.tileScaleX,this.graphics.tileScale.y=t.tileScaleY}}])&&De(t.prototype,e),Object.defineProperty(t,\"prototype\",{writable:!1}),n}();function Ke(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}var Xe=function(){function t(){if(!(this instanceof t))throw new TypeError(\"Cannot call a class as a function\")}var e,r;return e=t,r=[{key:\"create\",value:function(t){var e={C:V,R:ot,L:Q,S:Et,T:At,X:zt,G:ne,B:fe,A:ge,K:xe,P:Ie,D:We}[t];if(e)return new e;throw new Error(\"Exception: entity type not found: \"+t)}}],null&&Ke(e.prototype,null),r&&Ke(e,r),Object.defineProperty(e,\"prototype\",{writable:!1}),t}();function Be(t){var e=1.70158,r=0,n=1;return 0===t?0:1==(t/=1)?1:(r=r||.3,e=n<Math.abs(1)?(n=1,r/4):r/(2*Math.PI)*Math.asin(1/n),n*Math.pow(2,-10*t)*Math.sin((+t-e)*(2*Math.PI)/r)+1)}function Ue(t){return t<.5?2*t*t:(4-2*t)*t-1}function Le(t){return Math.pow(t,3)}function Ye(t){return 1+Math.pow(t-1,3)}function He(t,e){(null==e||e>t.length)&&(e=t.length);for(var r=0,n=new Array(e);r<e;r++)n[r]=t[r];return n}function Ve(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}function Ge(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}function ze(t,e,r){e&&Ge(t.prototype,e),r&&Ge(t,r),Object.defineProperty(t,\"prototype\",{writable:!1})}var Ne={r:\"rotation\",R:\"radius\",X:\"x2\",Y:\"y2\",w:\"width\",h:\"height\",t:\"tint\",f:\"fillColor\",F:\"fillAlpha\",c:\"lineColor\",W:\"lineWidth\",A:\"lineAlpha\",a:\"alpha\",i:\"image\",S:\"strokeThickness\",sc:\"strokeColor\",ff:\"fontFamily\",s:\"fontSize\",fw:\"fontWeight\",T:\"text\",ta:\"textAlign\",ch:\"children\",sx:\"scaleX\",sy:\"scaleY\",ax:\"anchorX\",ay:\"anchorY\",kx:\"skewX\",ky:\"skewY\",v:\"visible\",z:\"zIndex\",b:\"blendMode\",I:\"images\",rs:\"restarted\",p:\"playing\",l:\"loop\",d:\"duration\",bw:\"baseWidth\",bh:\"baseHeight\",ps:\"points\",tx:\"tileX\",ty:\"tileY\",tsx:\"tileScaleX\",tsy:\"tileScaleY\",sm:\"scaleMode\"};O=function(){function t(e,r){Ve(this,t),this.id=++r.instanceCount,this.type=e[0]}return ze(t,[{key:\"apply\",value:function(t){var e=Xe.create(this.type);e.id=this.id,t.set(this.id,e)}}]),t}(),r=function(){function t(e,r){for(var o=(e=function(t,e){return function(t){if(Array.isArray(t))return t}(t)||function(t,e){var r=null==t?null:\"undefined\"!=typeof Symbol&&t[Symbol.iterator]||t[\"@@iterator\"];if(null!=r){var n,o,i=[],a=!0,c=!1;try{for(r=r.call(t);!(a=(n=r.next()).done)&&(i.push(n.value),!e||i.length!==e);a=!0);}catch(t){c=!0,o=t}finally{try{a||null==r.return||r.return()}finally{if(c)throw o}}return i}}(t,e)||function(t,e){var r;if(t)return\"string\"==typeof t?He(t,e):\"Map\"===(r=\"Object\"===(r=Object.prototype.toString.call(t).slice(8,-1))&&t.constructor?t.constructor.name:r)||\"Set\"===r?Array.from(t):\"Arguments\"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)?He(t,e):void 0}(t,e)||function(){throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\")}()}(e,8))[0],i=e[1],a=e[2],c=e[3],u=e[4],s=e[5],l=e[6],f=(e=e[7],Ve(this,t),this.loader=new PIXI.Loader,\"0\"===a&&(a=PIXI.utils.TextureCache[i].width),\"0\"===c&&(c=PIXI.utils.TextureCache[i].height),0<e?e:l),p={frames:{},meta:{image:(n.baseUrl||\"\")+n.images[i]}},h=0;h<l;h++)p.frames[1<l?o+h:o]={frame:{x:a*s+h%f*a,y:c*u+Math.floor(h/f)*c,w:a,h:c},sourceSize:{w:a,h:c},rotated:!1,trimmed:!1};e=\"data:text/json;charset=UTF-8,\"+JSON.stringify(p),PIXI.utils.TextureCache[e+\"_image\"]||this.loader.add(e,{crossOrigin:!0})}return ze(t,[{key:\"apply\",value:function(){var t=this;if(0<Object.keys(this.loader.resources).length)return new Promise((function(e){t.loader.load(),t.loader.onComplete.add(e)}))}}]),t}();function $e(t){return function(t){if(Array.isArray(t))return qe(t)}(t)||function(t){if(\"undefined\"!=typeof Symbol&&null!=t[Symbol.iterator]||null!=t[\"@@iterator\"])return Array.from(t)}(t)||function(t,e){var r;if(t)return\"string\"==typeof t?qe(t,e):\"Map\"===(r=\"Object\"===(r=Object.prototype.toString.call(t).slice(8,-1))&&t.constructor?t.constructor.name:r)||\"Set\"===r?Array.from(t):\"Arguments\"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)?qe(t,e):void 0}(t)||function(){throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\")}()}function qe(t,e){(null==e||e>t.length)&&(e=t.length);for(var r=0,n=new Array(e);r<e;r++)n[r]=t[r];return n}function Je(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}var Qe={C:O,U:function(){function t(e,r,n){Ve(this,t),this.id=+e[0],this.t=+e[1],this.params={},this.curve={};for(var o=2;o<e.length;){var i=Ne[e[o]]||e[o],a=(c=x[i]||x.default).type(e[o+1]),c=(\"function\"==typeof c.convert&&(a=c.convert(a,r,n,this.t)),t.curves[e[o+2]]);this.params[i]=a,o+=2,c&&(this.curve[i]=c,o+=1)}}return ze(t,[{key:\"apply\",value:function(t,e){(t=t.get(this.id)).addState(this.t,{values:this.params,curve:this.curve},e.number,e),t.stateAdded=!0}}],[{key:\"curves\",get:function(){return{_:function(t){return t<1?0:1},\"\":Ue,\"\":Le,\"\":Ye,\"~\":Be,\"\":function(t){return 1}}}}]),t}(),L:r};function Ze(t,e){for(var r=[],n=\"\",o=0,i=\"\",a=!1;o<t.length;){var c=t[o++];c===e?a?n+=c:(r.push(n),n=\"\"):\"'\"===c&&\"\\\\\"!==i?(a=!a,n+=c):\"\\\\\"===i?n+=\"'\"===c?\"\\\\'\":\"\\\\\"+c:\"\\\\\"!==c&&(n+=c),i=c}return r.push(n),r}var tr=function(){function t(){if(!(this instanceof t))throw new TypeError(\"Cannot call a class as a function\")}var e,r;return e=t,r=[{key:\"parse\",value:function(t,e,r){var n,o=[],i=Ze(t,\"\\n\");for(n in i){var a=Qe[i[n][0]];if(!a)throw new Error(\"Unrecognised command : \"+i[n][0]);o=[].concat($e(o),$e(function(t,e,r,n){e=Ze(e,\";\");var o=[];return e.forEach((function(e){return o.push(new t(Ze(e,\" \"),r,n))})),o}(a,i[n].slice(1),e,r)))}return o}}],null&&Je(e.prototype,null),r&&Je(e,r),Object.defineProperty(e,\"prototype\",{writable:!1}),t}(),er=1920,rr=1080;function nr(t,e){(null==e||e>t.length)&&(e=t.length);for(var r=0,n=new Array(e);r<e;r++)n[r]=t[r];return n}function or(t,e){var r,n=Object.keys(t);return Object.getOwnPropertySymbols&&(r=Object.getOwnPropertySymbols(t),e&&(r=r.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,r)),n}function ir(t){for(var e=1;e<arguments.length;e++){var r=null!=arguments[e]?arguments[e]:{};e%2?or(Object(r),!0).forEach((function(e){var n,o;n=t,o=r[e=e],e in n?Object.defineProperty(n,e,{value:o,enumerable:!0,configurable:!0,writable:!0}):n[e]=o})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(r)):or(Object(r)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(r,e))}))}return t}function ar(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}var cr={};S=function(){function t(e){if(!(this instanceof t))throw new TypeError(\"Cannot call a class as a function\");(window.entityModule=this).entities=new Map,this.frames=[],this.loadingAssets=0,this.extrapolationMap={},this.globalData={toWorldUnits:1,mustResetTree:!0,maskUpdates:{},updatedBuffers:[],players:[],instanceCount:0},cr.entities=this.entities}var e,r,n;return e=t,n=[{key:\"name\",get:function(){return\"entitymodule\"}}],(r=[{key:\"handleFrameData\",value:function(t,e){var r=this;return(e=(e&&(e=tr.parse(e,this.globalData,t))&&e.forEach((function(e){(e=e.apply(r.entities,t))&&(r.loadingAssets++,e.then((function(){r.loadingAssets--})))})),ir({},t))).previous=this.frames[this.frames.length-1]||e,this.extrapolate(e),e!==e.previous&&(e.previous.next=e),this.frames.push(e),e}},{key:\"lastElementOf\",value:function(t){return t[t.length-1]}},{key:\"extrapolate\",value:function(t){var e=this,r=t.number,n=t.previous.number;this.entities.forEach((function(o){var i,a;o.stateAdded&&(o.stateAdded=!1,o.states[r]||(o.states[r]=[]),e.extrapolationMap[o.id]||(e.extrapolationMap[o.id]=ir({},o.defaultState)),(i=o.states[r]).sort((function(t,e){return t.t-e.t})),i.length&&1===e.lastElementOf(i).t||o.addState(1,{},r,t),a=e.extrapolationMap[o.id],o.states[n]&&n!==r&&(a=o.states[n][o.states[n].length-1]),o.states[r]=i.map((function(t){return t=e.extrapolationMap[o.id]=ir(ir({},e.extrapolationMap[o.id]),t),\"function\"==typeof o.computeAnimationProgressTime&&o.computeAnimationProgressTime(a,t),a=t})))}))}},{key:\"reinitScene\",value:function(t,e){this.globalData.toPixel=er/e.width*e.oversampling,this.globalData.mustResetTree=!0,cr.container=this.container=t,this.entities.forEach((function(t){t.init()}))}},{key:\"stillLoading\",value:function(){return 0<this.loadingAssets}},{key:\"updateScene\",value:function(t,e,r){var n=this;if(!this.stillLoading()){for(var o in this.entities.forEach((function(t){return t.render(r,e,n.globalData)})),this.globalData.mustResetTree&&(this.reconstructTree(),this.globalData.mustResetTree=!1),this.globalData.maskUpdates){var i=this.entities.get(+o);o=this.globalData.maskUpdates[o];i.container.mask=-1===o?null:this.entities.get(o).graphics}var a,c=function(t,e){var r,n,o,i,a=\"undefined\"!=typeof Symbol&&t[Symbol.iterator]||t[\"@@iterator\"];if(a)return n=!(r=!0),{s:function(){a=a.call(t)},n:function(){var t=a.next();return r=t.done,t},e:function(t){n=!0,o=t},f:function(){try{r||null==a.return||a.return()}finally{if(n)throw o}}};if(Array.isArray(t)||(a=function(t,e){var r;if(t)return\"string\"==typeof t?nr(t,e):\"Map\"===(r=\"Object\"===(r=Object.prototype.toString.call(t).slice(8,-1))&&t.constructor?t.constructor.name:r)||\"Set\"===r?Array.from(t):\"Arguments\"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)?nr(t,e):void 0}(t))||e&&t&&\"number\"==typeof t.length)return a&&(t=a),i=0,{s:e=function(){},n:function(){return i>=t.length?{done:!0}:{done:!1,value:t[i++]}},e:function(t){throw t},f:e};throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\")}(this.globalData.updatedBuffers);try{for(c.s();!(a=c.n()).done;)a.value.postUpdate()}catch(t){c.e(t)}finally{c.f()}this.globalData.maskUpdates={}}}},{key:\"reconstructTree\",value:function(){var t=this;this.container.removeChildren(),this.entities.forEach((function(e){e instanceof Zt&&(e.childrenContainer.removeChildren(),e.currentState.children.forEach((function(r){r=t.entities.get(r),e.childrenContainer.addChild(r.container),r.parent=e})),t.sortContainerChildren(e.childrenContainer),e.notifyChange())})),this.entities.forEach((function(e){e.container.parent||t.container.addChild(e.container)})),this.sortContainerChildren(this.container)}},{key:\"sortContainerChildren\",value:function(t){t.children.sort((function(t,e){return t.zIndex===e.zIndex?t.id-e.id:t.zIndex-e.zIndex}))}},{key:\"handleGlobalData\",value:function(t,e){this.globalData.players=t,t=e.width,e=e.height,this.globalData.toWorldUnits=a(t,e,er,rr),cr.toWorldUnits=this.globalData.toWorldUnits,cr.hasOwnProperty(\"coeff\")||Object.defineProperty(cr,\"coeff\",{get:function(){var t='The \"coeff\" property of GraphicEntityModule\\'s API is deprecated, please use \"toWorldUnits\" instead',e=(new Error).stack;return console.groupCollapsed?(console.groupCollapsed(\"%cDeprecation Warning: %c%s\",\"color:#614108;background:#fffbe6\",\"font-weight:normal;color:#614108;background:#fffbe6\",t),console.warn(e),console.groupEnd()):console.warn(\"Deprecation Warning: \",t),cr.toWorldUnits}})}}])&&ar(e.prototype,r),n&&ar(e,n),Object.defineProperty(e,\"prototype\",{writable:!1}),t}();function ur(t,e){var r,n=Object.keys(t);return Object.getOwnPropertySymbols&&(r=Object.getOwnPropertySymbols(t),e&&(r=r.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,r)),n}function sr(t){for(var e=1;e<arguments.length;e++){var r=null!=arguments[e]?arguments[e]:{};e%2?ur(Object(r),!0).forEach((function(e){var n,o;n=t,o=r[e=e],e in n?Object.defineProperty(n,e,{value:o,enumerable:!0,configurable:!0,writable:!0}):n[e]=o})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(r)):ur(Object(r)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(r,e))}))}return t}function lr(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}function fr(t,e){var r,n,o,i,a=\"undefined\"!=typeof Symbol&&t[Symbol.iterator]||t[\"@@iterator\"];if(a)return n=!(r=!0),{s:function(){a=a.call(t)},n:function(){var t=a.next();return r=t.done,t},e:function(t){n=!0,o=t},f:function(){try{r||null==a.return||a.return()}finally{if(n)throw o}}};if(Array.isArray(t)||(a=function(t,e){var r;if(t)return\"string\"==typeof t?pr(t,e):\"Map\"===(r=\"Object\"===(r=Object.prototype.toString.call(t).slice(8,-1))&&t.constructor?t.constructor.name:r)||\"Set\"===r?Array.from(t):\"Arguments\"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)?pr(t,e):void 0}(t))||e&&t&&\"number\"==typeof t.length)return a&&(t=a),i=0,{s:e=function(){},n:function(){return i>=t.length?{done:!0}:{done:!1,value:t[i++]}},e:function(t){throw t},f:e};throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\")}function pr(t,e){(null==e||e>t.length)&&(e=t.length);for(var r=0,n=new Array(e);r<e;r++)n[r]=t[r];return n}function hr(t,e){return(t=function(t,e){if(t.states[e])return t.states[e];for(var r=Object.keys(t.states),n=r.length-1;0<=n&&r[n]>e;)n--;return t.states[r[n]]||[]}(t,e))&&t.length?t[t.length-1]:null}function yr(t){return(yr=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&\"function\"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?\"symbol\":typeof t})(t)}function dr(t,e,r){return(dr=br()?Reflect.construct.bind():function(t,e,r){var n=[null];return n.push.apply(n,e),e=new(Function.bind.apply(t,n)),r&&vr(e,r.prototype),e}).apply(null,arguments)}function br(){if(\"undefined\"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if(\"function\"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}function vr(t,e){return(vr=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t})(t,e)}function mr(t){return(mr=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}P=function(){function t(e){if(!(this instanceof t))throw new TypeError(\"Cannot call a class as a function\");this.interactive={},this.previousFrame={registered:{}},this.lastProgress=1,this.lastFrame=0}var e,r,n;return e=t,n=[{key:\"name\",get:function(){return\"tooltips\"}}],(r=[{key:\"updateScene\",value:function(t,e,r){this.currentFrame=e,this.currentProgress=r}},{key:\"handleFrameData\",value:function(t){var e=this,r=(1<arguments.length&&void 0!==arguments[1]?arguments[1]:[])[0]||[],n=sr(sr({},this.previousFrame.registered),r);Object.keys(r).forEach((function(t){e.interactive[t]=!0})),r={registered:n,number:t.number};return this.previousFrame=r}},{key:\"reinitScene\",value:function(t){var e,r,n,o=this;this.tooltip=this.initTooltip(),cr.entities.forEach((function(t){var e,r,n,i,a,c;o.interactive[t.id]&&(t.container.interactive=!0,\"function\"==typeof(t.graphics&&t.graphics.containsPoint)?t.container.mousemove=(a=t,c=o.tooltip,function(t){a.graphics.containsPoint(t.data.global)?c.inside[a.id]=!0:delete c.inside[a.id]}):(t.container.mouseover=(n=t.id,i=o.tooltip,function(){i.inside[n]=!0}),t.container.mouseout=(e=t.id,r=o.tooltip,function(){delete r.inside[e]})))})),(this.container=t).interactive=!0,t.mousemove=(e=this.tooltip,r=t,n=this,function(t){if(e){t=t.data.getLocalPosition(r);var o,i=(e.x=t.x,e.y=t.y,[]),a=fr(Object.keys(e.inside).map((function(t){return+t})));try{for(a.s();!(o=a.n()).done;){var c,u=o.value;e.inside[u]&&(!(c=cr.entities.get(u))||!hr(c,n.currentFrame.number)||c.container&&!c.container.visible?delete e.inside[u]:i.push(u))}}catch(t){a.e(t)}finally{a.f()}if(i.length){var s,l=[],f=fr(i);try{for(f.s();!(s=f.n()).done;){var p,h=s.value;null!==hr(cr.entities.get(h),n.currentFrame.number)&&(p=n.currentFrame.registered[h])&&p.length&&\"0\"!==String(p).valueOf()&&(e.visible=!0,l.push(p))}}catch(t){f.e(t)}finally{f.f()}e.label.text=l.join(\"\\n\\n\")}else e.visible=!1;e.background.width=e.label.width+20,e.background.height=e.label.height+20,e.pivot.x=-30,e.pivot.y=-50,e.y-e.pivot.y+e.height>rr&&(e.pivot.y=10+e.height,e.y-=e.y-e.pivot.y+e.height-rr),e.x-e.pivot.x+e.width>er&&(e.pivot.x=e.width)}}),t.addChild(this.tooltip)}},{key:\"generateText\",value:function(t,e,r,n){return(t=new PIXI.Text(t,{fontSize:Math.round(e/1.2)+\"px\",fontFamily:\"Lato\",fontWeight:\"bold\",fill:r})).lineHeight=Math.round(e/1.2),\"right\"===n?t.anchor.x=1:\"center\"===n&&(t.anchor.x=.5),t}},{key:\"initTooltip\",value:function(){var t=new PIXI.Container,e=t.background=new PIXI.Graphics,r=t.label=this.generateText(\"\",36,16777215,\"left\");return e.beginFill(0,.7),e.drawRect(0,0,200,185),e.endFill(),e.x=-10,e.y=-10,t.visible=!1,t.inside={},t.addChild(e),t.addChild(r),t.interactiveChildren=!1,t}}])&&lr(e.prototype,r),n&&lr(e,n),Object.defineProperty(e,\"prototype\",{writable:!1}),t}();var gr=function(t){var e=n;if(\"function\"!=typeof t&&null!==t)throw new TypeError(\"Super expression must either be null or a function\");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),Object.defineProperty(e,\"prototype\",{writable:!1}),t&&vr(e,t);var r=function(t){var e=br();return function(){var r,n=mr(t);r=e?(r=mr(this).constructor,Reflect.construct(n,arguments,r)):n.apply(this,arguments),n=this;if(r&&(\"object\"===yr(r)||\"function\"==typeof r))return r;if(void 0!==r)throw new TypeError(\"Derived constructors may only return object or undefined\");if(void 0!==n)return n;throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\")}}(n);function n(t,e){var o;if(this instanceof n)return(o=r.call(this,'Could not find toggle: \"'+t+'\". Make sure it is set up correctly in your config.js.')).toggle=t,o.cause=e,o.name=\"MissingToggleError\",o;throw new TypeError(\"Cannot call a class as a function\")}return e=n,Object.defineProperty(e,\"prototype\",{writable:!1}),e}(function(t){var e=\"function\"==typeof Map?new Map:void 0;return function(t){if(null===t||-1===Function.toString.call(t).indexOf(\"[native code]\"))return t;if(\"function\"!=typeof t)throw new TypeError(\"Super expression must either be null or a function\");if(void 0!==e){if(e.has(t))return e.get(t);e.set(t,r)}function r(){return dr(t,arguments,mr(this).constructor)}return r.prototype=Object.create(t.prototype,{constructor:{value:r,enumerable:!1,writable:!0,configurable:!0}}),vr(r,t)}(t)}(Error));function wr(t){return(wr=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&\"function\"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?\"symbol\":typeof t})(t)}function Or(t,e,r){return(Or=Pr()?Reflect.construct.bind():function(t,e,r){var n=[null];return n.push.apply(n,e),e=new(Function.bind.apply(t,n)),r&&jr(e,r.prototype),e}).apply(null,arguments)}function Pr(){if(\"undefined\"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if(\"function\"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}function jr(t,e){return(jr=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t})(t,e)}function Sr(t){return(Sr=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}var xr=function(t){var e=n;if(\"function\"!=typeof t&&null!==t)throw new TypeError(\"Super expression must either be null or a function\");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),Object.defineProperty(e,\"prototype\",{writable:!1}),t&&jr(e,t);var r=function(t){var e=Pr();return function(){var r,n=Sr(t);r=e?(r=Sr(this).constructor,Reflect.construct(n,arguments,r)):n.apply(this,arguments),n=this;if(r&&(\"object\"===wr(r)||\"function\"==typeof r))return r;if(void 0!==r)throw new TypeError(\"Derived constructors may only return object or undefined\");if(void 0!==n)return n;throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\")}}(n);function n(t,e,o){if(this instanceof n)return(e=r.call(this,\"(\"+e.keys.toString()+\") have the same value '\"+e.value+\"' in toggle \\\"\"+t+'\". Avoid those duplicates in your config.js.')).toggle=t,e.cause=o,e.name=\"DuplicateToggleValueError\",e;throw new TypeError(\"Cannot call a class as a function\")}return e=n,Object.defineProperty(e,\"prototype\",{writable:!1}),e}(function(t){var e=\"function\"==typeof Map?new Map:void 0;return function(t){if(null===t||-1===Function.toString.call(t).indexOf(\"[native code]\"))return t;if(\"function\"!=typeof t)throw new TypeError(\"Super expression must either be null or a function\");if(void 0!==e){if(e.has(t))return e.get(t);e.set(t,r)}function r(){return Or(t,arguments,Sr(this).constructor)}return r.prototype=Object.create(t.prototype,{constructor:{value:r,enumerable:!1,writable:!0,configurable:!0}}),jr(r,t)}(t)}(Error));function Tr(t,e){var r,n=Object.keys(t);return Object.getOwnPropertySymbols&&(r=Object.getOwnPropertySymbols(t),e&&(r=r.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,r)),n}function Rr(t){for(var e=1;e<arguments.length;e++){var r=null!=arguments[e]?arguments[e]:{};e%2?Tr(Object(r),!0).forEach((function(e){var n,o;n=t,o=r[e=e],e in n?Object.defineProperty(n,e,{value:o,enumerable:!0,configurable:!0,writable:!0}):n[e]=o})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(r)):Tr(Object(r)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(r,e))}))}return t}function Er(t,e){var r;if(t)return\"string\"==typeof t?kr(t,e):\"Map\"===(r=\"Object\"===(r=Object.prototype.toString.call(t).slice(8,-1))&&t.constructor?t.constructor.name:r)||\"Set\"===r?Array.from(t):\"Arguments\"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)?kr(t,e):void 0}function kr(t,e){(null==e||e>t.length)&&(e=t.length);for(var r=0,n=new Array(e);r<e;r++)n[r]=t[r];return n}function _r(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}var Ir=function(){function t(e){var r,n=this;if(!(this instanceof t))throw new TypeError(\"Cannot call a class as a function\");for(r in this.previousFrame={},this.missingToggles={},t.refreshContent=function(){if(n.currentFrame)for(var e in n.currentFrame.registered){var r=cr.entities.get(parseInt(e)),o=(e=n.currentFrame.registered[e],t.toggles[e.name]);null!=o||n.missingToggles[e.name]||(l.push(new gr(e.name)),n.missingToggles[e.name]=!0),r.setHidden(o!==e.state)}},Ir.optionValues){var o,i=function(t,e){var r,n,o,i,a=\"undefined\"!=typeof Symbol&&t[Symbol.iterator]||t[\"@@iterator\"];if(a)return n=!(r=!0),{s:function(){a=a.call(t)},n:function(){var t=a.next();return r=t.done,t},e:function(t){n=!0,o=t},f:function(){try{r||null==a.return||a.return()}finally{if(n)throw o}}};if(Array.isArray(t)||(a=Er(t))||e&&t&&\"number\"==typeof t.length)return a&&(t=a),i=0,{s:e=function(){},n:function(){return i>=t.length?{done:!0}:{done:!1,value:t[i++]}},e:function(t){throw t},f:e};throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\")}(Ir.optionValues[r]);try{for(i.s();!(o=i.n()).done;){var a=o.value;1<a.keys.length&&l.push(new xr(r,a))}}catch(e){i.e(e)}finally{i.f()}}}var e,r,n;return e=t,n=[{key:\"refreshContent\",value:function(){}},{key:\"defineToggle\",value:function(e){var r,n=e;for(r in Ir.optionValues[n.toggle]=[],n.values)!function(t){var e=n.values[t],r=Ir.optionValues[n.toggle].find((function(t){return t.value===e}));r||Ir.optionValues[n.toggle].push(r={keys:[],value:e}),r.keys.push(t)}(r);return t.toggles[e.toggle]=e.default,e.get=function(){return t.toggles[e.toggle]},e.set=function(r){t.toggles[e.toggle]=r,t.refreshContent()},e}},{key:\"name\",get:function(){return\"toggles\"}}],(r=[{key:\"updateScene\",value:function(e,r,n){this.currentFrame=r,this.currentProgress=n,t.refreshContent()}},{key:\"handleFrameData\",value:function(t,e){var r={};return e&&Object.entries(e).forEach((function(t){var e=(t=function(t,e){return function(t){if(Array.isArray(t))return t}(t)||function(t,e){var r=null==t?null:\"undefined\"!=typeof Symbol&&t[Symbol.iterator]||t[\"@@iterator\"];if(null!=r){var n,o,i=[],a=!0,c=!1;try{for(r=r.call(t);!(a=(n=r.next()).done)&&(i.push(n.value),!e||i.length!==e);a=!0);}catch(t){c=!0,o=t}finally{try{a||null==r.return||r.return()}finally{if(c)throw o}}return i}}(t,e)||Er(t,e)||function(){throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\")}()}(t,2))[0];t[1].match(/\\d+./g).forEach((function(t){var n=t.slice(0,-1);t=\"+\"===t.slice(-1);r[n]={name:e,state:t}}))})),e={registered:Rr(Rr({},this.previousFrame.registered),r),number:t.number},this.previousFrame=e}},{key:\"reinitScene\",value:function(e,r){t.refreshContent()}}])&&_r(e.prototype,r),n&&_r(e,n),Object.defineProperty(e,\"prototype\",{writable:!1}),t}();function Cr(t){return(Cr=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&\"function\"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?\"symbol\":typeof t})(t)}function Dr(t,e,r){return(Dr=Fr()?Reflect.construct.bind():function(t,e,r){var n=[null];return n.push.apply(n,e),e=new(Function.bind.apply(t,n)),r&&Ar(e,r.prototype),e}).apply(null,arguments)}function Fr(){if(\"undefined\"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if(\"function\"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}function Ar(t,e){return(Ar=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t})(t,e)}function Mr(t){return(Mr=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}Ir.toggles={},Ir.optionValues={};var Wr=function(t){var e=n;if(\"function\"!=typeof t&&null!==t)throw new TypeError(\"Super expression must either be null or a function\");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),Object.defineProperty(e,\"prototype\",{writable:!1}),t&&Ar(e,t);var r=function(t){var e=Fr();return function(){var r,n=Mr(t);r=e?(r=Mr(this).constructor,Reflect.construct(n,arguments,r)):n.apply(this,arguments),n=this;if(r&&(\"object\"===Cr(r)||\"function\"==typeof r))return r;if(void 0!==r)throw new TypeError(\"Derived constructors may only return object or undefined\");if(void 0!==n)return n;throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\")}}(n);function n(t,e){var o;if(this instanceof n)return(o=r.call(this,'Could not find image: \"'+t+'\". Make sure it is in your assets folder and is spelled correctly.')).image=t,o.cause=e,o.name=\"MissingImageError\",o;throw new TypeError(\"Cannot call a class as a function\")}return e=n,Object.defineProperty(e,\"prototype\",{writable:!1}),e}(function(t){var e=\"function\"==typeof Map?new Map:void 0;return function(t){if(null===t||-1===Function.toString.call(t).indexOf(\"[native code]\"))return t;if(\"function\"!=typeof t)throw new TypeError(\"Super expression must either be null or a function\");if(void 0!==e){if(e.has(t))return e.get(t);e.set(t,r)}function r(){return Dr(t,arguments,Mr(this).constructor)}return r.prototype=Object.create(t.prototype,{constructor:{value:r,enumerable:!1,writable:!0,configurable:!0}}),Ar(r,t)}(t)}(Error));function Kr(t){return function(t){if(Array.isArray(t))return Xr(t)}(t)||function(t){if(\"undefined\"!=typeof Symbol&&null!=t[Symbol.iterator]||null!=t[\"@@iterator\"])return Array.from(t)}(t)||function(t,e){var r;if(t)return\"string\"==typeof t?Xr(t,e):\"Map\"===(r=\"Object\"===(r=Object.prototype.toString.call(t).slice(8,-1))&&t.constructor?t.constructor.name:r)||\"Set\"===r?Array.from(t):\"Arguments\"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)?Xr(t,e):void 0}(t)||function(){throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\")}()}function Xr(t,e){(null==e||e>t.length)&&(e=t.length);for(var r=0,n=new Array(e);r<e;r++)n[r]=t[r];return n}function Br(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}var Ur=[S,P,Ir,function(){function t(e){if(!(this instanceof t))throw new TypeError(\"Cannot call a class as a function\");this.states=[],this.scores=[],this.globalData={},this.atEnd=!1}var e,r,n;return e=t,n=[{key:\"name\",get:function(){return\"endScreen\"}}],(r=[{key:\"updateScene\",value:function(t,e,r){e.scores&&1===r?this.atEnd=!0:this.atEnd=!1}},{key:\"handleFrameData\",value:function(t,e){var r=null,n=null,o=null;e&&(r=e[0],n=e[1],o=e[2]),e={number:t.number,scores:r,spriteName:n,displayedText:o};return r&&(this.scores=r),n&&(this.spriteName=n),o&&(this.displayedText=o),this.states.push(e),e}},{key:\"reinitScene\",value:function(t,e){this.container=t,this.endLayer=this.createEndScene(this),this.atEnd&&this.initEndScene(),this.container.addChild(this.endLayer)}},{key:\"animateScene\",value:function(t){t=Math.min(32,t),this.atEnd?this.animationEnded||this.renderEndScene(t):(0<this.endTime&&this.destroyEndScene(),this.endTime=0)}},{key:\"destroyEndScene\",value:function(){this.animationEnded=!1,this.endLayer.visible=!1}},{key:\"initEndScene\",value:function(){this.animationEnded=!1,this.endLayer.visible=!0}},{key:\"renderEndScene\",value:function(t){0===this.endTime&&this.initEndScene();for(var e=i(0,400,this.endTime),r=(e=(this.endLayer.backgroundRanking.alpha=.9*e,i(400,1e3,this.endTime)),this.endLayer.titleRanking.scale.x=this.endLayer.titleRanking.scale.y=.001+o(10,.8,e),this.endLayer.titleRanking.visible=!!e,0);r<this.finishers.length;++r){var n=i(1e3+300*r,1e3+300*r+300,this.endTime);this.finishers[r].alpha=n}this.endTime+=t,1e4<=this.endTime&&(this.animationEnded=!0)}},{key:\"handleGlobalData\",value:function(t,e){this.globalData={players:t,playerCount:t.length}}},{key:\"fitTextInWidth\",value:function(t,e){for(var r=t.text;t.width>e;)r=r.slice(0,-1),t.text=r+\"...\"}},{key:\"generateText\",value:function(t,e,r,n){var o=4<arguments.length&&void 0!==arguments[4]?arguments[4]:null;return(t=new PIXI.Text(t,{fontSize:Math.round(e/1.2)+\"px\",fontFamily:\"Lato\",fontWeight:\"bold\",fill:n})).lineHeight=Math.round(e/1.2),\"right\"===r?t.anchor.x=1:\"center\"===r&&(t.anchor.x=.5),null!==o&&this.fitTextInWidth(t,o),t}},{key:\"createFinisher\",value:function(t){var e,r=new PIXI.Container,n=new PIXI.Container,o=((o=((e=((e=((e=(n.y=0,n.x=0,new PIXI.Graphics)).beginFill(16777215),e.alpha=.1,e.drawRect(0,0,240,120),n.addChild(e),new PIXI.Graphics)).lineStyle(1,16777215),e.alpha=.5,e.drawRect(0,0,120,120),n.addChild(e),new PIXI.Sprite(t.player.avatar))).width=e.height=120,this.generateText(t.rank.toString(),76,\"center\",t.player.color))).anchor.y=.5,o.position.x=160,o.position.y=56,n.addChild(o),\"TH\"),i=(o=((o=((o=(t.rank<4&&(o=[\"ST\",\"ND\",\"RD\"][t.rank-1]),this.generateText(o.toString(),34,\"left\",t.player.color))).position.x=184,o.position.y=32,n.addChild(o),new PIXI.Container)).addChild(e),n.addChild(o),e=this.globalData.playerCount<=4?1500:500,this.generateText(t.player.name.toUpperCase(),50,\"left\",t.player.color,e)),t.text||(0<=t.score?t.score.toString()+\" points\":\"-\"));i=this.generateText(i,64,\"left\",t.player.color,e);return o.x=330,o.y=-4,i.x=330,i.y=50,r.addChild(n),r.addChild(o),r.addChild(i),r}},{key:\"createEndScene\",value:function(){var t=new PIXI.Container,e=new PIXI.Graphics,r=(e.beginFill(0,.85),e.drawRect(0,0,er,rr),e.endFill(),t.backgroundRanking=e,this.spriteName);(r=PIXI.utils.TextureCache[r]?PIXI.Sprite.from(r):(l.push(new Wr(r)),new PIXI.Sprite(PIXI.Texture.EMPTY))).anchor.x=r.anchor.y=.5,(t.titleRanking=r).position.x=960,r.position.y=230;for(var n=[],o=0;o<this.globalData.playerCount;++o)n.push({score:this.scores[o],text:this.displayedText?this.displayedText[o]:null,player:this.globalData.players[o],rank:0});n.sort((function(t,e){return e.score-t.score})),this.finishers=[];var i,a=new PIXI.Container;for(o=0;o<n.length;++o)n[o].rank=n.filter((function(t){return t.score>n[o].score})).length+1,i=this.createFinisher(n[o]),a.addChild(i),this.finishers.push(i);if(this.finishers.length<=4){var c=Math.max.apply(Math,Kr(this.finishers.map((function(t){return t.width}))));for(o=0;o<this.finishers.length;++o)this.finishers[o].position.x=(er-c)/2,this.finishers[o].position.y=150*o}else{var u=Math.ceil(this.finishers.length/2),s=Math.max.apply(Math,Kr(this.finishers.slice(0,u).map((function(t){return t.width}))));for(o=0;o<this.finishers.length;++o)this.finishers[o].position.x=o<u?960-(s+50):1010,this.finishers[o].position.y=o%u*150}return a.y=400,t.addChild(e),t.addChild(r),t.addChild(a),t.visible=!1,t}}])&&Br(e.prototype,r),n&&Br(e,n),Object.defineProperty(e,\"prototype\",{writable:!1}),t}()],Lr=[],Yr={views:['KEY_FRAME 0\\n{\"global\":{\"entitymodule\":{\"width\":1920,\"height\":1080}},\"frame\":{\"duration\":800,\"entitymodule\":\"CR;R;K;T;K;K;K;K;K;K;K;K;K;T;K;K;K;K;K;K;K;K;K;T;K;K;K;K;K;K;K;K;K;T;K;K;K;K;K;K;K;K;K;T;K;K;K;K;K;K;K;K;K;T;K;K;K;K;K;K;K;K;K;T;K;K;K;K;K;K;K;K;K;T;K;K;K;K;K;K;K;K;K;T;T;K;T;K;T;K;T;K;T;K;T;K;T;K;T;K;T;C;C;G;K;T;S;T;T;T;G;K;T;S;T;T;T\\\\nU29 1 f 16776960 v 1 w 108 x 1041 y 243 c 0 W 20 h 108;82 1 f 16776960 v 1 w 108 x 1365 y 783 c 0 W 20 h 108;7 1 f 16776960 v 1 w 108 x 825 y 27 c 0 W 20 h 108;59 1 f 16776960 v 1 w 108 x 1041 y 567 c 0 W 20 h 108;43 1 f 16776960 v 1 w 108 x 501 y 459 c 0 W 20 h 108;32 1 f 16776960 v 1 w 108 x 1365 y 243 c 0 W 20 h 108;37 1 f 16776960 v 1 w 108 x 825 y 351 c 0 W 20 h 108;114 1 bw 200 i $1 v 1 ax 0.5 x 1720 y 250 bh 200;87 1 f 0 v 1 ff Verdana x 645 y 1012 s 54 T 1;30 1 f 16776960 v 1 w 108 x 1149 y 243 c 0 W 20 h 108;35 1 f 16776960 v 1 w 108 x 609 y 351 c 0 W 20 h 108;58 1 f 16776960 v 1 w 108 x 933 y 567 c 0 W 20 h 108;84 1 f 0 v 1 ff Verdana x 442 y 918 s 54 T 8;34 1 f 0 v 1 ff Verdana x 442 y 378 s 54 T 3;100 1 f 16776960 v 1 w 108 x 1365 y 891 c 0 W 20 h 108;112 1 f 13750752 v 1 x 1570 w 300 y 130 c 255 W 15 h 700;20 1 f 16776960 v 1 w 108 x 1149 y 135 c 0 W 20 h 108;99 1 f 0 v 1 ff Verdana x 1293 y 1012 s 54 T 7;38 1 f 16776960 v 1 w 108 x 933 y 351 c 0 W 20 h 108;80 1 f 16776960 v 1 w 108 x 1149 y 783 c 0 W 20 h 108;48 1 f 16776960 v 1 w 108 x 933 y 459 c 0 W 20 h 108;76 1 f 16776960 v 1 w 108 x 717 y 783 c 0 W 20 h 108;2 1 f 0 v 1 x 490 w 994 y 16 h 994;33 1 f 16776960 v 1 w 108 x 501 y 351 c 0 W 20 h 108;89 1 f 0 v 1 ff Verdana x 753 y 1012 s 54 T 2;13 1 f 16776960 v 1 w 108 x 501 y 135 c 0 W 20 h 108;81 1 f 16776960 v 1 w 108 x 1257 y 783 c 0 W 20 h 108;26 1 f 16776960 v 1 w 108 x 717 y 243 c 0 W 20 h 108;67 1 f 16776960 v 1 w 108 x 825 y 675 c 0 W 20 h 108;44 1 f 0 v 1 ff Verdana x 442 y 486 s 54 T 4;18 1 f 16776960 v 1 w 108 x 933 y 135 c 0 W 20 h 108;108 1 f 1258295 v 1 ff Verdana ax 0.5 x 200 y 510 s 45 T \\' last tile\\\\nremoved\\';27 1 f 16776960 v 1 w 108 x 825 y 243 c 0 W 20 h 108;61 1 f 16776960 v 1 w 108 x 1257 y 567 c 0 W 20 h 108;106 1 f 16711680 v 1 ff Verdana ax 0.5 x 200 y 150 s 45 T $0 fw bold;111 1 ch 113,112,114,117,116,115 v 1;46 1 f 16776960 v 1 w 108 x 717 y 459 c 0 W 20 h 108;23 1 f 16776960 v 1 w 108 x 501 y 243 c 0 W 20 h 108;62 1 f 16776960 v 1 w 108 x 1365 y 567 c 0 W 20 h 108;96 1 f 16776960 v 1 w 108 x 1149 y 891 c 0 W 20 h 108;117 1 f 1258295 v 1 ff Verdana ax 0.5 x 1715 y 730 s 35 T ;55 1 f 16776960 v 1 w 108 x 609 y 567 c 0 W 20 h 108;65 1 f 16776960 v 1 w 108 x 609 y 675 c 0 W 20 h 108;28 1 f 16776960 v 1 w 108 x 933 y 243 c 0 W 20 h 108;50 1 f 16776960 v 1 w 108 x 1149 y 459 c 0 W 20 h 108;72 1 f 16776960 v 1 w 108 x 1365 y 675 c 0 W 20 h 108;22 1 f 16776960 v 1 w 108 x 1365 y 135 c 0 W 20 h 108;52 1 f 16776960 v 1 w 108 x 1365 y 459 c 0 W 20 h 108;15 1 f 16776960 v 1 w 108 x 609 y 135 c 0 W 20 h 108;66 1 f 16776960 v 1 w 108 x 717 y 675 c 0 W 20 h 108;85 1 f 0 v 1 ff Verdana x 537 y 1012 s 54 T 0;94 1 f 16776960 v 1 w 108 x 1041 y 891 c 0 W 20 h 108;3 1 f 16776960 v 1 w 108 x 501 y 27 c 0 W 20 h 108;116 1 f 1258295 v 1 ff Verdana ax 0.5 x 1720 y 630 s 60 T -;47 1 f 16776960 v 1 w 108 x 825 y 459 c 0 W 20 h 108;1 1 f 8289921 w 1920 v 1 h 1080;5 1 f 16776960 v 1 w 108 x 609 y 27 c 0 W 20 h 108;51 1 f 16776960 v 1 w 108 x 1257 y 459 c 0 W 20 h 108;93 1 f 0 v 1 ff Verdana x 969 y 1012 s 54 T 4;109 1 f 1258295 v 1 ff Verdana ax 0.5 x 200 y 630 s 60 T -;54 1 f 0 v 1 ff Verdana x 442 y 594 s 54 T 5;98 1 f 16776960 v 1 w 108 x 1257 y 891 c 0 W 20 h 108;83 1 f 16776960 v 1 w 108 x 501 y 891 c 0 W 20 h 108;40 1 f 16776960 v 1 w 108 x 1149 y 351 c 0 W 20 h 108;6 1 f 16776960 v 1 w 108 x 717 y 27 c 0 W 20 h 108;42 1 f 16776960 v 1 w 108 x 1365 y 351 c 0 W 20 h 108;90 1 f 16776960 v 1 w 108 x 825 y 891 c 0 W 20 h 108;105 1 f 13750752 v 1 x 50 w 300 y 130 c 16711680 W 15 h 700;9 1 f 16776960 v 1 w 108 x 1041 y 27 c 0 W 20 h 108;41 1 f 16776960 v 1 w 108 x 1257 y 351 c 0 W 20 h 108;86 1 f 16776960 v 1 w 108 x 609 y 891 c 0 W 20 h 108;104 1 ch 105,107,109,110,108,106 v 1;79 1 f 16776960 v 1 w 108 x 1041 y 783 c 0 W 20 h 108;92 1 f 16776960 v 1 w 108 x 933 y 891 c 0 W 20 h 108;95 1 f 0 v 1 ff Verdana x 1077 y 1012 s 54 T 5;4 1 f 0 v 1 ff Verdana x 442 y 54 s 54 T 0;12 1 f 16776960 v 1 w 108 x 1365 y 27 c 0 W 20 h 108;78 1 f 16776960 v 1 w 108 x 933 y 783 c 0 W 20 h 108;14 1 f 0 v 1 ff Verdana x 442 y 162 s 54 T 1;16 1 f 16776960 v 1 w 108 x 717 y 135 c 0 W 20 h 108;75 1 f 16776960 v 1 w 108 x 609 y 783 c 0 W 20 h 108;69 1 f 16776960 v 1 w 108 x 1041 y 675 c 0 W 20 h 108;73 1 f 16776960 v 1 w 108 x 501 y 783 c 0 W 20 h 108;17 1 f 16776960 v 1 w 108 x 825 y 135 c 0 W 20 h 108;103 1 f 255 x 1419 y 513 v 1 R 32;57 1 f 16776960 v 1 w 108 x 825 y 567 c 0 W 20 h 108;45 1 f 16776960 v 1 w 108 x 609 y 459 c 0 W 20 h 108;56 1 f 16776960 v 1 w 108 x 717 y 567 c 0 W 20 h 108;101 1 f 0 v 1 ff Verdana x 1401 y 1012 s 54 T 8;39 1 f 16776960 v 1 w 108 x 1041 y 351 c 0 W 20 h 108;10 1 f 16776960 v 1 w 108 x 1149 y 27 c 0 W 20 h 108;97 1 f 0 v 1 ff Verdana x 1185 y 1012 s 54 T 6;68 1 f 16776960 v 1 w 108 x 933 y 675 c 0 W 20 h 108;107 1 bw 200 i $0 v 1 ax 0.5 x 200 y 250 bh 200;8 1 f 16776960 v 1 w 108 x 933 y 27 c 0 W 20 h 108;64 1 f 0 v 1 ff Verdana x 442 y 702 s 54 T 6;36 1 f 16776960 v 1 w 108 x 717 y 351 c 0 W 20 h 108;88 1 f 16776960 v 1 w 108 x 717 y 891 c 0 W 20 h 108;25 1 f 16776960 v 1 w 108 x 609 y 243 c 0 W 20 h 108;21 1 f 16776960 v 1 w 108 x 1257 y 135 c 0 W 20 h 108;24 1 f 0 v 1 ff Verdana x 442 y 270 s 54 T 2;53 1 f 16776960 v 1 w 108 x 501 y 567 c 0 W 20 h 108;115 1 f 1258295 v 1 ff Verdana ax 0.5 x 1720 y 510 s 45 T \\' last tile\\\\nremoved\\';19 1 f 16776960 v 1 w 108 x 1041 y 135 c 0 W 20 h 108;113 1 f 255 v 1 ff Verdana ax 0.5 x 1720 y 150 s 45 T $1 fw bold;11 1 f 16776960 v 1 w 108 x 1257 y 27 c 0 W 20 h 108;91 1 f 0 v 1 ff Verdana x 861 y 1012 s 54 T 3;60 1 f 16776960 v 1 w 108 x 1149 y 567 c 0 W 20 h 108;102 1 f 16711680 x 555 y 513 v 1 R 32;71 1 f 16776960 v 1 w 108 x 1257 y 675 c 0 W 20 h 108;31 1 f 16776960 v 1 w 108 x 1257 y 243 c 0 W 20 h 108;63 1 f 16776960 v 1 w 108 x 501 y 675 c 0 W 20 h 108;77 1 f 16776960 v 1 w 108 x 825 y 783 c 0 W 20 h 108;74 1 f 0 v 1 ff Verdana x 442 y 810 s 54 T 7;49 1 f 16776960 v 1 w 108 x 1041 y 459 c 0 W 20 h 108;70 1 f 16776960 v 1 w 108 x 1149 y 675 c 0 W 20 h 108;110 1 f 1258295 v 1 ff Verdana ax 0.5 x 195 y 730 s 35 T \",\"tooltips\":[{\"3\":\"(0, 0)\",\"5\":\"(1, 0)\",\"6\":\"(2, 0)\",\"7\":\"(3, 0)\",\"8\":\"(4, 0)\",\"9\":\"(5, 0)\",\"10\":\"(6, 0)\",\"11\":\"(7, 0)\",\"12\":\"(8, 0)\",\"13\":\"(0, 1)\",\"15\":\"(1, 1)\",\"16\":\"(2, 1)\",\"17\":\"(3, 1)\",\"18\":\"(4, 1)\",\"19\":\"(5, 1)\",\"20\":\"(6, 1)\",\"21\":\"(7, 1)\",\"22\":\"(8, 1)\",\"23\":\"(0, 2)\",\"25\":\"(1, 2)\",\"26\":\"(2, 2)\",\"27\":\"(3, 2)\",\"28\":\"(4, 2)\",\"29\":\"(5, 2)\",\"30\":\"(6, 2)\",\"31\":\"(7, 2)\",\"32\":\"(8, 2)\",\"33\":\"(0, 3)\",\"35\":\"(1, 3)\",\"36\":\"(2, 3)\",\"37\":\"(3, 3)\",\"38\":\"(4, 3)\",\"39\":\"(5, 3)\",\"40\":\"(6, 3)\",\"41\":\"(7, 3)\",\"42\":\"(8, 3)\",\"43\":\"(0, 4)\",\"45\":\"(1, 4)\",\"46\":\"(2, 4)\",\"47\":\"(3, 4)\",\"48\":\"(4, 4)\",\"49\":\"(5, 4)\",\"50\":\"(6, 4)\",\"51\":\"(7, 4)\",\"52\":\"(8, 4)\",\"53\":\"(0, 5)\",\"55\":\"(1, 5)\",\"56\":\"(2, 5)\",\"57\":\"(3, 5)\",\"58\":\"(4, 5)\",\"59\":\"(5, 5)\",\"60\":\"(6, 5)\",\"61\":\"(7, 5)\",\"62\":\"(8, 5)\",\"63\":\"(0, 6)\",\"65\":\"(1, 6)\",\"66\":\"(2, 6)\",\"67\":\"(3, 6)\",\"68\":\"(4, 6)\",\"69\":\"(5, 6)\",\"70\":\"(6, 6)\",\"71\":\"(7, 6)\",\"72\":\"(8, 6)\",\"73\":\"(0, 7)\",\"75\":\"(1, 7)\",\"76\":\"(2, 7)\",\"77\":\"(3, 7)\",\"78\":\"(4, 7)\",\"79\":\"(5, 7)\",\"80\":\"(6, 7)\",\"81\":\"(7, 7)\",\"82\":\"(8, 7)\",\"83\":\"(0, 8)\",\"86\":\"(1, 8)\",\"88\":\"(2, 8)\",\"90\":\"(3, 8)\",\"92\":\"(4, 8)\",\"94\":\"(5, 8)\",\"96\":\"(6, 8)\",\"98\":\"(7, 8)\",\"100\":\"(8, 8)\",\"110\":\"\",\"117\":\"\"}]}}\\n','KEY_FRAME 1\\n{\"entitymodule\":\"U104 0 a 1;111 0 a 0.5;110 0.1 T \\'KILL\\\\\\\\\\'EM ALL\\';102 0.6 x 663;109 1 T \\'6 4\\';50 1 f 0\",\"tooltips\":[{\"110\":\"KILL\\'EM ALL\"}]}\\n','KEY_FRAME 2\\n{\"entitymodule\":\"U104 0 a 0.5;111 0 a 1;117 0.1 T \\'I\\\\\\\\\\'LL TRY\\';103 0.6 x 1311 y 405;20 1 f 0;116 1 T \\'6 1\\'\",\"tooltips\":[{\"117\":\"I\\'LL TRY\"}]}\\n','KEY_FRAME 3\\n{\"entitymodule\":\"U104 0 a 1;111 0 a 0.5;102 0.6 x 771;109 1 T \\'6 3\\';40 1 f 0\"}\\n','KEY_FRAME 4\\n{\"entitymodule\":\"U104 0 a 0.5;111 0 a 1;103 0.6 y 513;63 1 f 0;116 1 T \\'0 6\\'\"}\\n','KEY_FRAME 5\\n{\"entitymodule\":\"U104 0 a 1;111 0 a 0.5;102 0.6 x 879;109 1 T \\'6 5\\';60 1 f 0\"}\\n','KEY_FRAME 6\\n{\"entitymodule\":\"U104 0 a 0.5;111 0 a 1;103 0.6 y 405;5 1 f 0;116 1 T \\'1 0\\'\"}\\n','KEY_FRAME 7\\n{\"entitymodule\":\"U104 0 a 1;111 0 a 0.5;102 0.6 x 987;109 1 T \\'6 2\\';30 1 f 0\"}\\n','KEY_FRAME 8\\n{\"entitymodule\":\"U104 0 a 0.5;111 0 a 1;103 0.6 x 1419 y 297;11 1 f 0;116 1 T \\'7 0\\'\"}\\n','KEY_FRAME 9\\n{\"entitymodule\":\"U104 0 a 1;111 0 a 0.5;102 0.6 x 879;31 1 f 0;109 1 T \\'7 2\\'\"}\\n','KEY_FRAME 10\\n{\"entitymodule\":\"U104 0 a 0.5;111 0 a 1;103 0.6 y 405;82 1 f 0;116 1 T \\'8 7\\'\"}\\n','KEY_FRAME 11\\n{\"entitymodule\":\"U104 0 a 1;111 0 a 0.5;102 0.6 y 405;51 1 f 0;109 1 T \\'7 4\\'\"}\\n','KEY_FRAME 12\\n{\"entitymodule\":\"U104 0 a 0.5;111 0 a 1;103 0.6 x 1311;94 1 f 0;116 1 T \\'5 8\\'\"}\\n','KEY_FRAME 13\\n{\"entitymodule\":\"U104 0 a 1;111 0 a 0.5;102 0.6 y 513;42 1 f 0;109 1 T \\'8 3\\'\"}\\n','KEY_FRAME 14\\n{\"entitymodule\":\"U104 0 a 0.5;111 0 a 1;103 0.6 x 1419 y 513;48 1 f 0;116 1 T \\'4 4\\'\"}\\n','KEY_FRAME 15\\n{\"entitymodule\":\"U104 0 a 1;111 0 a 0.5;102 0.6 y 405;109 1 T \\'7 5\\';61 1 f 0\"}\\n','KEY_FRAME 16\\n{\"entitymodule\":\"U104 0 a 0.5;111 0 a 1;103 0.6 y 621;116 1 T \\'5 3\\';39 1 f 0\"}\\n','KEY_FRAME 17\\n{\"entitymodule\":\"U104 0 a 1;111 0 a 0.5;102 0.6 y 297;109 1 T \\'7 6\\';71 1 f 0\"}\\n','KEY_FRAME 18\\n{\"entitymodule\":\"U104 0 a 0.5;111 0 a 1;103 0.6 y 513;116 1 T \\'1 7\\';75 1 f 0\"}\\n','KEY_FRAME 19\\n{\"entitymodule\":\"U104 0 a 1;111 0 a 0.5;102 0.6 x 771;109 1 T \\'7 3\\';41 1 f 0\"}\\n','KEY_FRAME 20\\n{\"entitymodule\":\"U104 0 a 0.5;111 0 a 1;103 0.6 y 621;116 1 T \\'0 3\\';33 1 f 0\"}\\n','KEY_FRAME 21\\n{\"entitymodule\":\"U104 0 a 1;111 0 a 0.5;102 0.6 y 189;109 1 T \\'8 6\\';72 1 f 0\"}\\n','KEY_FRAME 22\\n{\"entitymodule\":\"U104 0 a 0.5;111 0 a 1;103 0.6 y 513;116 1 T \\'8 0\\';12 1 f 0\"}\\n','KEY_FRAME 23\\n{\"entitymodule\":\"U104 0 a 1;111 0 a 0.5;102 0.6 y 81;62 1 f 0;109 1 T \\'8 5\\'\",\"endScreen\":[[1,0],\"logo.png\",[\"Won\",\"Lost\"]]}\\n'],agents:[{index:0,name:\"wala\",avatar:\"https://static.codingame.com/servlet/fileservlet?id=90904183775363&format=viewer_avatar\",agentId:0},{index:1,name:\"Player 1\",avatar:\"https://static.codingame.com/servlet/fileservlet?id=16085846089817&format=viewer_avatar\",agentId:1}]};function Hr(t){return(Hr=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&\"function\"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?\"symbol\":typeof t})(t)}function Vr(t,e,r){return(Vr=Gr()?Reflect.construct.bind():function(t,e,r){var n=[null];return n.push.apply(n,e),e=new(Function.bind.apply(t,n)),r&&zr(e,r.prototype),e}).apply(null,arguments)}function Gr(){if(\"undefined\"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if(\"function\"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}function zr(t,e){return(zr=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t})(t,e)}function Nr(t){return(Nr=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}var $r=function(t){var e=n;if(\"function\"!=typeof t&&null!==t)throw new TypeError(\"Super expression must either be null or a function\");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),Object.defineProperty(e,\"prototype\",{writable:!1}),t&&zr(e,t);var r=function(t){var e=Gr();return function(){var r,n=Nr(t);r=e?(r=Nr(this).constructor,Reflect.construct(n,arguments,r)):n.apply(this,arguments),n=this;if(r&&(\"object\"===Hr(r)||\"function\"==typeof r))return r;if(void 0!==r)throw new TypeError(\"Derived constructors may only return object or undefined\");if(void 0!==n)return n;throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\")}}(n);function n(t,e){if(this instanceof n)return(t=r.call(this,'<Error in module \"'+t+'\">')).cause=e,t.name=\"ModuleError\",t;throw new TypeError(\"Cannot call a class as a function\")}return e=n,Object.defineProperty(e,\"prototype\",{writable:!1}),e}(function(t){var e=\"function\"==typeof Map?new Map:void 0;return function(t){if(null===t||-1===Function.toString.call(t).indexOf(\"[native code]\"))return t;if(\"function\"!=typeof t)throw new TypeError(\"Super expression must either be null or a function\");if(void 0!==e){if(e.has(t))return e.get(t);e.set(t,r)}function r(){return Vr(t,arguments,Nr(this).constructor)}return r.prototype=Object.create(t.prototype,{constructor:{value:r,enumerable:!1,writable:!0,configurable:!0}}),zr(r,t)}(t)}(Error));function qr(t,e){var r,n=Object.keys(t);return Object.getOwnPropertySymbols&&(r=Object.getOwnPropertySymbols(t),e&&(r=r.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,r)),n}function Jr(t){for(var e=1;e<arguments.length;e++){var r=null!=arguments[e]?arguments[e]:{};e%2?qr(Object(r),!0).forEach((function(e){var n,o;n=t,o=r[e=e],e in n?Object.defineProperty(n,e,{value:o,enumerable:!0,configurable:!0,writable:!0}):n[e]=o})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(r)):qr(Object(r)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(r,e))}))}return t}function Qr(t,e){(null==e||e>t.length)&&(e=t.length);for(var r=0,n=new Array(e);r<e;r++)n[r]=t[r];return n}function Zr(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}var tn=function(){function t(e){if(!(this instanceof t))throw new TypeError(\"Cannot call a class as a function\");var r;PIXI.settings.STRICT_TEXTURE_CACHE=!0,this.toDestroy=[],this.stepByStepAnimateSpeed=null,(e=e||Yr)?(r=e.views,e=e.agents,this.demo={playerCount:e.length,logo:\"logo.png\",overlayAlpha:.2,agents:e,frames:r},this.demo.agents.forEach((function(e){e.color=t.playerColors[e.index]}))):this.demo=void 0}var e,r,o;return e=t,o=[{key:\"requirements\",get:function(){return{PIXI:\"PIXI6\"}}},{key:\"VERSION\",get:function(){return 2}},{key:\"WIDTH\",get:function(){return er}},{key:\"HEIGHT\",get:function(){return rr}},{key:\"getGameRatio\",value:function(){return t.WIDTH/t.HEIGHT}},{key:\"playerColors\",get:function(){return[\"#ff1d5c\",\"#22a1e4\",\"#ff8f16\",\"#6ac371\",\"#9975e2\",\"#3ac5ca\",\"#de6ddf\",\"#ff0000\"]}},{key:\"SDK_GAME\",get:function(){return!0}},{key:\"RenderTimeout\",get:function(){return\"localhost\"===window.location.hostname?1/0:2e4}}],(r=[{key:\"getDefaultOverSampling\",value:function(){return 2}},{key:\"handleModuleError\",value:function(t,e){l.push(new $r(t,e)),console.error(e),l.push({message:'<Module \"'.concat(t,'\" disabled>\\n')}),delete this.modules[t]}},{key:\"instantiateModules\",value:function(){this.modules={};var t,e=function(t,e){var r,n,o,i,a=\"undefined\"!=typeof Symbol&&t[Symbol.iterator]||t[\"@@iterator\"];if(a)return n=!(r=!0),{s:function(){a=a.call(t)},n:function(){var t=a.next();return r=t.done,t},e:function(t){n=!0,o=t},f:function(){try{r||null==a.return||a.return()}finally{if(n)throw o}}};if(Array.isArray(t)||(a=function(t,e){var r;if(t)return\"string\"==typeof t?Qr(t,e):\"Map\"===(r=\"Object\"===(r=Object.prototype.toString.call(t).slice(8,-1))&&t.constructor?t.constructor.name:r)||\"Set\"===r?Array.from(t):\"Arguments\"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)?Qr(t,e):void 0}(t))||e&&t&&\"number\"==typeof t.length)return a&&(t=a),i=0,{s:e=function(){},n:function(){return i>=t.length?{done:!0}:{done:!1,value:t[i++]}},e:function(t){throw t},f:e};throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\")}(Ur);try{for(e.s();!(t=e.n()).done;){var r=t.value;try{this.modules[r.moduleName||r.name]=new r(n)}catch(t){this.handleModuleError(r.moduleName||r.name,t)}}}catch(t){e.e(t)}finally{e.f()}}},{key:\"destroy\",value:function(){this.alreadyLoaded&&(this.renderer.destroy(),this.endCallback=null),this.destroyed=!0}},{key:\"destroyScene\",value:function(t){for(var e=0,r=ie.length;e<r;++e)ie[e].destroy(!0);ie=[]}},{key:\"getGameName\",value:function(){}},{key:\"canSwapPlayers\",value:function(){return!1}},{key:\"addErrorListener\",value:function(t){l.listen(t)}},{key:\"getResources\",value:function(){return Object.assign({baseUrl:\"\",images:{},spines:{},sprites:[],fonts:[],others:[]},n)}},{key:\"getOptions\",value:function(){return Lr?Lr.map((function(t){return Jr({},t)})):[]}},{key:\"setDebug\",value:function(e){this.asyncRenderingTime=t.RenderTimeout}},{key:\"initPreload\",value:function(t,e,r,n,o){t.canvasWidth=n,t.canvasHeight=o,t.loaderProgress=new PIXI.Text(\"100\",{fontSize:.117*o||30,fontFamily:\"Lato\",fontWeight:\"900\",fill:\"white\",align:\"center\"}),t.loaderProgress.anchor.y=1,t.loaderProgress.anchor.x=1.3,t.progress=t.realProgress=r,t.loaderProgress.position.y=o,t.progressBar=new PIXI.Graphics,e.addChild(t.progressBar),e.addChild(t.loaderProgress)}},{key:\"preload\",value:function(t,e,r,n,o,i){t.progress=r}},{key:\"renderPreloadScene\",value:function(t,e){return e=Math.pow(.998,e),t.realProgress=e*t.realProgress+(1-e)*t.progress,t.loaderProgress.text=(100*t.realProgress).toFixed(0),t.loaderProgress.position.x=t.realProgress*t.canvasWidth,t.progressBar.clear(),t.progressBar.beginFill(0,1),t.progressBar.drawRect(0,0,t.canvasWidth*t.realProgress+1,t.canvasHeight),t.progressBar.endFill(),t.progressBar.beginFill(4146246,1),t.progressBar.drawRect(t.canvasWidth*t.realProgress,0,t.canvasWidth,t.canvasHeight),t.progressBar.endFill(),!0}},{key:\"initDefaultScene\",value:function(e,r,n,o){var i=new PIXI.Container;if(e.drawer=this,e.time=0,this.demo){if(this.demo.logo)try{(c=PIXI.Sprite.from(this.demo.logo)).position.set(t.WIDTH/2,t.HEIGHT/2),c.anchor.set(.5),c.baseScale=a(c.texture.width,c.texture.height,2*t.WIDTH/3,t.HEIGHT/2,0),i.addChild(c),e.logo=c}catch(r){l.push({cause:r,message:'Missing \"logo.png\" to complete replay.'}),e.logo=new PIXI.Container,e.logo.baseScale=1,i.addChild(e.logo),e.missingLogo=!0}var c=new PIXI.Graphics,u=(e.missingLogo||(c.beginFill(0,this.demo.overlayAlpha||0),c.drawRect(0,0,t.WIDTH+20,t.HEIGHT+20),c.endFill(),c.x-=10,c.y-=10),new PIXI.Container);try{this.initDefaultFrames(this.demo.playerCount,this.demo.frames,this.demo.agents),this.preconstructScene(this.scope,r,this.initWidth,this.initHeight),this.initScene(this.scope,u,this.frames,!0),this.updateScene(this.scope,this.question,this.frames,this.currentFrame,this.progress,1,this.reasons[this.currentFrame],!0)}catch(r){l.push({cause:r,message:\"Cannot load demo, you might want to reset the demo\"})}e.demo=u,e.demotime=0,this.currentFrame=-1,r.addChild(u),r.addChild(c),r.addChild(i)}e.updateTime=0,e.frameTime=0}},{key:\"initDefaultFrames\",value:function(e,r,n){var o=this;(n=(this.instantiateModules(),this.playerInfo=n.map((function(t,e){return{name:t.name||\"Anonymous\",color:t.color?o.parseColor(t.color):\"#ffffff\",number:e,index:t.index,type:t.type,isMe:\"CODINGAMER\"===t.type&&t.typeData.me,avatar:t.avatarTexture}})),this.instantiateModules(),this._frames=r.map((function(t){var e,r=(t=t.split(\"\\n\"))[0].split(\" \");try{e=JSON.parse(t.slice(1).join(\"\\n\"))}catch(t){e={}}return Jr(Jr({},e),{},{key:\"KEY_FRAME\"===r[0]})})).filter((function(t){return t.key})),this.parseGlobalData(this._frames[0].global),this.playerCount=e,this.reasons=[],this.frames=[],this.currentFrame=0,this.currentFrameDuration=1e3,this.progress=1,this._frames[0].frame)).key=this._frames[0].key,this.frames.push(this.parseFrame(n,this.frames));for(var i=1;i<this._frames.length;++i)this.frames.push(this.parseFrame(this._frames[i],this.frames));this.asyncRenderingTime=t.RenderTimeout}},{key:\"renderDefaultScene\",value:function(t,e){if(e=Math.min(80,e),void 0===this.demo)return!1;this.currentFrame=this.currentFrameTemp||0,t.frameTime+=e,t.updateTime+=e,t.demotime+=e/1e3;var r=Math.max(0,Math.min(1,(t.demotime-1)/.5));t.logo&&(t.logo.alpha=r,t.logo.scale.x=t.logo.scale.y=(3-2*r)*t.logo.baseScale),!t.missingLogo&&1.5<t.demotime&&t.demotime<=2.2?(r=15*Math.max(0,1-(t.demotime-1.5)/.7),t.demo.x=(2*Math.random()-1)*r,t.demo.y=(2*Math.random()-1)*r):t.demo.x=t.demo.y=0,r=this.getFrameDuration(this.currentFrame);return 30<=t.updateTime&&(t.updateTime-=30,0===this.currentFrame?this.progress=1:this.progress=i(0,r,t.frameTime),this.updateScene(this.scope,this.question,this.frames,this.currentFrame,this.progress,1,this.reasons[this.currentFrame],!0)),t.frameTime>=r&&(t.frameTime-=r,this.currentFrame=(this.currentFrame+1)%this.frames.length),this.renderScene(this.scope,this.question,this.frames,this.currentFrame,this.progress,1,this.reasons[this.currentFrame],e,!0),this.currentFrameTemp=this.currentFrame,this.currentFrame=-1,!0}},{key:\"endDefaultScene\",value:function(t,e){return!0}},{key:\"parseGlobalData\",value:function(t){for(var e in this.modules){var r=this.modules[e];\"function\"==typeof r.handleGlobalData&&r.handleGlobalData(this.playerInfo,t[e])}}},{key:\"parseFrame\",value:function(t,e){var r,n={data:{},frameInfo:{number:e.length}};if(n.previous=e[e.length-1]||n,n!==n.previous&&(n.previous.next=n),!t.key)return n.previous;for(r in t.duration&&(this.currentFrameDuration=t.duration),n.frameInfo.frameDuration=this.currentFrameDuration,n===n.previous?(n.frameInfo.date=0,n.frameInfo.frameDuration=0):n.frameInfo.date=n.previous.frameInfo.date+n.previous.frameInfo.frameDuration,this.modules){var o=this.modules[r];\"function\"==typeof o.handleFrameData&&(n.data[r]=o.handleFrameData(n.frameInfo,t[r]))}return n}},{key:\"preconstructScene\",value:function(e,r,n,o){e.canvasHeight=o,e.canvasWidth=n,e.time=0,e.endTime=0,e.playerInfo=this.playerInfo,r.scale.x=n/t.WIDTH,r.scale.y=o/t.HEIGHT}},{key:\"initScene\",value:function(t,e,r){for(var n in this.modules){var o=this.modules[n],i=new PIXI.Container;try{o.reinitScene(i,{width:t.canvasWidth,height:t.canvasHeight,oversampling:this.oversampling})}catch(t){this.handleModuleError(n,t)}e.addChild(i)}}},{key:\"updateScene\",value:function(t,e,r,n,o,i,a,c,u){var s,l=r[n];if(!u&&this.stepByStepAnimateSpeed){if(this.checkSteppedToNextFrame(t,l,o))return void this.startAsynchronousAnimation(t,l);if(this.checkSteppedToPreviousFrame(t,l,o))return void this.startAsynchronousAnimation(t,t.currentFrame,!0);t.targetProgress=null}for(s in t.currentFrame=l,t.currentProgress=o,t.reason=a,this.modules){var f=this.modules[s];if(l.data.hasOwnProperty(s))try{f.updateScene(l.previous.data[s],l.data[s],o,i)}catch(t){this.handleModuleError(s,t)}}}},{key:\"startAsynchronousAnimation\",value:function(t,e){var r=2<arguments.length&&void 0!==arguments[2]&&arguments[2];t.targetProgress=r?0:1,r||1!==t.currentProgress||(t.currentProgress=0),t.currentFrame=e,t.reverseAsynchronousAnimation=r}},{key:\"checkStepped\",value:function(t,e,r){return t.currentFrame&&0===this.speed&&1===r}},{key:\"checkSteppedToNextFrame\",value:function(t,e,r){return this.checkStepped(t,e,r)&&(t.currentFrame===e.previous&&t.currentFrame!==e||t.currentFrame===e&&t.currentProgress!==r)}},{key:\"checkSteppedToPreviousFrame\",value:function(t,e,r){return this.checkStepped(t,e,r)&&t.currentFrame.previous===e&&t.currentFrame!==e}},{key:\"initEndScene\",value:function(t,e){t.endSceneViewed=!1}},{key:\"destroyEndScene\",value:function(t){}},{key:\"renderEndScene\",value:function(t,e,r){0===t.endTime&&this.initEndScene(t,r),t.endTime+=e,void 0<=t.endTime&&!t.endSceneViewed&&(this.endCallback&&this.endCallback(),t.endSceneViewed=!0)}},{key:\"renderScene\",value:function(t,e,r,n,o,i,a,c){var u,s;for(s in c=Math.min(80,c),this.debugMode||n!==r.length-1||1!==o?(0<t.endTime&&this.destroyEndScene(t),t.endTime=0):this.renderEndScene(t,c,\"Win\"!==a),this.stepByStepAnimateSpeed&&this.isAsynchronousAnimationOngoing(t)&&(n=this.currentFrame,t.reverseAsynchronousAnimation&&n++,r=c/200*this.getFrameSpeed(n)*this.stepByStepAnimateSpeed,t.reverseAsynchronousAnimation?(u=t.currentProgress-r)<=0&&(n=this.currentFrame,t.targetProgress=u=1):(u=t.currentProgress+r,u=Math.min(t.targetProgress,u)),this.updateScene(this.scope,this.question,this.frames,n,u,this.speed,this.reasons[n],!1,!0)),this.modules){var l=this.modules[s];if(\"function\"==typeof l.animateScene)try{l.animateScene(c)}catch(t){this.handleModuleError(s,t)}}return!0}},{key:\"isAsynchronousAnimationOngoing\",value:function(t){return null!=t.targetProgress&&t.currentProgress!==t.targetProgress}},{key:\"getFrameSpeed\",value:function(t){return 500/this.getFrameDuration(t)}},{key:\"getFrameDuration\",value:function(t){return this.frames&&this.frames[t]&&this.frames[t].frameInfo.frameDuration||1e3}},{key:\"enableAsyncRendering\",value:function(e){this.asyncRendering=e,this.asyncRenderingTime=t.RenderTimeout}},{key:\"purge\",value:function(){this.scope={},this.changed=!0,this.container.interactiveChildren=!1,this.container.destroy({texture:!1,children:!0}),delete this.container,this.container=new PIXI.Container}},{key:\"reinitScene\",value:function(){1<=this.loaded&&(this.destroyScene(this.scope),this.purge(),this.asyncRenderingTime=t.RenderTimeout,this.preconstructScene(this.scope,this.container,this.initWidth,this.initHeight),this.initScene(this.scope,this.container,this.frames),this.updateScene(this.scope,this.question,this.frames,this.currentFrame,this.progress,this.speed,this.reasons[this.currentFrame]),this.changed=!0)}},{key:\"reinitDefaultScene\",value:function(){1<=this.loaded&&(this.intro=!0,this.destroyScene(this.scope),this.purge(),this.asyncRenderingTime=t.RenderTimeout,this.initDefaultScene(this.scope,this.container,this.initWidth,this.initHeight),this.changed=!0)}},{key:\"reinitLoadingScene\",value:function(){this.loaded<1&&(this.purge(),this.asyncRenderingTime=t.RenderTimeout,this.initPreload(this.scope,this.container,this.loaded,this.initWidth,this.initHeight))}},{key:\"reinit\",value:function(t){1<=this.loaded&&!this.loading?0<=this.currentFrame&&!this.intro?this.reinitScene():this.intro&&!t||this.reinitDefaultScene():this.reinitLoadingScene()}},{key:\"animate\",value:function(t){var e;this.destroyed||(this.lastRenderTime||(this.lastRenderTime=t),e=t-this.lastRenderTime,this.asynchronousStep&&(e=this.asynchronousStep),this.onBeforeRender&&this.onBeforeRender(),this.loading||(this.loaded<1?this.changed|=this.renderPreloadScene(this.scope,e):(this.changed||this.asyncRendering&&0<this.asyncRenderingTime||this.isAsynchronousAnimationOngoing(this.scope))&&(this.currentFrame<0?this.changed|=this.renderDefaultScene(this.scope,e):this.intro?(this.changed=!0,this.endDefaultScene(this.scope,e)&&(this.intro=!1,this.reinit(!0))):this.changed|=this.renderScene(this.scope,this.question,this.frames,this.currentFrame,this.progress,this.speed,this.reasons[this.currentFrame],e)),this.changed&&(this.renderer.render(this.container),this.changed=!1)),this.onAfterRender&&this.onAfterRender(),this.lastRenderTime=t,this.destroyed||requestAnimationFrame(this.animate.bind(this)),this.asyncRenderingTime-=e)}},{key:\"_initFrames\",value:function(t,e){this.instantiateModules(),this._frames=e.map((function(t){var e,r=t[0].split(\" \");try{e=JSON.parse(t.slice(1).join(\"\\n\"))}catch(t){e={}}return Jr(Jr({},e),{},{key:\"KEY_FRAME\"===r[0]})})),this.parseGlobalData(this._frames[0].global),this.playerCount=t,this.reasons=[],this.frames=[],this.currentFrame=0,this.currentFrameDuration=1e3,this.progress=1,(e=this._frames[0].frame).key=this._frames[0].key,this.frames.push(this.parseFrame(e,this.frames));for(var r=1;r<this._frames.length;++r)this.frames.push(this.parseFrame(this._frames[r],this.frames))}},{key:\"isTurnBasedGame\",value:function(){return!1}},{key:\"initFrames\",value:function(t,e){function r(){n._initFrames(e.length,t),n.loading=!1,n.reinit(!1),i=!0}this.playerInfo&&this.playerInfo.forEach((function(t){t.avatar&&t.avatar.destroy(!0)}));var n=this,o=new PIXI.Loader(window.location.origin),i=(this.playerInfo=e.map((function(t,e){var r={name:t.name||\"Anonymous\",color:t.color?n.parseColor(t.color):\"#ffffff\",number:e,index:t.index,type:t.type,isMe:\"CODINGAMER\"===t.type&&t.typeData.me,avatar:null};return null!=t.avatar&&o.add(\"avatar\"+e,t.avatar,{loadType:2,crossOrigin:!0},(function(t){r.avatar=t.texture,PIXI.Texture.addToCache(t.texture,\"$\"+r.index)})),r})),!(this.loading=!0));o.onComplete.add(r),o.onError.add((function(t){console.warn(t),i||r()})),o.load()}},{key:\"update\",value:function(e,r,n){0<=this.currentFrame&&(this.asyncRenderingTime=t.RenderTimeout,this.changed=!0,this.speed=n,this.currentFrame=e,this.progress=r,1<=this.loaded)&&!this.intro&&this.updateScene(this.scope,this.question,this.frames,e,r,this.speed,this.reasons[this.currentFrame])}},{key:\"parseColor\",value:function(t){if(Array.isArray(t)){for(var e=[],r=0;r<t.length;++r)e.push(this.parseColor(t[r]));return e}return parseInt(t.substring(1),16)}},{key:\"init\",value:function(e,r,n,o,i,a,c){function u(){0<=f.currentFrame&&(f.changed=!0)}var s,f=this,p=(window.PIXI=t.PIXI||window.PIXI,this.oversampling=i||1,this.canvas=$(e),this.canvas.off(\"mousemove\"),this.canvas.off(\"wheel\"),this.canvas.bind(\"wheel\",u),this.canvas.mousemove(u),o&&(this.colors=this.parseColor(o)),\"ide\"===c&&(this.debugModeSetByUser||(this.debugMode=!0),l.listen((function(t){return console.error(t.cause||t)}))),this.asyncRendering=!0,this.asyncRenderingTime=0,this.destroyed=!1,this.asynchronousStep=null,this);if(this.initWidth=0|r,this.initHeight=0|n,this.endCallback=a||this.endCallback,this.alreadyLoaded)this.changed=!0,this.renderer.resize(this.initWidth,this.initHeight),this.reinit(!0);else{this.alreadyLoaded=!0,this.question=null,this.scope=null,this.currentFrame=-1,this.loaded=0,this.container=new PIXI.Container;var h,y=this.getResources(),d=(this.renderer=this.createRenderer(this.initWidth,this.initHeight,e),i=this.renderer,oe=i,new PIXI.Loader(y.baseUrl));for(s in y.images)d.add(s,y.images[s],{crossOrigin:!0});for(h=0;h<y.sprites.length;++h)d.add(y.sprites[h],{crossOrigin:!0});for(h=0;h<y.fonts.length;++h)d.add(y.fonts[h],{crossOrigin:!0});for(s in y.spines)d.add(s,y.spines[s],{crossOrigin:!0});for(h=0;h<y.others.length;++h)d.add(y.others[h],{crossOrigin:!0});this.demo&&this.demo.agents.forEach((function(t){d.add(\"avatar\"+t.index,t.avatar,{loadType:2,crossOrigin:!0},(function(e){t.avatarTexture=e.texture,PIXI.Texture.addToCache(e.texture,\"$\"+t.index)}))})),p.scope={},o=function(t,e){requestAnimationFrame(p.animate.bind(p)),p.initPreload(p.scope,p.container,p.loaded=0,p.initWidth,p.initHeight)},d.onStart.add(o),d.onProgress.add((function(t,e){t.progress<100&&p.preload(p.scope,p.container,p.loaded=t.progress/100,p.initWidth,p.initHeight,e)})),c=function(){for(var t in y.spines)y.spines.hasOwnProperty(t)&&(PIXI.AnimCache[t]=PIXI.AnimCache[y.baseUrl+y.spines[t]]);p.loaded=1,p.reinit(!0),p.changed=!0},d.onComplete.add(c),d.onError.add((function(t){console.warn(t)})),Object.keys(d.resources).length?d.load():(o(),c())}}},{key:\"createRenderer\",value:function(t,e,r){return PIXI.autoDetectRenderer({width:t,height:e,view:r,clearBeforeRender:!0,preserveDrawingBuffer:!1})}},{key:\"isReady\",value:function(){return 1<=this.loaded}}])&&Zr(e.prototype,r),o&&Zr(e,o),Object.defineProperty(e,\"prototype\",{writable:!1}),t}()}]).Drawer;",
      "levelParams": {
        "0": {
          "aiCode": "import java.util.*;\r\nimport java.text.*;\r\nimport java.util.function.*;\r\nimport java.util.stream.*;\r\nimport java.util.concurrent.*;\r\nimport java.util.Map.*;\r\nclass Game{\r\nstatic Logger logger=Logger.getLogger(Game.class);\r\nstatic final Game instance=new Game();\r\nint[] board=BoardUtils.constructBoard();\r\nGame(){}\r\npublic static Game getInstance(){\r\nreturn instance;\r\n}\r\npublic void init(Scanner in){\r\nint playerPositionX=in.nextInt();\r\nint playerPositionY=in.nextInt();\r\nConstant.PLAYER_ID=playerPositionX==0?0:1;\r\nConstant.OPPONENT_ID=1-Constant.PLAYER_ID;\r\nBoardUtils.init(board);\r\n\r\n}\r\npublic void init(int[] board){\r\nthis.board=board;\r\n}\r\npublic void update(Scanner in){\r\nint opponentPosition=PointUtils.getPosition(in);\r\nConstant.ROUND++;\r\nTimer.getInstance().init();\r\n\r\nBoardUtils.setTeamPosition(board,opponentPosition,Constant.OPPONENT_ID);\r\nint opponentLastRemovedTile=PointUtils.getPosition(in);\r\nif(opponentLastRemovedTile!=FrameworkConstant.OUT){\r\nBoardUtils.removeTile(board,opponentLastRemovedTile);\r\n}\r\n}\r\npublic int[] getBoard(){\r\nreturn board;\r\n}\r\n}\r\n\r\nclass Player{\r\npublic static void main(String args[]){\r\nScanner in=new Scanner(System.in);\r\nGame game=Game.getInstance();\r\ngame.init(in);\r\nwhile(true){\r\ngame.update(in);\r\nString action=NextMoveUtils.proceed();\r\nSystem.out.println(action+getMessage());\r\n}\r\n}\r\npublic static String getMessage(){\r\nreturn Parameter.BOSS_NB==3\r\n?\";I'M THE BOSS!!!\"\r\n:Parameter.BOSS_NB==2?\";IT'S OVER!!\":\";I'M A NOOB!\";\r\n}\r\n}\r\n\r\nclass Bit128Utils{\r\nstatic final long[] masksLowerN=new long[64];\r\nstatic final long maskCut;\r\nstatic{\r\nlong tmp=0l;\r\nfor(int i=0;i<masksLowerN.length;i++){\r\nmasksLowerN[i]=tmp;\r\ntmp=tmp << 1l;\r\ntmp=tmp |= 1;\r\n}\r\ntmp=0;\r\nfor(int i=0;i<FrameworkConstant.CASE_NB%64;i++){\r\ntmp=tmp|(1l << i);\r\n}\r\nmaskCut=tmp;\r\n}\r\npublic static void shiftLeft(long[] bits,int nb){\r\nbits[1]=((bits[1] << nb)|(bits[0] >>>(64-nb)))&maskCut;\r\nbits[0]=bits[0] << nb;\r\n}\r\npublic static void shiftRight(long[] bits,int nb){\r\nbits[0]=(bits[0] >>> nb)|(bits[1] <<(64-nb));\r\nbits[1]=bits[1] >>> nb;\r\n}\r\npublic static String toBinaryString(long[] bits){\r\nString s=Long.toBinaryString(bits[0]);\r\nif(bits[1]!=0){\r\nwhile(s.length()<64){\r\ns=\"0\"+s;\r\n}\r\ns=Long.toBinaryString(bits[1])+s;\r\n}\r\nreturn s;\r\n}\r\npublic static String shiftLeft(String s,int nb){\r\nif(!s.equals(\"0\")){\r\ns+=new String(new char[nb]).replace(\"\\0\",\"0\");\r\n}\r\nif(s.length()>FrameworkConstant.CASE_NB){\r\ns=s.substring(s.length()-FrameworkConstant.CASE_NB,s.length());\r\n}\r\nreturn s;\r\n}\r\npublic static String shiftRight(String s,int nb){\r\ns=s.substring(0,Math.max(s.length()-nb,0));\r\nif(s.equals(\"\")){\r\ns=\"0\";\r\n}\r\nreturn s;\r\n}\r\npublic static boolean isSet(long[] bits,int nb){\r\nif(nb>=64){\r\nreturn(bits[1]&(1l <<(nb-64)))!=0;\r\n}\r\nreturn(bits[0]&(1l << nb))!=0;\r\n}\r\npublic static void set(long[] bits,int nb){\r\nif(nb>=64){\r\nbits[1]=bits[1]|(1l <<(nb-64));\r\n}else{\r\nbits[0]=bits[0]|(1l << nb);\r\n}\r\n}\r\npublic static void reset(long[] bits,int nb){\r\nif(nb>=64){\r\nbits[1]=bits[1]&~(1l <<(nb-64));\r\n}else{\r\nbits[0]=bits[0]&~(1l << nb);\r\n}\r\n}\r\npublic static void and(long[] bits1,int index1,long[] bits2,int index2){\r\nint tmp=2*index1;\r\nbits1[tmp]=bits1[tmp]&bits2[2*index2];\r\ntmp++;\r\nbits1[tmp]=bits1[tmp]&bits2[2*index1+1];\r\n}\r\npublic static void and(long[] bits1,long[] bits2){\r\nbits1[0]=bits1[0]&bits2[0];\r\nbits1[1]=bits1[1]&bits2[1];\r\n}\r\npublic static void or(long[] bits1,int index1,long[] bits2,int index2){\r\nbits1[2*index1]=bits1[2*index1]|bits2[2*index2];\r\nbits1[2*index1+1]=bits1[2*index1+1]|bits2[2*index2+1];\r\n}\r\npublic static void or(long[] bits1,long[] bits2){\r\nbits1[0]=bits1[0]|bits2[0];\r\nbits1[1]=bits1[1]|bits2[1];\r\n}\r\npublic static void reverse(long[] bits){\r\nbits[0]=~bits[0];\r\nbits[1]=~bits[1]&maskCut;\r\n}\r\n}\r\n\r\nclass BoardBitUtils{\r\nstatic Logger logger=Logger.getLogger(BoardBitUtils.class);\r\npublic static String toString(long[] boards){\r\nStringBuilder sb=new StringBuilder();\r\nsb.append(\"\\n\");\r\nfor(int y=0;y<FrameworkConstant.HEIGHT;y++){\r\nfor(int x=0;x<FrameworkConstant.WIDTH;x++){\r\nint nb=getIndex(x,y);\r\nif(Bit128Utils.isSet( boards,nb)){\r\nsb.append(\"0\");\r\n}else{\r\nsb.append(\".\");\r\n}\r\n}\r\nsb.append(\"\\n\");\r\n}\r\nreturn sb.toString();\r\n}\r\npublic static int getIndex(int x,int y){\r\nreturn FrameworkConstant.WIDTH*y+x;\r\n}\r\nstatic final long[] verticalLeft=new long[2];\r\nstatic final long[] horizontalUp=new long[2];\r\nstatic final long[] diagonalLeftUp=new long[2];\r\nstatic final long[] diagonalLeftDown=new long[2];\r\nstatic final long[] diagonalRightUp=new long[2];\r\nstatic final long[] diagonalRightDown=new long[2];\r\nstatic final long[] horizontalDown=new long[2];\r\nstatic final long[] verticalRight=new long[2];\r\npublic static final long[][] arounds =\r\nnew long[FrameworkConstant.WIDTH*FrameworkConstant.HEIGHT][];\r\nstatic final long[] tmpBoard=new long[2];\r\nstatic final long[] tmpBoard1=new long[2];\r\nstatic final long[] tmpBoard2=new long[2];\r\nstatic final long[] tmpBoard3=new long[2];\r\nstatic final int WIDTH_PLUS_ONE=FrameworkConstant.WIDTH+1;\r\nstatic final int WIDTH_MINUS_ONE=FrameworkConstant.WIDTH-1;\r\nstatic{\r\nfor(int y=0;y<FrameworkConstant.HEIGHT;y++){\r\nfor(int x=1;x<FrameworkConstant.WIDTH;x++){\r\nint nb=getIndex(x,y);\r\nBit128Utils.set(verticalLeft,nb);\r\n}\r\n}\r\nfor(int y=0;y<FrameworkConstant.HEIGHT;y++){\r\nfor(int x=0;x<FrameworkConstant.WIDTH-1;x++){\r\nint nb=getIndex(x,y);\r\nBit128Utils.set(verticalRight,nb);\r\n}\r\n}\r\nfor(int y=1;y<FrameworkConstant.HEIGHT;y++){\r\nfor(int x=0;x<FrameworkConstant.WIDTH;x++){\r\nint nb=getIndex(x,y);\r\nBit128Utils.set(horizontalUp,nb);\r\n}\r\n}\r\nfor(int y=0;y<FrameworkConstant.HEIGHT-1;y++){\r\nfor(int x=0;x<FrameworkConstant.WIDTH;x++){\r\nint nb=getIndex(x,y);\r\nBit128Utils.set(horizontalDown,nb);\r\n}\r\n}\r\nfor(int y=1;y<FrameworkConstant.HEIGHT;y++){\r\nfor(int x=1;x<FrameworkConstant.WIDTH;x++){\r\nint nb=getIndex(x,y);\r\nBit128Utils.set(diagonalLeftUp,nb);\r\n}\r\n}\r\nfor(int y=0;y<FrameworkConstant.HEIGHT-1;y++){\r\nfor(int x=1;x<FrameworkConstant.WIDTH;x++){\r\nint nb=getIndex(x,y);\r\nBit128Utils.set(diagonalLeftDown,nb);\r\n}\r\n}\r\nfor(int y=1;y<FrameworkConstant.HEIGHT;y++){\r\nfor(int x=0;x<FrameworkConstant.WIDTH-1;x++){\r\nint nb=getIndex(x,y);\r\nBit128Utils.set(diagonalRightUp,nb);\r\n}\r\n}\r\nfor(int y=0;y<FrameworkConstant.HEIGHT-1;y++){\r\nfor(int x=0;x<FrameworkConstant.WIDTH-1;x++){\r\nint nb=getIndex(x,y);\r\nBit128Utils.set(diagonalRightDown,nb);\r\n}\r\n}\r\nfor(int y=0;y<FrameworkConstant.HEIGHT;y++){\r\nfor(int x=0;x<FrameworkConstant.WIDTH;x++){\r\nint nb=getIndex(x,y);\r\ntmpBoard1[0]=0;\r\ntmpBoard1[1]=0;\r\ntmpBoard[0]=0;\r\ntmpBoard[1]=0;\r\nBit128Utils.set(tmpBoard,nb);\r\nshiftLeft(tmpBoard);\r\nBit128Utils.or(tmpBoard1,0,tmpBoard,0);\r\ntmpBoard[0]=0;\r\ntmpBoard[1]=0;\r\nBit128Utils.set(tmpBoard,nb);\r\nshiftRight(tmpBoard);\r\nBit128Utils.or(tmpBoard1,0,tmpBoard,0);\r\ntmpBoard[0]=0;\r\ntmpBoard[1]=0;\r\nBit128Utils.set(tmpBoard,nb);\r\nshiftUp(tmpBoard);\r\nBit128Utils.or(tmpBoard1,0,tmpBoard,0);\r\ntmpBoard[0]=0;\r\ntmpBoard[1]=0;\r\nBit128Utils.set(tmpBoard,nb);\r\nshiftDown(tmpBoard);\r\nBit128Utils.or(tmpBoard1,0,tmpBoard,0);\r\ntmpBoard[0]=0;\r\ntmpBoard[1]=0;\r\nBit128Utils.set(tmpBoard,nb);\r\nshiftLeftUp(tmpBoard);\r\nBit128Utils.or(tmpBoard1,0,tmpBoard,0);\r\ntmpBoard[0]=0;\r\ntmpBoard[1]=0;\r\nBit128Utils.set(tmpBoard,nb);\r\nshiftLeftDown(tmpBoard);\r\nBit128Utils.or(tmpBoard1,0,tmpBoard,0);\r\ntmpBoard[0]=0;\r\ntmpBoard[1]=0;\r\nBit128Utils.set(tmpBoard,nb);\r\nshiftRightUp(tmpBoard);\r\nBit128Utils.or(tmpBoard1,0,tmpBoard,0);\r\ntmpBoard[0]=0;\r\ntmpBoard[1]=0;\r\nBit128Utils.set(tmpBoard,nb);\r\nshiftRightDown(tmpBoard);\r\nBit128Utils.or(tmpBoard1,0,tmpBoard,0);\r\nlong[] tmp=new long[2];\r\ntmp[0]=tmpBoard1[0];\r\ntmp[1]=tmpBoard1[1];\r\narounds[nb]=tmp;\r\n}\r\n}\r\n}\r\npublic static int calculateLongBitCount(long[] bitboard){\r\nreturn bitCount(bitboard[0])+bitCount(bitboard[1]);\r\n}\r\nstatic int bitCount(long l){\r\nif(l==0){\r\nreturn 0;\r\n}\r\nreturn Long.bitCount(l);\r\n}\r\npublic static void shiftLeft(long[] bitboard){\r\nBit128Utils.and(bitboard,verticalLeft);\r\nBit128Utils.shiftRight(bitboard,1);\r\n}\r\npublic static void shiftRight(long[] bitboard){\r\nBit128Utils.and(bitboard,verticalRight);\r\nBit128Utils.shiftLeft(bitboard,1);\r\n}\r\npublic static void shiftUp(long[] bitboard){\r\nBit128Utils.and(bitboard,horizontalUp);\r\nBit128Utils.shiftRight(bitboard,FrameworkConstant.WIDTH);\r\n}\r\npublic static void shiftDown(long[] bitboard){\r\nBit128Utils.and(bitboard,horizontalDown);\r\nBit128Utils.shiftLeft(bitboard,FrameworkConstant.WIDTH);\r\n}\r\npublic static void shiftLeftUp(long[] bitboard){\r\nBit128Utils.and(bitboard,diagonalLeftUp);\r\nBit128Utils.shiftRight(bitboard,WIDTH_PLUS_ONE);\r\n}\r\npublic static void shiftLeftDown(long[] bitboard){\r\nBit128Utils.and(bitboard,diagonalLeftDown);\r\nBit128Utils.shiftLeft(bitboard,WIDTH_MINUS_ONE);\r\n}\r\npublic static void shiftRightUp(long[] bitboard){\r\nBit128Utils.and(bitboard,diagonalRightUp);\r\nBit128Utils.shiftRight(bitboard,WIDTH_MINUS_ONE);\r\n}\r\npublic static void shiftRightDown(long[] bitboard){\r\nBit128Utils.and(bitboard,diagonalRightDown);\r\nBit128Utils.shiftLeft(bitboard,WIDTH_PLUS_ONE);\r\n}\r\nstatic long[] copy=new long[2];\r\nstatic long[] finalBoard=new long[2];\r\nstatic long[] copyMoveAroundBoard=new long[2];\r\npublic static void toLongBoard(int[] board,long[] destination){\r\ndestination[0]=(((long)board[0])&0xFFFFFFFFL)|(((long)board[1])<< 32);\r\ndestination[1]=((long)board[2])&0xFFFFFFFFL;\r\nBit128Utils.reverse(destination);\r\n}\r\npublic static long[] moveAround(long[] board){\r\nclear(finalBoard);\r\ncopy(board,copy);\r\nshiftLeft(copy);\r\nBit128Utils.or(finalBoard,copy);\r\ncopy(board,copy);\r\nshiftRight(copy);\r\nBit128Utils.or(finalBoard,copy);\r\ncopy(board,copy);\r\nshiftUp(copy);\r\nBit128Utils.or(finalBoard,copy);\r\ncopy(board,copy);\r\nshiftDown(copy);\r\nBit128Utils.or(finalBoard,copy);\r\ncopy(board,copy);\r\nshiftLeftDown(copy);\r\nBit128Utils.or(finalBoard,copy);\r\ncopy(board,copy);\r\nshiftRightDown(copy);\r\nBit128Utils.or(finalBoard,copy);\r\ncopy(board,copy);\r\nshiftLeftUp(copy);\r\nBit128Utils.or(finalBoard,copy);\r\ncopy(board,copy);\r\nshiftRightUp(copy);\r\nBit128Utils.or(finalBoard,copy);\r\nreturn finalBoard;\r\n}\r\npublic static void copy(long[] source,long[] destination){\r\ndestination[0]=source[0];\r\ndestination[1]=source[1];\r\n}\r\npublic static void clear(long[] source){\r\nsource[0]=0;\r\nsource[1]=0;\r\n}\r\n}\r\n\r\nclass BoardCache{\r\nstatic final Logger logger=Logger.getLogger(BoardCache.class);\r\nstatic final int[][] CACHE=new int[Parameter.BOARD_CACHE_NB][];\r\nstatic int maxIndex;\r\nstatic int index;\r\npublic static void reset(){\r\nmaxIndex=Math.max(maxIndex,index);\r\nindex=0;\r\n}\r\npublic static int[] next()throws NoMoreBoardException{\r\ntry{\r\nint[] ret=CACHE[index];\r\nif(ret==null){\r\nret=BoardUtils.constructBoard();\r\nCACHE[index]=ret;\r\n}\r\nindex++;\r\nreturn ret;\r\n}catch(IndexOutOfBoundsException e){\r\nthrow NoMoreBoardException.EXCEPTION;\r\n}\r\n}\r\npublic static int[] getWay(int index){\r\nreturn CACHE[index];\r\n}\r\npublic static int getIndex(){\r\nreturn index;\r\n}\r\npublic static void printIndex(){\r\n\r\n}\r\n}\r\n\r\nclass BoardUtils{\r\nstatic final Logger logger=Logger.getLogger(BoardUtils.class);\r\nstatic int index=0;\r\npublic static final int MAP_INDEX=index;\r\npublic static final int BIT_NB=32;\r\npublic static final int MAP_LENGTH=(int)Math.ceil(FrameworkConstant.CASE_NB/(double)BIT_NB);\r\nstatic{\r\nindex+=MAP_LENGTH;\r\n}\r\nstatic final int TEAM_POSITION_INDEX=index;\r\nstatic{\r\nindex+=2;\r\n}\r\nstatic final int LAST_TILE=index++;\r\nstatic final int CHILD_NB=index++;\r\nstatic final int CHILD_START=index++;\r\nstatic final int LENGTH=index;\r\npublic static int[] constructBoard(){\r\nreturn new int[LENGTH];\r\n}\r\npublic static void init(int[] board){\r\nint x=(FrameworkConstant.HEIGHT-1)/2;\r\nsetTeamPosition(board,PointUtils.getPosition(0,x),0);\r\nsetTeamPosition(board,PointUtils.getPosition(FrameworkConstant.WIDTH-1,x),1);\r\n}\r\npublic static boolean isChildInit(int[] board){\r\nreturn getChildNb(board)!=-1;\r\n}\r\npublic static void reset(int[] board){\r\nsetChildNb(board,-1);\r\n}\r\npublic static int[] calculateNextWay(int[] board,int move,int tile,int team){\r\nint[] ret=copy(board);\r\nmove(ret,move,tile,team);\r\nreturn ret;\r\n}\r\npublic static void move(int[] board,int move,int tile,int team){\r\nsetTeamPosition(board,move,team);\r\nremoveTile(board,tile);\r\nsetLastTile(board,tile);\r\n}\r\npublic static int[] copy(int[] board){\r\nint[] ret=BoardCache.next();\r\nSystem.arraycopy(board,0,ret,0,LAST_TILE);\r\nreset(ret);\r\nreturn ret;\r\n}\r\npublic static void copy(int[] source,int[] destination){\r\nSystem.arraycopy(source,0,destination,0,LAST_TILE);\r\nreset(destination);\r\n}\r\npublic static void removeTile(int[] board,int position){\r\nboard[MAP_INDEX+position/BIT_NB] |= 1 <<(position%BIT_NB);\r\n}\r\npublic static boolean hasTile(int[] board,int position){\r\nreturn(board[MAP_INDEX+position/BIT_NB]&(1 <<(position%BIT_NB)))==0;\r\n}\r\npublic static void copyMap(int[] board,int[] map){\r\nfor(int i=0;i<MAP_LENGTH;i++){\r\nmap[i]=board[MAP_INDEX+i];\r\n}\r\n}\r\npublic static void setTeamPosition(int[] board,int position,int team){\r\nboard[TEAM_POSITION_INDEX+team]=position;\r\n}\r\npublic static int getTeamPosition(int[] board,int team){\r\nreturn board[TEAM_POSITION_INDEX+team];\r\n}\r\npublic static void setLastTile(int[] board,int position){\r\nboard[LAST_TILE]=position;\r\n}\r\npublic static int getLastTile(int[] board){\r\nreturn board[LAST_TILE];\r\n}\r\npublic static void setChildNb(int[] board,int value){\r\nboard[CHILD_NB]=value;\r\n}\r\npublic static int getChildNb(int[] board){\r\nreturn board[CHILD_NB];\r\n}\r\npublic static void setChildStartIndex(int[] board,int value){\r\nboard[CHILD_START]=value;\r\n}\r\npublic static int getChildStartIndex(int[] board){\r\nreturn board[CHILD_START];\r\n}\r\npublic static void initChild(int[] way,int teamId,boolean first){\r\nif(isChildInit(way)){\r\nreturn;\r\n}\r\nint childNb=0;\r\nint startIndex=BoardCache.getIndex();\r\nsetChildStartIndex(way,startIndex);\r\nint playerPosition=getTeamPosition(way,teamId);\r\nint opponentPosition=getTeamPosition(way,1-teamId);\r\nbyte[] possibleTiles=TilePruningUtils.calculatePossiblePruningTiles(way,teamId,first);\r\nint size=ByteListUtils.size(possibleTiles);\r\nbyte[] positions=MapUtils.getAroundPositions(playerPosition);\r\nfor(int i=0;i<positions.length;i++){\r\nbyte move=positions[i];\r\nif(hasTile(way,move)&&move!=opponentPosition){\r\nfor(int j=0;j<size;j++){\r\nint tile=ByteListUtils.get(possibleTiles,j);\r\nif(tile!=move){\r\ncalculateNextWay(way,move,tile,teamId);\r\nchildNb++;\r\n}\r\n}\r\n}\r\n}\r\nsetChildNb(way,childNb);\r\n}\r\npublic static String toString(int[] board){\r\nif(board==null){\r\nreturn null;\r\n}\r\nStringBuilder sb=new StringBuilder(\"\\n\");\r\nfor(int p=0;p<FrameworkConstant.CASE_NB;p++){\r\nif(hasTile(board,p)){\r\nif(p==getTeamPosition(board,0)){\r\nsb.append('0');\r\n}else if(p==getTeamPosition(board,1)){\r\nsb.append('1');\r\n}else{\r\nsb.append('.');\r\n}\r\n}else{\r\nsb.append('X');\r\n}\r\nif((p+1)%FrameworkConstant.WIDTH==0){\r\nsb.append('\\n');\r\n}\r\n}\r\nsb.append(\"tile:\"+PointUtils.toPoint(getLastTile(board)));\r\nsb.append('\\n');\r\nreturn sb.toString();\r\n}\r\npublic static String toMapString(int[] board){\r\nif(board==null){\r\nreturn null;\r\n}\r\nStringBuilder sb=new StringBuilder(\"\\n\");\r\nfor(int p=0;p<FrameworkConstant.CASE_NB;p++){\r\nif(hasTile(board,p)){\r\nsb.append('.');\r\n}else{\r\nsb.append('X');\r\n}\r\nif((p+1)%FrameworkConstant.WIDTH==0){\r\nsb.append('\\n');\r\n}\r\n}\r\nreturn sb.toString();\r\n}\r\n}\r\n\r\nclass IslandUtils{\r\nstatic Logger logger=Logger.getLogger(IslandUtils.class);\r\npublic static final byte[][] possiblePruningTiles=new byte[3][];\r\nstatic{\r\nfor(int i=0;i<possiblePruningTiles.length;i++){\r\npossiblePruningTiles[i]=new byte[FrameworkConstant.CASE_NB+1];\r\n}\r\n}\r\npublic static final int[][] places=new int[2][];\r\nstatic{\r\nfor(int i=0;i<places.length;i++){\r\nplaces[i]=new int[3];\r\n}\r\n}\r\npublic static boolean sameIsland;\r\npublic static void calculateIsland(int[] board){\r\nfor(int i=0;i<possiblePruningTiles.length;i++){\r\nByteListUtils.clear(possiblePruningTiles[i]);\r\n}\r\nfor(int i=0;i<2;i++){\r\nPlaceUtils.calculatePlace(board,i);\r\nPlaceUtils.copy(PlaceUtils.place,places[i]);\r\n}\r\nfor(byte i=0;i<FrameworkConstant.CASE_NB;i++){\r\nif(BoardUtils.hasTile(board,i)){\r\nboolean freeIsland=true;\r\nfor(int id=0;id<2;id++){\r\nif(!PlaceUtils.isFree(places[id],i)){\r\nByteListUtils.add(possiblePruningTiles[id],i);\r\nfreeIsland=false;\r\n}\r\n}\r\nif(freeIsland){\r\nByteListUtils.add(possiblePruningTiles[2],i);\r\n}\r\n}\r\n}\r\nsameIsland =\r\nByteListUtils.size(possiblePruningTiles[1])==ByteListUtils.size(possiblePruningTiles[0]);\r\nif(sameIsland){\r\nfor(int i=0;i<ByteListUtils.size(possiblePruningTiles[0]);i++){\r\nif(!ByteListUtils.contains(\r\npossiblePruningTiles[1],ByteListUtils.get(possiblePruningTiles[0],i))){\r\nsameIsland=false;\r\nbreak;\r\n}\r\n}\r\n}\r\nfor(int i=0;i<possiblePruningTiles.length;i++){\r\n\r\n}\r\n\r\n}\r\n}\r\n\r\nclass NoMoreBoardException extends RuntimeException{\r\npublic static final NoMoreBoardException EXCEPTION=new NoMoreBoardException();\r\n}\r\n\r\nclass PlaceUtils{\r\nstatic Logger logger=Logger.getLogger(PlaceUtils.class);\r\npublic static byte[][] positions=new byte[FrameworkConstant.CASE_NB][];\r\nstatic{\r\nfor(int i=0;i<positions.length;i++){\r\npositions[i]=new byte[FrameworkConstant.CASE_NB+1];\r\n}\r\n}\r\npublic static int[] place=new int[BoardUtils.MAP_LENGTH];\r\npublic static int size;\r\npublic static int[] dones=new int[BoardUtils.MAP_LENGTH];\r\npublic static int[] lastDones=new int[BoardUtils.MAP_LENGTH];\r\npublic static void calculatePlace(int[] way,int teamId){\r\ncalculatePlace(way,teamId,Integer.MAX_VALUE,false);\r\n}\r\npublic static void calculatePlace(int[] way,int teamId,int limit,boolean pawnBlock){\r\nint start=BoardUtils.getTeamPosition(way,teamId);\r\nBoardUtils.copyMap(way,dones);\r\nsetDone(dones,start);\r\nbyte[] currents=positions[0];\r\nByteListUtils.clear(currents);\r\nByteListUtils.add(currents,(byte)start);\r\nint n=0;\r\nsetDone(place,start);\r\nif(pawnBlock){\r\nint opponentPosition=BoardUtils.getTeamPosition(way,1-teamId);\r\nsetDone(dones,opponentPosition);\r\n}\r\nwhile(!ByteListUtils.isEmpty(currents)&&n<limit){\r\nn++;\r\nbyte[] nexts=positions[n];\r\nByteListUtils.clear(nexts);\r\nint l=ByteListUtils.size(currents);\r\nfor(int j=1;j<=l;j++){\r\nbyte p=currents[j];\r\nbyte[] arounds=MapUtils.getAroundPositions(p);\r\nint l1=arounds.length;\r\nfor(int i=0;i<l1;i++){\r\nbyte p2=arounds[i];\r\nif(isFree(dones,p2)){\r\nsetDone(dones,p2);\r\nByteListUtils.add(nexts,p2);\r\n}\r\n}\r\n}\r\ncurrents=nexts;\r\n}\r\nfor(int i=0;i<place.length;i++){\r\nplace[i]=way[BoardUtils.MAP_INDEX+i] ^ dones[i];\r\n}\r\nByteListUtils.clear(positions[n+1]);\r\n}\r\npublic static void calculateScore1(int[] way,int teamId,int limit){\r\nint start=BoardUtils.getTeamPosition(way,teamId);\r\nBoardUtils.copyMap(way,dones);\r\nsetDone(dones,start);\r\nbyte[] currents=positions[0];\r\nByteListUtils.clear(currents);\r\nByteListUtils.add(currents,(byte)start);\r\nint n=0;\r\nsetDone(place,start);\r\nint opponentPosition=BoardUtils.getTeamPosition(way,1-teamId);\r\nsetDone(dones,opponentPosition);\r\nwhile(!ByteListUtils.isEmpty(currents)&&n<limit){\r\nn++;\r\nbyte[] nexts=positions[n];\r\nByteListUtils.clear(nexts);\r\nint l=ByteListUtils.size(currents);\r\nfor(int j=1;j<=l;j++){\r\nbyte p=currents[j];\r\nbyte[] arounds=MapUtils.getAroundPositions(p);\r\nint l1=arounds.length;\r\nfor(int i=0;i<l1;i++){\r\nbyte p2=arounds[i];\r\nif(isFree(dones,p2)){\r\nsetDone(dones,p2);\r\nByteListUtils.add(nexts,p2);\r\n}\r\n}\r\n}\r\ncurrents=nexts;\r\ncounts[n]=ByteListUtils.size(currents);\r\n}\r\nByteListUtils.clear(positions[n+1]);\r\ncounts[n+1]=0;\r\n}\r\nstatic long[] initBoard=new long[2];\r\nstatic long[][] boards=new long[FrameworkConstant.CASE_NB][];\r\nstatic{\r\nfor(int i=0;i<boards.length;i++){\r\nboards[i]=new long[2];;\r\n}\r\n}\r\npublic static void calculateScore5(int[] board,int teamId,int limit){\r\nint p=BoardUtils.getTeamPosition(board,teamId);\r\nBoardBitUtils.toLongBoard(board,initBoard);\r\nBit128Utils.reset(initBoard,BoardUtils.getTeamPosition(board,1-teamId));\r\nlong[] a=BoardBitUtils.arounds[p];\r\nlong[] tmp=boards[1];\r\nBoardBitUtils.copy(a,tmp);\r\nBit128Utils.and(tmp,initBoard);\r\nBit128Utils.set(tmp,p);\r\ncounts[1]=BoardBitUtils.calculateLongBitCount(tmp);\r\nfor(int i=2;i<=limit ;i++){\r\ntmp=boards[i];\r\nBoardBitUtils.copy(BoardBitUtils.moveAround(boards[i-1]),tmp);\r\nBit128Utils.and(tmp,initBoard);\r\ncounts[i]=BoardBitUtils.calculateLongBitCount(tmp);\r\nif(counts[i]==counts[i-1]){\r\nbreak;\r\n}\r\n}\r\nfor(int i=limit;i>1;){\r\ncounts[i--]-=counts[i];\r\n}\r\ncounts[1]--;\r\ncounts[limit+1]=0;\r\n}\r\npublic static void setDone(int[] map,int position){\r\nmap[position/BoardUtils.BIT_NB] |= 1 <<(position%BoardUtils.BIT_NB);\r\n}\r\npublic static void setUndone(int[] map,int position){\r\nmap[position/BoardUtils.BIT_NB] &= ~(1 <<(position%BoardUtils.BIT_NB));\r\n}\r\npublic static boolean isFree(int[] map,int position){\r\nreturn(map[position/BoardUtils.BIT_NB]&(1 <<(position%BoardUtils.BIT_NB)))==0;\r\n}\r\npublic static void copy(int[] source,int[] destination){\r\nfor(int i=0;i<destination.length;i++){\r\ndestination[i]=source[i];\r\n}\r\n}\r\nstatic final int[][] mapScore=new int[2][];\r\nstatic final int[] mapClear=new int[FrameworkConstant.CASE_NB];\r\nstatic{\r\nfor(int i=0;i<mapScore.length;i++){\r\nmapScore[i]=new int[FrameworkConstant.CASE_NB];\r\n}\r\n}\r\npublic static final int[] counts=new int[FrameworkConstant.CASE_NB];\r\npublic static void calculateScore2(int[] way,int teamId,int limit){\r\nint start=BoardUtils.getTeamPosition(way,teamId);\r\nBoardUtils.copyMap(way,dones);\r\nbyte[] currents=positions[0];\r\nByteListUtils.clear(currents);\r\nByteListUtils.add(currents,(byte)start);\r\nint[] currentMap=mapScore[0];\r\nSystem.arraycopy(mapClear,0,currentMap,0,FrameworkConstant.CASE_NB);\r\ncurrentMap[start]=1;\r\nint n=0;\r\nint opponentPosition=BoardUtils.getTeamPosition(way,1-teamId);\r\nsetDone(dones,opponentPosition);\r\nwhile(!ByteListUtils.isEmpty(currents)&&n<limit){\r\nn++;\r\nbyte[] nexts=positions[n];\r\nByteListUtils.clear(nexts);\r\nBoardUtils.copyMap(dones,lastDones);\r\nint count=0;\r\nint l=ByteListUtils.size(currents);\r\nfor(int j=1;j<=l;j++){\r\nbyte p=currents[j];\r\nbyte[] arounds=MapUtils.getAroundPositions(p);\r\nint l1=arounds.length;\r\nint wayNb=currentMap[p];\r\nfor(int i=0;i<l1;i++){\r\nbyte p2=arounds[i];\r\nif(isFree(lastDones,p2)){\r\nif(isFree(dones,p2)){\r\nsetDone(dones,p2);\r\nByteListUtils.add(nexts,p2);\r\n}\r\ncurrentMap[p2]+=wayNb;\r\ncount+=wayNb;\r\n}\r\n}\r\n}\r\ncurrents=nexts;\r\ncounts[n]=count;\r\n}\r\ncounts[n+1]=0;\r\nByteListUtils.clear(positions[n+1]);\r\n}\r\npublic static void calculateScore3(int[] way,int teamId,int limit){\r\nint start=BoardUtils.getTeamPosition(way,teamId);\r\nBoardUtils.copyMap(way,dones);\r\nbyte[] currents=positions[0];\r\nByteListUtils.clear(currents);\r\nByteListUtils.add(currents,(byte)start);\r\nint n=0;\r\nint opponentPosition=BoardUtils.getTeamPosition(way,1-teamId);\r\nsetDone(dones,opponentPosition);\r\nwhile(!ByteListUtils.isEmpty(currents)&&n<limit){\r\nn++;\r\nbyte[] nexts=positions[n];\r\nByteListUtils.clear(nexts);\r\nBoardUtils.copyMap(dones,lastDones);\r\nint count=0;\r\nint l=ByteListUtils.size(currents);\r\nfor(int j=1;j<=l;j++){\r\nbyte p=currents[j];\r\nbyte[] arounds=MapUtils.getAroundPositions(p);\r\nint l1=arounds.length;\r\nfor(int i=0;i<l1;i++){\r\nbyte p2=arounds[i];\r\nif(isFree(lastDones,p2)){\r\nif(isFree(dones,p2)){\r\nsetDone(dones,p2);\r\nByteListUtils.add(nexts,p2);\r\n}\r\ncount++;\r\n}\r\n}\r\n}\r\ncurrents=nexts;\r\ncounts[n]=count;\r\n}\r\ncounts[n+1]=0;\r\nByteListUtils.clear(positions[n+1]);\r\n}\r\npublic static void calculateScore4(int[] way,int teamId,int limit){\r\ncalculateScore1(way,teamId,1);\r\n}\r\npublic static String toString(int[] place){\r\nif(place==null){\r\nreturn null;\r\n}\r\nStringBuilder sb=new StringBuilder(\"\\n\");\r\nfor(int p=0;p<FrameworkConstant.CASE_NB;p++){\r\nsb.append(place[p]);\r\nsb.append(' ');\r\nif((p+1)%FrameworkConstant.WIDTH==0){\r\nsb.append('\\n');\r\n}\r\n}\r\nreturn sb.toString();\r\n}\r\n}\r\n\r\nclass ScoreUtils{\r\nstatic Logger logger=Logger.getLogger(ScoreUtils.class);\r\npublic static final double MAX_SCORE=1e100;\r\npublic static double calculateScore(int[] board,int depth,int teamId){\r\ndouble ret=calculateScoreBest(board,depth,teamId);\r\nreturn ret;\r\n}\r\npublic static double calculateScore2(int[] board,int depth,int teamId){\r\ndouble score=0;\r\nint oppMoveNb=calculatePossibleMoveNb(board,1-teamId);\r\nint playerMoveNb=calculatePossibleMoveNb(board,teamId);\r\nif(playerMoveNb==0){\r\nscore=MAX_SCORE*(depth+1);\r\n}else{\r\nscore+=(oppMoveNb-playerMoveNb)*1e5;\r\nint playerPosition=BoardUtils.getTeamPosition(board,teamId);\r\nint oppPosition=BoardUtils.getTeamPosition(board,1-teamId);\r\nscore +=\r\nPointUtils.distance(FrameworkConstant.CENTER,playerPosition)\r\n-PointUtils.distance(FrameworkConstant.CENTER,oppPosition);\r\n}\r\nif(teamId==Constant.PLAYER_ID){\r\nscore*=-1;\r\n}\r\nreturn score;\r\n}\r\npublic static double calculateScoreBest(int[] board,int depth,int playingTeam){\r\ndouble score=0;\r\nint limit=Parameter.LIMIT_WAY;\r\nfor(int id=0;id<2;id++){\r\ndouble multpl=(id==Constant.PLAYER_ID?1:-1);\r\nswitch(Parameter.SCORE_EVALUATION){\r\ncase 3:\r\nPlaceUtils.calculateScore3(board,id,limit);\r\nbreak;\r\ncase 5:\r\nPlaceUtils.calculateScore5(board,id,limit);\r\nbreak;\r\ncase 6:\r\nPlaceUtils.calculateScore5(board,id,limit);\r\nbreak;\r\ncase 1:\r\nPlaceUtils.calculateScore1(board,id,limit);\r\nbreak;\r\ncase 2:\r\nPlaceUtils.calculateScore2(board,id,limit);\r\nbreak;\r\ncase 4:\r\nPlaceUtils.calculateScore4(board,id,limit);\r\nbreak;\r\ncase 7:\r\nPlaceUtils.calculateScore1(board,id,limit);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nfor(int i=1;i<=limit;i++){\r\nint nb=PlaceUtils.counts[i];\r\nif(Parameter.LOG){\r\n\r\n}\r\nif(nb==0){\r\nif(i==1){\r\nscore+=-multpl*MAX_SCORE*(depth+1);\r\nif(id==playingTeam){\r\nscore+=-multpl*MAX_SCORE*(depth+1);\r\n}\r\n}\r\nbreak;\r\n}\r\nscore+=multpl*nb*Pow.getPow(i-1);\r\n}\r\n}\r\nif(Parameter.LOG){\r\n\r\n\r\n}\r\nreturn score;\r\n}\r\npublic static int calculatePossibleMoveNb(int[] board,int teamId){\r\nint ret=0;\r\nint p=BoardUtils.getTeamPosition(board,teamId);\r\nbyte[] positions=MapUtils.getAroundPositions(p);\r\nint opponentPosition=BoardUtils.getTeamPosition(board,1-teamId);\r\nfor(int i=0;i<positions.length;i++){\r\nbyte p1=positions[i];\r\nif(BoardUtils.hasTile(board,p1)&&p1!=opponentPosition){\r\nret++;\r\n}\r\n}\r\nreturn ret;\r\n}\r\n}\r\n\r\nclass TilePruningUtils{\r\nstatic Logger logger=Logger.getLogger(TilePruningUtils.class);\r\npublic static final byte[] possibleRemoveTiles=new byte[100];\r\nstatic final int[] tmpMap=new int[BoardUtils.MAP_LENGTH];\r\npublic static byte[] calculatePossiblePruningTiles(int[] board,int teamId,boolean first){\r\nByteListUtils.clear(possibleRemoveTiles);\r\nboolean playerFirstIteration=first&&teamId==Constant.PLAYER_ID;\r\nint opponentPosition=BoardUtils.getTeamPosition(board,1-teamId);\r\nint[] opponentIslandPlace=IslandUtils.places[1-teamId];\r\nboolean spiral=first||!Parameter.LIMIT_ONLY_FIRST_DEPTH;\r\nbyte[] spiralPositions =\r\nspiral\r\n?MapUtils.getSpiralPositions(opponentPosition)\r\n:MapUtils.getAroundPositions(opponentPosition);\r\nint limit=playerFirstIteration?Parameter.TILE_LIMIT_NB:Parameter.TILE_LIMIT_NB2;\r\nif(IslandUtils.sameIsland&&!ByteListUtils.isEmpty(IslandUtils.possiblePruningTiles[2])){\r\nlimit--;\r\n}\r\nif(spiral){\r\nint[] tmp =\r\nplayerFirstIteration?prunedTileFirstIteration:opponentIslandPlace;\r\nfor(int i=0;i<BoardUtils.MAP_LENGTH;i++){\r\ntmpMap[i]=(~board[BoardUtils.MAP_INDEX+i])&tmp[i];\r\n}\r\nfor(int i=0;i<spiralPositions.length;i++){\r\nbyte p=spiralPositions[i];\r\nif(!PlaceUtils.isFree(tmpMap,p)){\r\nByteListUtils.add(possibleRemoveTiles,p);\r\nif(ByteListUtils.size(possibleRemoveTiles)==limit){\r\nbreak;\r\n}\r\n}\r\n}\r\n}else{\r\nfor(int i=0;i<spiralPositions.length;i++){\r\nbyte p=spiralPositions[i];\r\nif(BoardUtils.hasTile(board,p)){\r\nByteListUtils.add(possibleRemoveTiles,p);\r\n}\r\n}\r\n}\r\nif(ByteListUtils.size(possibleRemoveTiles)<=0||IslandUtils.sameIsland){\r\nbyte[] freeIslandTile=IslandUtils.possiblePruningTiles[2];\r\nboolean addExternalTile=false;\r\nint l=ByteListUtils.size(freeIslandTile);\r\nfor(int i=0;i<l;i++){\r\nbyte tmp=ByteListUtils.get(freeIslandTile,i);\r\nif(BoardUtils.hasTile(board,tmp)){\r\nByteListUtils.add(possibleRemoveTiles,tmp);\r\naddExternalTile=true;\r\nbreak;\r\n}\r\n}\r\nif(!addExternalTile&&!playerFirstIteration){\r\nbyte[] closestPositions=closestTiles[1-teamId];\r\nint l2=ByteListUtils.size(closestPositions);\r\nfor(int i=l2-1;i>=0;i--){\r\nbyte tmp=ByteListUtils.get(closestPositions,i);\r\nif(BoardUtils.hasTile(board,tmp)){\r\nByteListUtils.add(possibleRemoveTiles,tmp);\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\nif(ByteListUtils.size(possibleRemoveTiles)<=0){\r\nByteListUtils.add(possibleRemoveTiles,(byte)BoardUtils.getTeamPosition(board,teamId));\r\n}\r\nreturn possibleRemoveTiles;\r\n}\r\nstatic final int[] prunedTileFirstIteration=new int[BoardUtils.MAP_LENGTH];\r\nstatic final byte[][] closestTiles=new byte[2][];\r\nstatic{\r\nfor(int i=0;i<closestTiles.length;i++){\r\nclosestTiles[i]=new byte[FrameworkConstant.CASE_NB+1];\r\n}\r\n}\r\npublic static void initPrunedTileFirstIteration(int[] board){\r\nfor(int i=0;i<BoardUtils.MAP_LENGTH;i++){\r\nprunedTileFirstIteration[i]=0;\r\n}\r\nfor(int i=0;i<closestTiles.length;i++){\r\nByteListUtils.clear(closestTiles[i]);\r\n}\r\nPlaceUtils.calculatePlace(board,Constant.OPPONENT_ID,Integer.MAX_VALUE,false);\r\nfor(int i=1;;i++){\r\nbyte[] positions=PlaceUtils.positions[i];\r\nint l=ByteListUtils.size(positions);\r\nif(l==0){\r\nbreak;\r\n}\r\nfor(int j=0;j<l;j++){\r\nbyte p=ByteListUtils.get(positions,j);\r\nif(i<=Parameter.TILE_MAX_DISTANCE){\r\nPlaceUtils.setDone(prunedTileFirstIteration,p);\r\n}\r\nByteListUtils.add(closestTiles[Constant.OPPONENT_ID],p);\r\n}\r\n}\r\nPlaceUtils.calculatePlace(board,Constant.PLAYER_ID,Integer.MAX_VALUE,false);\r\nfor(int i=1;;i++){\r\nbyte[] positions=PlaceUtils.positions[i];\r\nint l=ByteListUtils.size(positions);\r\nif(l==0){\r\nbreak;\r\n}\r\nfor(int j=0;j<l;j++){\r\nbyte p=ByteListUtils.get(positions,j);\r\nByteListUtils.add(closestTiles[Constant.PLAYER_ID],p);\r\n}\r\n}\r\n}\r\n}\r\n\r\nclass FirstRoundUtils{\r\npublic static void proceed(){\r\nif(Constant.isFirstRound()){\r\nMapUtils.initCache();\r\nGarbageCollectorUtils.avoidTimeOut();\r\n}\r\n}\r\n}\r\n\r\nclass MinMaxAlphaBetaCalculateSearcher{\r\nstatic final Logger logger=Logger.getLogger(MinMaxAlphaBetaCalculateSearcher.class);\r\nstatic MinMaxAlphaBetaCalculateSearcher instance=new MinMaxAlphaBetaCalculateSearcher();\r\npublic boolean log=Parameter.LOG;\r\nboolean timeOut=false;\r\nboolean increaseFirstOpponentMoveNb;\r\nMinMaxAlphaBetaCalculateSearcher(){}\r\npublic static MinMaxAlphaBetaCalculateSearcher getInstance(){\r\nreturn instance;\r\n}\r\ndouble minTurn(int[] state,int depth,double alpha,double beta,boolean first)\r\nthrows TimeOutException{\r\nif(stop(state,depth)){\r\nif(timeOut){\r\nTimeOutUtils.stopTimeException();\r\n}\r\nreturn ScoreUtils.calculateScore(state,depth,Constant.OPPONENT_ID);\r\n}\r\nBoardUtils.initChild(state,Constant.OPPONENT_ID,first);\r\nint childNb=BoardUtils.getChildNb(state);\r\nif(childNb==0){\r\nreturn ScoreUtils.MAX_SCORE*(depth+1);\r\n}\r\nint childStartIndex=BoardUtils.getChildStartIndex(state);\r\nfor(int i=childStartIndex;i<childStartIndex+childNb;i++){\r\nint[] childState=BoardCache.getWay(i);\r\ndouble val=maxTurn(childState,depth-1,alpha,beta);\r\nif(val<beta){\r\nbeta=val;\r\n}\r\nif(alpha>=beta){\r\nbreak;\r\n}\r\n}\r\nreturn beta;\r\n}\r\ndouble maxTurn(int[] state,int depth,double alpha,double beta)\r\nthrows TimeOutException{\r\nif(stop(state,depth)){\r\nif(timeOut){\r\nTimeOutUtils.stopTimeException();\r\n}\r\nreturn ScoreUtils.calculateScore(state,depth,Constant.PLAYER_ID);\r\n}\r\nBoardUtils.initChild(state,Constant.PLAYER_ID,false);\r\nint childNb=BoardUtils.getChildNb(state);\r\nif(childNb==0){\r\nreturn -ScoreUtils.MAX_SCORE*(depth+1);\r\n}\r\nint childStartIndex=BoardUtils.getChildStartIndex(state);\r\nfor(int i=childStartIndex;i<childStartIndex+childNb;i++){\r\nint[] childState=BoardCache.getWay(i);\r\ndouble val=minTurn(childState,depth-1,alpha,beta,false);\r\nif(alpha<val){\r\nalpha=val;\r\n}\r\nif(alpha>=beta){\r\nbreak;\r\n}\r\n}\r\nreturn alpha;\r\n}\r\nboolean stop(int[] currentMapAll,int depth){\r\nreturn depth<=0;\r\n}\r\nvoid increaseFirstOpponentMoveNb(){\r\nif(Constant.ROUND==Parameter.INCREASE_FIRST_OPPONENT_MOVE_NB_ROUND){\r\nincreaseFirstOpponentMoveNb=true;\r\n}\r\n}\r\npublic int minimax(int depth,int[] gameState){\r\nTilePruningUtils.initPrunedTileFirstIteration(gameState);\r\nincreaseFirstOpponentMoveNb();\r\nBoardCache.reset();\r\nIslandUtils.calculateIsland(gameState);\r\nint ret=-1;\r\ntry{\r\ntimeOut=false;\r\nret=minimaxNoTimeOut(depth,gameState);\r\n}catch(TimeOutException e){\r\nthrow new IllegalStateException();\r\n}catch(NoMoreBoardException e){\r\nthrow new IllegalStateException();\r\n}\r\ntimeOut=Parameter.MIN_MAX_TIME_OUT;\r\nif(!timeOut){\r\nreturn ret;\r\n}\r\ntry{\r\nint lastCacheIndex=BoardCache.getIndex();\r\nwhile(timeOut){\r\ndepth++;\r\nret=minimaxTimeOut(depth,gameState);\r\nif(lastCacheIndex==BoardCache.getIndex()){\r\n\r\nbreak;\r\n}\r\nlastCacheIndex=BoardCache.getIndex();\r\n}\r\n}catch(TimeOutException e){\r\n\r\n}catch(NoMoreBoardException e){\r\n\r\n}\r\nBoardCache.printIndex();\r\nreturn ret;\r\n}\r\npublic int minimaxNoTimeOut(int depth,int[] state)throws TimeOutException{\r\nDouble bestScoreTmp=null;\r\nInteger bestSuccessorTmp=null;\r\nBoardUtils.reset(state);\r\nBoardUtils.initChild(state,Constant.PLAYER_ID,true);\r\nint childNb=BoardUtils.getChildNb(state);\r\n\r\nint childStartIndex=BoardUtils.getChildStartIndex(state);\r\nfor(int i=childStartIndex;i<childStartIndex+childNb;i++){\r\nint[] childState=BoardCache.getWay(i);\r\nif(log){\r\n\r\n}\r\ndouble val =\r\nminTurn(\r\nchildState,\r\ndepth,\r\nDouble.NEGATIVE_INFINITY,\r\nDouble.POSITIVE_INFINITY,\r\nincreaseFirstOpponentMoveNb);\r\nif(log){\r\n\r\n}\r\nif(bestScoreTmp==null||val>bestScoreTmp){\r\nif(log){\r\n\r\n}\r\nbestSuccessorTmp=i;\r\nbestScoreTmp=val;\r\n}\r\n}\r\nlogWin(bestScoreTmp);\r\nreturn bestSuccessorTmp;\r\n}\r\npublic int minimaxTimeOut(int depth,int[] state)throws TimeOutException{\r\nDouble bestScoreTmp=null;\r\nInteger bestSuccessorTmp=null;\r\nint childNb=BoardUtils.getChildNb(state);\r\n\r\nint childStartIndex=BoardUtils.getChildStartIndex(state);\r\nfor(int i=childStartIndex;i<childStartIndex+childNb;i++){\r\nint[] childState=BoardCache.getWay(i);\r\ndouble val =\r\nminTurn(\r\nchildState,\r\ndepth,\r\nDouble.NEGATIVE_INFINITY,\r\nDouble.POSITIVE_INFINITY,\r\nincreaseFirstOpponentMoveNb);\r\nif(bestScoreTmp==null||val>bestScoreTmp){\r\nbestSuccessorTmp=i;\r\nbestScoreTmp=val;\r\n}\r\n}\r\nlogWin(bestScoreTmp);\r\nreturn bestSuccessorTmp;\r\n}\r\nstatic boolean win;\r\nvoid logWin(Double bestScoreTmp){\r\nif(bestScoreTmp>=ScoreUtils.MAX_SCORE){\r\n\r\nwin=true;\r\n}else if(bestScoreTmp<=-ScoreUtils.MAX_SCORE){\r\n\r\n}\r\n}\r\n}\r\n\r\nclass NextMoveUtils{\r\nstatic Logger logger=Logger.getLogger(NextMoveUtils.class);\r\npublic static String proceed(){\r\nFirstRoundUtils.proceed();\r\nint[] board=Game.getInstance().getBoard();\r\n\r\nincreaseDepth();\r\nint index=MinMaxAlphaBetaCalculateSearcher.getInstance().minimax(Parameter.DEPTH,board);\r\nint[] bestWay=BoardCache.getWay(index);\r\nint bestMove=BoardUtils.getTeamPosition(bestWay,Constant.PLAYER_ID);\r\nint bestTile=BoardUtils.getLastTile(bestWay);\r\nBoardUtils.move(board,bestMove,bestTile,Constant.PLAYER_ID);\r\nTimeOutUtils.time=Parameter.TIME_OUT;\r\nreturn PointUtils.toXYString(bestMove)+\" \"+PointUtils.toXYString(bestTile);\r\n}\r\nstatic void increaseDepth(){\r\nif(Constant.ROUND==Parameter.INCREASE_DEPTH_ROUND){\r\nParameter.DEPTH++;\r\n}\r\n}\r\n}\r\n\r\nclass Constant{\r\npublic static int PLAYER_ID;\r\npublic static int OPPONENT_ID;\r\npublic static int ROUND;\r\npublic static boolean isFirstRound(){\r\nreturn ROUND==1;\r\n}\r\n}\r\n\r\nclass Parameter{\r\npublic static final int AVOID_TIME_OUT_NB=0;\r\npublic static int FIRST_ROUND_TIME_OUT=950;\r\npublic static int TIME_OUT=95;\r\npublic static final boolean REMOVE_LOG=true;\r\npublic static final boolean REMOVE_ASSERT=true;\r\npublic static int BOARD_CACHE_NB=800_000;\r\npublic static boolean LOG=false;\r\npublic static final int BOSS_NB=1;\r\npublic static boolean MIN_MAX_TIME_OUT=BOSS_NB==3;\r\npublic static final int TILE_LIMIT_NB2=9;\r\npublic static final boolean LIMIT_ONLY_FIRST_DEPTH=true;\r\npublic static final int INCREASE_DEPTH_ROUND=BOSS_NB==3?10:-1;\r\npublic static final int INCREASE_FIRST_OPPONENT_MOVE_NB_ROUND=15;\r\npublic static int TILE_LIMIT_NB=20;\r\npublic static int LIMIT_WAY=3;\r\npublic static final int TILE_MAX_DISTANCE=3;\r\npublic static int SCORE_EVALUATION=BOSS_NB==1?7:3;\r\npublic static int DEPTH=BOSS_NB==3?1:0;\r\npublic static double[] BEST_POWS ={0,0.75,1,1.15,1,0.75,0.75,0};\r\npublic static double POW=BEST_POWS[SCORE_EVALUATION];\r\n}\r\n\r\nclass Pow{\r\nstatic final double[] POWS0_9=new double[50];\r\nstatic{\r\nfor(int i=0;i<POWS0_9.length;i++){\r\nPOWS0_9[i]=Math.pow(Parameter.POW,i);\r\n}\r\n}\r\npublic static  void init(){\r\nfor(int i=0;i<POWS0_9.length;i++){\r\nPOWS0_9[i]=Math.pow(Parameter.POW,i);\r\n}\r\n}\r\npublic static double getPow(int i){\r\nreturn POWS0_9[i];\r\n}\r\n}\r\n\r\nclass AllUtils{\r\nstatic Logger logger=Logger.getLogger(AllUtils.class);\r\npublic static void copy(int[] source,int[] destination){\r\nSystem.arraycopy(source,0,destination,0,source.length);\r\n}\r\npublic static String toString(Object... p){\r\nStringBuilder str=new StringBuilder();\r\nint i=0;\r\nfor(Object o:p){\r\nstr.append(o==null?\"null\":o.toString());\r\nif(++i<p.length){\r\nstr.append(\" \");\r\n}\r\n}\r\nreturn str.toString();\r\n}\r\n}\r\n\r\nclass AssertUtils{\r\nstatic Logger logger=Logger.getLogger(AssertUtils.class);\r\npublic static void test(boolean b,Object... o){\r\nif(!b){\r\nString str=AllUtils.toString(o);\r\n\r\nthrow new IllegalStateException(str);\r\n}\r\n}\r\n}\r\n\r\nclass ByteUtils{\r\npublic static byte[] copy(byte[] s){\r\nbyte[] d=new byte[s.length];\r\nSystem.arraycopy(s,0,d,0,s.length);\r\nreturn d;\r\n}\r\npublic static byte[] copy(byte[] array,int length){\r\nbyte[] newArray=new byte[length];\r\nSystem.arraycopy(array,0,newArray,0,length);\r\nreturn newArray;\r\n}\r\npublic static void copy(byte[] s,byte[] d){\r\nSystem.arraycopy(s,0,d,0,s.length);\r\n}\r\npublic static void copy(byte[] s,byte[] d,int start){\r\nSystem.arraycopy(s,0,d,start,s.length);\r\n}\r\n}\r\n\r\nenum Direction{\r\nUP(0,-1,4),\r\nDOWN(0,1,1),\r\nLEFT(-1,0,2),\r\nRIGHT(1,0,3),\r\nUL(-1,-1,5),\r\nUR(1,-1,6),\r\nDL(-1,1,7),\r\nDR(1,1,8);\r\nbyte num;\r\nint x;\r\nint y;\r\nstatic Direction[] numToDirection;\r\nstatic boolean initialized;\r\npublic static void init(){\r\nif(initialized){\r\nreturn;\r\n}\r\ninitialized=true;\r\nnumToDirection=new Direction[Direction.values().length+1];\r\nDirection[] values=Direction.values();\r\nfor(int i=0;i<values.length;i++){\r\nDirection value=values[i];\r\nnumToDirection[value.getNum()]=value;\r\n}\r\n}\r\nDirection(int x,int y,int num){\r\nthis.x=x;\r\nthis.y=y;\r\nthis.num=(byte)num;\r\n}\r\npublic byte getNum(){\r\nreturn num;\r\n}\r\npublic int getX(){\r\nreturn x;\r\n}\r\npublic int getY(){\r\nreturn y;\r\n}\r\npublic Direction getOpposite(){\r\nswitch(this){\r\ncase LEFT:\r\nreturn Direction.RIGHT;\r\ncase RIGHT:\r\nreturn Direction.LEFT;\r\ncase UP:\r\nreturn Direction.DOWN;\r\ncase DOWN:\r\nreturn Direction.UP;\r\ncase UL:\r\nreturn Direction.DR;\r\ncase UR:\r\nreturn Direction.DL;\r\ncase DR:\r\nreturn Direction.UL;\r\ncase DL:\r\nreturn Direction.UR;\r\ndefault:\r\nthrow new IllegalStateException();\r\n}\r\n}\r\npublic static Direction fromNum(byte num){\r\nreturn numToDirection[num];\r\n}\r\npublic boolean is(byte num){\r\nreturn num==this.num;\r\n}\r\n}\r\n\r\nclass DirectionUtils{\r\npublic static int construct(int index,Direction dir){\r\nint x=PointUtils.getX(index)+dir.getX();\r\nint y=PointUtils.getY(index)+dir.getY();\r\nif(PointUtils.isIn(x,y)){\r\nreturn PointUtils.getPosition(x,y);\r\n}\r\nreturn FrameworkConstant.OUT;\r\n}\r\n}\r\n\r\nclass FrameworkConstant{\r\npublic static int HEIGHT=9;\r\npublic static int WIDTH=9;\r\npublic static int CASE_NB=HEIGHT*WIDTH;\r\npublic static byte[] MAP;\r\npublic static final int CENTER=PointUtils.getPosition(WIDTH/2,HEIGHT/2);\r\npublic static final byte OUT=-1;\r\n}\r\n\r\nclass GarbageCollectorUtils{\r\nstatic Logger logger=Logger.getLogger(GarbageCollectorUtils.class);\r\nstatic int lastRoundGC=0;\r\nstatic final int BETWEEN_GC_ROUND_NB=20;\r\nstatic final int AVOID_TIME_OUT_NB=2000000;\r\nstatic long start;\r\npublic static void garbageCollect(int round){\r\ngarbageCollect(round,true);\r\n}\r\npublic static void avoidTimeOut(){\r\nStringBuilder[] FOR_ALLOC=new StringBuilder[AVOID_TIME_OUT_NB];\r\nfor(int i=0;i<AVOID_TIME_OUT_NB;i++){\r\nFOR_ALLOC[i]=new StringBuilder();\r\n}\r\nFOR_ALLOC=null;\r\ngarbageCollect(0);\r\n}\r\npublic static void garbageCollect(int round,boolean force){\r\nif(force||round-lastRoundGC>20){\r\nSystem.err.println(\r\n(Timer.getInstance().getTime())\r\n+\"GARBAGE COLECTOR START \"\r\n+Runtime.getRuntime().freeMemory());\r\nSystem.gc();\r\nSystem.err.println(\r\n(Timer.getInstance().getTime())\r\n+\"GARBAGE COLECTOR END \"\r\n+Runtime.getRuntime().freeMemory());\r\nlastRoundGC=round;\r\n}\r\n}\r\npublic static void initFreeMemory(){\r\nstart=Runtime.getRuntime().freeMemory();\r\n}\r\npublic static void printUsedMemory(){\r\n\r\n}\r\n}\r\n\r\nclass ByteListUtils{\r\npublic static void add(byte[] array,byte p){\r\narray[size(array)+1]=p;\r\narray[0]++;\r\n}\r\npublic static void remove(byte[] array,byte p){\r\nboolean remove=false;\r\nfor(byte i=0;i<size(array);i++){\r\nbyte value=get(array,i);\r\nif(remove){\r\nset(array,(byte)(i-1),value);\r\n}else if(value==p){\r\nremove=true;\r\n}\r\n}\r\nif(remove){\r\narray[0]--;\r\n}\r\n}\r\npublic static void removeByIndex(byte[] array,int index){\r\nboolean remove=false;\r\nfor(byte i=0;i<size(array);i++){\r\nif(remove){\r\nbyte value=get(array,i);\r\nset(array,(byte)(i-1),value);\r\n}else if(i==index){\r\nremove=true;\r\n}\r\n}\r\nif(remove){\r\narray[0]--;\r\n}\r\n}\r\npublic static void clear(byte[] array){\r\narray[0]=0;\r\n}\r\npublic static byte size(byte[] array){\r\nreturn array[0];\r\n}\r\npublic static boolean isEmpty(byte[] array){\r\nreturn size(array)==0;\r\n}\r\npublic static byte get(byte[] array,int i){\r\nreturn array[i+1];\r\n}\r\npublic static void set(byte[] array,byte i,byte newValue){\r\narray[i+1]=newValue;\r\n}\r\npublic static boolean contains(byte[] array,byte i){\r\nfor(byte j=0;j<size(array);j++){\r\nif(get(array,j)==i){\r\nreturn true;\r\n}\r\n}\r\nreturn false;\r\n}\r\npublic static byte[] cut(byte[] array){\r\nbyte[] tmp=new byte[size(array)];\r\nSystem.arraycopy(array,1,tmp,0,tmp.length);\r\nreturn tmp;\r\n}\r\npublic static void copy(byte[] source,byte[] destination){\r\nSystem.arraycopy(source,0,destination,0,size(source)+1);\r\n}\r\npublic static byte getLast(byte[] array){\r\nbyte size=size(array);\r\n\r\nreturn get(array,(byte)(size-1));\r\n}\r\npublic static String toString(byte[] array){\r\nreturn Arrays.toString(cut(array));\r\n}\r\n}\r\n\r\nclass Logger{\r\nenum Level{\r\nDEBUG,\r\nERROR,\r\nNONE;\r\n}\r\nstatic String[] tmp ={\r\n};\r\nstatic Map<String,String> map=new HashMap<>();\r\n{\r\nfor(int i=0;i<tmp.length;i+=2){\r\nmap.put(tmp[i],tmp[i+1]);\r\n}\r\n}\r\npublic static Level level=Level.ERROR;\r\nLevel levelSpecific;\r\nClass<?> clazz;\r\nLogger(Class<?> clazz){\r\nthis.clazz=clazz;\r\n}\r\npublic static Logger getLogger(Class<?> clazz){\r\nreturn new Logger(clazz);\r\n}\r\npublic static Logger getLogger(Class<?> clazz,Level levelSpecific){\r\nLogger ret=new Logger(clazz);\r\nret.levelSpecific=levelSpecific;\r\nreturn ret;\r\n}\r\npublic void error(Object... s){\r\nprint(s);\r\n}\r\npublic void debug(Object... s){\r\nif(getLevel()==Level.DEBUG){\r\nprint(s);\r\n}\r\n}\r\nstatic StringBuilder sb=new StringBuilder(5000);\r\npublic void print(Object... s){\r\nif(getLevel()==Level.NONE){\r\nreturn;\r\n}\r\nsb.delete(0,sb.length());\r\nsb.append(Timer.getInstance().getTime());\r\nsb.append(\" \");\r\nsb.append(clazz.getSimpleName());\r\nsb.append(\":\");\r\nint i=0;\r\nfor(Object o:s){\r\nsb.append(o==null?\"null\":o.toString());\r\nif(++i<s.length){\r\nsb.append(\" \");\r\n}\r\n}\r\nSystem.err.println(sb);\r\n}\r\nLevel getLevel(){\r\nif(levelSpecific==null||level==Level.NONE){\r\nreturn level;\r\n}\r\nreturn levelSpecific;\r\n}\r\n}\r\n\r\nclass Timer{\r\nstatic Timer instance=new Timer();\r\nlong timeStart;\r\nTimer(){}\r\npublic static Timer getInstance(){\r\nreturn instance;\r\n}\r\npublic void init(){\r\ntimeStart=System.currentTimeMillis();\r\n}\r\npublic long getTime(){\r\nreturn System.currentTimeMillis()-timeStart;\r\n}\r\n}\r\n\r\nclass MapUtils{\r\nstatic Logger logger=Logger.getLogger(MapUtils.class);\r\nstatic final byte[][] CACHE_AROUND_POSITIONS=new byte[FrameworkConstant.CASE_NB][];\r\nstatic final byte[][] CACHE_SPIRAL_POSITIONS=new byte[FrameworkConstant.CASE_NB][];\r\npublic static byte[] getAroundPositions(int p){\r\nreturn CACHE_AROUND_POSITIONS[p];\r\n}\r\npublic static byte[] getSpiralPositions(int p){\r\nreturn CACHE_SPIRAL_POSITIONS[p];\r\n}\r\npublic static void initCache(){\r\nDirection.init();\r\nfor(byte i=0;i<FrameworkConstant.CASE_NB;i++){\r\ncalculateAroundPositions(i);\r\ncalculateSpiralPositions(i);\r\n}\r\n}\r\nstatic void calculateAroundPositions(int p){\r\nDirection[] dirs=Direction.values();\r\nbyte[] ret=new byte[dirs.length];\r\nint index=0;\r\nfor(int i=0;i<dirs.length;i++){\r\nDirection direction=dirs[i];\r\nint p2=DirectionUtils.construct(p,direction);\r\nif(p2!=FrameworkConstant.OUT){\r\nret[index++]=(byte)p2;\r\n}\r\n}\r\nCACHE_AROUND_POSITIONS[p]=ByteUtils.copy(ret,index);\r\n}\r\nstatic void calculateSpiralPositions(int p){\r\nbyte[] ret=new byte[FrameworkConstant.CASE_NB-1];\r\nint index=0;\r\nfor(int i=0;i<FrameworkConstant.CASE_NB;i++){\r\nif(i!=p&&PointUtils.distance(i,p)<=Parameter.TILE_MAX_DISTANCE){\r\nret[index++]=(byte)i;\r\n}\r\n}\r\nbyte[] cut=new byte[index];\r\nSystem.arraycopy(ret,0,cut,0,index);\r\nbubbleSort(cut,p);\r\nCACHE_SPIRAL_POSITIONS[p]=cut;\r\n}\r\npublic static void main(String[] args){\r\ninitCache();\r\n}\r\nstatic void bubbleSort(byte arr[],int p){\r\nint n=arr.length;\r\nfor(int i=0;i<n-1;i++)\r\nfor(int j=0;j<n-i-1;j++)\r\nif(value(arr[j],p)>value(arr[j+1],p)){\r\nbyte temp=arr[j];\r\narr[j]=arr[j+1];\r\narr[j+1]=temp;\r\n}\r\n}\r\nstatic int value(byte pos,int p){\r\nreturn PointUtils.distance2(pos,FrameworkConstant.CENTER)\r\n+100\r\n*(PointUtils.distance(pos,FrameworkConstant.CENTER)\r\n+100*PointUtils.distance(pos,p));\r\n}\r\n}\r\n\r\nclass Point{\r\nint x;\r\nint y;\r\npublic Point(){}\r\npublic Point(int x,int y){\r\nthis.x=x;\r\nthis.y=y;\r\n}\r\npublic int getX(){\r\nreturn x;\r\n}\r\npublic void setX(int x){\r\nthis.x=x;\r\n}\r\npublic int getY(){\r\nreturn y;\r\n}\r\npublic void setY(int y){\r\nthis.y=y;\r\n}\r\npublic void copy(Point p){\r\nx=p.x;\r\ny=p.y;\r\n}\r\nboolean isIn(){\r\nreturn x>=0&&x<FrameworkConstant.WIDTH&&y>=0&&y<FrameworkConstant.HEIGHT;\r\n}\r\n@Override public int hashCode(){\r\nfinal int prime=31;\r\nint result=1;\r\nresult=prime*result+x;\r\nresult=prime*result+y;\r\nreturn result;\r\n}\r\n@Override public boolean equals(Object obj){\r\nif(this==obj)return true;\r\nif(obj==null)return false;\r\nif(getClass()!=obj.getClass())return false;\r\nPoint other=(Point)obj;\r\nif(x!=other.x)return false;\r\nif(y!=other.y)return false;\r\nreturn true;\r\n}\r\n@Override public String toString(){\r\nreturn \"(\"+x+\",\"+y+\")\";\r\n}\r\npublic String toInputString(){\r\nreturn x+\" \"+y;\r\n}\r\n}\r\n\r\nclass PointUtils{\r\nstatic final Point[] CACHE_POINT=new Point[FrameworkConstant.CASE_NB];\r\npublic static Point toPoint(int p){\r\nint index=p;\r\nPoint ret=CACHE_POINT[index];\r\nif(ret==null){\r\nret=new Point(getX(p),getY(p));\r\nCACHE_POINT[index]=ret;\r\n}\r\nreturn ret;\r\n}\r\npublic static List<Point> toPoint(byte[] way){\r\nreturn IntStream.range(0,way.length)\r\n.mapToObj(i->way[i])\r\n.map(i->toPoint(i))\r\n.collect(Collectors.toList());\r\n}\r\npublic static List<Point> toPoint(Collection<Byte> way){\r\nreturn way.stream().map(i->toPoint(i)).collect(Collectors.toList());\r\n}\r\npublic static int getPosition(Scanner in){\r\nint x=in.nextInt();\r\nint y=in.nextInt();\r\nif(x==-1){\r\nreturn FrameworkConstant.OUT;\r\n}\r\nreturn getPosition(x,y);\r\n}\r\npublic static int getPosition(int x,int y){\r\nreturn x+FrameworkConstant.WIDTH*y;\r\n}\r\npublic static int distance(int p1,int p2){\r\nreturn Math.max(getDeltaX(p1,p2),getDeltaY(p1,p2));\r\n}\r\npublic static int distance2(int p1,int p2){\r\nreturn getDeltaX(p1,p2)+getDeltaY(p1,p2);\r\n}\r\nstatic int getDeltaX(int p1,int p2){\r\nreturn Math.abs(getX(p1)-getX(p2));\r\n}\r\nstatic int getDeltaY(int p1,int p2){\r\nreturn Math.abs(getY(p1)-getY(p2));\r\n}\r\npublic static boolean isNextTo(int p1,int p2){\r\nreturn distance(p1,p2)<=1;\r\n}\r\npublic static int getX(int p){\r\nreturn p%FrameworkConstant.WIDTH;\r\n}\r\npublic static int getY(int p){\r\nreturn p/FrameworkConstant.WIDTH;\r\n}\r\npublic static String toXYString(int p){\r\nreturn getX(p)+\" \"+getY(p);\r\n}\r\npublic static boolean isIn(int x,int y){\r\nreturn x>=0&&x<FrameworkConstant.WIDTH&&y>=0&&y<FrameworkConstant.HEIGHT;\r\n}\r\n}\r\n\r\nclass TimeOutException extends Exception{}\r\n\r\nclass TimeOutUtils{\r\npublic static int time=Parameter.FIRST_ROUND_TIME_OUT;\r\nstatic Timer timer=Timer.getInstance();\r\npublic static final TimeOutException EXCEPTION=new TimeOutException();\r\npublic static int count;\r\npublic static void init(){\r\ntime=Parameter.TIME_OUT;\r\n}\r\npublic static void stopTimeException()throws TimeOutException{\r\nif(isStopTime()){\r\nthrow EXCEPTION;\r\n}\r\n}\r\npublic static boolean isStopTime(){\r\nreturn timer.getTime()>=time;\r\n}\r\n}\r\n\r\n",
          "testCases": [],
          "maxPlayers": 2,
          "minPlayers": 2,
          "statements": {
            "1": "<div\n\tstyle=\"color: #000000; background-color: rgba(255, 255, 255, 0.5); padding: 20px; margin-bottom: 10px; text-align: left\">\n\tThis is a port of the board game <a\n\t\thref=\"https://fr.wikipedia.org/wiki/Isola_(jeu)\">Isola</a> :\n\t<br /> <br />\n\t<p style=\"text-align: center;\">\n\t\t<img\n\t\t\tsrc=\"https://github.com/wala-fr/CodingameIsolation/blob/master/CodingameIsolation/src/main/resources/view/statement/isola_statement.png?raw=true\"\n\t\t\tstyle=\"height: 200px; width: auto;\"></img>\n\t</p>\n\t<p>\n\t\tThe source code of this game is available <a rel=\"nofollow\"\n\t\t\ttarget=\"_blank\" href=\"https://github.com/wala-fr/CodingameIsola\">on\n\t\t\tthis GitHub repo</a>. <br />\n</div>\n\n<div id=\"statement_back\" class=\"statement_back\" style=\"display: none\"></div>\n<div class=\"statement-body\">\n\t<!-- GOAL -->\n\t<div class=\"statement-section statement-goal\">\n\t\t<h1>\n\t\t\t<span class=\"icon icon-goal\">&nbsp;</span> <span>The Goal</span>\n\t\t</h1>\n\t\t<div class=\"statement-goal-content\">The goal of the game is to\n\t\t\tblock the opponent's pawn.</div>\n\t</div>\n\t<!-- RULES -->\n\t<div class=\"statement-section statement-rules\">\n\t\t<h1>\n\t\t\t<span class=\"icon icon-rules\">&nbsp;</span> <span>Rules</span>\n\t\t</h1>\n\t\t<div class=\"statement-rules-content\">\n\t\t\t<strong>Board: </strong>\n\t\t\t<ul>\n\t\t\t\t<li>The game is played on a <const>9 x 9</const> board.\n\t\t\t\t</li>\n\t\t\t\t<li>Player 0 always starts at <const>(0, 4)</const> and player\n\t\t\t\t\t1 at <const>(8, 4)</const>.\n\t\t\t\t</li>\n\t\t\t</ul>\n\t\t\t<strong>At each turn: </strong><br>\n\t\t\t<ol>\n\t\t\t\t<li>You must <b>move your pawn</b> to an adjacent tile\n\t\t\t\t\t(diagonal included) :<br> <br>\n\n\t\t\t\t\t<p style=\"text-align: center;\">\n\t\t\t\t\t\t<img\n\t\t\t\t\t\t\tsrc=\"https://github.com/wala-fr/CodingameIsolation/blob/master/CodingameIsolation/src/main/resources/view/statement/moves.png?raw=true\"\n\t\t\t\t\t\t\tstyle=\"height: 200px; width: auto;\"></img>\n\t\t\t\t\t</p>You can't :\n\t\t\t\t\t<ul>\n\t\t\t\t\t\t<li>stay put</li>\n\t\t\t\t\t\t<li>move to the tile occupied by the opponent's pawn</li>\n\t\t\t\t\t\t<li>move to an already removed tile.</li>\n\t\t\t\t\t</ul>\n\n\t\t\t\t</li>\n\t\t\t\t<li><b>Then</b> you must <b>remove a free tile</b>.<br />You\n\t\t\t\t\tcan't remove a tile occupied by a pawn.</li>\n\t\t\t</ol>\n\t\t</div>\n\t</div>\n\n\t<!-- Victory conditions -->\n\t<div class=\"statement-victory-conditions\">\n\t\t<div class=\"icon victory\"></div>\n\t\t<div class=\"blk\">\n\t\t\t<div class=\"title\">Victory Conditions</div>\n\t\t\t<div class=\"text\">\n\t\t\t\t<ul style=\"padding-bottom: 0;\">\n\t\t\t\t\t<li>At his turn, the opponent can't move his pawn.</li>\n\t\t\t\t</ul>\n\t\t\t</div>\n\t\t</div>\n\t</div>\n\n\t<!-- Lose conditions -->\n\t<div class=\"statement-lose-conditions\">\n\t\t<div class=\"icon lose\"></div>\n\t\t<div class=\"blk\">\n\t\t\t<div class=\"title\">Loss Conditions</div>\n\t\t\t<div class=\"text\">\n\t\t\t\t<ul style=\"padding-bottom: 0;\">\n\t\t\t\t\t<li>At your turn, you can't move your pawn.</li>\n\t\t\t\t\t<li>You do not respond in time or output an invalid action.</li>\n\t\t\t\t</ul>\n\t\t\t</div>\n\t\t</div>\n\t</div>\n\n\t<!-- PROTOCOL -->\n\t<div class=\"statement-section statement-protocol\">\n\t\t<h1>\n\t\t\t<span class=\"icon icon-protocol\">&nbsp;</span> <span>Game\n\t\t\t\tInput</span>\n\t\t</h1>\n\n\t\t<!-- Protocol block -->\n\t\t<div class=\"blk\">\n\t\t\t<div class=\"title\">Initialization input</div>\n\t\t\t<div class=\"text\">\n\t\t\t\t<span class=\"statement-lineno\">Line 1</span>:\n\t\t\t\t<var>playerPositionX</var>\n\t\t\t\t<br> <span class=\"statement-lineno\">Line 2</span>:\n\t\t\t\t<var>playerPositionY</var>\n\t\t\t\tthe coordinates of your pawn.\n\t\t\t</div>\n\t\t\t<br>\n\t\t\t<div class=\"title\">Input for one game turn</div>\n\t\t\t<div class=\"text\">\n\t\t\t\t<span class=\"statement-lineno\">Line 1</span>:\n\t\t\t\t<var>opponentPositionX</var>\n\t\t\t\t<br> <span class=\"statement-lineno\">Line 2</span>:\n\t\t\t\t<var>opponentPositionY</var>\n\t\t\t\tthe coordinates of the opponent's pawn. <br> <span\n\t\t\t\t\tclass=\"statement-lineno\">Line 3</span>:\n\t\t\t\t<var>opponentLastRemovedTileX</var>\n\t\t\t\t<br> <span class=\"statement-lineno\">Line 4</span>:\n\t\t\t\t<var>opponentLastRemovedTileY</var>\n\t\t\t\tthe coordinates of the last tile removed by the opponent (\n\t\t\t\t<const>-1 -1</const>\n\t\t\t\tif no tile has been removed (first round)). <br>\n\t\t\t</div>\n\t\t</div>\n\n\t\t<!-- Protocol block -->\n\t\t<div class=\"blk\">\n\t\t\t<div class=\"title\">Output</div>\n\t\t\t<div class=\"text\">\n\t\t\t\t<span class=\"statement-lineno\">A single line</span> containing the\n\t\t\t\tcoordinates where you want to move your pawn, followed by the\n\t\t\t\tcoordinates of the tile you want to remove.<br>Example:\n\t\t\t\t<action>1 4 7 4</action>\n\t\t\t\t<br> You can also add a message :<br> Example:\n\t\t\t\t<action>1 4 7 4;MESSAGE</action>\n\t\t\t\t<br> NB : You can print\n\t\t\t\t<action>RANDOM</action>\n\t\t\t\tinstead of the 4 coordinates. Then a random possible move and tile\n\t\t\t\twill be chosen.\n\t\t\t</div>\n\t\t</div>\n\n\t\t<!-- Protocol block -->\n\t\t<div class=\"blk\">\n\t\t\t<div class=\"title\">Constraints</div>\n\t\t\tResponse time first turn is &le;\n\t\t\t<const>1000</const>\n\t\t\tms. <br>Response time per turn is &le;\n\t\t\t<const>100</const>\n\t\t\tms.\n\t\t</div>\n\t</div>\n</div>",
            "2": "<div\n\tstyle=\"color: #000000; background-color: rgba(255, 255, 255, 0.5); padding: 20px; margin-bottom: 10px; text-align: left\">\n\tThis is a port of the board game <a\n\t\thref=\"https://fr.wikipedia.org/wiki/Isola_(jeu)\">Isola</a> :\n\t<br /> <br />\n\t<p style=\"text-align: center;\">\n\t\t<img\n\t\t\tsrc=\"https://github.com/wala-fr/CodingameIsolation/blob/master/CodingameIsolation/src/main/resources/view/statement/isola_statement.png?raw=true\"\n\t\t\tstyle=\"height: 200px; width: auto;\"></img>\n\t</p>\n\t<p>\n\t\tThe source code of this game is available <a rel=\"nofollow\"\n\t\t\ttarget=\"_blank\" href=\"https://github.com/wala-fr/CodingameIsola\">on\n\t\t\tthis GitHub repo</a>. <br />\n</div>\n\n<div id=\"statement_back\" class=\"statement_back\" style=\"display: none\"></div>\n<div class=\"statement-body\">\n\t<!-- GOAL -->\n\t<div class=\"statement-section statement-goal\">\n\t\t<h1>\n\t\t\t<span class=\"icon icon-goal\">&nbsp;</span> <span>The Goal</span>\n\t\t</h1>\n\t\t<div class=\"statement-goal-content\">The goal of the game is to\n\t\t\tblock the opponent's pawn.</div>\n\t</div>\n\t<!-- RULES -->\n\t<div class=\"statement-section statement-rules\">\n\t\t<h1>\n\t\t\t<span class=\"icon icon-rules\">&nbsp;</span> <span>Rules</span>\n\t\t</h1>\n\t\t<div class=\"statement-rules-content\">\n\t\t\t<strong>Board: </strong>\n\t\t\t<ul>\n\t\t\t\t<li>The game is played on a <const>9 x 9</const> board.\n\t\t\t\t</li>\n\t\t\t\t<li>Player 0 always starts at <const>(0, 4)</const> and player\n\t\t\t\t\t1 at <const>(8, 4)</const>.\n\t\t\t\t</li>\n\t\t\t</ul>\n\t\t\t<strong>At each turn: </strong><br>\n\t\t\t<ol>\n\t\t\t\t<li>You must <b>move your pawn</b> to an adjacent tile\n\t\t\t\t\t(diagonal included) :<br> <br>\n\n\t\t\t\t\t<p style=\"text-align: center;\">\n\t\t\t\t\t\t<img\n\t\t\t\t\t\t\tsrc=\"https://github.com/wala-fr/CodingameIsolation/blob/master/CodingameIsolation/src/main/resources/view/statement/moves.png?raw=true\"\n\t\t\t\t\t\t\tstyle=\"height: 200px; width: auto;\"></img>\n\t\t\t\t\t</p>You can't :\n\t\t\t\t\t<ul>\n\t\t\t\t\t\t<li>stay put</li>\n\t\t\t\t\t\t<li>move to the tile occupied by the opponent's pawn</li>\n\t\t\t\t\t\t<li>move to an already removed tile.</li>\n\t\t\t\t\t</ul>\n\n\t\t\t\t</li>\n\t\t\t\t<li><b>Then</b> you must <b>remove a free tile</b>.<br />You\n\t\t\t\t\tcan't remove a tile occupied by a pawn.</li>\n\t\t\t</ol>\n\t\t</div>\n\t</div>\n\n\t<!-- Victory conditions -->\n\t<div class=\"statement-victory-conditions\">\n\t\t<div class=\"icon victory\"></div>\n\t\t<div class=\"blk\">\n\t\t\t<div class=\"title\">Victory Conditions</div>\n\t\t\t<div class=\"text\">\n\t\t\t\t<ul style=\"padding-bottom: 0;\">\n\t\t\t\t\t<li>At his turn, the opponent can't move his pawn.</li>\n\t\t\t\t</ul>\n\t\t\t</div>\n\t\t</div>\n\t</div>\n\n\t<!-- Lose conditions -->\n\t<div class=\"statement-lose-conditions\">\n\t\t<div class=\"icon lose\"></div>\n\t\t<div class=\"blk\">\n\t\t\t<div class=\"title\">Loss Conditions</div>\n\t\t\t<div class=\"text\">\n\t\t\t\t<ul style=\"padding-bottom: 0;\">\n\t\t\t\t\t<li>At your turn, you can't move your pawn.</li>\n\t\t\t\t\t<li>You do not respond in time or output an invalid action.</li>\n\t\t\t\t</ul>\n\t\t\t</div>\n\t\t</div>\n\t</div>\n\n\t<!-- PROTOCOL -->\n\t<div class=\"statement-section statement-protocol\">\n\t\t<h1>\n\t\t\t<span class=\"icon icon-protocol\">&nbsp;</span> <span>Game\n\t\t\t\tInput</span>\n\t\t</h1>\n\n\t\t<!-- Protocol block -->\n\t\t<div class=\"blk\">\n\t\t\t<div class=\"title\">Initialization input</div>\n\t\t\t<div class=\"text\">\n\t\t\t\t<span class=\"statement-lineno\">Line 1</span>:\n\t\t\t\t<var>playerPositionX</var>\n\t\t\t\t<br> <span class=\"statement-lineno\">Line 2</span>:\n\t\t\t\t<var>playerPositionY</var>\n\t\t\t\tthe coordinates of your pawn.\n\t\t\t</div>\n\t\t\t<br>\n\t\t\t<div class=\"title\">Input for one game turn</div>\n\t\t\t<div class=\"text\">\n\t\t\t\t<span class=\"statement-lineno\">Line 1</span>:\n\t\t\t\t<var>opponentPositionX</var>\n\t\t\t\t<br> <span class=\"statement-lineno\">Line 2</span>:\n\t\t\t\t<var>opponentPositionY</var>\n\t\t\t\tthe coordinates of the opponent's pawn. <br> <span\n\t\t\t\t\tclass=\"statement-lineno\">Line 3</span>:\n\t\t\t\t<var>opponentLastRemovedTileX</var>\n\t\t\t\t<br> <span class=\"statement-lineno\">Line 4</span>:\n\t\t\t\t<var>opponentLastRemovedTileY</var>\n\t\t\t\tthe coordinates of the last tile removed by the opponent (\n\t\t\t\t<const>-1 -1</const>\n\t\t\t\tif no tile has been removed (first round)). <br>\n\t\t\t</div>\n\t\t</div>\n\n\t\t<!-- Protocol block -->\n\t\t<div class=\"blk\">\n\t\t\t<div class=\"title\">Output</div>\n\t\t\t<div class=\"text\">\n\t\t\t\t<span class=\"statement-lineno\">A single line</span> containing the\n\t\t\t\tcoordinates where you want to move your pawn, followed by the\n\t\t\t\tcoordinates of the tile you want to remove.<br>Example:\n\t\t\t\t<action>1 4 7 4</action>\n\t\t\t\t<br> You can also add a message :<br> Example:\n\t\t\t\t<action>1 4 7 4;MESSAGE</action>\n\t\t\t\t<br> NB : You can print\n\t\t\t\t<action>RANDOM</action>\n\t\t\t\tinstead of the 4 coordinates. Then a random possible move and tile\n\t\t\t\twill be chosen.\n\t\t\t</div>\n\t\t</div>\n\n\t\t<!-- Protocol block -->\n\t\t<div class=\"blk\">\n\t\t\t<div class=\"title\">Constraints</div>\n\t\t\tResponse time first turn is &le;\n\t\t\t<const>1000</const>\n\t\t\tms. <br>Response time per turn is &le;\n\t\t\t<const>100</const>\n\t\t\tms.\n\t\t</div>\n\t</div>\n</div>"
          },
          "questionType": "multi",
          "stubGenerator": "read playerPositionX:int\nread playerPositionY:int\ngameloop\nread opponentPositionX:int\nread opponentPositionY:int\nread opponentLastRemovedTileX:int\nread opponentLastRemovedTileY:int\nwrite RANDOM;MESSAGE\n\nINPUT\nplayerPositionY:player's coordinates.\nopponentPositionY:opponent's coordinates.\nopponentLastRemovedTileY:coordinates of the last removed tile. (-1 -1) if no tile has been removed.\n",
          "welcomePopups": {},
          "aiCodeExtension": "java",
          "criteriaLanguageMap": {}
        },
        "1": {
          "aiCode": "import java.util.*;\r\nimport java.text.*;\r\nimport java.util.function.*;\r\nimport java.util.stream.*;\r\nimport java.util.concurrent.*;\r\nimport java.util.Map.*;\r\nclass Game{\r\nstatic Logger logger=Logger.getLogger(Game.class);\r\nstatic final Game instance=new Game();\r\nint[] board=BoardUtils.constructBoard();\r\nGame(){}\r\npublic static Game getInstance(){\r\nreturn instance;\r\n}\r\npublic void init(Scanner in){\r\nint playerPositionX=in.nextInt();\r\nint playerPositionY=in.nextInt();\r\nConstant.PLAYER_ID=playerPositionX==0?0:1;\r\nConstant.OPPONENT_ID=1-Constant.PLAYER_ID;\r\nBoardUtils.init(board);\r\n\r\n}\r\npublic void init(int[] board){\r\nthis.board=board;\r\n}\r\npublic void update(Scanner in){\r\nint opponentPosition=PointUtils.getPosition(in);\r\nConstant.ROUND++;\r\nTimer.getInstance().init();\r\n\r\nBoardUtils.setTeamPosition(board,opponentPosition,Constant.OPPONENT_ID);\r\nint opponentLastRemovedTile=PointUtils.getPosition(in);\r\nif(opponentLastRemovedTile!=FrameworkConstant.OUT){\r\nBoardUtils.removeTile(board,opponentLastRemovedTile);\r\n}\r\n}\r\npublic int[] getBoard(){\r\nreturn board;\r\n}\r\n}\r\n\r\nclass Player{\r\npublic static void main(String args[]){\r\nScanner in=new Scanner(System.in);\r\nGame game=Game.getInstance();\r\ngame.init(in);\r\nwhile(true){\r\ngame.update(in);\r\nString action=NextMoveUtils.proceed();\r\nSystem.out.println(action+getMessage());\r\n}\r\n}\r\npublic static String getMessage(){\r\nreturn Parameter.BOSS_NB==3\r\n?\";I'M THE BOSS!!!\"\r\n:Parameter.BOSS_NB==2?\";IT'S OVER!!\":\";YOU'RE DEAD!\";\r\n}\r\n}\r\n\r\nclass Bit128Utils{\r\nstatic final long[] masksLowerN=new long[64];\r\nstatic final long maskCut;\r\nstatic{\r\nlong tmp=0l;\r\nfor(int i=0;i<masksLowerN.length;i++){\r\nmasksLowerN[i]=tmp;\r\ntmp=tmp << 1l;\r\ntmp=tmp |= 1;\r\n}\r\ntmp=0;\r\nfor(int i=0;i<FrameworkConstant.CASE_NB%64;i++){\r\ntmp=tmp|(1l << i);\r\n}\r\nmaskCut=tmp;\r\n}\r\npublic static void shiftLeft(long[] bits,int nb){\r\nbits[1]=((bits[1] << nb)|(bits[0] >>>(64-nb)))&maskCut;\r\nbits[0]=bits[0] << nb;\r\n}\r\npublic static void shiftRight(long[] bits,int nb){\r\nbits[0]=(bits[0] >>> nb)|(bits[1] <<(64-nb));\r\nbits[1]=bits[1] >>> nb;\r\n}\r\npublic static String toBinaryString(long[] bits){\r\nString s=Long.toBinaryString(bits[0]);\r\nif(bits[1]!=0){\r\nwhile(s.length()<64){\r\ns=\"0\"+s;\r\n}\r\ns=Long.toBinaryString(bits[1])+s;\r\n}\r\nreturn s;\r\n}\r\npublic static String shiftLeft(String s,int nb){\r\nif(!s.equals(\"0\")){\r\ns+=new String(new char[nb]).replace(\"\\0\",\"0\");\r\n}\r\nif(s.length()>FrameworkConstant.CASE_NB){\r\ns=s.substring(s.length()-FrameworkConstant.CASE_NB,s.length());\r\n}\r\nreturn s;\r\n}\r\npublic static String shiftRight(String s,int nb){\r\ns=s.substring(0,Math.max(s.length()-nb,0));\r\nif(s.equals(\"\")){\r\ns=\"0\";\r\n}\r\nreturn s;\r\n}\r\npublic static boolean isSet(long[] bits,int nb){\r\nif(nb>=64){\r\nreturn(bits[1]&(1l <<(nb-64)))!=0;\r\n}\r\nreturn(bits[0]&(1l << nb))!=0;\r\n}\r\npublic static void set(long[] bits,int nb){\r\nif(nb>=64){\r\nbits[1]=bits[1]|(1l <<(nb-64));\r\n}else{\r\nbits[0]=bits[0]|(1l << nb);\r\n}\r\n}\r\npublic static void reset(long[] bits,int nb){\r\nif(nb>=64){\r\nbits[1]=bits[1]&~(1l <<(nb-64));\r\n}else{\r\nbits[0]=bits[0]&~(1l << nb);\r\n}\r\n}\r\npublic static void and(long[] bits1,int index1,long[] bits2,int index2){\r\nint tmp=2*index1;\r\nbits1[tmp]=bits1[tmp]&bits2[2*index2];\r\ntmp++;\r\nbits1[tmp]=bits1[tmp]&bits2[2*index1+1];\r\n}\r\npublic static void and(long[] bits1,long[] bits2){\r\nbits1[0]=bits1[0]&bits2[0];\r\nbits1[1]=bits1[1]&bits2[1];\r\n}\r\npublic static void or(long[] bits1,int index1,long[] bits2,int index2){\r\nbits1[2*index1]=bits1[2*index1]|bits2[2*index2];\r\nbits1[2*index1+1]=bits1[2*index1+1]|bits2[2*index2+1];\r\n}\r\npublic static void or(long[] bits1,long[] bits2){\r\nbits1[0]=bits1[0]|bits2[0];\r\nbits1[1]=bits1[1]|bits2[1];\r\n}\r\npublic static void reverse(long[] bits){\r\nbits[0]=~bits[0];\r\nbits[1]=~bits[1]&maskCut;\r\n}\r\n}\r\n\r\nclass BoardBitUtils{\r\nstatic Logger logger=Logger.getLogger(BoardBitUtils.class);\r\npublic static String toString(long[] boards){\r\nStringBuilder sb=new StringBuilder();\r\nsb.append(\"\\n\");\r\nfor(int y=0;y<FrameworkConstant.HEIGHT;y++){\r\nfor(int x=0;x<FrameworkConstant.WIDTH;x++){\r\nint nb=getIndex(x,y);\r\nif(Bit128Utils.isSet( boards,nb)){\r\nsb.append(\"0\");\r\n}else{\r\nsb.append(\".\");\r\n}\r\n}\r\nsb.append(\"\\n\");\r\n}\r\nreturn sb.toString();\r\n}\r\npublic static int getIndex(int x,int y){\r\nreturn FrameworkConstant.WIDTH*y+x;\r\n}\r\nstatic final long[] verticalLeft=new long[2];\r\nstatic final long[] horizontalUp=new long[2];\r\nstatic final long[] diagonalLeftUp=new long[2];\r\nstatic final long[] diagonalLeftDown=new long[2];\r\nstatic final long[] diagonalRightUp=new long[2];\r\nstatic final long[] diagonalRightDown=new long[2];\r\nstatic final long[] horizontalDown=new long[2];\r\nstatic final long[] verticalRight=new long[2];\r\npublic static final long[][] arounds =\r\nnew long[FrameworkConstant.WIDTH*FrameworkConstant.HEIGHT][];\r\nstatic final long[] tmpBoard=new long[2];\r\nstatic final long[] tmpBoard1=new long[2];\r\nstatic final long[] tmpBoard2=new long[2];\r\nstatic final long[] tmpBoard3=new long[2];\r\nstatic final int WIDTH_PLUS_ONE=FrameworkConstant.WIDTH+1;\r\nstatic final int WIDTH_MINUS_ONE=FrameworkConstant.WIDTH-1;\r\nstatic{\r\nfor(int y=0;y<FrameworkConstant.HEIGHT;y++){\r\nfor(int x=1;x<FrameworkConstant.WIDTH;x++){\r\nint nb=getIndex(x,y);\r\nBit128Utils.set(verticalLeft,nb);\r\n}\r\n}\r\nfor(int y=0;y<FrameworkConstant.HEIGHT;y++){\r\nfor(int x=0;x<FrameworkConstant.WIDTH-1;x++){\r\nint nb=getIndex(x,y);\r\nBit128Utils.set(verticalRight,nb);\r\n}\r\n}\r\nfor(int y=1;y<FrameworkConstant.HEIGHT;y++){\r\nfor(int x=0;x<FrameworkConstant.WIDTH;x++){\r\nint nb=getIndex(x,y);\r\nBit128Utils.set(horizontalUp,nb);\r\n}\r\n}\r\nfor(int y=0;y<FrameworkConstant.HEIGHT-1;y++){\r\nfor(int x=0;x<FrameworkConstant.WIDTH;x++){\r\nint nb=getIndex(x,y);\r\nBit128Utils.set(horizontalDown,nb);\r\n}\r\n}\r\nfor(int y=1;y<FrameworkConstant.HEIGHT;y++){\r\nfor(int x=1;x<FrameworkConstant.WIDTH;x++){\r\nint nb=getIndex(x,y);\r\nBit128Utils.set(diagonalLeftUp,nb);\r\n}\r\n}\r\nfor(int y=0;y<FrameworkConstant.HEIGHT-1;y++){\r\nfor(int x=1;x<FrameworkConstant.WIDTH;x++){\r\nint nb=getIndex(x,y);\r\nBit128Utils.set(diagonalLeftDown,nb);\r\n}\r\n}\r\nfor(int y=1;y<FrameworkConstant.HEIGHT;y++){\r\nfor(int x=0;x<FrameworkConstant.WIDTH-1;x++){\r\nint nb=getIndex(x,y);\r\nBit128Utils.set(diagonalRightUp,nb);\r\n}\r\n}\r\nfor(int y=0;y<FrameworkConstant.HEIGHT-1;y++){\r\nfor(int x=0;x<FrameworkConstant.WIDTH-1;x++){\r\nint nb=getIndex(x,y);\r\nBit128Utils.set(diagonalRightDown,nb);\r\n}\r\n}\r\nfor(int y=0;y<FrameworkConstant.HEIGHT;y++){\r\nfor(int x=0;x<FrameworkConstant.WIDTH;x++){\r\nint nb=getIndex(x,y);\r\ntmpBoard1[0]=0;\r\ntmpBoard1[1]=0;\r\ntmpBoard[0]=0;\r\ntmpBoard[1]=0;\r\nBit128Utils.set(tmpBoard,nb);\r\nshiftLeft(tmpBoard);\r\nBit128Utils.or(tmpBoard1,0,tmpBoard,0);\r\ntmpBoard[0]=0;\r\ntmpBoard[1]=0;\r\nBit128Utils.set(tmpBoard,nb);\r\nshiftRight(tmpBoard);\r\nBit128Utils.or(tmpBoard1,0,tmpBoard,0);\r\ntmpBoard[0]=0;\r\ntmpBoard[1]=0;\r\nBit128Utils.set(tmpBoard,nb);\r\nshiftUp(tmpBoard);\r\nBit128Utils.or(tmpBoard1,0,tmpBoard,0);\r\ntmpBoard[0]=0;\r\ntmpBoard[1]=0;\r\nBit128Utils.set(tmpBoard,nb);\r\nshiftDown(tmpBoard);\r\nBit128Utils.or(tmpBoard1,0,tmpBoard,0);\r\ntmpBoard[0]=0;\r\ntmpBoard[1]=0;\r\nBit128Utils.set(tmpBoard,nb);\r\nshiftLeftUp(tmpBoard);\r\nBit128Utils.or(tmpBoard1,0,tmpBoard,0);\r\ntmpBoard[0]=0;\r\ntmpBoard[1]=0;\r\nBit128Utils.set(tmpBoard,nb);\r\nshiftLeftDown(tmpBoard);\r\nBit128Utils.or(tmpBoard1,0,tmpBoard,0);\r\ntmpBoard[0]=0;\r\ntmpBoard[1]=0;\r\nBit128Utils.set(tmpBoard,nb);\r\nshiftRightUp(tmpBoard);\r\nBit128Utils.or(tmpBoard1,0,tmpBoard,0);\r\ntmpBoard[0]=0;\r\ntmpBoard[1]=0;\r\nBit128Utils.set(tmpBoard,nb);\r\nshiftRightDown(tmpBoard);\r\nBit128Utils.or(tmpBoard1,0,tmpBoard,0);\r\nlong[] tmp=new long[2];\r\ntmp[0]=tmpBoard1[0];\r\ntmp[1]=tmpBoard1[1];\r\narounds[nb]=tmp;\r\n}\r\n}\r\n}\r\npublic static int calculateLongBitCount(long[] bitboard){\r\nreturn bitCount(bitboard[0])+bitCount(bitboard[1]);\r\n}\r\nstatic int bitCount(long l){\r\nif(l==0){\r\nreturn 0;\r\n}\r\nreturn Long.bitCount(l);\r\n}\r\npublic static void shiftLeft(long[] bitboard){\r\nBit128Utils.and(bitboard,verticalLeft);\r\nBit128Utils.shiftRight(bitboard,1);\r\n}\r\npublic static void shiftRight(long[] bitboard){\r\nBit128Utils.and(bitboard,verticalRight);\r\nBit128Utils.shiftLeft(bitboard,1);\r\n}\r\npublic static void shiftUp(long[] bitboard){\r\nBit128Utils.and(bitboard,horizontalUp);\r\nBit128Utils.shiftRight(bitboard,FrameworkConstant.WIDTH);\r\n}\r\npublic static void shiftDown(long[] bitboard){\r\nBit128Utils.and(bitboard,horizontalDown);\r\nBit128Utils.shiftLeft(bitboard,FrameworkConstant.WIDTH);\r\n}\r\npublic static void shiftLeftUp(long[] bitboard){\r\nBit128Utils.and(bitboard,diagonalLeftUp);\r\nBit128Utils.shiftRight(bitboard,WIDTH_PLUS_ONE);\r\n}\r\npublic static void shiftLeftDown(long[] bitboard){\r\nBit128Utils.and(bitboard,diagonalLeftDown);\r\nBit128Utils.shiftLeft(bitboard,WIDTH_MINUS_ONE);\r\n}\r\npublic static void shiftRightUp(long[] bitboard){\r\nBit128Utils.and(bitboard,diagonalRightUp);\r\nBit128Utils.shiftRight(bitboard,WIDTH_MINUS_ONE);\r\n}\r\npublic static void shiftRightDown(long[] bitboard){\r\nBit128Utils.and(bitboard,diagonalRightDown);\r\nBit128Utils.shiftLeft(bitboard,WIDTH_PLUS_ONE);\r\n}\r\nstatic long[] copy=new long[2];\r\nstatic long[] finalBoard=new long[2];\r\nstatic long[] copyMoveAroundBoard=new long[2];\r\npublic static void toLongBoard(int[] board,long[] destination){\r\ndestination[0]=(((long)board[0])&0xFFFFFFFFL)|(((long)board[1])<< 32);\r\ndestination[1]=((long)board[2])&0xFFFFFFFFL;\r\nBit128Utils.reverse(destination);\r\n}\r\npublic static long[] moveAround(long[] board){\r\nclear(finalBoard);\r\ncopy(board,copy);\r\nshiftLeft(copy);\r\nBit128Utils.or(finalBoard,copy);\r\ncopy(board,copy);\r\nshiftRight(copy);\r\nBit128Utils.or(finalBoard,copy);\r\ncopy(board,copy);\r\nshiftUp(copy);\r\nBit128Utils.or(finalBoard,copy);\r\ncopy(board,copy);\r\nshiftDown(copy);\r\nBit128Utils.or(finalBoard,copy);\r\ncopy(board,copy);\r\nshiftLeftDown(copy);\r\nBit128Utils.or(finalBoard,copy);\r\ncopy(board,copy);\r\nshiftRightDown(copy);\r\nBit128Utils.or(finalBoard,copy);\r\ncopy(board,copy);\r\nshiftLeftUp(copy);\r\nBit128Utils.or(finalBoard,copy);\r\ncopy(board,copy);\r\nshiftRightUp(copy);\r\nBit128Utils.or(finalBoard,copy);\r\nreturn finalBoard;\r\n}\r\npublic static void copy(long[] source,long[] destination){\r\ndestination[0]=source[0];\r\ndestination[1]=source[1];\r\n}\r\npublic static void clear(long[] source){\r\nsource[0]=0;\r\nsource[1]=0;\r\n}\r\n}\r\n\r\nclass BoardCache{\r\nstatic final Logger logger=Logger.getLogger(BoardCache.class);\r\nstatic final int[][] CACHE=new int[Parameter.BOARD_CACHE_NB][];\r\nstatic int maxIndex;\r\nstatic int index;\r\npublic static void reset(){\r\nmaxIndex=Math.max(maxIndex,index);\r\nindex=0;\r\n}\r\npublic static int[] next()throws NoMoreBoardException{\r\ntry{\r\nint[] ret=CACHE[index];\r\nif(ret==null){\r\nret=BoardUtils.constructBoard();\r\nCACHE[index]=ret;\r\n}\r\nindex++;\r\nreturn ret;\r\n}catch(IndexOutOfBoundsException e){\r\nthrow NoMoreBoardException.EXCEPTION;\r\n}\r\n}\r\npublic static int[] getWay(int index){\r\nreturn CACHE[index];\r\n}\r\npublic static int getIndex(){\r\nreturn index;\r\n}\r\npublic static void printIndex(){\r\n\r\n}\r\n}\r\n\r\nclass BoardUtils{\r\nstatic final Logger logger=Logger.getLogger(BoardUtils.class);\r\nstatic int index=0;\r\npublic static final int MAP_INDEX=index;\r\npublic static final int BIT_NB=32;\r\npublic static final int MAP_LENGTH=(int)Math.ceil(FrameworkConstant.CASE_NB/(double)BIT_NB);\r\nstatic{\r\nindex+=MAP_LENGTH;\r\n}\r\nstatic final int TEAM_POSITION_INDEX=index;\r\nstatic{\r\nindex+=2;\r\n}\r\nstatic final int LAST_TILE=index++;\r\nstatic final int CHILD_NB=index++;\r\nstatic final int CHILD_START=index++;\r\nstatic final int LENGTH=index;\r\npublic static int[] constructBoard(){\r\nreturn new int[LENGTH];\r\n}\r\npublic static void init(int[] board){\r\nint x=(FrameworkConstant.HEIGHT-1)/2;\r\nsetTeamPosition(board,PointUtils.getPosition(0,x),0);\r\nsetTeamPosition(board,PointUtils.getPosition(FrameworkConstant.WIDTH-1,x),1);\r\n}\r\npublic static boolean isChildInit(int[] board){\r\nreturn getChildNb(board)!=-1;\r\n}\r\npublic static void reset(int[] board){\r\nsetChildNb(board,-1);\r\n}\r\npublic static int[] calculateNextWay(int[] board,int move,int tile,int team){\r\nint[] ret=copy(board);\r\nmove(ret,move,tile,team);\r\nreturn ret;\r\n}\r\npublic static void move(int[] board,int move,int tile,int team){\r\nsetTeamPosition(board,move,team);\r\nremoveTile(board,tile);\r\nsetLastTile(board,tile);\r\n}\r\npublic static int[] copy(int[] board){\r\nint[] ret=BoardCache.next();\r\nSystem.arraycopy(board,0,ret,0,LAST_TILE);\r\nreset(ret);\r\nreturn ret;\r\n}\r\npublic static void copy(int[] source,int[] destination){\r\nSystem.arraycopy(source,0,destination,0,LAST_TILE);\r\nreset(destination);\r\n}\r\npublic static void removeTile(int[] board,int position){\r\nboard[MAP_INDEX+position/BIT_NB] |= 1 <<(position%BIT_NB);\r\n}\r\npublic static boolean hasTile(int[] board,int position){\r\nreturn(board[MAP_INDEX+position/BIT_NB]&(1 <<(position%BIT_NB)))==0;\r\n}\r\npublic static void copyMap(int[] board,int[] map){\r\nfor(int i=0;i<MAP_LENGTH;i++){\r\nmap[i]=board[MAP_INDEX+i];\r\n}\r\n}\r\npublic static void setTeamPosition(int[] board,int position,int team){\r\nboard[TEAM_POSITION_INDEX+team]=position;\r\n}\r\npublic static int getTeamPosition(int[] board,int team){\r\nreturn board[TEAM_POSITION_INDEX+team];\r\n}\r\npublic static void setLastTile(int[] board,int position){\r\nboard[LAST_TILE]=position;\r\n}\r\npublic static int getLastTile(int[] board){\r\nreturn board[LAST_TILE];\r\n}\r\npublic static void setChildNb(int[] board,int value){\r\nboard[CHILD_NB]=value;\r\n}\r\npublic static int getChildNb(int[] board){\r\nreturn board[CHILD_NB];\r\n}\r\npublic static void setChildStartIndex(int[] board,int value){\r\nboard[CHILD_START]=value;\r\n}\r\npublic static int getChildStartIndex(int[] board){\r\nreturn board[CHILD_START];\r\n}\r\npublic static void initChild(int[] way,int teamId,boolean first){\r\nif(isChildInit(way)){\r\nreturn;\r\n}\r\nint childNb=0;\r\nint startIndex=BoardCache.getIndex();\r\nsetChildStartIndex(way,startIndex);\r\nint playerPosition=getTeamPosition(way,teamId);\r\nint opponentPosition=getTeamPosition(way,1-teamId);\r\nbyte[] possibleTiles=TilePruningUtils.calculatePossiblePruningTiles(way,teamId,first);\r\nint size=ByteListUtils.size(possibleTiles);\r\nbyte[] positions=MapUtils.getAroundPositions(playerPosition);\r\nfor(int i=0;i<positions.length;i++){\r\nbyte move=positions[i];\r\nif(hasTile(way,move)&&move!=opponentPosition){\r\nfor(int j=0;j<size;j++){\r\nint tile=ByteListUtils.get(possibleTiles,j);\r\nif(tile!=move){\r\ncalculateNextWay(way,move,tile,teamId);\r\nchildNb++;\r\n}\r\n}\r\n}\r\n}\r\nsetChildNb(way,childNb);\r\n}\r\npublic static String toString(int[] board){\r\nif(board==null){\r\nreturn null;\r\n}\r\nStringBuilder sb=new StringBuilder(\"\\n\");\r\nfor(int p=0;p<FrameworkConstant.CASE_NB;p++){\r\nif(hasTile(board,p)){\r\nif(p==getTeamPosition(board,0)){\r\nsb.append('0');\r\n}else if(p==getTeamPosition(board,1)){\r\nsb.append('1');\r\n}else{\r\nsb.append('.');\r\n}\r\n}else{\r\nsb.append('X');\r\n}\r\nif((p+1)%FrameworkConstant.WIDTH==0){\r\nsb.append('\\n');\r\n}\r\n}\r\nsb.append(\"tile:\"+PointUtils.toPoint(getLastTile(board)));\r\nsb.append('\\n');\r\nreturn sb.toString();\r\n}\r\npublic static String toMapString(int[] board){\r\nif(board==null){\r\nreturn null;\r\n}\r\nStringBuilder sb=new StringBuilder(\"\\n\");\r\nfor(int p=0;p<FrameworkConstant.CASE_NB;p++){\r\nif(hasTile(board,p)){\r\nsb.append('.');\r\n}else{\r\nsb.append('X');\r\n}\r\nif((p+1)%FrameworkConstant.WIDTH==0){\r\nsb.append('\\n');\r\n}\r\n}\r\nreturn sb.toString();\r\n}\r\n}\r\n\r\nclass IslandUtils{\r\nstatic Logger logger=Logger.getLogger(IslandUtils.class);\r\npublic static final byte[][] possiblePruningTiles=new byte[3][];\r\nstatic{\r\nfor(int i=0;i<possiblePruningTiles.length;i++){\r\npossiblePruningTiles[i]=new byte[FrameworkConstant.CASE_NB+1];\r\n}\r\n}\r\npublic static final int[][] places=new int[2][];\r\nstatic{\r\nfor(int i=0;i<places.length;i++){\r\nplaces[i]=new int[3];\r\n}\r\n}\r\npublic static boolean sameIsland;\r\npublic static void calculateIsland(int[] board){\r\nfor(int i=0;i<possiblePruningTiles.length;i++){\r\nByteListUtils.clear(possiblePruningTiles[i]);\r\n}\r\nfor(int i=0;i<2;i++){\r\nPlaceUtils.calculatePlace(board,i);\r\nPlaceUtils.copy(PlaceUtils.place,places[i]);\r\n}\r\nfor(byte i=0;i<FrameworkConstant.CASE_NB;i++){\r\nif(BoardUtils.hasTile(board,i)){\r\nboolean freeIsland=true;\r\nfor(int id=0;id<2;id++){\r\nif(!PlaceUtils.isFree(places[id],i)){\r\nByteListUtils.add(possiblePruningTiles[id],i);\r\nfreeIsland=false;\r\n}\r\n}\r\nif(freeIsland){\r\nByteListUtils.add(possiblePruningTiles[2],i);\r\n}\r\n}\r\n}\r\nsameIsland =\r\nByteListUtils.size(possiblePruningTiles[1])==ByteListUtils.size(possiblePruningTiles[0]);\r\nif(sameIsland){\r\nfor(int i=0;i<ByteListUtils.size(possiblePruningTiles[0]);i++){\r\nif(!ByteListUtils.contains(\r\npossiblePruningTiles[1],ByteListUtils.get(possiblePruningTiles[0],i))){\r\nsameIsland=false;\r\nbreak;\r\n}\r\n}\r\n}\r\nfor(int i=0;i<possiblePruningTiles.length;i++){\r\n\r\n}\r\n\r\n}\r\n}\r\n\r\nclass NoMoreBoardException extends RuntimeException{\r\npublic static final NoMoreBoardException EXCEPTION=new NoMoreBoardException();\r\n}\r\n\r\nclass PlaceUtils{\r\nstatic Logger logger=Logger.getLogger(PlaceUtils.class);\r\npublic static byte[][] positions=new byte[FrameworkConstant.CASE_NB][];\r\nstatic{\r\nfor(int i=0;i<positions.length;i++){\r\npositions[i]=new byte[FrameworkConstant.CASE_NB+1];\r\n}\r\n}\r\npublic static int[] place=new int[BoardUtils.MAP_LENGTH];\r\npublic static int size;\r\npublic static int[] dones=new int[BoardUtils.MAP_LENGTH];\r\npublic static int[] lastDones=new int[BoardUtils.MAP_LENGTH];\r\npublic static void calculatePlace(int[] way,int teamId){\r\ncalculatePlace(way,teamId,Integer.MAX_VALUE,false);\r\n}\r\npublic static void calculatePlace(int[] way,int teamId,int limit,boolean pawnBlock){\r\nint start=BoardUtils.getTeamPosition(way,teamId);\r\nBoardUtils.copyMap(way,dones);\r\nsetDone(dones,start);\r\nbyte[] currents=positions[0];\r\nByteListUtils.clear(currents);\r\nByteListUtils.add(currents,(byte)start);\r\nint n=0;\r\nsetDone(place,start);\r\nif(pawnBlock){\r\nint opponentPosition=BoardUtils.getTeamPosition(way,1-teamId);\r\nsetDone(dones,opponentPosition);\r\n}\r\nwhile(!ByteListUtils.isEmpty(currents)&&n<limit){\r\nn++;\r\nbyte[] nexts=positions[n];\r\nByteListUtils.clear(nexts);\r\nint l=ByteListUtils.size(currents);\r\nfor(int j=1;j<=l;j++){\r\nbyte p=currents[j];\r\nbyte[] arounds=MapUtils.getAroundPositions(p);\r\nint l1=arounds.length;\r\nfor(int i=0;i<l1;i++){\r\nbyte p2=arounds[i];\r\nif(isFree(dones,p2)){\r\nsetDone(dones,p2);\r\nByteListUtils.add(nexts,p2);\r\n}\r\n}\r\n}\r\ncurrents=nexts;\r\n}\r\nfor(int i=0;i<place.length;i++){\r\nplace[i]=way[BoardUtils.MAP_INDEX+i] ^ dones[i];\r\n}\r\nByteListUtils.clear(positions[n+1]);\r\n}\r\npublic static void calculateScore1(int[] way,int teamId,int limit){\r\nint start=BoardUtils.getTeamPosition(way,teamId);\r\nBoardUtils.copyMap(way,dones);\r\nsetDone(dones,start);\r\nbyte[] currents=positions[0];\r\nByteListUtils.clear(currents);\r\nByteListUtils.add(currents,(byte)start);\r\nint n=0;\r\nsetDone(place,start);\r\nint opponentPosition=BoardUtils.getTeamPosition(way,1-teamId);\r\nsetDone(dones,opponentPosition);\r\nwhile(!ByteListUtils.isEmpty(currents)&&n<limit){\r\nn++;\r\nbyte[] nexts=positions[n];\r\nByteListUtils.clear(nexts);\r\nint l=ByteListUtils.size(currents);\r\nfor(int j=1;j<=l;j++){\r\nbyte p=currents[j];\r\nbyte[] arounds=MapUtils.getAroundPositions(p);\r\nint l1=arounds.length;\r\nfor(int i=0;i<l1;i++){\r\nbyte p2=arounds[i];\r\nif(isFree(dones,p2)){\r\nsetDone(dones,p2);\r\nByteListUtils.add(nexts,p2);\r\n}\r\n}\r\n}\r\ncurrents=nexts;\r\ncounts[n]=ByteListUtils.size(currents);\r\n}\r\nByteListUtils.clear(positions[n+1]);\r\ncounts[n+1]=0;\r\n}\r\nstatic long[] initBoard=new long[2];\r\nstatic long[][] boards=new long[FrameworkConstant.CASE_NB][];\r\nstatic{\r\nfor(int i=0;i<boards.length;i++){\r\nboards[i]=new long[2];;\r\n}\r\n}\r\npublic static void calculateScore5(int[] board,int teamId,int limit){\r\nint p=BoardUtils.getTeamPosition(board,teamId);\r\nBoardBitUtils.toLongBoard(board,initBoard);\r\nBit128Utils.reset(initBoard,BoardUtils.getTeamPosition(board,1-teamId));\r\nlong[] a=BoardBitUtils.arounds[p];\r\nlong[] tmp=boards[1];\r\nBoardBitUtils.copy(a,tmp);\r\nBit128Utils.and(tmp,initBoard);\r\nBit128Utils.set(tmp,p);\r\ncounts[1]=BoardBitUtils.calculateLongBitCount(tmp);\r\nfor(int i=2;i<=limit ;i++){\r\ntmp=boards[i];\r\nBoardBitUtils.copy(BoardBitUtils.moveAround(boards[i-1]),tmp);\r\nBit128Utils.and(tmp,initBoard);\r\ncounts[i]=BoardBitUtils.calculateLongBitCount(tmp);\r\nif(counts[i]==counts[i-1]){\r\nbreak;\r\n}\r\n}\r\nfor(int i=limit;i>1;){\r\ncounts[i--]-=counts[i];\r\n}\r\ncounts[1]--;\r\ncounts[limit+1]=0;\r\n}\r\npublic static void setDone(int[] map,int position){\r\nmap[position/BoardUtils.BIT_NB] |= 1 <<(position%BoardUtils.BIT_NB);\r\n}\r\npublic static void setUndone(int[] map,int position){\r\nmap[position/BoardUtils.BIT_NB] &= ~(1 <<(position%BoardUtils.BIT_NB));\r\n}\r\npublic static boolean isFree(int[] map,int position){\r\nreturn(map[position/BoardUtils.BIT_NB]&(1 <<(position%BoardUtils.BIT_NB)))==0;\r\n}\r\npublic static void copy(int[] source,int[] destination){\r\nfor(int i=0;i<destination.length;i++){\r\ndestination[i]=source[i];\r\n}\r\n}\r\nstatic final int[][] mapScore=new int[2][];\r\nstatic final int[] mapClear=new int[FrameworkConstant.CASE_NB];\r\nstatic{\r\nfor(int i=0;i<mapScore.length;i++){\r\nmapScore[i]=new int[FrameworkConstant.CASE_NB];\r\n}\r\n}\r\npublic static final int[] counts=new int[FrameworkConstant.CASE_NB];\r\npublic static void calculateScore2(int[] way,int teamId,int limit){\r\nint start=BoardUtils.getTeamPosition(way,teamId);\r\nBoardUtils.copyMap(way,dones);\r\nbyte[] currents=positions[0];\r\nByteListUtils.clear(currents);\r\nByteListUtils.add(currents,(byte)start);\r\nint[] currentMap=mapScore[0];\r\nSystem.arraycopy(mapClear,0,currentMap,0,FrameworkConstant.CASE_NB);\r\ncurrentMap[start]=1;\r\nint n=0;\r\nint opponentPosition=BoardUtils.getTeamPosition(way,1-teamId);\r\nsetDone(dones,opponentPosition);\r\nwhile(!ByteListUtils.isEmpty(currents)&&n<limit){\r\nn++;\r\nbyte[] nexts=positions[n];\r\nByteListUtils.clear(nexts);\r\nBoardUtils.copyMap(dones,lastDones);\r\nint count=0;\r\nint l=ByteListUtils.size(currents);\r\nfor(int j=1;j<=l;j++){\r\nbyte p=currents[j];\r\nbyte[] arounds=MapUtils.getAroundPositions(p);\r\nint l1=arounds.length;\r\nint wayNb=currentMap[p];\r\nfor(int i=0;i<l1;i++){\r\nbyte p2=arounds[i];\r\nif(isFree(lastDones,p2)){\r\nif(isFree(dones,p2)){\r\nsetDone(dones,p2);\r\nByteListUtils.add(nexts,p2);\r\n}\r\ncurrentMap[p2]+=wayNb;\r\ncount+=wayNb;\r\n}\r\n}\r\n}\r\ncurrents=nexts;\r\ncounts[n]=count;\r\n}\r\ncounts[n+1]=0;\r\nByteListUtils.clear(positions[n+1]);\r\n}\r\npublic static void calculateScore3(int[] way,int teamId,int limit){\r\nint start=BoardUtils.getTeamPosition(way,teamId);\r\nBoardUtils.copyMap(way,dones);\r\nbyte[] currents=positions[0];\r\nByteListUtils.clear(currents);\r\nByteListUtils.add(currents,(byte)start);\r\nint n=0;\r\nint opponentPosition=BoardUtils.getTeamPosition(way,1-teamId);\r\nsetDone(dones,opponentPosition);\r\nwhile(!ByteListUtils.isEmpty(currents)&&n<limit){\r\nn++;\r\nbyte[] nexts=positions[n];\r\nByteListUtils.clear(nexts);\r\nBoardUtils.copyMap(dones,lastDones);\r\nint count=0;\r\nint l=ByteListUtils.size(currents);\r\nfor(int j=1;j<=l;j++){\r\nbyte p=currents[j];\r\nbyte[] arounds=MapUtils.getAroundPositions(p);\r\nint l1=arounds.length;\r\nfor(int i=0;i<l1;i++){\r\nbyte p2=arounds[i];\r\nif(isFree(lastDones,p2)){\r\nif(isFree(dones,p2)){\r\nsetDone(dones,p2);\r\nByteListUtils.add(nexts,p2);\r\n}\r\ncount++;\r\n}\r\n}\r\n}\r\ncurrents=nexts;\r\ncounts[n]=count;\r\n}\r\ncounts[n+1]=0;\r\nByteListUtils.clear(positions[n+1]);\r\n}\r\npublic static void calculateScore4(int[] way,int teamId,int limit){\r\ncalculateScore1(way,teamId,1);\r\n}\r\npublic static String toString(int[] place){\r\nif(place==null){\r\nreturn null;\r\n}\r\nStringBuilder sb=new StringBuilder(\"\\n\");\r\nfor(int p=0;p<FrameworkConstant.CASE_NB;p++){\r\nsb.append(place[p]);\r\nsb.append(' ');\r\nif((p+1)%FrameworkConstant.WIDTH==0){\r\nsb.append('\\n');\r\n}\r\n}\r\nreturn sb.toString();\r\n}\r\n}\r\n\r\nclass ScoreUtils{\r\nstatic Logger logger=Logger.getLogger(ScoreUtils.class);\r\npublic static final double MAX_SCORE=1e100;\r\npublic static double calculateScore(int[] board,int depth,int teamId){\r\ndouble ret=calculateScoreBest(board,depth,teamId);\r\nreturn ret;\r\n}\r\npublic static double calculateScore2(int[] board,int depth,int teamId){\r\ndouble score=0;\r\nint oppMoveNb=calculatePossibleMoveNb(board,1-teamId);\r\nint playerMoveNb=calculatePossibleMoveNb(board,teamId);\r\nif(playerMoveNb==0){\r\nscore=MAX_SCORE*(depth+1);\r\n}else{\r\nscore+=(oppMoveNb-playerMoveNb)*1e5;\r\nint playerPosition=BoardUtils.getTeamPosition(board,teamId);\r\nint oppPosition=BoardUtils.getTeamPosition(board,1-teamId);\r\nscore +=\r\nPointUtils.distance(FrameworkConstant.CENTER,playerPosition)\r\n-PointUtils.distance(FrameworkConstant.CENTER,oppPosition);\r\n}\r\nif(teamId==Constant.PLAYER_ID){\r\nscore*=-1;\r\n}\r\nreturn score;\r\n}\r\npublic static double calculateScoreBest(int[] board,int depth,int playingTeam){\r\ndouble score=0;\r\nint limit=Parameter.LIMIT_WAY;\r\nfor(int id=0;id<2;id++){\r\ndouble multpl=(id==Constant.PLAYER_ID?1:-1);\r\nswitch(Parameter.SCORE_EVALUATION){\r\ncase 3:\r\nPlaceUtils.calculateScore3(board,id,limit);\r\nbreak;\r\ncase 5:\r\nPlaceUtils.calculateScore5(board,id,limit);\r\nbreak;\r\ncase 6:\r\nPlaceUtils.calculateScore5(board,id,limit);\r\nbreak;\r\ncase 1:\r\nPlaceUtils.calculateScore1(board,id,limit);\r\nbreak;\r\ncase 2:\r\nPlaceUtils.calculateScore2(board,id,limit);\r\nbreak;\r\ncase 4:\r\nPlaceUtils.calculateScore4(board,id,limit);\r\nbreak;\r\ncase 7:\r\nPlaceUtils.calculateScore1(board,id,limit);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nfor(int i=1;i<=limit;i++){\r\nint nb=PlaceUtils.counts[i];\r\nif(Parameter.LOG){\r\n\r\n}\r\nif(nb==0){\r\nif(i==1){\r\nscore+=-multpl*MAX_SCORE*(depth+1);\r\nif(id==playingTeam){\r\nscore+=-multpl*MAX_SCORE*(depth+1);\r\n}\r\n}\r\nbreak;\r\n}\r\nscore+=multpl*nb*Pow.getPow(i-1);\r\n}\r\n}\r\nif(Parameter.LOG){\r\n\r\n\r\n}\r\nreturn score;\r\n}\r\npublic static int calculatePossibleMoveNb(int[] board,int teamId){\r\nint ret=0;\r\nint p=BoardUtils.getTeamPosition(board,teamId);\r\nbyte[] positions=MapUtils.getAroundPositions(p);\r\nint opponentPosition=BoardUtils.getTeamPosition(board,1-teamId);\r\nfor(int i=0;i<positions.length;i++){\r\nbyte p1=positions[i];\r\nif(BoardUtils.hasTile(board,p1)&&p1!=opponentPosition){\r\nret++;\r\n}\r\n}\r\nreturn ret;\r\n}\r\n}\r\n\r\nclass TilePruningUtils{\r\nstatic Logger logger=Logger.getLogger(TilePruningUtils.class);\r\npublic static final byte[] possibleRemoveTiles=new byte[100];\r\nstatic final int[] tmpMap=new int[BoardUtils.MAP_LENGTH];\r\npublic static byte[] calculatePossiblePruningTiles(int[] board,int teamId,boolean first){\r\nByteListUtils.clear(possibleRemoveTiles);\r\nboolean playerFirstIteration=first&&teamId==Constant.PLAYER_ID;\r\nint opponentPosition=BoardUtils.getTeamPosition(board,1-teamId);\r\nint[] opponentIslandPlace=IslandUtils.places[1-teamId];\r\nboolean spiral=first||!Parameter.LIMIT_ONLY_FIRST_DEPTH;\r\nbyte[] spiralPositions =\r\nspiral\r\n?MapUtils.getSpiralPositions(opponentPosition)\r\n:MapUtils.getAroundPositions(opponentPosition);\r\nint limit=playerFirstIteration?Parameter.TILE_LIMIT_NB:Parameter.TILE_LIMIT_NB2;\r\nif(IslandUtils.sameIsland&&!ByteListUtils.isEmpty(IslandUtils.possiblePruningTiles[2])){\r\nlimit--;\r\n}\r\nif(spiral){\r\nint[] tmp =\r\nplayerFirstIteration?prunedTileFirstIteration:opponentIslandPlace;\r\nfor(int i=0;i<BoardUtils.MAP_LENGTH;i++){\r\ntmpMap[i]=(~board[BoardUtils.MAP_INDEX+i])&tmp[i];\r\n}\r\nfor(int i=0;i<spiralPositions.length;i++){\r\nbyte p=spiralPositions[i];\r\nif(!PlaceUtils.isFree(tmpMap,p)){\r\nByteListUtils.add(possibleRemoveTiles,p);\r\nif(ByteListUtils.size(possibleRemoveTiles)==limit){\r\nbreak;\r\n}\r\n}\r\n}\r\n}else{\r\nfor(int i=0;i<spiralPositions.length;i++){\r\nbyte p=spiralPositions[i];\r\nif(BoardUtils.hasTile(board,p)){\r\nByteListUtils.add(possibleRemoveTiles,p);\r\n}\r\n}\r\n}\r\nif(ByteListUtils.size(possibleRemoveTiles)<=0||IslandUtils.sameIsland){\r\nbyte[] freeIslandTile=IslandUtils.possiblePruningTiles[2];\r\nboolean addExternalTile=false;\r\nint l=ByteListUtils.size(freeIslandTile);\r\nfor(int i=0;i<l;i++){\r\nbyte tmp=ByteListUtils.get(freeIslandTile,i);\r\nif(BoardUtils.hasTile(board,tmp)){\r\nByteListUtils.add(possibleRemoveTiles,tmp);\r\naddExternalTile=true;\r\nbreak;\r\n}\r\n}\r\nif(!addExternalTile&&!playerFirstIteration){\r\nbyte[] closestPositions=closestTiles[1-teamId];\r\nint l2=ByteListUtils.size(closestPositions);\r\nfor(int i=l2-1;i>=0;i--){\r\nbyte tmp=ByteListUtils.get(closestPositions,i);\r\nif(BoardUtils.hasTile(board,tmp)){\r\nByteListUtils.add(possibleRemoveTiles,tmp);\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\nif(ByteListUtils.size(possibleRemoveTiles)<=0){\r\nByteListUtils.add(possibleRemoveTiles,(byte)BoardUtils.getTeamPosition(board,teamId));\r\n}\r\nreturn possibleRemoveTiles;\r\n}\r\nstatic final int[] prunedTileFirstIteration=new int[BoardUtils.MAP_LENGTH];\r\nstatic final byte[][] closestTiles=new byte[2][];\r\nstatic{\r\nfor(int i=0;i<closestTiles.length;i++){\r\nclosestTiles[i]=new byte[FrameworkConstant.CASE_NB+1];\r\n}\r\n}\r\npublic static void initPrunedTileFirstIteration(int[] board){\r\nfor(int i=0;i<BoardUtils.MAP_LENGTH;i++){\r\nprunedTileFirstIteration[i]=0;\r\n}\r\nfor(int i=0;i<closestTiles.length;i++){\r\nByteListUtils.clear(closestTiles[i]);\r\n}\r\nPlaceUtils.calculatePlace(board,Constant.OPPONENT_ID,Integer.MAX_VALUE,false);\r\nfor(int i=1;;i++){\r\nbyte[] positions=PlaceUtils.positions[i];\r\nint l=ByteListUtils.size(positions);\r\nif(l==0){\r\nbreak;\r\n}\r\nfor(int j=0;j<l;j++){\r\nbyte p=ByteListUtils.get(positions,j);\r\nif(i<=Parameter.TILE_MAX_DISTANCE){\r\nPlaceUtils.setDone(prunedTileFirstIteration,p);\r\n}\r\nByteListUtils.add(closestTiles[Constant.OPPONENT_ID],p);\r\n}\r\n}\r\nPlaceUtils.calculatePlace(board,Constant.PLAYER_ID,Integer.MAX_VALUE,false);\r\nfor(int i=1;;i++){\r\nbyte[] positions=PlaceUtils.positions[i];\r\nint l=ByteListUtils.size(positions);\r\nif(l==0){\r\nbreak;\r\n}\r\nfor(int j=0;j<l;j++){\r\nbyte p=ByteListUtils.get(positions,j);\r\nByteListUtils.add(closestTiles[Constant.PLAYER_ID],p);\r\n}\r\n}\r\n}\r\n}\r\n\r\nclass FirstRoundUtils{\r\npublic static void proceed(){\r\nif(Constant.isFirstRound()){\r\nMapUtils.initCache();\r\nGarbageCollectorUtils.avoidTimeOut();\r\n}\r\n}\r\n}\r\n\r\nclass MinMaxAlphaBetaCalculateSearcher{\r\nstatic final Logger logger=Logger.getLogger(MinMaxAlphaBetaCalculateSearcher.class);\r\nstatic MinMaxAlphaBetaCalculateSearcher instance=new MinMaxAlphaBetaCalculateSearcher();\r\npublic boolean log=Parameter.LOG;\r\nboolean timeOut=false;\r\nboolean increaseFirstOpponentMoveNb;\r\nMinMaxAlphaBetaCalculateSearcher(){}\r\npublic static MinMaxAlphaBetaCalculateSearcher getInstance(){\r\nreturn instance;\r\n}\r\ndouble minTurn(int[] state,int depth,double alpha,double beta,boolean first)\r\nthrows TimeOutException{\r\nif(stop(state,depth)){\r\nif(timeOut){\r\nTimeOutUtils.stopTimeException();\r\n}\r\nreturn ScoreUtils.calculateScore(state,depth,Constant.OPPONENT_ID);\r\n}\r\nBoardUtils.initChild(state,Constant.OPPONENT_ID,first);\r\nint childNb=BoardUtils.getChildNb(state);\r\nif(childNb==0){\r\nreturn ScoreUtils.MAX_SCORE*(depth+1);\r\n}\r\nint childStartIndex=BoardUtils.getChildStartIndex(state);\r\nfor(int i=childStartIndex;i<childStartIndex+childNb;i++){\r\nint[] childState=BoardCache.getWay(i);\r\ndouble val=maxTurn(childState,depth-1,alpha,beta);\r\nif(val<beta){\r\nbeta=val;\r\n}\r\nif(alpha>=beta){\r\nbreak;\r\n}\r\n}\r\nreturn beta;\r\n}\r\ndouble maxTurn(int[] state,int depth,double alpha,double beta)\r\nthrows TimeOutException{\r\nif(stop(state,depth)){\r\nif(timeOut){\r\nTimeOutUtils.stopTimeException();\r\n}\r\nreturn ScoreUtils.calculateScore(state,depth,Constant.PLAYER_ID);\r\n}\r\nBoardUtils.initChild(state,Constant.PLAYER_ID,false);\r\nint childNb=BoardUtils.getChildNb(state);\r\nif(childNb==0){\r\nreturn -ScoreUtils.MAX_SCORE*(depth+1);\r\n}\r\nint childStartIndex=BoardUtils.getChildStartIndex(state);\r\nfor(int i=childStartIndex;i<childStartIndex+childNb;i++){\r\nint[] childState=BoardCache.getWay(i);\r\ndouble val=minTurn(childState,depth-1,alpha,beta,false);\r\nif(alpha<val){\r\nalpha=val;\r\n}\r\nif(alpha>=beta){\r\nbreak;\r\n}\r\n}\r\nreturn alpha;\r\n}\r\nboolean stop(int[] currentMapAll,int depth){\r\nreturn depth<=0;\r\n}\r\nvoid increaseFirstOpponentMoveNb(){\r\nif(Constant.ROUND==Parameter.INCREASE_FIRST_OPPONENT_MOVE_NB_ROUND){\r\nincreaseFirstOpponentMoveNb=true;\r\n}\r\n}\r\npublic int minimax(int depth,int[] gameState){\r\nTilePruningUtils.initPrunedTileFirstIteration(gameState);\r\nincreaseFirstOpponentMoveNb();\r\nBoardCache.reset();\r\nIslandUtils.calculateIsland(gameState);\r\nint ret=-1;\r\ntry{\r\ntimeOut=false;\r\nret=minimaxNoTimeOut(depth,gameState);\r\n}catch(TimeOutException e){\r\nthrow new IllegalStateException();\r\n}catch(NoMoreBoardException e){\r\nthrow new IllegalStateException();\r\n}\r\ntimeOut=Parameter.MIN_MAX_TIME_OUT;\r\nif(!timeOut){\r\nreturn ret;\r\n}\r\ntry{\r\nint lastCacheIndex=BoardCache.getIndex();\r\nwhile(timeOut){\r\ndepth++;\r\nret=minimaxTimeOut(depth,gameState);\r\nif(lastCacheIndex==BoardCache.getIndex()){\r\n\r\nbreak;\r\n}\r\nlastCacheIndex=BoardCache.getIndex();\r\n}\r\n}catch(TimeOutException e){\r\n\r\n}catch(NoMoreBoardException e){\r\n\r\n}\r\nBoardCache.printIndex();\r\nreturn ret;\r\n}\r\npublic int minimaxNoTimeOut(int depth,int[] state)throws TimeOutException{\r\nDouble bestScoreTmp=null;\r\nInteger bestSuccessorTmp=null;\r\nBoardUtils.reset(state);\r\nBoardUtils.initChild(state,Constant.PLAYER_ID,true);\r\nint childNb=BoardUtils.getChildNb(state);\r\n\r\nint childStartIndex=BoardUtils.getChildStartIndex(state);\r\nfor(int i=childStartIndex;i<childStartIndex+childNb;i++){\r\nint[] childState=BoardCache.getWay(i);\r\nif(log){\r\n\r\n}\r\ndouble val =\r\nminTurn(\r\nchildState,\r\ndepth,\r\nDouble.NEGATIVE_INFINITY,\r\nDouble.POSITIVE_INFINITY,\r\nincreaseFirstOpponentMoveNb);\r\nif(log){\r\n\r\n}\r\nif(bestScoreTmp==null||val>bestScoreTmp){\r\nif(log){\r\n\r\n}\r\nbestSuccessorTmp=i;\r\nbestScoreTmp=val;\r\n}\r\n}\r\nlogWin(bestScoreTmp);\r\nreturn bestSuccessorTmp;\r\n}\r\npublic int minimaxTimeOut(int depth,int[] state)throws TimeOutException{\r\nDouble bestScoreTmp=null;\r\nInteger bestSuccessorTmp=null;\r\nint childNb=BoardUtils.getChildNb(state);\r\n\r\nint childStartIndex=BoardUtils.getChildStartIndex(state);\r\nfor(int i=childStartIndex;i<childStartIndex+childNb;i++){\r\nint[] childState=BoardCache.getWay(i);\r\ndouble val =\r\nminTurn(\r\nchildState,\r\ndepth,\r\nDouble.NEGATIVE_INFINITY,\r\nDouble.POSITIVE_INFINITY,\r\nincreaseFirstOpponentMoveNb);\r\nif(bestScoreTmp==null||val>bestScoreTmp){\r\nbestSuccessorTmp=i;\r\nbestScoreTmp=val;\r\n}\r\n}\r\nlogWin(bestScoreTmp);\r\nreturn bestSuccessorTmp;\r\n}\r\nstatic boolean win;\r\nvoid logWin(Double bestScoreTmp){\r\nif(bestScoreTmp>=ScoreUtils.MAX_SCORE){\r\n\r\nwin=true;\r\n}else if(bestScoreTmp<=-ScoreUtils.MAX_SCORE){\r\n\r\n}\r\n}\r\n}\r\n\r\nclass NextMoveUtils{\r\nstatic Logger logger=Logger.getLogger(NextMoveUtils.class);\r\npublic static String proceed(){\r\nFirstRoundUtils.proceed();\r\nint[] board=Game.getInstance().getBoard();\r\n\r\nincreaseDepth();\r\nint index=MinMaxAlphaBetaCalculateSearcher.getInstance().minimax(Parameter.DEPTH,board);\r\nint[] bestWay=BoardCache.getWay(index);\r\nint bestMove=BoardUtils.getTeamPosition(bestWay,Constant.PLAYER_ID);\r\nint bestTile=BoardUtils.getLastTile(bestWay);\r\nBoardUtils.move(board,bestMove,bestTile,Constant.PLAYER_ID);\r\nTimeOutUtils.time=Parameter.TIME_OUT;\r\nreturn PointUtils.toXYString(bestMove)+\" \"+PointUtils.toXYString(bestTile);\r\n}\r\nstatic void increaseDepth(){\r\nif(Constant.ROUND==Parameter.INCREASE_DEPTH_ROUND){\r\nParameter.DEPTH++;\r\n}\r\n}\r\n}\r\n\r\nclass Constant{\r\npublic static int PLAYER_ID;\r\npublic static int OPPONENT_ID;\r\npublic static int ROUND;\r\npublic static boolean isFirstRound(){\r\nreturn ROUND==1;\r\n}\r\n}\r\n\r\nclass Parameter{\r\npublic static final int AVOID_TIME_OUT_NB=0;\r\npublic static int FIRST_ROUND_TIME_OUT=950;\r\npublic static int TIME_OUT=95;\r\npublic static final boolean REMOVE_LOG=true;\r\npublic static final boolean REMOVE_ASSERT=true;\r\npublic static int BOARD_CACHE_NB=800_000;\r\npublic static boolean LOG=false;\r\npublic static final int BOSS_NB=2;\r\npublic static boolean MIN_MAX_TIME_OUT=BOSS_NB==3;\r\npublic static final int TILE_LIMIT_NB2=9;\r\npublic static final boolean LIMIT_ONLY_FIRST_DEPTH=true;\r\npublic static final int INCREASE_DEPTH_ROUND=BOSS_NB==3?10:-1;\r\npublic static final int INCREASE_FIRST_OPPONENT_MOVE_NB_ROUND=15;\r\npublic static int TILE_LIMIT_NB=20;\r\npublic static int LIMIT_WAY=3;\r\npublic static final int TILE_MAX_DISTANCE=3;\r\npublic static int SCORE_EVALUATION=BOSS_NB==1?7:3;\r\npublic static int DEPTH=BOSS_NB==3?1:0;\r\npublic static double[] BEST_POWS ={0,0.75,1,1.15,1,0.75,0.75,0};\r\npublic static double POW=BEST_POWS[SCORE_EVALUATION];\r\n}\r\n\r\nclass Pow{\r\nstatic final double[] POWS0_9=new double[50];\r\nstatic{\r\nfor(int i=0;i<POWS0_9.length;i++){\r\nPOWS0_9[i]=Math.pow(Parameter.POW,i);\r\n}\r\n}\r\npublic static  void init(){\r\nfor(int i=0;i<POWS0_9.length;i++){\r\nPOWS0_9[i]=Math.pow(Parameter.POW,i);\r\n}\r\n}\r\npublic static double getPow(int i){\r\nreturn POWS0_9[i];\r\n}\r\n}\r\n\r\nclass AllUtils{\r\nstatic Logger logger=Logger.getLogger(AllUtils.class);\r\npublic static void copy(int[] source,int[] destination){\r\nSystem.arraycopy(source,0,destination,0,source.length);\r\n}\r\npublic static String toString(Object... p){\r\nStringBuilder str=new StringBuilder();\r\nint i=0;\r\nfor(Object o:p){\r\nstr.append(o==null?\"null\":o.toString());\r\nif(++i<p.length){\r\nstr.append(\" \");\r\n}\r\n}\r\nreturn str.toString();\r\n}\r\n}\r\n\r\nclass AssertUtils{\r\nstatic Logger logger=Logger.getLogger(AssertUtils.class);\r\npublic static void test(boolean b,Object... o){\r\nif(!b){\r\nString str=AllUtils.toString(o);\r\n\r\nthrow new IllegalStateException(str);\r\n}\r\n}\r\n}\r\n\r\nclass ByteUtils{\r\npublic static byte[] copy(byte[] s){\r\nbyte[] d=new byte[s.length];\r\nSystem.arraycopy(s,0,d,0,s.length);\r\nreturn d;\r\n}\r\npublic static byte[] copy(byte[] array,int length){\r\nbyte[] newArray=new byte[length];\r\nSystem.arraycopy(array,0,newArray,0,length);\r\nreturn newArray;\r\n}\r\npublic static void copy(byte[] s,byte[] d){\r\nSystem.arraycopy(s,0,d,0,s.length);\r\n}\r\npublic static void copy(byte[] s,byte[] d,int start){\r\nSystem.arraycopy(s,0,d,start,s.length);\r\n}\r\n}\r\n\r\nenum Direction{\r\nUP(0,-1,4),\r\nDOWN(0,1,1),\r\nLEFT(-1,0,2),\r\nRIGHT(1,0,3),\r\nUL(-1,-1,5),\r\nUR(1,-1,6),\r\nDL(-1,1,7),\r\nDR(1,1,8);\r\nbyte num;\r\nint x;\r\nint y;\r\nstatic Direction[] numToDirection;\r\nstatic boolean initialized;\r\npublic static void init(){\r\nif(initialized){\r\nreturn;\r\n}\r\ninitialized=true;\r\nnumToDirection=new Direction[Direction.values().length+1];\r\nDirection[] values=Direction.values();\r\nfor(int i=0;i<values.length;i++){\r\nDirection value=values[i];\r\nnumToDirection[value.getNum()]=value;\r\n}\r\n}\r\nDirection(int x,int y,int num){\r\nthis.x=x;\r\nthis.y=y;\r\nthis.num=(byte)num;\r\n}\r\npublic byte getNum(){\r\nreturn num;\r\n}\r\npublic int getX(){\r\nreturn x;\r\n}\r\npublic int getY(){\r\nreturn y;\r\n}\r\npublic Direction getOpposite(){\r\nswitch(this){\r\ncase LEFT:\r\nreturn Direction.RIGHT;\r\ncase RIGHT:\r\nreturn Direction.LEFT;\r\ncase UP:\r\nreturn Direction.DOWN;\r\ncase DOWN:\r\nreturn Direction.UP;\r\ncase UL:\r\nreturn Direction.DR;\r\ncase UR:\r\nreturn Direction.DL;\r\ncase DR:\r\nreturn Direction.UL;\r\ncase DL:\r\nreturn Direction.UR;\r\ndefault:\r\nthrow new IllegalStateException();\r\n}\r\n}\r\npublic static Direction fromNum(byte num){\r\nreturn numToDirection[num];\r\n}\r\npublic boolean is(byte num){\r\nreturn num==this.num;\r\n}\r\n}\r\n\r\nclass DirectionUtils{\r\npublic static int construct(int index,Direction dir){\r\nint x=PointUtils.getX(index)+dir.getX();\r\nint y=PointUtils.getY(index)+dir.getY();\r\nif(PointUtils.isIn(x,y)){\r\nreturn PointUtils.getPosition(x,y);\r\n}\r\nreturn FrameworkConstant.OUT;\r\n}\r\n}\r\n\r\nclass FrameworkConstant{\r\npublic static int HEIGHT=9;\r\npublic static int WIDTH=9;\r\npublic static int CASE_NB=HEIGHT*WIDTH;\r\npublic static byte[] MAP;\r\npublic static final int CENTER=PointUtils.getPosition(WIDTH/2,HEIGHT/2);\r\npublic static final byte OUT=-1;\r\n}\r\n\r\nclass GarbageCollectorUtils{\r\nstatic Logger logger=Logger.getLogger(GarbageCollectorUtils.class);\r\nstatic int lastRoundGC=0;\r\nstatic final int BETWEEN_GC_ROUND_NB=20;\r\nstatic final int AVOID_TIME_OUT_NB=2000000;\r\nstatic long start;\r\npublic static void garbageCollect(int round){\r\ngarbageCollect(round,true);\r\n}\r\npublic static void avoidTimeOut(){\r\nStringBuilder[] FOR_ALLOC=new StringBuilder[AVOID_TIME_OUT_NB];\r\nfor(int i=0;i<AVOID_TIME_OUT_NB;i++){\r\nFOR_ALLOC[i]=new StringBuilder();\r\n}\r\nFOR_ALLOC=null;\r\ngarbageCollect(0);\r\n}\r\npublic static void garbageCollect(int round,boolean force){\r\nif(force||round-lastRoundGC>20){\r\nSystem.err.println(\r\n(Timer.getInstance().getTime())\r\n+\"GARBAGE COLECTOR START \"\r\n+Runtime.getRuntime().freeMemory());\r\nSystem.gc();\r\nSystem.err.println(\r\n(Timer.getInstance().getTime())\r\n+\"GARBAGE COLECTOR END \"\r\n+Runtime.getRuntime().freeMemory());\r\nlastRoundGC=round;\r\n}\r\n}\r\npublic static void initFreeMemory(){\r\nstart=Runtime.getRuntime().freeMemory();\r\n}\r\npublic static void printUsedMemory(){\r\n\r\n}\r\n}\r\n\r\nclass ByteListUtils{\r\npublic static void add(byte[] array,byte p){\r\narray[size(array)+1]=p;\r\narray[0]++;\r\n}\r\npublic static void remove(byte[] array,byte p){\r\nboolean remove=false;\r\nfor(byte i=0;i<size(array);i++){\r\nbyte value=get(array,i);\r\nif(remove){\r\nset(array,(byte)(i-1),value);\r\n}else if(value==p){\r\nremove=true;\r\n}\r\n}\r\nif(remove){\r\narray[0]--;\r\n}\r\n}\r\npublic static void removeByIndex(byte[] array,int index){\r\nboolean remove=false;\r\nfor(byte i=0;i<size(array);i++){\r\nif(remove){\r\nbyte value=get(array,i);\r\nset(array,(byte)(i-1),value);\r\n}else if(i==index){\r\nremove=true;\r\n}\r\n}\r\nif(remove){\r\narray[0]--;\r\n}\r\n}\r\npublic static void clear(byte[] array){\r\narray[0]=0;\r\n}\r\npublic static byte size(byte[] array){\r\nreturn array[0];\r\n}\r\npublic static boolean isEmpty(byte[] array){\r\nreturn size(array)==0;\r\n}\r\npublic static byte get(byte[] array,int i){\r\nreturn array[i+1];\r\n}\r\npublic static void set(byte[] array,byte i,byte newValue){\r\narray[i+1]=newValue;\r\n}\r\npublic static boolean contains(byte[] array,byte i){\r\nfor(byte j=0;j<size(array);j++){\r\nif(get(array,j)==i){\r\nreturn true;\r\n}\r\n}\r\nreturn false;\r\n}\r\npublic static byte[] cut(byte[] array){\r\nbyte[] tmp=new byte[size(array)];\r\nSystem.arraycopy(array,1,tmp,0,tmp.length);\r\nreturn tmp;\r\n}\r\npublic static void copy(byte[] source,byte[] destination){\r\nSystem.arraycopy(source,0,destination,0,size(source)+1);\r\n}\r\npublic static byte getLast(byte[] array){\r\nbyte size=size(array);\r\n\r\nreturn get(array,(byte)(size-1));\r\n}\r\npublic static String toString(byte[] array){\r\nreturn Arrays.toString(cut(array));\r\n}\r\n}\r\n\r\nclass Logger{\r\nenum Level{\r\nDEBUG,\r\nERROR,\r\nNONE;\r\n}\r\nstatic String[] tmp ={\r\n};\r\nstatic Map<String,String> map=new HashMap<>();\r\n{\r\nfor(int i=0;i<tmp.length;i+=2){\r\nmap.put(tmp[i],tmp[i+1]);\r\n}\r\n}\r\npublic static Level level=Level.ERROR;\r\nLevel levelSpecific;\r\nClass<?> clazz;\r\nLogger(Class<?> clazz){\r\nthis.clazz=clazz;\r\n}\r\npublic static Logger getLogger(Class<?> clazz){\r\nreturn new Logger(clazz);\r\n}\r\npublic static Logger getLogger(Class<?> clazz,Level levelSpecific){\r\nLogger ret=new Logger(clazz);\r\nret.levelSpecific=levelSpecific;\r\nreturn ret;\r\n}\r\npublic void error(Object... s){\r\nprint(s);\r\n}\r\npublic void debug(Object... s){\r\nif(getLevel()==Level.DEBUG){\r\nprint(s);\r\n}\r\n}\r\nstatic StringBuilder sb=new StringBuilder(5000);\r\npublic void print(Object... s){\r\nif(getLevel()==Level.NONE){\r\nreturn;\r\n}\r\nsb.delete(0,sb.length());\r\nsb.append(Timer.getInstance().getTime());\r\nsb.append(\" \");\r\nsb.append(clazz.getSimpleName());\r\nsb.append(\":\");\r\nint i=0;\r\nfor(Object o:s){\r\nsb.append(o==null?\"null\":o.toString());\r\nif(++i<s.length){\r\nsb.append(\" \");\r\n}\r\n}\r\nSystem.err.println(sb);\r\n}\r\nLevel getLevel(){\r\nif(levelSpecific==null||level==Level.NONE){\r\nreturn level;\r\n}\r\nreturn levelSpecific;\r\n}\r\n}\r\n\r\nclass Timer{\r\nstatic Timer instance=new Timer();\r\nlong timeStart;\r\nTimer(){}\r\npublic static Timer getInstance(){\r\nreturn instance;\r\n}\r\npublic void init(){\r\ntimeStart=System.currentTimeMillis();\r\n}\r\npublic long getTime(){\r\nreturn System.currentTimeMillis()-timeStart;\r\n}\r\n}\r\n\r\nclass MapUtils{\r\nstatic Logger logger=Logger.getLogger(MapUtils.class);\r\nstatic final byte[][] CACHE_AROUND_POSITIONS=new byte[FrameworkConstant.CASE_NB][];\r\nstatic final byte[][] CACHE_SPIRAL_POSITIONS=new byte[FrameworkConstant.CASE_NB][];\r\npublic static byte[] getAroundPositions(int p){\r\nreturn CACHE_AROUND_POSITIONS[p];\r\n}\r\npublic static byte[] getSpiralPositions(int p){\r\nreturn CACHE_SPIRAL_POSITIONS[p];\r\n}\r\npublic static void initCache(){\r\nDirection.init();\r\nfor(byte i=0;i<FrameworkConstant.CASE_NB;i++){\r\ncalculateAroundPositions(i);\r\ncalculateSpiralPositions(i);\r\n}\r\n}\r\nstatic void calculateAroundPositions(int p){\r\nDirection[] dirs=Direction.values();\r\nbyte[] ret=new byte[dirs.length];\r\nint index=0;\r\nfor(int i=0;i<dirs.length;i++){\r\nDirection direction=dirs[i];\r\nint p2=DirectionUtils.construct(p,direction);\r\nif(p2!=FrameworkConstant.OUT){\r\nret[index++]=(byte)p2;\r\n}\r\n}\r\nCACHE_AROUND_POSITIONS[p]=ByteUtils.copy(ret,index);\r\n}\r\nstatic void calculateSpiralPositions(int p){\r\nbyte[] ret=new byte[FrameworkConstant.CASE_NB-1];\r\nint index=0;\r\nfor(int i=0;i<FrameworkConstant.CASE_NB;i++){\r\nif(i!=p&&PointUtils.distance(i,p)<=Parameter.TILE_MAX_DISTANCE){\r\nret[index++]=(byte)i;\r\n}\r\n}\r\nbyte[] cut=new byte[index];\r\nSystem.arraycopy(ret,0,cut,0,index);\r\nbubbleSort(cut,p);\r\nCACHE_SPIRAL_POSITIONS[p]=cut;\r\n}\r\npublic static void main(String[] args){\r\ninitCache();\r\n}\r\nstatic void bubbleSort(byte arr[],int p){\r\nint n=arr.length;\r\nfor(int i=0;i<n-1;i++)\r\nfor(int j=0;j<n-i-1;j++)\r\nif(value(arr[j],p)>value(arr[j+1],p)){\r\nbyte temp=arr[j];\r\narr[j]=arr[j+1];\r\narr[j+1]=temp;\r\n}\r\n}\r\nstatic int value(byte pos,int p){\r\nreturn PointUtils.distance2(pos,FrameworkConstant.CENTER)\r\n+100\r\n*(PointUtils.distance(pos,FrameworkConstant.CENTER)\r\n+100*PointUtils.distance(pos,p));\r\n}\r\n}\r\n\r\nclass Point{\r\nint x;\r\nint y;\r\npublic Point(){}\r\npublic Point(int x,int y){\r\nthis.x=x;\r\nthis.y=y;\r\n}\r\npublic int getX(){\r\nreturn x;\r\n}\r\npublic void setX(int x){\r\nthis.x=x;\r\n}\r\npublic int getY(){\r\nreturn y;\r\n}\r\npublic void setY(int y){\r\nthis.y=y;\r\n}\r\npublic void copy(Point p){\r\nx=p.x;\r\ny=p.y;\r\n}\r\nboolean isIn(){\r\nreturn x>=0&&x<FrameworkConstant.WIDTH&&y>=0&&y<FrameworkConstant.HEIGHT;\r\n}\r\n@Override public int hashCode(){\r\nfinal int prime=31;\r\nint result=1;\r\nresult=prime*result+x;\r\nresult=prime*result+y;\r\nreturn result;\r\n}\r\n@Override public boolean equals(Object obj){\r\nif(this==obj)return true;\r\nif(obj==null)return false;\r\nif(getClass()!=obj.getClass())return false;\r\nPoint other=(Point)obj;\r\nif(x!=other.x)return false;\r\nif(y!=other.y)return false;\r\nreturn true;\r\n}\r\n@Override public String toString(){\r\nreturn \"(\"+x+\",\"+y+\")\";\r\n}\r\npublic String toInputString(){\r\nreturn x+\" \"+y;\r\n}\r\n}\r\n\r\nclass PointUtils{\r\nstatic final Point[] CACHE_POINT=new Point[FrameworkConstant.CASE_NB];\r\npublic static Point toPoint(int p){\r\nint index=p;\r\nPoint ret=CACHE_POINT[index];\r\nif(ret==null){\r\nret=new Point(getX(p),getY(p));\r\nCACHE_POINT[index]=ret;\r\n}\r\nreturn ret;\r\n}\r\npublic static List<Point> toPoint(byte[] way){\r\nreturn IntStream.range(0,way.length)\r\n.mapToObj(i->way[i])\r\n.map(i->toPoint(i))\r\n.collect(Collectors.toList());\r\n}\r\npublic static List<Point> toPoint(Collection<Byte> way){\r\nreturn way.stream().map(i->toPoint(i)).collect(Collectors.toList());\r\n}\r\npublic static int getPosition(Scanner in){\r\nint x=in.nextInt();\r\nint y=in.nextInt();\r\nif(x==-1){\r\nreturn FrameworkConstant.OUT;\r\n}\r\nreturn getPosition(x,y);\r\n}\r\npublic static int getPosition(int x,int y){\r\nreturn x+FrameworkConstant.WIDTH*y;\r\n}\r\npublic static int distance(int p1,int p2){\r\nreturn Math.max(getDeltaX(p1,p2),getDeltaY(p1,p2));\r\n}\r\npublic static int distance2(int p1,int p2){\r\nreturn getDeltaX(p1,p2)+getDeltaY(p1,p2);\r\n}\r\nstatic int getDeltaX(int p1,int p2){\r\nreturn Math.abs(getX(p1)-getX(p2));\r\n}\r\nstatic int getDeltaY(int p1,int p2){\r\nreturn Math.abs(getY(p1)-getY(p2));\r\n}\r\npublic static boolean isNextTo(int p1,int p2){\r\nreturn distance(p1,p2)<=1;\r\n}\r\npublic static int getX(int p){\r\nreturn p%FrameworkConstant.WIDTH;\r\n}\r\npublic static int getY(int p){\r\nreturn p/FrameworkConstant.WIDTH;\r\n}\r\npublic static String toXYString(int p){\r\nreturn getX(p)+\" \"+getY(p);\r\n}\r\npublic static boolean isIn(int x,int y){\r\nreturn x>=0&&x<FrameworkConstant.WIDTH&&y>=0&&y<FrameworkConstant.HEIGHT;\r\n}\r\n}\r\n\r\nclass TimeOutException extends Exception{}\r\n\r\nclass TimeOutUtils{\r\npublic static int time=Parameter.FIRST_ROUND_TIME_OUT;\r\nstatic Timer timer=Timer.getInstance();\r\npublic static final TimeOutException EXCEPTION=new TimeOutException();\r\npublic static int count;\r\npublic static void init(){\r\ntime=Parameter.TIME_OUT;\r\n}\r\npublic static void stopTimeException()throws TimeOutException{\r\nif(isStopTime()){\r\nthrow EXCEPTION;\r\n}\r\n}\r\npublic static boolean isStopTime(){\r\nreturn timer.getTime()>=time;\r\n}\r\n}\r\n\r\n",
          "testCases": [],
          "maxPlayers": 2,
          "minPlayers": 2,
          "statements": {
            "1": "<div\n\tstyle=\"color: #000000; background-color: rgba(255, 255, 255, 0.5); padding: 20px; margin-bottom: 10px; text-align: left\">\n\tThis is a port of the board game <a\n\t\thref=\"https://fr.wikipedia.org/wiki/Isola_(jeu)\">Isola</a> :\n\t<br /> <br />\n\t<p style=\"text-align: center;\">\n\t\t<img\n\t\t\tsrc=\"https://github.com/wala-fr/CodingameIsolation/blob/master/CodingameIsolation/src/main/resources/view/statement/isola_statement.png?raw=true\"\n\t\t\tstyle=\"height: 200px; width: auto;\"></img>\n\t</p>\n\t<p>\n\t\tThe source code of this game is available <a rel=\"nofollow\"\n\t\t\ttarget=\"_blank\" href=\"https://github.com/wala-fr/CodingameIsola\">on\n\t\t\tthis GitHub repo</a>. <br />\n</div>\n\n<div id=\"statement_back\" class=\"statement_back\" style=\"display: none\"></div>\n<div class=\"statement-body\">\n\t<!-- GOAL -->\n\t<div class=\"statement-section statement-goal\">\n\t\t<h1>\n\t\t\t<span class=\"icon icon-goal\">&nbsp;</span> <span>The Goal</span>\n\t\t</h1>\n\t\t<div class=\"statement-goal-content\">The goal of the game is to\n\t\t\tblock the opponent's pawn.</div>\n\t</div>\n\t<!-- RULES -->\n\t<div class=\"statement-section statement-rules\">\n\t\t<h1>\n\t\t\t<span class=\"icon icon-rules\">&nbsp;</span> <span>Rules</span>\n\t\t</h1>\n\t\t<div class=\"statement-rules-content\">\n\t\t\t<strong>Board: </strong>\n\t\t\t<ul>\n\t\t\t\t<li>The game is played on a <const>9 x 9</const> board.\n\t\t\t\t</li>\n\t\t\t\t<li>Player 0 always starts at <const>(0, 4)</const> and player\n\t\t\t\t\t1 at <const>(8, 4)</const>.\n\t\t\t\t</li>\n\t\t\t</ul>\n\t\t\t<strong>At each turn: </strong><br>\n\t\t\t<ol>\n\t\t\t\t<li>You must <b>move your pawn</b> to an adjacent tile\n\t\t\t\t\t(diagonal included) :<br> <br>\n\n\t\t\t\t\t<p style=\"text-align: center;\">\n\t\t\t\t\t\t<img\n\t\t\t\t\t\t\tsrc=\"https://github.com/wala-fr/CodingameIsolation/blob/master/CodingameIsolation/src/main/resources/view/statement/moves.png?raw=true\"\n\t\t\t\t\t\t\tstyle=\"height: 200px; width: auto;\"></img>\n\t\t\t\t\t</p>You can't :\n\t\t\t\t\t<ul>\n\t\t\t\t\t\t<li>stay put</li>\n\t\t\t\t\t\t<li>move to the tile occupied by the opponent's pawn</li>\n\t\t\t\t\t\t<li>move to an already removed tile.</li>\n\t\t\t\t\t</ul>\n\n\t\t\t\t</li>\n\t\t\t\t<li><b>Then</b> you must <b>remove a free tile</b>.<br />You\n\t\t\t\t\tcan't remove a tile occupied by a pawn.</li>\n\t\t\t</ol>\n\t\t</div>\n\t</div>\n\n\t<!-- Victory conditions -->\n\t<div class=\"statement-victory-conditions\">\n\t\t<div class=\"icon victory\"></div>\n\t\t<div class=\"blk\">\n\t\t\t<div class=\"title\">Victory Conditions</div>\n\t\t\t<div class=\"text\">\n\t\t\t\t<ul style=\"padding-bottom: 0;\">\n\t\t\t\t\t<li>At his turn, the opponent can't move his pawn.</li>\n\t\t\t\t</ul>\n\t\t\t</div>\n\t\t</div>\n\t</div>\n\n\t<!-- Lose conditions -->\n\t<div class=\"statement-lose-conditions\">\n\t\t<div class=\"icon lose\"></div>\n\t\t<div class=\"blk\">\n\t\t\t<div class=\"title\">Loss Conditions</div>\n\t\t\t<div class=\"text\">\n\t\t\t\t<ul style=\"padding-bottom: 0;\">\n\t\t\t\t\t<li>At your turn, you can't move your pawn.</li>\n\t\t\t\t\t<li>You do not respond in time or output an invalid action.</li>\n\t\t\t\t</ul>\n\t\t\t</div>\n\t\t</div>\n\t</div>\n\n\t<!-- PROTOCOL -->\n\t<div class=\"statement-section statement-protocol\">\n\t\t<h1>\n\t\t\t<span class=\"icon icon-protocol\">&nbsp;</span> <span>Game\n\t\t\t\tInput</span>\n\t\t</h1>\n\n\t\t<!-- Protocol block -->\n\t\t<div class=\"blk\">\n\t\t\t<div class=\"title\">Initialization input</div>\n\t\t\t<div class=\"text\">\n\t\t\t\t<span class=\"statement-lineno\">Line 1</span>:\n\t\t\t\t<var>playerPositionX</var>\n\t\t\t\t<br> <span class=\"statement-lineno\">Line 2</span>:\n\t\t\t\t<var>playerPositionY</var>\n\t\t\t\tthe coordinates of your pawn.\n\t\t\t</div>\n\t\t\t<br>\n\t\t\t<div class=\"title\">Input for one game turn</div>\n\t\t\t<div class=\"text\">\n\t\t\t\t<span class=\"statement-lineno\">Line 1</span>:\n\t\t\t\t<var>opponentPositionX</var>\n\t\t\t\t<br> <span class=\"statement-lineno\">Line 2</span>:\n\t\t\t\t<var>opponentPositionY</var>\n\t\t\t\tthe coordinates of the opponent's pawn. <br> <span\n\t\t\t\t\tclass=\"statement-lineno\">Line 3</span>:\n\t\t\t\t<var>opponentLastRemovedTileX</var>\n\t\t\t\t<br> <span class=\"statement-lineno\">Line 4</span>:\n\t\t\t\t<var>opponentLastRemovedTileY</var>\n\t\t\t\tthe coordinates of the last tile removed by the opponent (\n\t\t\t\t<const>-1 -1</const>\n\t\t\t\tif no tile has been removed (first round)). <br>\n\t\t\t</div>\n\t\t</div>\n\n\t\t<!-- Protocol block -->\n\t\t<div class=\"blk\">\n\t\t\t<div class=\"title\">Output</div>\n\t\t\t<div class=\"text\">\n\t\t\t\t<span class=\"statement-lineno\">A single line</span> containing the\n\t\t\t\tcoordinates where you want to move your pawn, followed by the\n\t\t\t\tcoordinates of the tile you want to remove.<br>Example:\n\t\t\t\t<action>1 4 7 4</action>\n\t\t\t\t<br> You can also add a message :<br> Example:\n\t\t\t\t<action>1 4 7 4;MESSAGE</action>\n\t\t\t\t<br> NB : You can print\n\t\t\t\t<action>RANDOM</action>\n\t\t\t\tinstead of the 4 coordinates. Then a random possible move and tile\n\t\t\t\twill be chosen.\n\t\t\t</div>\n\t\t</div>\n\n\t\t<!-- Protocol block -->\n\t\t<div class=\"blk\">\n\t\t\t<div class=\"title\">Constraints</div>\n\t\t\tResponse time first turn is &le;\n\t\t\t<const>1000</const>\n\t\t\tms. <br>Response time per turn is &le;\n\t\t\t<const>100</const>\n\t\t\tms.\n\t\t</div>\n\t</div>\n</div>",
            "2": "<div\n\tstyle=\"color: #000000; background-color: rgba(255, 255, 255, 0.5); padding: 20px; margin-bottom: 10px; text-align: left\">\n\tThis is a port of the board game <a\n\t\thref=\"https://fr.wikipedia.org/wiki/Isola_(jeu)\">Isola</a> :\n\t<br /> <br />\n\t<p style=\"text-align: center;\">\n\t\t<img\n\t\t\tsrc=\"https://github.com/wala-fr/CodingameIsolation/blob/master/CodingameIsolation/src/main/resources/view/statement/isola_statement.png?raw=true\"\n\t\t\tstyle=\"height: 200px; width: auto;\"></img>\n\t</p>\n\t<p>\n\t\tThe source code of this game is available <a rel=\"nofollow\"\n\t\t\ttarget=\"_blank\" href=\"https://github.com/wala-fr/CodingameIsola\">on\n\t\t\tthis GitHub repo</a>. <br />\n</div>\n\n<div id=\"statement_back\" class=\"statement_back\" style=\"display: none\"></div>\n<div class=\"statement-body\">\n\t<!-- GOAL -->\n\t<div class=\"statement-section statement-goal\">\n\t\t<h1>\n\t\t\t<span class=\"icon icon-goal\">&nbsp;</span> <span>The Goal</span>\n\t\t</h1>\n\t\t<div class=\"statement-goal-content\">The goal of the game is to\n\t\t\tblock the opponent's pawn.</div>\n\t</div>\n\t<!-- RULES -->\n\t<div class=\"statement-section statement-rules\">\n\t\t<h1>\n\t\t\t<span class=\"icon icon-rules\">&nbsp;</span> <span>Rules</span>\n\t\t</h1>\n\t\t<div class=\"statement-rules-content\">\n\t\t\t<strong>Board: </strong>\n\t\t\t<ul>\n\t\t\t\t<li>The game is played on a <const>9 x 9</const> board.\n\t\t\t\t</li>\n\t\t\t\t<li>Player 0 always starts at <const>(0, 4)</const> and player\n\t\t\t\t\t1 at <const>(8, 4)</const>.\n\t\t\t\t</li>\n\t\t\t</ul>\n\t\t\t<strong>At each turn: </strong><br>\n\t\t\t<ol>\n\t\t\t\t<li>You must <b>move your pawn</b> to an adjacent tile\n\t\t\t\t\t(diagonal included) :<br> <br>\n\n\t\t\t\t\t<p style=\"text-align: center;\">\n\t\t\t\t\t\t<img\n\t\t\t\t\t\t\tsrc=\"https://github.com/wala-fr/CodingameIsolation/blob/master/CodingameIsolation/src/main/resources/view/statement/moves.png?raw=true\"\n\t\t\t\t\t\t\tstyle=\"height: 200px; width: auto;\"></img>\n\t\t\t\t\t</p>You can't :\n\t\t\t\t\t<ul>\n\t\t\t\t\t\t<li>stay put</li>\n\t\t\t\t\t\t<li>move to the tile occupied by the opponent's pawn</li>\n\t\t\t\t\t\t<li>move to an already removed tile.</li>\n\t\t\t\t\t</ul>\n\n\t\t\t\t</li>\n\t\t\t\t<li><b>Then</b> you must <b>remove a free tile</b>.<br />You\n\t\t\t\t\tcan't remove a tile occupied by a pawn.</li>\n\t\t\t</ol>\n\t\t</div>\n\t</div>\n\n\t<!-- Victory conditions -->\n\t<div class=\"statement-victory-conditions\">\n\t\t<div class=\"icon victory\"></div>\n\t\t<div class=\"blk\">\n\t\t\t<div class=\"title\">Victory Conditions</div>\n\t\t\t<div class=\"text\">\n\t\t\t\t<ul style=\"padding-bottom: 0;\">\n\t\t\t\t\t<li>At his turn, the opponent can't move his pawn.</li>\n\t\t\t\t</ul>\n\t\t\t</div>\n\t\t</div>\n\t</div>\n\n\t<!-- Lose conditions -->\n\t<div class=\"statement-lose-conditions\">\n\t\t<div class=\"icon lose\"></div>\n\t\t<div class=\"blk\">\n\t\t\t<div class=\"title\">Loss Conditions</div>\n\t\t\t<div class=\"text\">\n\t\t\t\t<ul style=\"padding-bottom: 0;\">\n\t\t\t\t\t<li>At your turn, you can't move your pawn.</li>\n\t\t\t\t\t<li>You do not respond in time or output an invalid action.</li>\n\t\t\t\t</ul>\n\t\t\t</div>\n\t\t</div>\n\t</div>\n\n\t<!-- PROTOCOL -->\n\t<div class=\"statement-section statement-protocol\">\n\t\t<h1>\n\t\t\t<span class=\"icon icon-protocol\">&nbsp;</span> <span>Game\n\t\t\t\tInput</span>\n\t\t</h1>\n\n\t\t<!-- Protocol block -->\n\t\t<div class=\"blk\">\n\t\t\t<div class=\"title\">Initialization input</div>\n\t\t\t<div class=\"text\">\n\t\t\t\t<span class=\"statement-lineno\">Line 1</span>:\n\t\t\t\t<var>playerPositionX</var>\n\t\t\t\t<br> <span class=\"statement-lineno\">Line 2</span>:\n\t\t\t\t<var>playerPositionY</var>\n\t\t\t\tthe coordinates of your pawn.\n\t\t\t</div>\n\t\t\t<br>\n\t\t\t<div class=\"title\">Input for one game turn</div>\n\t\t\t<div class=\"text\">\n\t\t\t\t<span class=\"statement-lineno\">Line 1</span>:\n\t\t\t\t<var>opponentPositionX</var>\n\t\t\t\t<br> <span class=\"statement-lineno\">Line 2</span>:\n\t\t\t\t<var>opponentPositionY</var>\n\t\t\t\tthe coordinates of the opponent's pawn. <br> <span\n\t\t\t\t\tclass=\"statement-lineno\">Line 3</span>:\n\t\t\t\t<var>opponentLastRemovedTileX</var>\n\t\t\t\t<br> <span class=\"statement-lineno\">Line 4</span>:\n\t\t\t\t<var>opponentLastRemovedTileY</var>\n\t\t\t\tthe coordinates of the last tile removed by the opponent (\n\t\t\t\t<const>-1 -1</const>\n\t\t\t\tif no tile has been removed (first round)). <br>\n\t\t\t</div>\n\t\t</div>\n\n\t\t<!-- Protocol block -->\n\t\t<div class=\"blk\">\n\t\t\t<div class=\"title\">Output</div>\n\t\t\t<div class=\"text\">\n\t\t\t\t<span class=\"statement-lineno\">A single line</span> containing the\n\t\t\t\tcoordinates where you want to move your pawn, followed by the\n\t\t\t\tcoordinates of the tile you want to remove.<br>Example:\n\t\t\t\t<action>1 4 7 4</action>\n\t\t\t\t<br> You can also add a message :<br> Example:\n\t\t\t\t<action>1 4 7 4;MESSAGE</action>\n\t\t\t\t<br> NB : You can print\n\t\t\t\t<action>RANDOM</action>\n\t\t\t\tinstead of the 4 coordinates. Then a random possible move and tile\n\t\t\t\twill be chosen.\n\t\t\t</div>\n\t\t</div>\n\n\t\t<!-- Protocol block -->\n\t\t<div class=\"blk\">\n\t\t\t<div class=\"title\">Constraints</div>\n\t\t\tResponse time first turn is &le;\n\t\t\t<const>1000</const>\n\t\t\tms. <br>Response time per turn is &le;\n\t\t\t<const>100</const>\n\t\t\tms.\n\t\t</div>\n\t</div>\n</div>"
          },
          "questionType": "multi",
          "stubGenerator": "read playerPositionX:int\nread playerPositionY:int\ngameloop\nread opponentPositionX:int\nread opponentPositionY:int\nread opponentLastRemovedTileX:int\nread opponentLastRemovedTileY:int\nwrite RANDOM;MESSAGE\n\nINPUT\nplayerPositionY:player's coordinates.\nopponentPositionY:opponent's coordinates.\nopponentLastRemovedTileY:coordinates of the last removed tile. (-1 -1) if no tile has been removed.\n",
          "welcomePopups": {
            "1": "<div style=\"text-align:center\">\r\n  <h2>You&#39;ve made it to the next league</h2>\r\n</div>",
            "2": "<div style=\"text-align:center\">\r\n  <h2>You&#39;ve made it to the next league</h2>\r\n</div>"
          },
          "aiCodeExtension": "java",
          "criteriaLanguageMap": {}
        },
        "2": {
          "aiCode": "import java.util.*;\r\nimport java.text.*;\r\nimport java.util.function.*;\r\nimport java.util.stream.*;\r\nimport java.util.concurrent.*;\r\nimport java.util.Map.*;\r\nclass Game{\r\nstatic Logger logger=Logger.getLogger(Game.class);\r\nstatic final Game instance=new Game();\r\nint[] board=BoardUtils.constructBoard();\r\nGame(){}\r\npublic static Game getInstance(){\r\nreturn instance;\r\n}\r\npublic void init(Scanner in){\r\nint playerPositionX=in.nextInt();\r\nint playerPositionY=in.nextInt();\r\nConstant.PLAYER_ID=playerPositionX==0?0:1;\r\nConstant.OPPONENT_ID=1-Constant.PLAYER_ID;\r\nBoardUtils.init(board);\r\n\r\n}\r\npublic void init(int[] board){\r\nthis.board=board;\r\n}\r\npublic void update(Scanner in){\r\nint opponentPosition=PointUtils.getPosition(in);\r\nConstant.ROUND++;\r\nTimer.getInstance().init();\r\n\r\nBoardUtils.setTeamPosition(board,opponentPosition,Constant.OPPONENT_ID);\r\nint opponentLastRemovedTile=PointUtils.getPosition(in);\r\nif(opponentLastRemovedTile!=FrameworkConstant.OUT){\r\nBoardUtils.removeTile(board,opponentLastRemovedTile);\r\n}\r\n}\r\npublic int[] getBoard(){\r\nreturn board;\r\n}\r\n}\r\n\r\nclass Player{\r\npublic static void main(String args[]){\r\nScanner in=new Scanner(System.in);\r\nGame game=Game.getInstance();\r\ngame.init(in);\r\nwhile(true){\r\ngame.update(in);\r\nString action=NextMoveUtils.proceed();\r\nSystem.out.println(action+getMessage());\r\n}\r\n}\r\npublic static String getMessage(){\r\nreturn Parameter.BOSS_NB==3\r\n?\";I'M THE BOSS!!!\"\r\n:Parameter.BOSS_NB==2?\";IT'S OVER!!\":\";YOU'RE DEAD!\";\r\n}\r\n}\r\n\r\nclass Bit128Utils{\r\nstatic final long[] masksLowerN=new long[64];\r\nstatic final long maskCut;\r\nstatic{\r\nlong tmp=0l;\r\nfor(int i=0;i<masksLowerN.length;i++){\r\nmasksLowerN[i]=tmp;\r\ntmp=tmp << 1l;\r\ntmp=tmp |= 1;\r\n}\r\ntmp=0;\r\nfor(int i=0;i<FrameworkConstant.CASE_NB%64;i++){\r\ntmp=tmp|(1l << i);\r\n}\r\nmaskCut=tmp;\r\n}\r\npublic static void shiftLeft(long[] bits,int nb){\r\nbits[1]=((bits[1] << nb)|(bits[0] >>>(64-nb)))&maskCut;\r\nbits[0]=bits[0] << nb;\r\n}\r\npublic static void shiftRight(long[] bits,int nb){\r\nbits[0]=(bits[0] >>> nb)|(bits[1] <<(64-nb));\r\nbits[1]=bits[1] >>> nb;\r\n}\r\npublic static String toBinaryString(long[] bits){\r\nString s=Long.toBinaryString(bits[0]);\r\nif(bits[1]!=0){\r\nwhile(s.length()<64){\r\ns=\"0\"+s;\r\n}\r\ns=Long.toBinaryString(bits[1])+s;\r\n}\r\nreturn s;\r\n}\r\npublic static String shiftLeft(String s,int nb){\r\nif(!s.equals(\"0\")){\r\ns+=new String(new char[nb]).replace(\"\\0\",\"0\");\r\n}\r\nif(s.length()>FrameworkConstant.CASE_NB){\r\ns=s.substring(s.length()-FrameworkConstant.CASE_NB,s.length());\r\n}\r\nreturn s;\r\n}\r\npublic static String shiftRight(String s,int nb){\r\ns=s.substring(0,Math.max(s.length()-nb,0));\r\nif(s.equals(\"\")){\r\ns=\"0\";\r\n}\r\nreturn s;\r\n}\r\npublic static boolean isSet(long[] bits,int nb){\r\nif(nb>=64){\r\nreturn(bits[1]&(1l <<(nb-64)))!=0;\r\n}\r\nreturn(bits[0]&(1l << nb))!=0;\r\n}\r\npublic static void set(long[] bits,int nb){\r\nif(nb>=64){\r\nbits[1]=bits[1]|(1l <<(nb-64));\r\n}else{\r\nbits[0]=bits[0]|(1l << nb);\r\n}\r\n}\r\npublic static void reset(long[] bits,int nb){\r\nif(nb>=64){\r\nbits[1]=bits[1]&~(1l <<(nb-64));\r\n}else{\r\nbits[0]=bits[0]&~(1l << nb);\r\n}\r\n}\r\npublic static void and(long[] bits1,int index1,long[] bits2,int index2){\r\nint tmp=2*index1;\r\nbits1[tmp]=bits1[tmp]&bits2[2*index2];\r\ntmp++;\r\nbits1[tmp]=bits1[tmp]&bits2[2*index1+1];\r\n}\r\npublic static void and(long[] bits1,long[] bits2){\r\nbits1[0]=bits1[0]&bits2[0];\r\nbits1[1]=bits1[1]&bits2[1];\r\n}\r\npublic static void or(long[] bits1,int index1,long[] bits2,int index2){\r\nbits1[2*index1]=bits1[2*index1]|bits2[2*index2];\r\nbits1[2*index1+1]=bits1[2*index1+1]|bits2[2*index2+1];\r\n}\r\npublic static void or(long[] bits1,long[] bits2){\r\nbits1[0]=bits1[0]|bits2[0];\r\nbits1[1]=bits1[1]|bits2[1];\r\n}\r\npublic static void reverse(long[] bits){\r\nbits[0]=~bits[0];\r\nbits[1]=~bits[1]&maskCut;\r\n}\r\n}\r\n\r\nclass BoardBitUtils{\r\nstatic Logger logger=Logger.getLogger(BoardBitUtils.class);\r\npublic static String toString(long[] boards){\r\nStringBuilder sb=new StringBuilder();\r\nsb.append(\"\\n\");\r\nfor(int y=0;y<FrameworkConstant.HEIGHT;y++){\r\nfor(int x=0;x<FrameworkConstant.WIDTH;x++){\r\nint nb=getIndex(x,y);\r\nif(Bit128Utils.isSet( boards,nb)){\r\nsb.append(\"0\");\r\n}else{\r\nsb.append(\".\");\r\n}\r\n}\r\nsb.append(\"\\n\");\r\n}\r\nreturn sb.toString();\r\n}\r\npublic static int getIndex(int x,int y){\r\nreturn FrameworkConstant.WIDTH*y+x;\r\n}\r\nstatic final long[] verticalLeft=new long[2];\r\nstatic final long[] horizontalUp=new long[2];\r\nstatic final long[] diagonalLeftUp=new long[2];\r\nstatic final long[] diagonalLeftDown=new long[2];\r\nstatic final long[] diagonalRightUp=new long[2];\r\nstatic final long[] diagonalRightDown=new long[2];\r\nstatic final long[] horizontalDown=new long[2];\r\nstatic final long[] verticalRight=new long[2];\r\npublic static final long[][] arounds =\r\nnew long[FrameworkConstant.WIDTH*FrameworkConstant.HEIGHT][];\r\nstatic final long[] tmpBoard=new long[2];\r\nstatic final long[] tmpBoard1=new long[2];\r\nstatic final long[] tmpBoard2=new long[2];\r\nstatic final long[] tmpBoard3=new long[2];\r\nstatic final int WIDTH_PLUS_ONE=FrameworkConstant.WIDTH+1;\r\nstatic final int WIDTH_MINUS_ONE=FrameworkConstant.WIDTH-1;\r\nstatic{\r\nfor(int y=0;y<FrameworkConstant.HEIGHT;y++){\r\nfor(int x=1;x<FrameworkConstant.WIDTH;x++){\r\nint nb=getIndex(x,y);\r\nBit128Utils.set(verticalLeft,nb);\r\n}\r\n}\r\nfor(int y=0;y<FrameworkConstant.HEIGHT;y++){\r\nfor(int x=0;x<FrameworkConstant.WIDTH-1;x++){\r\nint nb=getIndex(x,y);\r\nBit128Utils.set(verticalRight,nb);\r\n}\r\n}\r\nfor(int y=1;y<FrameworkConstant.HEIGHT;y++){\r\nfor(int x=0;x<FrameworkConstant.WIDTH;x++){\r\nint nb=getIndex(x,y);\r\nBit128Utils.set(horizontalUp,nb);\r\n}\r\n}\r\nfor(int y=0;y<FrameworkConstant.HEIGHT-1;y++){\r\nfor(int x=0;x<FrameworkConstant.WIDTH;x++){\r\nint nb=getIndex(x,y);\r\nBit128Utils.set(horizontalDown,nb);\r\n}\r\n}\r\nfor(int y=1;y<FrameworkConstant.HEIGHT;y++){\r\nfor(int x=1;x<FrameworkConstant.WIDTH;x++){\r\nint nb=getIndex(x,y);\r\nBit128Utils.set(diagonalLeftUp,nb);\r\n}\r\n}\r\nfor(int y=0;y<FrameworkConstant.HEIGHT-1;y++){\r\nfor(int x=1;x<FrameworkConstant.WIDTH;x++){\r\nint nb=getIndex(x,y);\r\nBit128Utils.set(diagonalLeftDown,nb);\r\n}\r\n}\r\nfor(int y=1;y<FrameworkConstant.HEIGHT;y++){\r\nfor(int x=0;x<FrameworkConstant.WIDTH-1;x++){\r\nint nb=getIndex(x,y);\r\nBit128Utils.set(diagonalRightUp,nb);\r\n}\r\n}\r\nfor(int y=0;y<FrameworkConstant.HEIGHT-1;y++){\r\nfor(int x=0;x<FrameworkConstant.WIDTH-1;x++){\r\nint nb=getIndex(x,y);\r\nBit128Utils.set(diagonalRightDown,nb);\r\n}\r\n}\r\nfor(int y=0;y<FrameworkConstant.HEIGHT;y++){\r\nfor(int x=0;x<FrameworkConstant.WIDTH;x++){\r\nint nb=getIndex(x,y);\r\ntmpBoard1[0]=0;\r\ntmpBoard1[1]=0;\r\ntmpBoard[0]=0;\r\ntmpBoard[1]=0;\r\nBit128Utils.set(tmpBoard,nb);\r\nshiftLeft(tmpBoard);\r\nBit128Utils.or(tmpBoard1,0,tmpBoard,0);\r\ntmpBoard[0]=0;\r\ntmpBoard[1]=0;\r\nBit128Utils.set(tmpBoard,nb);\r\nshiftRight(tmpBoard);\r\nBit128Utils.or(tmpBoard1,0,tmpBoard,0);\r\ntmpBoard[0]=0;\r\ntmpBoard[1]=0;\r\nBit128Utils.set(tmpBoard,nb);\r\nshiftUp(tmpBoard);\r\nBit128Utils.or(tmpBoard1,0,tmpBoard,0);\r\ntmpBoard[0]=0;\r\ntmpBoard[1]=0;\r\nBit128Utils.set(tmpBoard,nb);\r\nshiftDown(tmpBoard);\r\nBit128Utils.or(tmpBoard1,0,tmpBoard,0);\r\ntmpBoard[0]=0;\r\ntmpBoard[1]=0;\r\nBit128Utils.set(tmpBoard,nb);\r\nshiftLeftUp(tmpBoard);\r\nBit128Utils.or(tmpBoard1,0,tmpBoard,0);\r\ntmpBoard[0]=0;\r\ntmpBoard[1]=0;\r\nBit128Utils.set(tmpBoard,nb);\r\nshiftLeftDown(tmpBoard);\r\nBit128Utils.or(tmpBoard1,0,tmpBoard,0);\r\ntmpBoard[0]=0;\r\ntmpBoard[1]=0;\r\nBit128Utils.set(tmpBoard,nb);\r\nshiftRightUp(tmpBoard);\r\nBit128Utils.or(tmpBoard1,0,tmpBoard,0);\r\ntmpBoard[0]=0;\r\ntmpBoard[1]=0;\r\nBit128Utils.set(tmpBoard,nb);\r\nshiftRightDown(tmpBoard);\r\nBit128Utils.or(tmpBoard1,0,tmpBoard,0);\r\nlong[] tmp=new long[2];\r\ntmp[0]=tmpBoard1[0];\r\ntmp[1]=tmpBoard1[1];\r\narounds[nb]=tmp;\r\n}\r\n}\r\n}\r\npublic static int calculateLongBitCount(long[] bitboard){\r\nreturn bitCount(bitboard[0])+bitCount(bitboard[1]);\r\n}\r\nstatic int bitCount(long l){\r\nif(l==0){\r\nreturn 0;\r\n}\r\nreturn Long.bitCount(l);\r\n}\r\npublic static void shiftLeft(long[] bitboard){\r\nBit128Utils.and(bitboard,verticalLeft);\r\nBit128Utils.shiftRight(bitboard,1);\r\n}\r\npublic static void shiftRight(long[] bitboard){\r\nBit128Utils.and(bitboard,verticalRight);\r\nBit128Utils.shiftLeft(bitboard,1);\r\n}\r\npublic static void shiftUp(long[] bitboard){\r\nBit128Utils.and(bitboard,horizontalUp);\r\nBit128Utils.shiftRight(bitboard,FrameworkConstant.WIDTH);\r\n}\r\npublic static void shiftDown(long[] bitboard){\r\nBit128Utils.and(bitboard,horizontalDown);\r\nBit128Utils.shiftLeft(bitboard,FrameworkConstant.WIDTH);\r\n}\r\npublic static void shiftLeftUp(long[] bitboard){\r\nBit128Utils.and(bitboard,diagonalLeftUp);\r\nBit128Utils.shiftRight(bitboard,WIDTH_PLUS_ONE);\r\n}\r\npublic static void shiftLeftDown(long[] bitboard){\r\nBit128Utils.and(bitboard,diagonalLeftDown);\r\nBit128Utils.shiftLeft(bitboard,WIDTH_MINUS_ONE);\r\n}\r\npublic static void shiftRightUp(long[] bitboard){\r\nBit128Utils.and(bitboard,diagonalRightUp);\r\nBit128Utils.shiftRight(bitboard,WIDTH_MINUS_ONE);\r\n}\r\npublic static void shiftRightDown(long[] bitboard){\r\nBit128Utils.and(bitboard,diagonalRightDown);\r\nBit128Utils.shiftLeft(bitboard,WIDTH_PLUS_ONE);\r\n}\r\nstatic long[] copy=new long[2];\r\nstatic long[] finalBoard=new long[2];\r\nstatic long[] copyMoveAroundBoard=new long[2];\r\npublic static void toLongBoard(int[] board,long[] destination){\r\ndestination[0]=(((long)board[0])&0xFFFFFFFFL)|(((long)board[1])<< 32);\r\ndestination[1]=((long)board[2])&0xFFFFFFFFL;\r\nBit128Utils.reverse(destination);\r\n}\r\npublic static long[] moveAround(long[] board){\r\nclear(finalBoard);\r\ncopy(board,copy);\r\nshiftLeft(copy);\r\nBit128Utils.or(finalBoard,copy);\r\ncopy(board,copy);\r\nshiftRight(copy);\r\nBit128Utils.or(finalBoard,copy);\r\ncopy(board,copy);\r\nshiftUp(copy);\r\nBit128Utils.or(finalBoard,copy);\r\ncopy(board,copy);\r\nshiftDown(copy);\r\nBit128Utils.or(finalBoard,copy);\r\ncopy(board,copy);\r\nshiftLeftDown(copy);\r\nBit128Utils.or(finalBoard,copy);\r\ncopy(board,copy);\r\nshiftRightDown(copy);\r\nBit128Utils.or(finalBoard,copy);\r\ncopy(board,copy);\r\nshiftLeftUp(copy);\r\nBit128Utils.or(finalBoard,copy);\r\ncopy(board,copy);\r\nshiftRightUp(copy);\r\nBit128Utils.or(finalBoard,copy);\r\nreturn finalBoard;\r\n}\r\npublic static void copy(long[] source,long[] destination){\r\ndestination[0]=source[0];\r\ndestination[1]=source[1];\r\n}\r\npublic static void clear(long[] source){\r\nsource[0]=0;\r\nsource[1]=0;\r\n}\r\n}\r\n\r\nclass BoardCache{\r\nstatic final Logger logger=Logger.getLogger(BoardCache.class);\r\nstatic final int[][] CACHE=new int[Parameter.BOARD_CACHE_NB][];\r\nstatic int maxIndex;\r\nstatic int index;\r\npublic static void reset(){\r\nmaxIndex=Math.max(maxIndex,index);\r\nindex=0;\r\n}\r\npublic static int[] next()throws NoMoreBoardException{\r\ntry{\r\nint[] ret=CACHE[index];\r\nif(ret==null){\r\nret=BoardUtils.constructBoard();\r\nCACHE[index]=ret;\r\n}\r\nindex++;\r\nreturn ret;\r\n}catch(IndexOutOfBoundsException e){\r\nthrow NoMoreBoardException.EXCEPTION;\r\n}\r\n}\r\npublic static int[] getWay(int index){\r\nreturn CACHE[index];\r\n}\r\npublic static int getIndex(){\r\nreturn index;\r\n}\r\npublic static void printIndex(){\r\n\r\n}\r\n}\r\n\r\nclass BoardUtils{\r\nstatic final Logger logger=Logger.getLogger(BoardUtils.class);\r\nstatic int index=0;\r\npublic static final int MAP_INDEX=index;\r\npublic static final int BIT_NB=32;\r\npublic static final int MAP_LENGTH=(int)Math.ceil(FrameworkConstant.CASE_NB/(double)BIT_NB);\r\nstatic{\r\nindex+=MAP_LENGTH;\r\n}\r\nstatic final int TEAM_POSITION_INDEX=index;\r\nstatic{\r\nindex+=2;\r\n}\r\nstatic final int LAST_TILE=index++;\r\nstatic final int CHILD_NB=index++;\r\nstatic final int CHILD_START=index++;\r\nstatic final int LENGTH=index;\r\npublic static int[] constructBoard(){\r\nreturn new int[LENGTH];\r\n}\r\npublic static void init(int[] board){\r\nint x=(FrameworkConstant.HEIGHT-1)/2;\r\nsetTeamPosition(board,PointUtils.getPosition(0,x),0);\r\nsetTeamPosition(board,PointUtils.getPosition(FrameworkConstant.WIDTH-1,x),1);\r\n}\r\npublic static boolean isChildInit(int[] board){\r\nreturn getChildNb(board)!=-1;\r\n}\r\npublic static void reset(int[] board){\r\nsetChildNb(board,-1);\r\n}\r\npublic static int[] calculateNextWay(int[] board,int move,int tile,int team){\r\nint[] ret=copy(board);\r\nmove(ret,move,tile,team);\r\nreturn ret;\r\n}\r\npublic static void move(int[] board,int move,int tile,int team){\r\nsetTeamPosition(board,move,team);\r\nremoveTile(board,tile);\r\nsetLastTile(board,tile);\r\n}\r\npublic static int[] copy(int[] board){\r\nint[] ret=BoardCache.next();\r\nSystem.arraycopy(board,0,ret,0,LAST_TILE);\r\nreset(ret);\r\nreturn ret;\r\n}\r\npublic static void copy(int[] source,int[] destination){\r\nSystem.arraycopy(source,0,destination,0,LAST_TILE);\r\nreset(destination);\r\n}\r\npublic static void removeTile(int[] board,int position){\r\nboard[MAP_INDEX+position/BIT_NB] |= 1 <<(position%BIT_NB);\r\n}\r\npublic static boolean hasTile(int[] board,int position){\r\nreturn(board[MAP_INDEX+position/BIT_NB]&(1 <<(position%BIT_NB)))==0;\r\n}\r\npublic static void copyMap(int[] board,int[] map){\r\nfor(int i=0;i<MAP_LENGTH;i++){\r\nmap[i]=board[MAP_INDEX+i];\r\n}\r\n}\r\npublic static void setTeamPosition(int[] board,int position,int team){\r\nboard[TEAM_POSITION_INDEX+team]=position;\r\n}\r\npublic static int getTeamPosition(int[] board,int team){\r\nreturn board[TEAM_POSITION_INDEX+team];\r\n}\r\npublic static void setLastTile(int[] board,int position){\r\nboard[LAST_TILE]=position;\r\n}\r\npublic static int getLastTile(int[] board){\r\nreturn board[LAST_TILE];\r\n}\r\npublic static void setChildNb(int[] board,int value){\r\nboard[CHILD_NB]=value;\r\n}\r\npublic static int getChildNb(int[] board){\r\nreturn board[CHILD_NB];\r\n}\r\npublic static void setChildStartIndex(int[] board,int value){\r\nboard[CHILD_START]=value;\r\n}\r\npublic static int getChildStartIndex(int[] board){\r\nreturn board[CHILD_START];\r\n}\r\npublic static void initChild(int[] way,int teamId,boolean first){\r\nif(isChildInit(way)){\r\nreturn;\r\n}\r\nint childNb=0;\r\nint startIndex=BoardCache.getIndex();\r\nsetChildStartIndex(way,startIndex);\r\nint playerPosition=getTeamPosition(way,teamId);\r\nint opponentPosition=getTeamPosition(way,1-teamId);\r\nbyte[] possibleTiles=TilePruningUtils.calculatePossiblePruningTiles(way,teamId,first);\r\nint size=ByteListUtils.size(possibleTiles);\r\nbyte[] positions=MapUtils.getAroundPositions(playerPosition);\r\nfor(int i=0;i<positions.length;i++){\r\nbyte move=positions[i];\r\nif(hasTile(way,move)&&move!=opponentPosition){\r\nfor(int j=0;j<size;j++){\r\nint tile=ByteListUtils.get(possibleTiles,j);\r\nif(tile!=move){\r\ncalculateNextWay(way,move,tile,teamId);\r\nchildNb++;\r\n}\r\n}\r\n}\r\n}\r\nsetChildNb(way,childNb);\r\n}\r\npublic static String toString(int[] board){\r\nif(board==null){\r\nreturn null;\r\n}\r\nStringBuilder sb=new StringBuilder(\"\\n\");\r\nfor(int p=0;p<FrameworkConstant.CASE_NB;p++){\r\nif(hasTile(board,p)){\r\nif(p==getTeamPosition(board,0)){\r\nsb.append('0');\r\n}else if(p==getTeamPosition(board,1)){\r\nsb.append('1');\r\n}else{\r\nsb.append('.');\r\n}\r\n}else{\r\nsb.append('X');\r\n}\r\nif((p+1)%FrameworkConstant.WIDTH==0){\r\nsb.append('\\n');\r\n}\r\n}\r\nsb.append(\"tile:\"+PointUtils.toPoint(getLastTile(board)));\r\nsb.append('\\n');\r\nreturn sb.toString();\r\n}\r\npublic static String toMapString(int[] board){\r\nif(board==null){\r\nreturn null;\r\n}\r\nStringBuilder sb=new StringBuilder(\"\\n\");\r\nfor(int p=0;p<FrameworkConstant.CASE_NB;p++){\r\nif(hasTile(board,p)){\r\nsb.append('.');\r\n}else{\r\nsb.append('X');\r\n}\r\nif((p+1)%FrameworkConstant.WIDTH==0){\r\nsb.append('\\n');\r\n}\r\n}\r\nreturn sb.toString();\r\n}\r\n}\r\n\r\nclass IslandUtils{\r\nstatic Logger logger=Logger.getLogger(IslandUtils.class);\r\npublic static final byte[][] possiblePruningTiles=new byte[3][];\r\nstatic{\r\nfor(int i=0;i<possiblePruningTiles.length;i++){\r\npossiblePruningTiles[i]=new byte[FrameworkConstant.CASE_NB+1];\r\n}\r\n}\r\npublic static final int[][] places=new int[2][];\r\nstatic{\r\nfor(int i=0;i<places.length;i++){\r\nplaces[i]=new int[3];\r\n}\r\n}\r\npublic static boolean sameIsland;\r\npublic static void calculateIsland(int[] board){\r\nfor(int i=0;i<possiblePruningTiles.length;i++){\r\nByteListUtils.clear(possiblePruningTiles[i]);\r\n}\r\nfor(int i=0;i<2;i++){\r\nPlaceUtils.calculatePlace(board,i);\r\nPlaceUtils.copy(PlaceUtils.place,places[i]);\r\n}\r\nfor(byte i=0;i<FrameworkConstant.CASE_NB;i++){\r\nif(BoardUtils.hasTile(board,i)){\r\nboolean freeIsland=true;\r\nfor(int id=0;id<2;id++){\r\nif(!PlaceUtils.isFree(places[id],i)){\r\nByteListUtils.add(possiblePruningTiles[id],i);\r\nfreeIsland=false;\r\n}\r\n}\r\nif(freeIsland){\r\nByteListUtils.add(possiblePruningTiles[2],i);\r\n}\r\n}\r\n}\r\nsameIsland =\r\nByteListUtils.size(possiblePruningTiles[1])==ByteListUtils.size(possiblePruningTiles[0]);\r\nif(sameIsland){\r\nfor(int i=0;i<ByteListUtils.size(possiblePruningTiles[0]);i++){\r\nif(!ByteListUtils.contains(\r\npossiblePruningTiles[1],ByteListUtils.get(possiblePruningTiles[0],i))){\r\nsameIsland=false;\r\nbreak;\r\n}\r\n}\r\n}\r\nfor(int i=0;i<possiblePruningTiles.length;i++){\r\n\r\n}\r\n\r\n}\r\n}\r\n\r\nclass NoMoreBoardException extends RuntimeException{\r\npublic static final NoMoreBoardException EXCEPTION=new NoMoreBoardException();\r\n}\r\n\r\nclass PlaceUtils{\r\nstatic Logger logger=Logger.getLogger(PlaceUtils.class);\r\npublic static byte[][] positions=new byte[FrameworkConstant.CASE_NB][];\r\nstatic{\r\nfor(int i=0;i<positions.length;i++){\r\npositions[i]=new byte[FrameworkConstant.CASE_NB+1];\r\n}\r\n}\r\npublic static int[] place=new int[BoardUtils.MAP_LENGTH];\r\npublic static int size;\r\npublic static int[] dones=new int[BoardUtils.MAP_LENGTH];\r\npublic static int[] lastDones=new int[BoardUtils.MAP_LENGTH];\r\npublic static void calculatePlace(int[] way,int teamId){\r\ncalculatePlace(way,teamId,Integer.MAX_VALUE,false);\r\n}\r\npublic static void calculatePlace(int[] way,int teamId,int limit,boolean pawnBlock){\r\nint start=BoardUtils.getTeamPosition(way,teamId);\r\nBoardUtils.copyMap(way,dones);\r\nsetDone(dones,start);\r\nbyte[] currents=positions[0];\r\nByteListUtils.clear(currents);\r\nByteListUtils.add(currents,(byte)start);\r\nint n=0;\r\nsetDone(place,start);\r\nif(pawnBlock){\r\nint opponentPosition=BoardUtils.getTeamPosition(way,1-teamId);\r\nsetDone(dones,opponentPosition);\r\n}\r\nwhile(!ByteListUtils.isEmpty(currents)&&n<limit){\r\nn++;\r\nbyte[] nexts=positions[n];\r\nByteListUtils.clear(nexts);\r\nint l=ByteListUtils.size(currents);\r\nfor(int j=1;j<=l;j++){\r\nbyte p=currents[j];\r\nbyte[] arounds=MapUtils.getAroundPositions(p);\r\nint l1=arounds.length;\r\nfor(int i=0;i<l1;i++){\r\nbyte p2=arounds[i];\r\nif(isFree(dones,p2)){\r\nsetDone(dones,p2);\r\nByteListUtils.add(nexts,p2);\r\n}\r\n}\r\n}\r\ncurrents=nexts;\r\n}\r\nfor(int i=0;i<place.length;i++){\r\nplace[i]=way[BoardUtils.MAP_INDEX+i] ^ dones[i];\r\n}\r\nByteListUtils.clear(positions[n+1]);\r\n}\r\npublic static void calculateScore1(int[] way,int teamId,int limit){\r\nint start=BoardUtils.getTeamPosition(way,teamId);\r\nBoardUtils.copyMap(way,dones);\r\nsetDone(dones,start);\r\nbyte[] currents=positions[0];\r\nByteListUtils.clear(currents);\r\nByteListUtils.add(currents,(byte)start);\r\nint n=0;\r\nsetDone(place,start);\r\nint opponentPosition=BoardUtils.getTeamPosition(way,1-teamId);\r\nsetDone(dones,opponentPosition);\r\nwhile(!ByteListUtils.isEmpty(currents)&&n<limit){\r\nn++;\r\nbyte[] nexts=positions[n];\r\nByteListUtils.clear(nexts);\r\nint l=ByteListUtils.size(currents);\r\nfor(int j=1;j<=l;j++){\r\nbyte p=currents[j];\r\nbyte[] arounds=MapUtils.getAroundPositions(p);\r\nint l1=arounds.length;\r\nfor(int i=0;i<l1;i++){\r\nbyte p2=arounds[i];\r\nif(isFree(dones,p2)){\r\nsetDone(dones,p2);\r\nByteListUtils.add(nexts,p2);\r\n}\r\n}\r\n}\r\ncurrents=nexts;\r\ncounts[n]=ByteListUtils.size(currents);\r\n}\r\nByteListUtils.clear(positions[n+1]);\r\ncounts[n+1]=0;\r\n}\r\nstatic long[] initBoard=new long[2];\r\nstatic long[][] boards=new long[FrameworkConstant.CASE_NB][];\r\nstatic{\r\nfor(int i=0;i<boards.length;i++){\r\nboards[i]=new long[2];;\r\n}\r\n}\r\npublic static void calculateScore5(int[] board,int teamId,int limit){\r\nint p=BoardUtils.getTeamPosition(board,teamId);\r\nBoardBitUtils.toLongBoard(board,initBoard);\r\nBit128Utils.reset(initBoard,BoardUtils.getTeamPosition(board,1-teamId));\r\nlong[] a=BoardBitUtils.arounds[p];\r\nlong[] tmp=boards[1];\r\nBoardBitUtils.copy(a,tmp);\r\nBit128Utils.and(tmp,initBoard);\r\nBit128Utils.set(tmp,p);\r\ncounts[1]=BoardBitUtils.calculateLongBitCount(tmp);\r\nfor(int i=2;i<=limit ;i++){\r\ntmp=boards[i];\r\nBoardBitUtils.copy(BoardBitUtils.moveAround(boards[i-1]),tmp);\r\nBit128Utils.and(tmp,initBoard);\r\ncounts[i]=BoardBitUtils.calculateLongBitCount(tmp);\r\nif(counts[i]==counts[i-1]){\r\nbreak;\r\n}\r\n}\r\nfor(int i=limit;i>1;){\r\ncounts[i--]-=counts[i];\r\n}\r\ncounts[1]--;\r\ncounts[limit+1]=0;\r\n}\r\npublic static void setDone(int[] map,int position){\r\nmap[position/BoardUtils.BIT_NB] |= 1 <<(position%BoardUtils.BIT_NB);\r\n}\r\npublic static void setUndone(int[] map,int position){\r\nmap[position/BoardUtils.BIT_NB] &= ~(1 <<(position%BoardUtils.BIT_NB));\r\n}\r\npublic static boolean isFree(int[] map,int position){\r\nreturn(map[position/BoardUtils.BIT_NB]&(1 <<(position%BoardUtils.BIT_NB)))==0;\r\n}\r\npublic static void copy(int[] source,int[] destination){\r\nfor(int i=0;i<destination.length;i++){\r\ndestination[i]=source[i];\r\n}\r\n}\r\nstatic final int[][] mapScore=new int[2][];\r\nstatic final int[] mapClear=new int[FrameworkConstant.CASE_NB];\r\nstatic{\r\nfor(int i=0;i<mapScore.length;i++){\r\nmapScore[i]=new int[FrameworkConstant.CASE_NB];\r\n}\r\n}\r\npublic static final int[] counts=new int[FrameworkConstant.CASE_NB];\r\npublic static void calculateScore2(int[] way,int teamId,int limit){\r\nint start=BoardUtils.getTeamPosition(way,teamId);\r\nBoardUtils.copyMap(way,dones);\r\nbyte[] currents=positions[0];\r\nByteListUtils.clear(currents);\r\nByteListUtils.add(currents,(byte)start);\r\nint[] currentMap=mapScore[0];\r\nSystem.arraycopy(mapClear,0,currentMap,0,FrameworkConstant.CASE_NB);\r\ncurrentMap[start]=1;\r\nint n=0;\r\nint opponentPosition=BoardUtils.getTeamPosition(way,1-teamId);\r\nsetDone(dones,opponentPosition);\r\nwhile(!ByteListUtils.isEmpty(currents)&&n<limit){\r\nn++;\r\nbyte[] nexts=positions[n];\r\nByteListUtils.clear(nexts);\r\nBoardUtils.copyMap(dones,lastDones);\r\nint count=0;\r\nint l=ByteListUtils.size(currents);\r\nfor(int j=1;j<=l;j++){\r\nbyte p=currents[j];\r\nbyte[] arounds=MapUtils.getAroundPositions(p);\r\nint l1=arounds.length;\r\nint wayNb=currentMap[p];\r\nfor(int i=0;i<l1;i++){\r\nbyte p2=arounds[i];\r\nif(isFree(lastDones,p2)){\r\nif(isFree(dones,p2)){\r\nsetDone(dones,p2);\r\nByteListUtils.add(nexts,p2);\r\n}\r\ncurrentMap[p2]+=wayNb;\r\ncount+=wayNb;\r\n}\r\n}\r\n}\r\ncurrents=nexts;\r\ncounts[n]=count;\r\n}\r\ncounts[n+1]=0;\r\nByteListUtils.clear(positions[n+1]);\r\n}\r\npublic static void calculateScore3(int[] way,int teamId,int limit){\r\nint start=BoardUtils.getTeamPosition(way,teamId);\r\nBoardUtils.copyMap(way,dones);\r\nbyte[] currents=positions[0];\r\nByteListUtils.clear(currents);\r\nByteListUtils.add(currents,(byte)start);\r\nint n=0;\r\nint opponentPosition=BoardUtils.getTeamPosition(way,1-teamId);\r\nsetDone(dones,opponentPosition);\r\nwhile(!ByteListUtils.isEmpty(currents)&&n<limit){\r\nn++;\r\nbyte[] nexts=positions[n];\r\nByteListUtils.clear(nexts);\r\nBoardUtils.copyMap(dones,lastDones);\r\nint count=0;\r\nint l=ByteListUtils.size(currents);\r\nfor(int j=1;j<=l;j++){\r\nbyte p=currents[j];\r\nbyte[] arounds=MapUtils.getAroundPositions(p);\r\nint l1=arounds.length;\r\nfor(int i=0;i<l1;i++){\r\nbyte p2=arounds[i];\r\nif(isFree(lastDones,p2)){\r\nif(isFree(dones,p2)){\r\nsetDone(dones,p2);\r\nByteListUtils.add(nexts,p2);\r\n}\r\ncount++;\r\n}\r\n}\r\n}\r\ncurrents=nexts;\r\ncounts[n]=count;\r\n}\r\ncounts[n+1]=0;\r\nByteListUtils.clear(positions[n+1]);\r\n}\r\npublic static void calculateScore4(int[] way,int teamId,int limit){\r\ncalculateScore1(way,teamId,1);\r\n}\r\npublic static String toString(int[] place){\r\nif(place==null){\r\nreturn null;\r\n}\r\nStringBuilder sb=new StringBuilder(\"\\n\");\r\nfor(int p=0;p<FrameworkConstant.CASE_NB;p++){\r\nsb.append(place[p]);\r\nsb.append(' ');\r\nif((p+1)%FrameworkConstant.WIDTH==0){\r\nsb.append('\\n');\r\n}\r\n}\r\nreturn sb.toString();\r\n}\r\n}\r\n\r\nclass ScoreUtils{\r\nstatic Logger logger=Logger.getLogger(ScoreUtils.class);\r\npublic static final double MAX_SCORE=1e100;\r\npublic static double calculateScore(int[] board,int depth,int teamId){\r\ndouble ret=calculateScoreBest(board,depth,teamId);\r\nreturn ret;\r\n}\r\npublic static double calculateScore2(int[] board,int depth,int teamId){\r\ndouble score=0;\r\nint oppMoveNb=calculatePossibleMoveNb(board,1-teamId);\r\nint playerMoveNb=calculatePossibleMoveNb(board,teamId);\r\nif(playerMoveNb==0){\r\nscore=MAX_SCORE*(depth+1);\r\n}else{\r\nscore+=(oppMoveNb-playerMoveNb)*1e5;\r\nint playerPosition=BoardUtils.getTeamPosition(board,teamId);\r\nint oppPosition=BoardUtils.getTeamPosition(board,1-teamId);\r\nscore +=\r\nPointUtils.distance(FrameworkConstant.CENTER,playerPosition)\r\n-PointUtils.distance(FrameworkConstant.CENTER,oppPosition);\r\n}\r\nif(teamId==Constant.PLAYER_ID){\r\nscore*=-1;\r\n}\r\nreturn score;\r\n}\r\npublic static double calculateScoreBest(int[] board,int depth,int playingTeam){\r\ndouble score=0;\r\nint limit=Parameter.LIMIT_WAY;\r\nfor(int id=0;id<2;id++){\r\ndouble multpl=(id==Constant.PLAYER_ID?1:-1);\r\nswitch(Parameter.SCORE_EVALUATION){\r\ncase 3:\r\nPlaceUtils.calculateScore3(board,id,limit);\r\nbreak;\r\ncase 5:\r\nPlaceUtils.calculateScore5(board,id,limit);\r\nbreak;\r\ncase 6:\r\nPlaceUtils.calculateScore5(board,id,limit);\r\nbreak;\r\ncase 1:\r\nPlaceUtils.calculateScore1(board,id,limit);\r\nbreak;\r\ncase 2:\r\nPlaceUtils.calculateScore2(board,id,limit);\r\nbreak;\r\ncase 4:\r\nPlaceUtils.calculateScore4(board,id,limit);\r\nbreak;\r\ncase 7:\r\nPlaceUtils.calculateScore1(board,id,limit);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nfor(int i=1;i<=limit;i++){\r\nint nb=PlaceUtils.counts[i];\r\nif(Parameter.LOG){\r\n\r\n}\r\nif(nb==0){\r\nif(i==1){\r\nscore+=-multpl*MAX_SCORE*(depth+1);\r\nif(id==playingTeam){\r\nscore+=-multpl*MAX_SCORE*(depth+1);\r\n}\r\n}\r\nbreak;\r\n}\r\nscore+=multpl*nb*Pow.getPow(i-1);\r\n}\r\n}\r\nif(Parameter.LOG){\r\n\r\n\r\n}\r\nreturn score;\r\n}\r\npublic static int calculatePossibleMoveNb(int[] board,int teamId){\r\nint ret=0;\r\nint p=BoardUtils.getTeamPosition(board,teamId);\r\nbyte[] positions=MapUtils.getAroundPositions(p);\r\nint opponentPosition=BoardUtils.getTeamPosition(board,1-teamId);\r\nfor(int i=0;i<positions.length;i++){\r\nbyte p1=positions[i];\r\nif(BoardUtils.hasTile(board,p1)&&p1!=opponentPosition){\r\nret++;\r\n}\r\n}\r\nreturn ret;\r\n}\r\n}\r\n\r\nclass TilePruningUtils{\r\nstatic Logger logger=Logger.getLogger(TilePruningUtils.class);\r\npublic static final byte[] possibleRemoveTiles=new byte[100];\r\nstatic final int[] tmpMap=new int[BoardUtils.MAP_LENGTH];\r\npublic static byte[] calculatePossiblePruningTiles(int[] board,int teamId,boolean first){\r\nByteListUtils.clear(possibleRemoveTiles);\r\nboolean playerFirstIteration=first&&teamId==Constant.PLAYER_ID;\r\nint opponentPosition=BoardUtils.getTeamPosition(board,1-teamId);\r\nint[] opponentIslandPlace=IslandUtils.places[1-teamId];\r\nboolean spiral=first||!Parameter.LIMIT_ONLY_FIRST_DEPTH;\r\nbyte[] spiralPositions =\r\nspiral\r\n?MapUtils.getSpiralPositions(opponentPosition)\r\n:MapUtils.getAroundPositions(opponentPosition);\r\nint limit=playerFirstIteration?Parameter.TILE_LIMIT_NB:Parameter.TILE_LIMIT_NB2;\r\nif(IslandUtils.sameIsland&&!ByteListUtils.isEmpty(IslandUtils.possiblePruningTiles[2])){\r\nlimit--;\r\n}\r\nif(spiral){\r\nint[] tmp =\r\nplayerFirstIteration?prunedTileFirstIteration:opponentIslandPlace;\r\nfor(int i=0;i<BoardUtils.MAP_LENGTH;i++){\r\ntmpMap[i]=(~board[BoardUtils.MAP_INDEX+i])&tmp[i];\r\n}\r\nfor(int i=0;i<spiralPositions.length;i++){\r\nbyte p=spiralPositions[i];\r\nif(!PlaceUtils.isFree(tmpMap,p)){\r\nByteListUtils.add(possibleRemoveTiles,p);\r\nif(ByteListUtils.size(possibleRemoveTiles)==limit){\r\nbreak;\r\n}\r\n}\r\n}\r\n}else{\r\nfor(int i=0;i<spiralPositions.length;i++){\r\nbyte p=spiralPositions[i];\r\nif(BoardUtils.hasTile(board,p)){\r\nByteListUtils.add(possibleRemoveTiles,p);\r\n}\r\n}\r\n}\r\nif(ByteListUtils.size(possibleRemoveTiles)<=0||IslandUtils.sameIsland){\r\nbyte[] freeIslandTile=IslandUtils.possiblePruningTiles[2];\r\nboolean addExternalTile=false;\r\nint l=ByteListUtils.size(freeIslandTile);\r\nfor(int i=0;i<l;i++){\r\nbyte tmp=ByteListUtils.get(freeIslandTile,i);\r\nif(BoardUtils.hasTile(board,tmp)){\r\nByteListUtils.add(possibleRemoveTiles,tmp);\r\naddExternalTile=true;\r\nbreak;\r\n}\r\n}\r\nif(!addExternalTile&&!playerFirstIteration){\r\nbyte[] closestPositions=closestTiles[1-teamId];\r\nint l2=ByteListUtils.size(closestPositions);\r\nfor(int i=l2-1;i>=0;i--){\r\nbyte tmp=ByteListUtils.get(closestPositions,i);\r\nif(BoardUtils.hasTile(board,tmp)){\r\nByteListUtils.add(possibleRemoveTiles,tmp);\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\nif(ByteListUtils.size(possibleRemoveTiles)<=0){\r\nByteListUtils.add(possibleRemoveTiles,(byte)BoardUtils.getTeamPosition(board,teamId));\r\n}\r\nreturn possibleRemoveTiles;\r\n}\r\nstatic final int[] prunedTileFirstIteration=new int[BoardUtils.MAP_LENGTH];\r\nstatic final byte[][] closestTiles=new byte[2][];\r\nstatic{\r\nfor(int i=0;i<closestTiles.length;i++){\r\nclosestTiles[i]=new byte[FrameworkConstant.CASE_NB+1];\r\n}\r\n}\r\npublic static void initPrunedTileFirstIteration(int[] board){\r\nfor(int i=0;i<BoardUtils.MAP_LENGTH;i++){\r\nprunedTileFirstIteration[i]=0;\r\n}\r\nfor(int i=0;i<closestTiles.length;i++){\r\nByteListUtils.clear(closestTiles[i]);\r\n}\r\nPlaceUtils.calculatePlace(board,Constant.OPPONENT_ID,Integer.MAX_VALUE,false);\r\nfor(int i=1;;i++){\r\nbyte[] positions=PlaceUtils.positions[i];\r\nint l=ByteListUtils.size(positions);\r\nif(l==0){\r\nbreak;\r\n}\r\nfor(int j=0;j<l;j++){\r\nbyte p=ByteListUtils.get(positions,j);\r\nif(i<=Parameter.TILE_MAX_DISTANCE){\r\nPlaceUtils.setDone(prunedTileFirstIteration,p);\r\n}\r\nByteListUtils.add(closestTiles[Constant.OPPONENT_ID],p);\r\n}\r\n}\r\nPlaceUtils.calculatePlace(board,Constant.PLAYER_ID,Integer.MAX_VALUE,false);\r\nfor(int i=1;;i++){\r\nbyte[] positions=PlaceUtils.positions[i];\r\nint l=ByteListUtils.size(positions);\r\nif(l==0){\r\nbreak;\r\n}\r\nfor(int j=0;j<l;j++){\r\nbyte p=ByteListUtils.get(positions,j);\r\nByteListUtils.add(closestTiles[Constant.PLAYER_ID],p);\r\n}\r\n}\r\n}\r\n}\r\n\r\nclass FirstRoundUtils{\r\npublic static void proceed(){\r\nif(Constant.isFirstRound()){\r\nMapUtils.initCache();\r\nGarbageCollectorUtils.avoidTimeOut();\r\n}\r\n}\r\n}\r\n\r\nclass MinMaxAlphaBetaCalculateSearcher{\r\nstatic final Logger logger=Logger.getLogger(MinMaxAlphaBetaCalculateSearcher.class);\r\nstatic MinMaxAlphaBetaCalculateSearcher instance=new MinMaxAlphaBetaCalculateSearcher();\r\npublic boolean log=Parameter.LOG;\r\nboolean timeOut=false;\r\nboolean increaseFirstOpponentMoveNb;\r\nMinMaxAlphaBetaCalculateSearcher(){}\r\npublic static MinMaxAlphaBetaCalculateSearcher getInstance(){\r\nreturn instance;\r\n}\r\ndouble minTurn(int[] state,int depth,double alpha,double beta,boolean first)\r\nthrows TimeOutException{\r\nif(stop(state,depth)){\r\nif(timeOut){\r\nTimeOutUtils.stopTimeException();\r\n}\r\nreturn ScoreUtils.calculateScore(state,depth,Constant.OPPONENT_ID);\r\n}\r\nBoardUtils.initChild(state,Constant.OPPONENT_ID,first);\r\nint childNb=BoardUtils.getChildNb(state);\r\nif(childNb==0){\r\nreturn ScoreUtils.MAX_SCORE*(depth+1);\r\n}\r\nint childStartIndex=BoardUtils.getChildStartIndex(state);\r\nfor(int i=childStartIndex;i<childStartIndex+childNb;i++){\r\nint[] childState=BoardCache.getWay(i);\r\ndouble val=maxTurn(childState,depth-1,alpha,beta);\r\nif(val<beta){\r\nbeta=val;\r\n}\r\nif(alpha>=beta){\r\nbreak;\r\n}\r\n}\r\nreturn beta;\r\n}\r\ndouble maxTurn(int[] state,int depth,double alpha,double beta)\r\nthrows TimeOutException{\r\nif(stop(state,depth)){\r\nif(timeOut){\r\nTimeOutUtils.stopTimeException();\r\n}\r\nreturn ScoreUtils.calculateScore(state,depth,Constant.PLAYER_ID);\r\n}\r\nBoardUtils.initChild(state,Constant.PLAYER_ID,false);\r\nint childNb=BoardUtils.getChildNb(state);\r\nif(childNb==0){\r\nreturn -ScoreUtils.MAX_SCORE*(depth+1);\r\n}\r\nint childStartIndex=BoardUtils.getChildStartIndex(state);\r\nfor(int i=childStartIndex;i<childStartIndex+childNb;i++){\r\nint[] childState=BoardCache.getWay(i);\r\ndouble val=minTurn(childState,depth-1,alpha,beta,false);\r\nif(alpha<val){\r\nalpha=val;\r\n}\r\nif(alpha>=beta){\r\nbreak;\r\n}\r\n}\r\nreturn alpha;\r\n}\r\nboolean stop(int[] currentMapAll,int depth){\r\nreturn depth<=0;\r\n}\r\nvoid increaseFirstOpponentMoveNb(){\r\nif(Constant.ROUND==Parameter.INCREASE_FIRST_OPPONENT_MOVE_NB_ROUND){\r\nincreaseFirstOpponentMoveNb=true;\r\n}\r\n}\r\npublic int minimax(int depth,int[] gameState){\r\nTilePruningUtils.initPrunedTileFirstIteration(gameState);\r\nincreaseFirstOpponentMoveNb();\r\nBoardCache.reset();\r\nIslandUtils.calculateIsland(gameState);\r\nint ret=-1;\r\ntry{\r\ntimeOut=false;\r\nret=minimaxNoTimeOut(depth,gameState);\r\n}catch(TimeOutException e){\r\nthrow new IllegalStateException();\r\n}catch(NoMoreBoardException e){\r\nthrow new IllegalStateException();\r\n}\r\ntimeOut=Parameter.MIN_MAX_TIME_OUT;\r\nif(!timeOut){\r\nreturn ret;\r\n}\r\ntry{\r\nint lastCacheIndex=BoardCache.getIndex();\r\nwhile(timeOut){\r\ndepth++;\r\nret=minimaxTimeOut(depth,gameState);\r\nif(lastCacheIndex==BoardCache.getIndex()){\r\n\r\nbreak;\r\n}\r\nlastCacheIndex=BoardCache.getIndex();\r\n}\r\n}catch(TimeOutException e){\r\n\r\n}catch(NoMoreBoardException e){\r\n\r\n}\r\nBoardCache.printIndex();\r\nreturn ret;\r\n}\r\npublic int minimaxNoTimeOut(int depth,int[] state)throws TimeOutException{\r\nDouble bestScoreTmp=null;\r\nInteger bestSuccessorTmp=null;\r\nBoardUtils.reset(state);\r\nBoardUtils.initChild(state,Constant.PLAYER_ID,true);\r\nint childNb=BoardUtils.getChildNb(state);\r\n\r\nint childStartIndex=BoardUtils.getChildStartIndex(state);\r\nfor(int i=childStartIndex;i<childStartIndex+childNb;i++){\r\nint[] childState=BoardCache.getWay(i);\r\nif(log){\r\n\r\n}\r\ndouble val =\r\nminTurn(\r\nchildState,\r\ndepth,\r\nDouble.NEGATIVE_INFINITY,\r\nDouble.POSITIVE_INFINITY,\r\nincreaseFirstOpponentMoveNb);\r\nif(log){\r\n\r\n}\r\nif(bestScoreTmp==null||val>bestScoreTmp){\r\nif(log){\r\n\r\n}\r\nbestSuccessorTmp=i;\r\nbestScoreTmp=val;\r\n}\r\n}\r\nlogWin(bestScoreTmp);\r\nreturn bestSuccessorTmp;\r\n}\r\npublic int minimaxTimeOut(int depth,int[] state)throws TimeOutException{\r\nDouble bestScoreTmp=null;\r\nInteger bestSuccessorTmp=null;\r\nint childNb=BoardUtils.getChildNb(state);\r\n\r\nint childStartIndex=BoardUtils.getChildStartIndex(state);\r\nfor(int i=childStartIndex;i<childStartIndex+childNb;i++){\r\nint[] childState=BoardCache.getWay(i);\r\ndouble val =\r\nminTurn(\r\nchildState,\r\ndepth,\r\nDouble.NEGATIVE_INFINITY,\r\nDouble.POSITIVE_INFINITY,\r\nincreaseFirstOpponentMoveNb);\r\nif(bestScoreTmp==null||val>bestScoreTmp){\r\nbestSuccessorTmp=i;\r\nbestScoreTmp=val;\r\n}\r\n}\r\nlogWin(bestScoreTmp);\r\nreturn bestSuccessorTmp;\r\n}\r\nstatic boolean win;\r\nvoid logWin(Double bestScoreTmp){\r\nif(bestScoreTmp>=ScoreUtils.MAX_SCORE){\r\n\r\nwin=true;\r\n}else if(bestScoreTmp<=-ScoreUtils.MAX_SCORE){\r\n\r\n}\r\n}\r\n}\r\n\r\nclass NextMoveUtils{\r\nstatic Logger logger=Logger.getLogger(NextMoveUtils.class);\r\npublic static String proceed(){\r\nFirstRoundUtils.proceed();\r\nint[] board=Game.getInstance().getBoard();\r\n\r\nincreaseDepth();\r\nint index=MinMaxAlphaBetaCalculateSearcher.getInstance().minimax(Parameter.DEPTH,board);\r\nint[] bestWay=BoardCache.getWay(index);\r\nint bestMove=BoardUtils.getTeamPosition(bestWay,Constant.PLAYER_ID);\r\nint bestTile=BoardUtils.getLastTile(bestWay);\r\nBoardUtils.move(board,bestMove,bestTile,Constant.PLAYER_ID);\r\nTimeOutUtils.time=Parameter.TIME_OUT;\r\nreturn PointUtils.toXYString(bestMove)+\" \"+PointUtils.toXYString(bestTile);\r\n}\r\nstatic void increaseDepth(){\r\nif(Constant.ROUND==Parameter.INCREASE_DEPTH_ROUND){\r\nParameter.DEPTH++;\r\n}\r\n}\r\n}\r\n\r\nclass Constant{\r\npublic static int PLAYER_ID;\r\npublic static int OPPONENT_ID;\r\npublic static int ROUND;\r\npublic static boolean isFirstRound(){\r\nreturn ROUND==1;\r\n}\r\n}\r\n\r\nclass Parameter{\r\npublic static final int AVOID_TIME_OUT_NB=0;\r\npublic static int FIRST_ROUND_TIME_OUT=950;\r\npublic static int TIME_OUT=95;\r\npublic static final boolean REMOVE_LOG=true;\r\npublic static final boolean REMOVE_ASSERT=true;\r\npublic static int BOARD_CACHE_NB=800_000;\r\npublic static boolean LOG=false;\r\npublic static final int BOSS_NB=3;\r\npublic static boolean MIN_MAX_TIME_OUT=BOSS_NB==3;\r\npublic static final int TILE_LIMIT_NB2=9;\r\npublic static final boolean LIMIT_ONLY_FIRST_DEPTH=true;\r\npublic static final int INCREASE_DEPTH_ROUND=BOSS_NB==3?10:-1;\r\npublic static final int INCREASE_FIRST_OPPONENT_MOVE_NB_ROUND=15;\r\npublic static int TILE_LIMIT_NB=20;\r\npublic static int LIMIT_WAY=3;\r\npublic static final int TILE_MAX_DISTANCE=3;\r\npublic static int SCORE_EVALUATION=BOSS_NB==1?7:3;\r\npublic static int DEPTH=BOSS_NB==3?1:0;\r\npublic static double[] BEST_POWS ={0,0.75,1,1.15,1,0.75,0.75,0};\r\npublic static double POW=BEST_POWS[SCORE_EVALUATION];\r\n}\r\n\r\nclass Pow{\r\nstatic final double[] POWS0_9=new double[50];\r\nstatic{\r\nfor(int i=0;i<POWS0_9.length;i++){\r\nPOWS0_9[i]=Math.pow(Parameter.POW,i);\r\n}\r\n}\r\npublic static  void init(){\r\nfor(int i=0;i<POWS0_9.length;i++){\r\nPOWS0_9[i]=Math.pow(Parameter.POW,i);\r\n}\r\n}\r\npublic static double getPow(int i){\r\nreturn POWS0_9[i];\r\n}\r\n}\r\n\r\nclass AllUtils{\r\nstatic Logger logger=Logger.getLogger(AllUtils.class);\r\npublic static void copy(int[] source,int[] destination){\r\nSystem.arraycopy(source,0,destination,0,source.length);\r\n}\r\npublic static String toString(Object... p){\r\nStringBuilder str=new StringBuilder();\r\nint i=0;\r\nfor(Object o:p){\r\nstr.append(o==null?\"null\":o.toString());\r\nif(++i<p.length){\r\nstr.append(\" \");\r\n}\r\n}\r\nreturn str.toString();\r\n}\r\n}\r\n\r\nclass AssertUtils{\r\nstatic Logger logger=Logger.getLogger(AssertUtils.class);\r\npublic static void test(boolean b,Object... o){\r\nif(!b){\r\nString str=AllUtils.toString(o);\r\n\r\nthrow new IllegalStateException(str);\r\n}\r\n}\r\n}\r\n\r\nclass ByteUtils{\r\npublic static byte[] copy(byte[] s){\r\nbyte[] d=new byte[s.length];\r\nSystem.arraycopy(s,0,d,0,s.length);\r\nreturn d;\r\n}\r\npublic static byte[] copy(byte[] array,int length){\r\nbyte[] newArray=new byte[length];\r\nSystem.arraycopy(array,0,newArray,0,length);\r\nreturn newArray;\r\n}\r\npublic static void copy(byte[] s,byte[] d){\r\nSystem.arraycopy(s,0,d,0,s.length);\r\n}\r\npublic static void copy(byte[] s,byte[] d,int start){\r\nSystem.arraycopy(s,0,d,start,s.length);\r\n}\r\n}\r\n\r\nenum Direction{\r\nUP(0,-1,4),\r\nDOWN(0,1,1),\r\nLEFT(-1,0,2),\r\nRIGHT(1,0,3),\r\nUL(-1,-1,5),\r\nUR(1,-1,6),\r\nDL(-1,1,7),\r\nDR(1,1,8);\r\nbyte num;\r\nint x;\r\nint y;\r\nstatic Direction[] numToDirection;\r\nstatic boolean initialized;\r\npublic static void init(){\r\nif(initialized){\r\nreturn;\r\n}\r\ninitialized=true;\r\nnumToDirection=new Direction[Direction.values().length+1];\r\nDirection[] values=Direction.values();\r\nfor(int i=0;i<values.length;i++){\r\nDirection value=values[i];\r\nnumToDirection[value.getNum()]=value;\r\n}\r\n}\r\nDirection(int x,int y,int num){\r\nthis.x=x;\r\nthis.y=y;\r\nthis.num=(byte)num;\r\n}\r\npublic byte getNum(){\r\nreturn num;\r\n}\r\npublic int getX(){\r\nreturn x;\r\n}\r\npublic int getY(){\r\nreturn y;\r\n}\r\npublic Direction getOpposite(){\r\nswitch(this){\r\ncase LEFT:\r\nreturn Direction.RIGHT;\r\ncase RIGHT:\r\nreturn Direction.LEFT;\r\ncase UP:\r\nreturn Direction.DOWN;\r\ncase DOWN:\r\nreturn Direction.UP;\r\ncase UL:\r\nreturn Direction.DR;\r\ncase UR:\r\nreturn Direction.DL;\r\ncase DR:\r\nreturn Direction.UL;\r\ncase DL:\r\nreturn Direction.UR;\r\ndefault:\r\nthrow new IllegalStateException();\r\n}\r\n}\r\npublic static Direction fromNum(byte num){\r\nreturn numToDirection[num];\r\n}\r\npublic boolean is(byte num){\r\nreturn num==this.num;\r\n}\r\n}\r\n\r\nclass DirectionUtils{\r\npublic static int construct(int index,Direction dir){\r\nint x=PointUtils.getX(index)+dir.getX();\r\nint y=PointUtils.getY(index)+dir.getY();\r\nif(PointUtils.isIn(x,y)){\r\nreturn PointUtils.getPosition(x,y);\r\n}\r\nreturn FrameworkConstant.OUT;\r\n}\r\n}\r\n\r\nclass FrameworkConstant{\r\npublic static int HEIGHT=9;\r\npublic static int WIDTH=9;\r\npublic static int CASE_NB=HEIGHT*WIDTH;\r\npublic static byte[] MAP;\r\npublic static final int CENTER=PointUtils.getPosition(WIDTH/2,HEIGHT/2);\r\npublic static final byte OUT=-1;\r\n}\r\n\r\nclass GarbageCollectorUtils{\r\nstatic Logger logger=Logger.getLogger(GarbageCollectorUtils.class);\r\nstatic int lastRoundGC=0;\r\nstatic final int BETWEEN_GC_ROUND_NB=20;\r\nstatic final int AVOID_TIME_OUT_NB=2000000;\r\nstatic long start;\r\npublic static void garbageCollect(int round){\r\ngarbageCollect(round,true);\r\n}\r\npublic static void avoidTimeOut(){\r\nStringBuilder[] FOR_ALLOC=new StringBuilder[AVOID_TIME_OUT_NB];\r\nfor(int i=0;i<AVOID_TIME_OUT_NB;i++){\r\nFOR_ALLOC[i]=new StringBuilder();\r\n}\r\nFOR_ALLOC=null;\r\ngarbageCollect(0);\r\n}\r\npublic static void garbageCollect(int round,boolean force){\r\nif(force||round-lastRoundGC>20){\r\nSystem.err.println(\r\n(Timer.getInstance().getTime())\r\n+\"GARBAGE COLECTOR START \"\r\n+Runtime.getRuntime().freeMemory());\r\nSystem.gc();\r\nSystem.err.println(\r\n(Timer.getInstance().getTime())\r\n+\"GARBAGE COLECTOR END \"\r\n+Runtime.getRuntime().freeMemory());\r\nlastRoundGC=round;\r\n}\r\n}\r\npublic static void initFreeMemory(){\r\nstart=Runtime.getRuntime().freeMemory();\r\n}\r\npublic static void printUsedMemory(){\r\n\r\n}\r\n}\r\n\r\nclass ByteListUtils{\r\npublic static void add(byte[] array,byte p){\r\narray[size(array)+1]=p;\r\narray[0]++;\r\n}\r\npublic static void remove(byte[] array,byte p){\r\nboolean remove=false;\r\nfor(byte i=0;i<size(array);i++){\r\nbyte value=get(array,i);\r\nif(remove){\r\nset(array,(byte)(i-1),value);\r\n}else if(value==p){\r\nremove=true;\r\n}\r\n}\r\nif(remove){\r\narray[0]--;\r\n}\r\n}\r\npublic static void removeByIndex(byte[] array,int index){\r\nboolean remove=false;\r\nfor(byte i=0;i<size(array);i++){\r\nif(remove){\r\nbyte value=get(array,i);\r\nset(array,(byte)(i-1),value);\r\n}else if(i==index){\r\nremove=true;\r\n}\r\n}\r\nif(remove){\r\narray[0]--;\r\n}\r\n}\r\npublic static void clear(byte[] array){\r\narray[0]=0;\r\n}\r\npublic static byte size(byte[] array){\r\nreturn array[0];\r\n}\r\npublic static boolean isEmpty(byte[] array){\r\nreturn size(array)==0;\r\n}\r\npublic static byte get(byte[] array,int i){\r\nreturn array[i+1];\r\n}\r\npublic static void set(byte[] array,byte i,byte newValue){\r\narray[i+1]=newValue;\r\n}\r\npublic static boolean contains(byte[] array,byte i){\r\nfor(byte j=0;j<size(array);j++){\r\nif(get(array,j)==i){\r\nreturn true;\r\n}\r\n}\r\nreturn false;\r\n}\r\npublic static byte[] cut(byte[] array){\r\nbyte[] tmp=new byte[size(array)];\r\nSystem.arraycopy(array,1,tmp,0,tmp.length);\r\nreturn tmp;\r\n}\r\npublic static void copy(byte[] source,byte[] destination){\r\nSystem.arraycopy(source,0,destination,0,size(source)+1);\r\n}\r\npublic static byte getLast(byte[] array){\r\nbyte size=size(array);\r\n\r\nreturn get(array,(byte)(size-1));\r\n}\r\npublic static String toString(byte[] array){\r\nreturn Arrays.toString(cut(array));\r\n}\r\n}\r\n\r\nclass Logger{\r\nenum Level{\r\nDEBUG,\r\nERROR,\r\nNONE;\r\n}\r\nstatic String[] tmp ={\r\n};\r\nstatic Map<String,String> map=new HashMap<>();\r\n{\r\nfor(int i=0;i<tmp.length;i+=2){\r\nmap.put(tmp[i],tmp[i+1]);\r\n}\r\n}\r\npublic static Level level=Level.ERROR;\r\nLevel levelSpecific;\r\nClass<?> clazz;\r\nLogger(Class<?> clazz){\r\nthis.clazz=clazz;\r\n}\r\npublic static Logger getLogger(Class<?> clazz){\r\nreturn new Logger(clazz);\r\n}\r\npublic static Logger getLogger(Class<?> clazz,Level levelSpecific){\r\nLogger ret=new Logger(clazz);\r\nret.levelSpecific=levelSpecific;\r\nreturn ret;\r\n}\r\npublic void error(Object... s){\r\nprint(s);\r\n}\r\npublic void debug(Object... s){\r\nif(getLevel()==Level.DEBUG){\r\nprint(s);\r\n}\r\n}\r\nstatic StringBuilder sb=new StringBuilder(5000);\r\npublic void print(Object... s){\r\nif(getLevel()==Level.NONE){\r\nreturn;\r\n}\r\nsb.delete(0,sb.length());\r\nsb.append(Timer.getInstance().getTime());\r\nsb.append(\" \");\r\nsb.append(clazz.getSimpleName());\r\nsb.append(\":\");\r\nint i=0;\r\nfor(Object o:s){\r\nsb.append(o==null?\"null\":o.toString());\r\nif(++i<s.length){\r\nsb.append(\" \");\r\n}\r\n}\r\nSystem.err.println(sb);\r\n}\r\nLevel getLevel(){\r\nif(levelSpecific==null||level==Level.NONE){\r\nreturn level;\r\n}\r\nreturn levelSpecific;\r\n}\r\n}\r\n\r\nclass Timer{\r\nstatic Timer instance=new Timer();\r\nlong timeStart;\r\nTimer(){}\r\npublic static Timer getInstance(){\r\nreturn instance;\r\n}\r\npublic void init(){\r\ntimeStart=System.currentTimeMillis();\r\n}\r\npublic long getTime(){\r\nreturn System.currentTimeMillis()-timeStart;\r\n}\r\n}\r\n\r\nclass MapUtils{\r\nstatic Logger logger=Logger.getLogger(MapUtils.class);\r\nstatic final byte[][] CACHE_AROUND_POSITIONS=new byte[FrameworkConstant.CASE_NB][];\r\nstatic final byte[][] CACHE_SPIRAL_POSITIONS=new byte[FrameworkConstant.CASE_NB][];\r\npublic static byte[] getAroundPositions(int p){\r\nreturn CACHE_AROUND_POSITIONS[p];\r\n}\r\npublic static byte[] getSpiralPositions(int p){\r\nreturn CACHE_SPIRAL_POSITIONS[p];\r\n}\r\npublic static void initCache(){\r\nDirection.init();\r\nfor(byte i=0;i<FrameworkConstant.CASE_NB;i++){\r\ncalculateAroundPositions(i);\r\ncalculateSpiralPositions(i);\r\n}\r\n}\r\nstatic void calculateAroundPositions(int p){\r\nDirection[] dirs=Direction.values();\r\nbyte[] ret=new byte[dirs.length];\r\nint index=0;\r\nfor(int i=0;i<dirs.length;i++){\r\nDirection direction=dirs[i];\r\nint p2=DirectionUtils.construct(p,direction);\r\nif(p2!=FrameworkConstant.OUT){\r\nret[index++]=(byte)p2;\r\n}\r\n}\r\nCACHE_AROUND_POSITIONS[p]=ByteUtils.copy(ret,index);\r\n}\r\nstatic void calculateSpiralPositions(int p){\r\nbyte[] ret=new byte[FrameworkConstant.CASE_NB-1];\r\nint index=0;\r\nfor(int i=0;i<FrameworkConstant.CASE_NB;i++){\r\nif(i!=p&&PointUtils.distance(i,p)<=Parameter.TILE_MAX_DISTANCE){\r\nret[index++]=(byte)i;\r\n}\r\n}\r\nbyte[] cut=new byte[index];\r\nSystem.arraycopy(ret,0,cut,0,index);\r\nbubbleSort(cut,p);\r\nCACHE_SPIRAL_POSITIONS[p]=cut;\r\n}\r\npublic static void main(String[] args){\r\ninitCache();\r\n}\r\nstatic void bubbleSort(byte arr[],int p){\r\nint n=arr.length;\r\nfor(int i=0;i<n-1;i++)\r\nfor(int j=0;j<n-i-1;j++)\r\nif(value(arr[j],p)>value(arr[j+1],p)){\r\nbyte temp=arr[j];\r\narr[j]=arr[j+1];\r\narr[j+1]=temp;\r\n}\r\n}\r\nstatic int value(byte pos,int p){\r\nreturn PointUtils.distance2(pos,FrameworkConstant.CENTER)\r\n+100\r\n*(PointUtils.distance(pos,FrameworkConstant.CENTER)\r\n+100*PointUtils.distance(pos,p));\r\n}\r\n}\r\n\r\nclass Point{\r\nint x;\r\nint y;\r\npublic Point(){}\r\npublic Point(int x,int y){\r\nthis.x=x;\r\nthis.y=y;\r\n}\r\npublic int getX(){\r\nreturn x;\r\n}\r\npublic void setX(int x){\r\nthis.x=x;\r\n}\r\npublic int getY(){\r\nreturn y;\r\n}\r\npublic void setY(int y){\r\nthis.y=y;\r\n}\r\npublic void copy(Point p){\r\nx=p.x;\r\ny=p.y;\r\n}\r\nboolean isIn(){\r\nreturn x>=0&&x<FrameworkConstant.WIDTH&&y>=0&&y<FrameworkConstant.HEIGHT;\r\n}\r\n@Override public int hashCode(){\r\nfinal int prime=31;\r\nint result=1;\r\nresult=prime*result+x;\r\nresult=prime*result+y;\r\nreturn result;\r\n}\r\n@Override public boolean equals(Object obj){\r\nif(this==obj)return true;\r\nif(obj==null)return false;\r\nif(getClass()!=obj.getClass())return false;\r\nPoint other=(Point)obj;\r\nif(x!=other.x)return false;\r\nif(y!=other.y)return false;\r\nreturn true;\r\n}\r\n@Override public String toString(){\r\nreturn \"(\"+x+\",\"+y+\")\";\r\n}\r\npublic String toInputString(){\r\nreturn x+\" \"+y;\r\n}\r\n}\r\n\r\nclass PointUtils{\r\nstatic final Point[] CACHE_POINT=new Point[FrameworkConstant.CASE_NB];\r\npublic static Point toPoint(int p){\r\nint index=p;\r\nPoint ret=CACHE_POINT[index];\r\nif(ret==null){\r\nret=new Point(getX(p),getY(p));\r\nCACHE_POINT[index]=ret;\r\n}\r\nreturn ret;\r\n}\r\npublic static List<Point> toPoint(byte[] way){\r\nreturn IntStream.range(0,way.length)\r\n.mapToObj(i->way[i])\r\n.map(i->toPoint(i))\r\n.collect(Collectors.toList());\r\n}\r\npublic static List<Point> toPoint(Collection<Byte> way){\r\nreturn way.stream().map(i->toPoint(i)).collect(Collectors.toList());\r\n}\r\npublic static int getPosition(Scanner in){\r\nint x=in.nextInt();\r\nint y=in.nextInt();\r\nif(x==-1){\r\nreturn FrameworkConstant.OUT;\r\n}\r\nreturn getPosition(x,y);\r\n}\r\npublic static int getPosition(int x,int y){\r\nreturn x+FrameworkConstant.WIDTH*y;\r\n}\r\npublic static int distance(int p1,int p2){\r\nreturn Math.max(getDeltaX(p1,p2),getDeltaY(p1,p2));\r\n}\r\npublic static int distance2(int p1,int p2){\r\nreturn getDeltaX(p1,p2)+getDeltaY(p1,p2);\r\n}\r\nstatic int getDeltaX(int p1,int p2){\r\nreturn Math.abs(getX(p1)-getX(p2));\r\n}\r\nstatic int getDeltaY(int p1,int p2){\r\nreturn Math.abs(getY(p1)-getY(p2));\r\n}\r\npublic static boolean isNextTo(int p1,int p2){\r\nreturn distance(p1,p2)<=1;\r\n}\r\npublic static int getX(int p){\r\nreturn p%FrameworkConstant.WIDTH;\r\n}\r\npublic static int getY(int p){\r\nreturn p/FrameworkConstant.WIDTH;\r\n}\r\npublic static String toXYString(int p){\r\nreturn getX(p)+\" \"+getY(p);\r\n}\r\npublic static boolean isIn(int x,int y){\r\nreturn x>=0&&x<FrameworkConstant.WIDTH&&y>=0&&y<FrameworkConstant.HEIGHT;\r\n}\r\n}\r\n\r\nclass TimeOutException extends Exception{}\r\n\r\nclass TimeOutUtils{\r\npublic static int time=Parameter.FIRST_ROUND_TIME_OUT;\r\nstatic Timer timer=Timer.getInstance();\r\npublic static final TimeOutException EXCEPTION=new TimeOutException();\r\npublic static int count;\r\npublic static void init(){\r\ntime=Parameter.TIME_OUT;\r\n}\r\npublic static void stopTimeException()throws TimeOutException{\r\nif(isStopTime()){\r\nthrow EXCEPTION;\r\n}\r\n}\r\npublic static boolean isStopTime(){\r\nreturn timer.getTime()>=time;\r\n}\r\n}\r\n\r\n",
          "testCases": [],
          "maxPlayers": 2,
          "minPlayers": 2,
          "statements": {
            "1": "<div\n\tstyle=\"color: #000000; background-color: rgba(255, 255, 255, 0.5); padding: 20px; margin-bottom: 10px; text-align: left\">\n\tThis is a port of the board game <a\n\t\thref=\"https://fr.wikipedia.org/wiki/Isola_(jeu)\">Isola</a> :\n\t<br /> <br />\n\t<p style=\"text-align: center;\">\n\t\t<img\n\t\t\tsrc=\"https://github.com/wala-fr/CodingameIsolation/blob/master/CodingameIsolation/src/main/resources/view/statement/isola_statement.png?raw=true\"\n\t\t\tstyle=\"height: 200px; width: auto;\"></img>\n\t</p>\n\t<p>\n\t\tThe source code of this game is available <a rel=\"nofollow\"\n\t\t\ttarget=\"_blank\" href=\"https://github.com/wala-fr/CodingameIsola\">on\n\t\t\tthis GitHub repo</a>. <br />\n</div>\n\n<div id=\"statement_back\" class=\"statement_back\" style=\"display: none\"></div>\n<div class=\"statement-body\">\n\t<!-- GOAL -->\n\t<div class=\"statement-section statement-goal\">\n\t\t<h1>\n\t\t\t<span class=\"icon icon-goal\">&nbsp;</span> <span>The Goal</span>\n\t\t</h1>\n\t\t<div class=\"statement-goal-content\">The goal of the game is to\n\t\t\tblock the opponent's pawn.</div>\n\t</div>\n\t<!-- RULES -->\n\t<div class=\"statement-section statement-rules\">\n\t\t<h1>\n\t\t\t<span class=\"icon icon-rules\">&nbsp;</span> <span>Rules</span>\n\t\t</h1>\n\t\t<div class=\"statement-rules-content\">\n\t\t\t<strong>Board: </strong>\n\t\t\t<ul>\n\t\t\t\t<li>The game is played on a <const>9 x 9</const> board.\n\t\t\t\t</li>\n\t\t\t\t<li>Player 0 always starts at <const>(0, 4)</const> and player\n\t\t\t\t\t1 at <const>(8, 4)</const>.\n\t\t\t\t</li>\n\t\t\t</ul>\n\t\t\t<strong>At each turn: </strong><br>\n\t\t\t<ol>\n\t\t\t\t<li>You must <b>move your pawn</b> to an adjacent tile\n\t\t\t\t\t(diagonal included) :<br> <br>\n\n\t\t\t\t\t<p style=\"text-align: center;\">\n\t\t\t\t\t\t<img\n\t\t\t\t\t\t\tsrc=\"https://github.com/wala-fr/CodingameIsolation/blob/master/CodingameIsolation/src/main/resources/view/statement/moves.png?raw=true\"\n\t\t\t\t\t\t\tstyle=\"height: 200px; width: auto;\"></img>\n\t\t\t\t\t</p>You can't :\n\t\t\t\t\t<ul>\n\t\t\t\t\t\t<li>stay put</li>\n\t\t\t\t\t\t<li>move to the tile occupied by the opponent's pawn</li>\n\t\t\t\t\t\t<li>move to an already removed tile.</li>\n\t\t\t\t\t</ul>\n\n\t\t\t\t</li>\n\t\t\t\t<li><b>Then</b> you must <b>remove a free tile</b>.<br />You\n\t\t\t\t\tcan't remove a tile occupied by a pawn.</li>\n\t\t\t</ol>\n\t\t</div>\n\t</div>\n\n\t<!-- Victory conditions -->\n\t<div class=\"statement-victory-conditions\">\n\t\t<div class=\"icon victory\"></div>\n\t\t<div class=\"blk\">\n\t\t\t<div class=\"title\">Victory Conditions</div>\n\t\t\t<div class=\"text\">\n\t\t\t\t<ul style=\"padding-bottom: 0;\">\n\t\t\t\t\t<li>At his turn, the opponent can't move his pawn.</li>\n\t\t\t\t</ul>\n\t\t\t</div>\n\t\t</div>\n\t</div>\n\n\t<!-- Lose conditions -->\n\t<div class=\"statement-lose-conditions\">\n\t\t<div class=\"icon lose\"></div>\n\t\t<div class=\"blk\">\n\t\t\t<div class=\"title\">Loss Conditions</div>\n\t\t\t<div class=\"text\">\n\t\t\t\t<ul style=\"padding-bottom: 0;\">\n\t\t\t\t\t<li>At your turn, you can't move your pawn.</li>\n\t\t\t\t\t<li>You do not respond in time or output an invalid action.</li>\n\t\t\t\t</ul>\n\t\t\t</div>\n\t\t</div>\n\t</div>\n\n\t<!-- PROTOCOL -->\n\t<div class=\"statement-section statement-protocol\">\n\t\t<h1>\n\t\t\t<span class=\"icon icon-protocol\">&nbsp;</span> <span>Game\n\t\t\t\tInput</span>\n\t\t</h1>\n\n\t\t<!-- Protocol block -->\n\t\t<div class=\"blk\">\n\t\t\t<div class=\"title\">Initialization input</div>\n\t\t\t<div class=\"text\">\n\t\t\t\t<span class=\"statement-lineno\">Line 1</span>:\n\t\t\t\t<var>playerPositionX</var>\n\t\t\t\t<br> <span class=\"statement-lineno\">Line 2</span>:\n\t\t\t\t<var>playerPositionY</var>\n\t\t\t\tthe coordinates of your pawn.\n\t\t\t</div>\n\t\t\t<br>\n\t\t\t<div class=\"title\">Input for one game turn</div>\n\t\t\t<div class=\"text\">\n\t\t\t\t<span class=\"statement-lineno\">Line 1</span>:\n\t\t\t\t<var>opponentPositionX</var>\n\t\t\t\t<br> <span class=\"statement-lineno\">Line 2</span>:\n\t\t\t\t<var>opponentPositionY</var>\n\t\t\t\tthe coordinates of the opponent's pawn. <br> <span\n\t\t\t\t\tclass=\"statement-lineno\">Line 3</span>:\n\t\t\t\t<var>opponentLastRemovedTileX</var>\n\t\t\t\t<br> <span class=\"statement-lineno\">Line 4</span>:\n\t\t\t\t<var>opponentLastRemovedTileY</var>\n\t\t\t\tthe coordinates of the last tile removed by the opponent (\n\t\t\t\t<const>-1 -1</const>\n\t\t\t\tif no tile has been removed (first round)). <br>\n\t\t\t</div>\n\t\t</div>\n\n\t\t<!-- Protocol block -->\n\t\t<div class=\"blk\">\n\t\t\t<div class=\"title\">Output</div>\n\t\t\t<div class=\"text\">\n\t\t\t\t<span class=\"statement-lineno\">A single line</span> containing the\n\t\t\t\tcoordinates where you want to move your pawn, followed by the\n\t\t\t\tcoordinates of the tile you want to remove.<br>Example:\n\t\t\t\t<action>1 4 7 4</action>\n\t\t\t\t<br> You can also add a message :<br> Example:\n\t\t\t\t<action>1 4 7 4;MESSAGE</action>\n\t\t\t\t<br> NB : You can print\n\t\t\t\t<action>RANDOM</action>\n\t\t\t\tinstead of the 4 coordinates. Then a random possible move and tile\n\t\t\t\twill be chosen.\n\t\t\t</div>\n\t\t</div>\n\n\t\t<!-- Protocol block -->\n\t\t<div class=\"blk\">\n\t\t\t<div class=\"title\">Constraints</div>\n\t\t\tResponse time first turn is &le;\n\t\t\t<const>1000</const>\n\t\t\tms. <br>Response time per turn is &le;\n\t\t\t<const>100</const>\n\t\t\tms.\n\t\t</div>\n\t</div>\n</div>",
            "2": "<div\n\tstyle=\"color: #000000; background-color: rgba(255, 255, 255, 0.5); padding: 20px; margin-bottom: 10px; text-align: left\">\n\tThis is a port of the board game <a\n\t\thref=\"https://fr.wikipedia.org/wiki/Isola_(jeu)\">Isola</a> :\n\t<br /> <br />\n\t<p style=\"text-align: center;\">\n\t\t<img\n\t\t\tsrc=\"https://github.com/wala-fr/CodingameIsolation/blob/master/CodingameIsolation/src/main/resources/view/statement/isola_statement.png?raw=true\"\n\t\t\tstyle=\"height: 200px; width: auto;\"></img>\n\t</p>\n\t<p>\n\t\tThe source code of this game is available <a rel=\"nofollow\"\n\t\t\ttarget=\"_blank\" href=\"https://github.com/wala-fr/CodingameIsola\">on\n\t\t\tthis GitHub repo</a>. <br />\n</div>\n\n<div id=\"statement_back\" class=\"statement_back\" style=\"display: none\"></div>\n<div class=\"statement-body\">\n\t<!-- GOAL -->\n\t<div class=\"statement-section statement-goal\">\n\t\t<h1>\n\t\t\t<span class=\"icon icon-goal\">&nbsp;</span> <span>The Goal</span>\n\t\t</h1>\n\t\t<div class=\"statement-goal-content\">The goal of the game is to\n\t\t\tblock the opponent's pawn.</div>\n\t</div>\n\t<!-- RULES -->\n\t<div class=\"statement-section statement-rules\">\n\t\t<h1>\n\t\t\t<span class=\"icon icon-rules\">&nbsp;</span> <span>Rules</span>\n\t\t</h1>\n\t\t<div class=\"statement-rules-content\">\n\t\t\t<strong>Board: </strong>\n\t\t\t<ul>\n\t\t\t\t<li>The game is played on a <const>9 x 9</const> board.\n\t\t\t\t</li>\n\t\t\t\t<li>Player 0 always starts at <const>(0, 4)</const> and player\n\t\t\t\t\t1 at <const>(8, 4)</const>.\n\t\t\t\t</li>\n\t\t\t</ul>\n\t\t\t<strong>At each turn: </strong><br>\n\t\t\t<ol>\n\t\t\t\t<li>You must <b>move your pawn</b> to an adjacent tile\n\t\t\t\t\t(diagonal included) :<br> <br>\n\n\t\t\t\t\t<p style=\"text-align: center;\">\n\t\t\t\t\t\t<img\n\t\t\t\t\t\t\tsrc=\"https://github.com/wala-fr/CodingameIsolation/blob/master/CodingameIsolation/src/main/resources/view/statement/moves.png?raw=true\"\n\t\t\t\t\t\t\tstyle=\"height: 200px; width: auto;\"></img>\n\t\t\t\t\t</p>You can't :\n\t\t\t\t\t<ul>\n\t\t\t\t\t\t<li>stay put</li>\n\t\t\t\t\t\t<li>move to the tile occupied by the opponent's pawn</li>\n\t\t\t\t\t\t<li>move to an already removed tile.</li>\n\t\t\t\t\t</ul>\n\n\t\t\t\t</li>\n\t\t\t\t<li><b>Then</b> you must <b>remove a free tile</b>.<br />You\n\t\t\t\t\tcan't remove a tile occupied by a pawn.</li>\n\t\t\t</ol>\n\t\t</div>\n\t</div>\n\n\t<!-- Victory conditions -->\n\t<div class=\"statement-victory-conditions\">\n\t\t<div class=\"icon victory\"></div>\n\t\t<div class=\"blk\">\n\t\t\t<div class=\"title\">Victory Conditions</div>\n\t\t\t<div class=\"text\">\n\t\t\t\t<ul style=\"padding-bottom: 0;\">\n\t\t\t\t\t<li>At his turn, the opponent can't move his pawn.</li>\n\t\t\t\t</ul>\n\t\t\t</div>\n\t\t</div>\n\t</div>\n\n\t<!-- Lose conditions -->\n\t<div class=\"statement-lose-conditions\">\n\t\t<div class=\"icon lose\"></div>\n\t\t<div class=\"blk\">\n\t\t\t<div class=\"title\">Loss Conditions</div>\n\t\t\t<div class=\"text\">\n\t\t\t\t<ul style=\"padding-bottom: 0;\">\n\t\t\t\t\t<li>At your turn, you can't move your pawn.</li>\n\t\t\t\t\t<li>You do not respond in time or output an invalid action.</li>\n\t\t\t\t</ul>\n\t\t\t</div>\n\t\t</div>\n\t</div>\n\n\t<!-- PROTOCOL -->\n\t<div class=\"statement-section statement-protocol\">\n\t\t<h1>\n\t\t\t<span class=\"icon icon-protocol\">&nbsp;</span> <span>Game\n\t\t\t\tInput</span>\n\t\t</h1>\n\n\t\t<!-- Protocol block -->\n\t\t<div class=\"blk\">\n\t\t\t<div class=\"title\">Initialization input</div>\n\t\t\t<div class=\"text\">\n\t\t\t\t<span class=\"statement-lineno\">Line 1</span>:\n\t\t\t\t<var>playerPositionX</var>\n\t\t\t\t<br> <span class=\"statement-lineno\">Line 2</span>:\n\t\t\t\t<var>playerPositionY</var>\n\t\t\t\tthe coordinates of your pawn.\n\t\t\t</div>\n\t\t\t<br>\n\t\t\t<div class=\"title\">Input for one game turn</div>\n\t\t\t<div class=\"text\">\n\t\t\t\t<span class=\"statement-lineno\">Line 1</span>:\n\t\t\t\t<var>opponentPositionX</var>\n\t\t\t\t<br> <span class=\"statement-lineno\">Line 2</span>:\n\t\t\t\t<var>opponentPositionY</var>\n\t\t\t\tthe coordinates of the opponent's pawn. <br> <span\n\t\t\t\t\tclass=\"statement-lineno\">Line 3</span>:\n\t\t\t\t<var>opponentLastRemovedTileX</var>\n\t\t\t\t<br> <span class=\"statement-lineno\">Line 4</span>:\n\t\t\t\t<var>opponentLastRemovedTileY</var>\n\t\t\t\tthe coordinates of the last tile removed by the opponent (\n\t\t\t\t<const>-1 -1</const>\n\t\t\t\tif no tile has been removed (first round)). <br>\n\t\t\t</div>\n\t\t</div>\n\n\t\t<!-- Protocol block -->\n\t\t<div class=\"blk\">\n\t\t\t<div class=\"title\">Output</div>\n\t\t\t<div class=\"text\">\n\t\t\t\t<span class=\"statement-lineno\">A single line</span> containing the\n\t\t\t\tcoordinates where you want to move your pawn, followed by the\n\t\t\t\tcoordinates of the tile you want to remove.<br>Example:\n\t\t\t\t<action>1 4 7 4</action>\n\t\t\t\t<br> You can also add a message :<br> Example:\n\t\t\t\t<action>1 4 7 4;MESSAGE</action>\n\t\t\t\t<br> NB : You can print\n\t\t\t\t<action>RANDOM</action>\n\t\t\t\tinstead of the 4 coordinates. Then a random possible move and tile\n\t\t\t\twill be chosen.\n\t\t\t</div>\n\t\t</div>\n\n\t\t<!-- Protocol block -->\n\t\t<div class=\"blk\">\n\t\t\t<div class=\"title\">Constraints</div>\n\t\t\tResponse time first turn is &le;\n\t\t\t<const>1000</const>\n\t\t\tms. <br>Response time per turn is &le;\n\t\t\t<const>100</const>\n\t\t\tms.\n\t\t</div>\n\t</div>\n</div>"
          },
          "questionType": "multi",
          "stubGenerator": "read playerPositionX:int\nread playerPositionY:int\ngameloop\nread opponentPositionX:int\nread opponentPositionY:int\nread opponentLastRemovedTileX:int\nread opponentLastRemovedTileY:int\nwrite RANDOM;MESSAGE\n\nINPUT\nplayerPositionY:player's coordinates.\nopponentPositionY:opponent's coordinates.\nopponentLastRemovedTileY:coordinates of the last removed tile. (-1 -1) if no tile has been removed.\n",
          "welcomePopups": {
            "1": "<div style=\"text-align:center\">\r\n  <h2>You&#39;ve made it to the next league</h2>\r\n</div>",
            "2": "<div style=\"text-align:center\">\r\n  <h2>You&#39;ve made it to the next league</h2>\r\n</div>"
          },
          "aiCodeExtension": "java",
          "criteriaLanguageMap": {}
        },
        "3": {
          "aiCode": "import java.util.*;\nimport java.io.*;\nimport java.math.*;\n\nclass Player {\n  public static void main(String args[]) {\n    Scanner in = new Scanner(System.in);\n    int x = in.nextInt();\n    int y = in.nextInt();\n    // game loop\n    while (true) {\n      int xOpp = in.nextInt();\n      int yOpp = in.nextInt();\n\n      int xTileRemoved = in.nextInt();\n      int yTileRemoved = in.nextInt();\n      System.out.println(\"RANDOM;I'M THE AI\");\n    }\n  }\n}\n",
          "testCases": [],
          "maxPlayers": 2,
          "minPlayers": 2,
          "statements": {
            "1": "<div\n\tstyle=\"color: #000000; background-color: rgba(255, 255, 255, 0.5); padding: 20px; margin-bottom: 10px; text-align: left\">\n\tThis is a port of the board game <a\n\t\thref=\"https://fr.wikipedia.org/wiki/Isola_(jeu)\">Isola</a> :\n\t<br /> <br />\n\t<p style=\"text-align: center;\">\n\t\t<img\n\t\t\tsrc=\"https://github.com/wala-fr/CodingameIsolation/blob/master/CodingameIsolation/src/main/resources/view/statement/isola_statement.png?raw=true\"\n\t\t\tstyle=\"height: 200px; width: auto;\"></img>\n\t</p>\n\t<p>\n\t\tThe source code of this game is available <a rel=\"nofollow\"\n\t\t\ttarget=\"_blank\" href=\"https://github.com/wala-fr/CodingameIsola\">on\n\t\t\tthis GitHub repo</a>. <br />\n</div>\n\n<div id=\"statement_back\" class=\"statement_back\" style=\"display: none\"></div>\n<div class=\"statement-body\">\n\t<!-- GOAL -->\n\t<div class=\"statement-section statement-goal\">\n\t\t<h1>\n\t\t\t<span class=\"icon icon-goal\">&nbsp;</span> <span>The Goal</span>\n\t\t</h1>\n\t\t<div class=\"statement-goal-content\">The goal of the game is to\n\t\t\tblock the opponent's pawn.</div>\n\t</div>\n\t<!-- RULES -->\n\t<div class=\"statement-section statement-rules\">\n\t\t<h1>\n\t\t\t<span class=\"icon icon-rules\">&nbsp;</span> <span>Rules</span>\n\t\t</h1>\n\t\t<div class=\"statement-rules-content\">\n\t\t\t<strong>Board: </strong>\n\t\t\t<ul>\n\t\t\t\t<li>The game is played on a <const>9 x 9</const> board.\n\t\t\t\t</li>\n\t\t\t\t<li>Player 0 always starts at <const>(0, 4)</const> and player\n\t\t\t\t\t1 at <const>(8, 4)</const>.\n\t\t\t\t</li>\n\t\t\t</ul>\n\t\t\t<strong>At each turn: </strong><br>\n\t\t\t<ol>\n\t\t\t\t<li>You must <b>move your pawn</b> to an adjacent tile\n\t\t\t\t\t(diagonal included) :<br> <br>\n\n\t\t\t\t\t<p style=\"text-align: center;\">\n\t\t\t\t\t\t<img\n\t\t\t\t\t\t\tsrc=\"https://github.com/wala-fr/CodingameIsolation/blob/master/CodingameIsolation/src/main/resources/view/statement/moves.png?raw=true\"\n\t\t\t\t\t\t\tstyle=\"height: 200px; width: auto;\"></img>\n\t\t\t\t\t</p>You can't :\n\t\t\t\t\t<ul>\n\t\t\t\t\t\t<li>stay put</li>\n\t\t\t\t\t\t<li>move to the tile occupied by the opponent's pawn</li>\n\t\t\t\t\t\t<li>move to an already removed tile.</li>\n\t\t\t\t\t</ul>\n\n\t\t\t\t</li>\n\t\t\t\t<li><b>Then</b> you must <b>remove a free tile</b>.<br />You\n\t\t\t\t\tcan't remove a tile occupied by a pawn.</li>\n\t\t\t</ol>\n\t\t</div>\n\t</div>\n\n\t<!-- Victory conditions -->\n\t<div class=\"statement-victory-conditions\">\n\t\t<div class=\"icon victory\"></div>\n\t\t<div class=\"blk\">\n\t\t\t<div class=\"title\">Victory Conditions</div>\n\t\t\t<div class=\"text\">\n\t\t\t\t<ul style=\"padding-bottom: 0;\">\n\t\t\t\t\t<li>At his turn, the opponent can't move his pawn.</li>\n\t\t\t\t</ul>\n\t\t\t</div>\n\t\t</div>\n\t</div>\n\n\t<!-- Lose conditions -->\n\t<div class=\"statement-lose-conditions\">\n\t\t<div class=\"icon lose\"></div>\n\t\t<div class=\"blk\">\n\t\t\t<div class=\"title\">Loss Conditions</div>\n\t\t\t<div class=\"text\">\n\t\t\t\t<ul style=\"padding-bottom: 0;\">\n\t\t\t\t\t<li>At your turn, you can't move your pawn.</li>\n\t\t\t\t\t<li>You do not respond in time or output an invalid action.</li>\n\t\t\t\t</ul>\n\t\t\t</div>\n\t\t</div>\n\t</div>\n\n\t<!-- PROTOCOL -->\n\t<div class=\"statement-section statement-protocol\">\n\t\t<h1>\n\t\t\t<span class=\"icon icon-protocol\">&nbsp;</span> <span>Game\n\t\t\t\tInput</span>\n\t\t</h1>\n\n\t\t<!-- Protocol block -->\n\t\t<div class=\"blk\">\n\t\t\t<div class=\"title\">Initialization input</div>\n\t\t\t<div class=\"text\">\n\t\t\t\t<span class=\"statement-lineno\">Line 1</span>:\n\t\t\t\t<var>playerPositionX</var>\n\t\t\t\t<br> <span class=\"statement-lineno\">Line 2</span>:\n\t\t\t\t<var>playerPositionY</var>\n\t\t\t\tthe coordinates of your pawn.\n\t\t\t</div>\n\t\t\t<br>\n\t\t\t<div class=\"title\">Input for one game turn</div>\n\t\t\t<div class=\"text\">\n\t\t\t\t<span class=\"statement-lineno\">Line 1</span>:\n\t\t\t\t<var>opponentPositionX</var>\n\t\t\t\t<br> <span class=\"statement-lineno\">Line 2</span>:\n\t\t\t\t<var>opponentPositionY</var>\n\t\t\t\tthe coordinates of the opponent's pawn. <br> <span\n\t\t\t\t\tclass=\"statement-lineno\">Line 3</span>:\n\t\t\t\t<var>opponentLastRemovedTileX</var>\n\t\t\t\t<br> <span class=\"statement-lineno\">Line 4</span>:\n\t\t\t\t<var>opponentLastRemovedTileY</var>\n\t\t\t\tthe coordinates of the last tile removed by the opponent (\n\t\t\t\t<const>-1 -1</const>\n\t\t\t\tif no tile has been removed (first round)). <br>\n\t\t\t</div>\n\t\t</div>\n\n\t\t<!-- Protocol block -->\n\t\t<div class=\"blk\">\n\t\t\t<div class=\"title\">Output</div>\n\t\t\t<div class=\"text\">\n\t\t\t\t<span class=\"statement-lineno\">A single line</span> containing the\n\t\t\t\tcoordinates where you want to move your pawn, followed by the\n\t\t\t\tcoordinates of the tile you want to remove.<br>Example:\n\t\t\t\t<action>1 4 7 4</action>\n\t\t\t\t<br> You can also add a message :<br> Example:\n\t\t\t\t<action>1 4 7 4;MESSAGE</action>\n\t\t\t\t<br> NB : You can print\n\t\t\t\t<action>RANDOM</action>\n\t\t\t\tinstead of the 4 coordinates. Then a random possible move and tile\n\t\t\t\twill be chosen.\n\t\t\t</div>\n\t\t</div>\n\n\t\t<!-- Protocol block -->\n\t\t<div class=\"blk\">\n\t\t\t<div class=\"title\">Constraints</div>\n\t\t\tResponse time first turn is &le;\n\t\t\t<const>1000</const>\n\t\t\tms. <br>Response time per turn is &le;\n\t\t\t<const>100</const>\n\t\t\tms.\n\t\t</div>\n\t</div>\n</div>",
            "2": "<div\n\tstyle=\"color: #000000; background-color: rgba(255, 255, 255, 0.5); padding: 20px; margin-bottom: 10px; text-align: left\">\n\tThis is a port of the board game <a\n\t\thref=\"https://fr.wikipedia.org/wiki/Isola_(jeu)\">Isola</a> :\n\t<br /> <br />\n\t<p style=\"text-align: center;\">\n\t\t<img\n\t\t\tsrc=\"https://github.com/wala-fr/CodingameIsolation/blob/master/CodingameIsolation/src/main/resources/view/statement/isola_statement.png?raw=true\"\n\t\t\tstyle=\"height: 200px; width: auto;\"></img>\n\t</p>\n\t<p>\n\t\tThe source code of this game is available <a rel=\"nofollow\"\n\t\t\ttarget=\"_blank\" href=\"https://github.com/wala-fr/CodingameIsola\">on\n\t\t\tthis GitHub repo</a>. <br />\n</div>\n\n<div id=\"statement_back\" class=\"statement_back\" style=\"display: none\"></div>\n<div class=\"statement-body\">\n\t<!-- GOAL -->\n\t<div class=\"statement-section statement-goal\">\n\t\t<h1>\n\t\t\t<span class=\"icon icon-goal\">&nbsp;</span> <span>The Goal</span>\n\t\t</h1>\n\t\t<div class=\"statement-goal-content\">The goal of the game is to\n\t\t\tblock the opponent's pawn.</div>\n\t</div>\n\t<!-- RULES -->\n\t<div class=\"statement-section statement-rules\">\n\t\t<h1>\n\t\t\t<span class=\"icon icon-rules\">&nbsp;</span> <span>Rules</span>\n\t\t</h1>\n\t\t<div class=\"statement-rules-content\">\n\t\t\t<strong>Board: </strong>\n\t\t\t<ul>\n\t\t\t\t<li>The game is played on a <const>9 x 9</const> board.\n\t\t\t\t</li>\n\t\t\t\t<li>Player 0 always starts at <const>(0, 4)</const> and player\n\t\t\t\t\t1 at <const>(8, 4)</const>.\n\t\t\t\t</li>\n\t\t\t</ul>\n\t\t\t<strong>At each turn: </strong><br>\n\t\t\t<ol>\n\t\t\t\t<li>You must <b>move your pawn</b> to an adjacent tile\n\t\t\t\t\t(diagonal included) :<br> <br>\n\n\t\t\t\t\t<p style=\"text-align: center;\">\n\t\t\t\t\t\t<img\n\t\t\t\t\t\t\tsrc=\"https://github.com/wala-fr/CodingameIsolation/blob/master/CodingameIsolation/src/main/resources/view/statement/moves.png?raw=true\"\n\t\t\t\t\t\t\tstyle=\"height: 200px; width: auto;\"></img>\n\t\t\t\t\t</p>You can't :\n\t\t\t\t\t<ul>\n\t\t\t\t\t\t<li>stay put</li>\n\t\t\t\t\t\t<li>move to the tile occupied by the opponent's pawn</li>\n\t\t\t\t\t\t<li>move to an already removed tile.</li>\n\t\t\t\t\t</ul>\n\n\t\t\t\t</li>\n\t\t\t\t<li><b>Then</b> you must <b>remove a free tile</b>.<br />You\n\t\t\t\t\tcan't remove a tile occupied by a pawn.</li>\n\t\t\t</ol>\n\t\t</div>\n\t</div>\n\n\t<!-- Victory conditions -->\n\t<div class=\"statement-victory-conditions\">\n\t\t<div class=\"icon victory\"></div>\n\t\t<div class=\"blk\">\n\t\t\t<div class=\"title\">Victory Conditions</div>\n\t\t\t<div class=\"text\">\n\t\t\t\t<ul style=\"padding-bottom: 0;\">\n\t\t\t\t\t<li>At his turn, the opponent can't move his pawn.</li>\n\t\t\t\t</ul>\n\t\t\t</div>\n\t\t</div>\n\t</div>\n\n\t<!-- Lose conditions -->\n\t<div class=\"statement-lose-conditions\">\n\t\t<div class=\"icon lose\"></div>\n\t\t<div class=\"blk\">\n\t\t\t<div class=\"title\">Loss Conditions</div>\n\t\t\t<div class=\"text\">\n\t\t\t\t<ul style=\"padding-bottom: 0;\">\n\t\t\t\t\t<li>At your turn, you can't move your pawn.</li>\n\t\t\t\t\t<li>You do not respond in time or output an invalid action.</li>\n\t\t\t\t</ul>\n\t\t\t</div>\n\t\t</div>\n\t</div>\n\n\t<!-- PROTOCOL -->\n\t<div class=\"statement-section statement-protocol\">\n\t\t<h1>\n\t\t\t<span class=\"icon icon-protocol\">&nbsp;</span> <span>Game\n\t\t\t\tInput</span>\n\t\t</h1>\n\n\t\t<!-- Protocol block -->\n\t\t<div class=\"blk\">\n\t\t\t<div class=\"title\">Initialization input</div>\n\t\t\t<div class=\"text\">\n\t\t\t\t<span class=\"statement-lineno\">Line 1</span>:\n\t\t\t\t<var>playerPositionX</var>\n\t\t\t\t<br> <span class=\"statement-lineno\">Line 2</span>:\n\t\t\t\t<var>playerPositionY</var>\n\t\t\t\tthe coordinates of your pawn.\n\t\t\t</div>\n\t\t\t<br>\n\t\t\t<div class=\"title\">Input for one game turn</div>\n\t\t\t<div class=\"text\">\n\t\t\t\t<span class=\"statement-lineno\">Line 1</span>:\n\t\t\t\t<var>opponentPositionX</var>\n\t\t\t\t<br> <span class=\"statement-lineno\">Line 2</span>:\n\t\t\t\t<var>opponentPositionY</var>\n\t\t\t\tthe coordinates of the opponent's pawn. <br> <span\n\t\t\t\t\tclass=\"statement-lineno\">Line 3</span>:\n\t\t\t\t<var>opponentLastRemovedTileX</var>\n\t\t\t\t<br> <span class=\"statement-lineno\">Line 4</span>:\n\t\t\t\t<var>opponentLastRemovedTileY</var>\n\t\t\t\tthe coordinates of the last tile removed by the opponent (\n\t\t\t\t<const>-1 -1</const>\n\t\t\t\tif no tile has been removed (first round)). <br>\n\t\t\t</div>\n\t\t</div>\n\n\t\t<!-- Protocol block -->\n\t\t<div class=\"blk\">\n\t\t\t<div class=\"title\">Output</div>\n\t\t\t<div class=\"text\">\n\t\t\t\t<span class=\"statement-lineno\">A single line</span> containing the\n\t\t\t\tcoordinates where you want to move your pawn, followed by the\n\t\t\t\tcoordinates of the tile you want to remove.<br>Example:\n\t\t\t\t<action>1 4 7 4</action>\n\t\t\t\t<br> You can also add a message :<br> Example:\n\t\t\t\t<action>1 4 7 4;MESSAGE</action>\n\t\t\t\t<br> NB : You can print\n\t\t\t\t<action>RANDOM</action>\n\t\t\t\tinstead of the 4 coordinates. Then a random possible move and tile\n\t\t\t\twill be chosen.\n\t\t\t</div>\n\t\t</div>\n\n\t\t<!-- Protocol block -->\n\t\t<div class=\"blk\">\n\t\t\t<div class=\"title\">Constraints</div>\n\t\t\tResponse time first turn is &le;\n\t\t\t<const>1000</const>\n\t\t\tms. <br>Response time per turn is &le;\n\t\t\t<const>100</const>\n\t\t\tms.\n\t\t</div>\n\t</div>\n</div>"
          },
          "questionType": "multi",
          "stubGenerator": "read playerPositionX:int\nread playerPositionY:int\ngameloop\nread opponentPositionX:int\nread opponentPositionY:int\nread opponentLastRemovedTileX:int\nread opponentLastRemovedTileY:int\nwrite RANDOM;MESSAGE\n\nINPUT\nplayerPositionY:player's coordinates.\nopponentPositionY:opponent's coordinates.\nopponentLastRemovedTileY:coordinates of the last removed tile. (-1 -1) if no tile has been removed.\n",
          "welcomePopups": {
            "1": "<div style=\"text-align:center\">\r\n  <h2>You&#39;ve made it to the next league</h2>\r\n</div>",
            "2": "<div style=\"text-align:center\">\r\n  <h2>You&#39;ve made it to the next league</h2>\r\n</div>"
          },
          "aiCodeExtension": "java",
          "criteriaLanguageMap": {}
        }
      },
      "coverBinaryId": 87279769849928,
      "directoryPrefix": "community/893541-1657559291523",
      "allowSourceDownload": false
    },
    "draft": false,
    "readyForModeration": true
  },
  "validatedFor": 109264945326,
  "avatar": 97577641170180,
  "commentCount": 21,
  "upVotes": 23,
  "downVotes": 0,
  "validateAction": {
    "actionId": 693414,
    "progress": 1,
    "alreadyDone": false
  },
  "statusHistory": [
    {
      "status": "ACCEPTED",
      "date": 1661464808435,
      "data": {
        "author": "ACTION"
      }
    }
  ],
  "editable": true,
  "draft": false,
  "readyForModeration": true
}