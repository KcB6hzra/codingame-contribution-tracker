{
  "id": 7031,
  "activeVersion": 21,
  "score": 4,
  "votableId": 19067439,
  "codingamerId": 3398492,
  "views": 141,
  "commentableId": 18968366,
  "title": "Train passenger",
  "status": "ACCEPTED",
  "type": "PUZZLE_INOUT",
  "nickname": "Rouge_dragon",
  "publicHandle": "70319e3d0c55e2108e1c44092472e37748ee",
  "codingamerHandle": "1ec7a67c61c9bdd986c99b604e7734892948933",
  "lastVersion": {
    "version": 21,
    "autocloseTime": 1627324093165,
    "data": {
      "title": "Train passenger",
      "topics": [
        {
          "id": 68,
          "handle": "pathfinding",
          "category": "ADVANCED",
          "labelMap": {
            "1": "Recherche de chemins",
            "2": "Pathfinding"
          },
          "pageTitle": "Pathfinding: exercises and theory",
          "puzzleCount": 34,
          "parentTopicId": 41,
          "contentDetailsId": 69
        },
        {
          "id": 54,
          "handle": "BFS",
          "category": "ADVANCED",
          "labelMap": {
            "1": "Parcours en largeur",
            "2": "BFS"
          },
          "pageTitle": "BFS: exercises and theory",
          "puzzleCount": 14,
          "parentTopicId": 41,
          "contentDetailsId": 84
        },
        {
          "id": 48,
          "handle": "graphs",
          "category": "INTERMEDIATE",
          "labelMap": {
            "1": "Graphes",
            "2": "Graphs"
          },
          "pageTitle": "Graphs: exercises and theory",
          "puzzleCount": 23,
          "parentTopicId": 40,
          "contentDetailsId": 75
        }
      ],
      "solution": "start = input()\nend = input()\nn = int(input())\nlinks = []\nfor i in range(n):\n    stationA, stationsB = input().split()\n    links.append([stationA, stationsB])\n\ndef recursive(station,target_station,links):\n    if station == target_station:\n        return [[station]]\n    if len(links) == 0:\n        return None\n\n    all_paths = []\n    for i,link in enumerate(links):\n        index = 0\n        if link[0] == station:\n            index = 1\n        if link[1] == station or link[0] == station:\n            new_links = links.copy()\n            new_links.pop(i)\n            paths = recursive(link[index],target_station,new_links)\n            if paths is not None:\n                for path in paths:\n                    path.append(station)\n                    all_paths.append(path)\n\n    return all_paths\n\nall_paths = recursive(start,end,links)\nshorstestN = None\nshorstestP = None\nfor path in all_paths:\n    path.reverse()\n    if shorstestN is None or len(path) < shorstestN:\n        shorstestP = path\n\no = \"\"\nfor stations in shorstestP:\n    o+= stations + \" > \"\nprint(o[:-3])",
      "statement": "You are a train passenger and you want to know the shortest path you can take between two stations. Unfortunately, there is no direct path between these two stations. So, you need to travel station to station to arrive at your destination. You want to find the shortest path you can take. The shortest path is the path that travels through the smallest number of stations.\nThere will always be a path from start to end.",
      "testCases": [
        {
          "title": "Simple A to B",
          "isTest": true,
          "testIn": "A\nB\n1\nA B",
          "testOut": "A > B",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Simple A to B",
          "isTest": false,
          "testIn": "D\nJ\n1\nD J",
          "testOut": "D > J",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "More stations",
          "isTest": true,
          "testIn": "E\nD\n2\nE G\nG D",
          "testOut": "E > G > D",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "More stations",
          "isTest": false,
          "testIn": "S\nT\n2\nS C\nC T",
          "testOut": "S > C > T",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "Even more stations",
          "isTest": true,
          "testIn": "A\nZ\n25\nA B\nB C\nC D\nD E\nE F\nF G\nG H\nH I\nI J\nJ K\nK L\nL M\nM N\nN O\nO P\nP Q\nQ R\nR S\nS T\nT U\nU V\nV W\nW X\nX Y\nY Z",
          "testOut": "A > B > C > D > E > F > G > H > I > J > K > L > M > N > O > P > Q > R > S > T > U > V > W > X > Y > Z",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Even more stations",
          "isTest": false,
          "testIn": "Z\nN\n12\nZ Y\nY X\nX W\nW V\nV U\nU T\nT S\nS R\nR Q\nQ P\nP O\nO N",
          "testOut": "Z > Y > X > W > V > U > T > S > R > Q > P > O > N",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "Not in correct order",
          "isTest": true,
          "testIn": "A\nE\n4\nD E\nD C\nA B\nC B",
          "testOut": "A > B > C > D > E",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Not in correct order",
          "isTest": false,
          "testIn": "D\nF\n4\nC F\nC E\nE R\nD R",
          "testOut": "D > R > E > C > F",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "Complex names",
          "isTest": true,
          "testIn": "BestStation\nWorstStation\n2\nBestStation MediumStation\nMediumStation WorstStation",
          "testOut": "BestStation > MediumStation > WorstStation",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Complex names",
          "isTest": false,
          "testIn": "GoodPlace\nBadPlace\n2\nGoodPlace MediumPlace\nMediumPlace BadPlace",
          "testOut": "GoodPlace > MediumPlace > BadPlace",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "Complex stations links",
          "isTest": true,
          "testIn": "A\nF\n17\nA E\nE R\nR Y\nY A\nR A\nG H\nH J\nJ K\nK L\nL M\nI R\nR P\nD C\nV S\nS D\nF D\nP V",
          "testOut": "A > R > P > V > S > D > F",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Complex stations links",
          "isTest": false,
          "testIn": "A\nS\n15\nA R\nR G\nG T\nA T\nT H\nT R\nT Y\nU T\nA D\nA C\nD X\nX L\nL I\nI D\nI S",
          "testOut": "A > D > I > S",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "Complete test",
          "isTest": true,
          "testIn": "ByTheWay\nImBadAtCoding\n8\nByTheWay ILoveCoding\nILoveCoding But\nBut ThisNeedToDistractYou\nBut ThisToo\nThisToo IsStupid\nIsStupid ToBeReallyStupid\nToBeReallyStupid WeNeed\nBut ImBadAtCoding",
          "testOut": "ByTheWay > ILoveCoding > But > ImBadAtCoding",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Complete test",
          "isTest": false,
          "testIn": "ThisIsAStation\nThisIsAlsoAStation\n7\nMaybeThisOneToo ThisIsNot\nThisIsNot IReallyDontKnow\nThisOneImNotSure ThisIsNot\nForRealThisIsTheOne ThisOneImNotSure\nThisStationIsNotEvenAStation MaybeThisOneToo\nThisIsAStation ThisStationIsNotEvenAStation\nThisOneImNotSure ThisIsAlsoAStation",
          "testOut": "ThisIsAStation > ThisStationIsNotEvenAStation > MaybeThisOneToo > ThisIsNot > ThisOneImNotSure > ThisIsAlsoAStation",
          "isValidator": true,
          "needValidation": true
        }
      ],
      "difficulty": "medium",
      "constraints": "0 < [[n]] < 30",
      "coverBinaryId": 66762008199518,
      "stubGenerator": "read start:string(100)\nread end:string(100)\nread n:int\nloop n read station1:word(100) station2:word(100)\nwrite answer",
      "inputDescription": "<<Line 1:>> A string [[start]] representing the <<start station>>.\n<<Line 2:>> A string [[end]] representing the <<end station>>.\n<<Line 3:>> An integer [[n]] representing the <<number of links>> between all stations.\n<<Next [[n]] lines:>> A string [[link]] formatted as: \"{{station1 station2}}\" saying that a direct path exists between {{station1}} and {{station2}}. This path is bidirectional.",
      "solutionLanguage": "Python3",
      "outputDescription": "<<Line 1:>> A string that represents the <<smallest path>> between the [[start]] and the [[end]] formatted as: \"{{A > B > C > D}}\" where <<A>> is [[start]] and <<D>> is [[end]]."
    },
    "draft": false,
    "readyForModeration": true,
    "statementHTML": "<div class=\"statement-body\">\n<div class=\"statement-section statement-goal\">\n   <h2><span class=\"icon icon-goal\">&nbsp;</span><span>Goal </span></h2>\n   <span class=\"question-statement\">You are a train passenger and you want to know the shortest path you can take between two stations. Unfortunately, there is no direct path between these two stations. So, you need to travel station to station to arrive at your destination. You want to find the shortest path you can take. The shortest path is the path that travels through the smallest number of stations.<br>There will always be a path from start to end.</span>\n</div>\n<div class=\"statement-section statement-protocol\">\n   <div class=\"blk\">\n      <div class=\"title\">Input</div>\n      <div class=\"question-statement-input\"><strong>Line 1:</strong> A string <var>start</var> representing the <strong>start station</strong>.<br><strong>Line 2:</strong> A string <var>end</var> representing the <strong>end station</strong>.<br><strong>Line 3:</strong> An integer <var>n</var> representing the <strong>number of links</strong> between all stations.<br><strong>Next <var>n</var> lines:</strong> A string <var>link</var> formatted as: &quot;<const>station1 station2</const>&quot; saying that a direct path exists between <const>station1</const> and <const>station2</const>. This path is bidirectional.</div>\n   </div>\n   <div class=\"blk\">\n      <div class=\"title\">Output</div>\n      <div class=\"question-statement-output\"><strong>Line 1:</strong> A string that represents the <strong>smallest path</strong> between the <var>start</var> and the <var>end</var> formatted as: &quot;<const>A &gt; B &gt; C &gt; D</const>&quot; where <strong>A</strong> is <var>start</var> and <strong>D</strong> is <var>end</var>.</div>\n   </div>\n   <div class=\"blk\">\n      <div class=\"title\">Constraints</div>\n      <div class=\"question-statement-constraints\">0 &lt; <var>n</var> &lt; 30</div>\n   </div>\n   <div class=\"blk\">\n      <div class=\"title\">Example</div>\n      <div class=\"statement-inout\">\n         <div class=\"statement-inout-in\">\n            <div class=\"title\">Input</div>\n            <pre class=\"question-statement-example-in\">A\nB\n1\nA B</pre>\n         </div>\n         <div class=\"statement-inout-out\">\n            <div class=\"title\">Output</div>\n            <pre class=\"question-statement-example-out\">A &gt; B</pre>\n         </div>\n      </div>\n   </div>\n</div>"
  },
  "validatedFor": 145470285987,
  "avatar": 65926126072050,
  "commentCount": 11,
  "upVotes": 6,
  "downVotes": 2,
  "validateAction": {
    "actionId": 574249,
    "progress": 1,
    "alreadyDone": false
  },
  "statusHistory": [
    {
      "status": "ACCEPTED",
      "date": 1625260134062,
      "data": {
        "author": "ACTION"
      }
    }
  ],
  "editable": true,
  "draft": false,
  "readyForModeration": true
}