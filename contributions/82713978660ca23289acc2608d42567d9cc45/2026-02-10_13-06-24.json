{
  "id": 82713,
  "activeVersion": 78,
  "score": 15,
  "votableId": 32511234,
  "codingamerId": 1036092,
  "views": 687,
  "commentableId": 32367971,
  "title": "Simple Pascal (PL/0) Compiler",
  "status": "ACCEPTED",
  "type": "PUZZLE_INOUT",
  "nickname": "JDOnline",
  "publicHandle": "82713978660ca23289acc2608d42567d9cc45",
  "codingamerHandle": "6aed1b19fc10b92d8f1d78dce39fb7592906301",
  "lastVersion": {
    "version": 78,
    "autocloseTime": 1719293051832,
    "data": {
      "title": "Simple Pascal (PL/0) Compiler",
      "topics": [
        {
          "id": 67,
          "handle": "parsing",
          "category": "FUNDAMENTALS",
          "labelMap": {
            "1": "Parsing",
            "2": "Parsing"
          },
          "pageTitle": "Parsing: exercises and theory",
          "puzzleCount": 37,
          "parentTopicId": 41,
          "contentDetailsId": 102
        },
        {
          "id": 235,
          "handle": "interpreter",
          "category": "INTERMEDIATE",
          "labelMap": {
            "1": "interpreter",
            "2": "Interpreters"
          },
          "puzzleCount": 9,
          "parentTopicId": 93
        },
        {
          "id": 112,
          "handle": "string-manipulation",
          "category": "FUNDAMENTALS",
          "labelMap": {
            "1": "String manipulation",
            "2": "String manipulation"
          },
          "puzzleCount": 62,
          "parentTopicId": 93
        }
      ],
      "solution": "\"\"\"\n\nPL/0 Compiler (Part I)\n\n\"\"\"\n\n#\n# PL/0 INSTRUCTIONS\n#\nPL_LIT=0\nPL_OPR=1\nPL_LOD=2\nPL_STO=3\nPL_CAL=4\nPL_INT=5\nPL_JMP=6\nPL_JPC=7\n\n#\n# PL/0 OPERATIONS\n#\nPL_OP_RET=0\nPL_OP_NEG=1\nPL_OP_ADD=2\nPL_OP_SUB=3\nPL_OP_MUL=4\nPL_OP_DIV=5\nPL_OP_ODD=6\nPL_OP_EQU=7\nPL_OP_DIF=8\nPL_OP_INF=9\nPL_OP_SEQ=10\nPL_OP_SUP=11\nPL_OP_IEQ=12\nPL_OP_OUT=13\nPL_OP_IN=14\n\n#\n# Compilation exception\n#\nclass CompilationException(Exception):\n    pass\n\n# -------------------------------------------------------------------\n#\n# PL/0 parser\n#\n# -------------------------------------------------------------------\n\n#\n# Parser PL0 tokens and symbols\n#\nclass PL0_Parser:\n\n    #\n    # All PL/0 tokens\n    #\n    tk_none = 0\n    tk_const = 1\n    tk_var = 2\n    tk_procedure = 3\n    tk_equal = 4\n    tk_eoc = 5\n    tk_comma = 6\n    tk_point = 7\n    tk_assign = 8\n    tk_call = 9\n    tk_input = 10\n    tk_output = 11\n    tk_begin = 12\n    tk_end = 13\n    tk_if = 14\n    tk_then = 15\n    tk_while = 16\n    tk_do = 17\n    tk_odd = 18\n    tk_equal = 19\n    tk_sup = 20\n    tk_inf = 21\n    tk_supeq = 22\n    tk_infeq = 23\n    tk_diff = 24\n    tk_plus = 25\n    tk_minus = 26\n    tk_mul = 27\n    tk_div = 28\n    tk_open = 29\n    tk_close = 30\n    tk_number = 31\n    tk_eol = 32\n    tk_ident = 33\n    tk_eof = 34\n    \n    # \n    # Reserved keywords\n    #\n    keywords = {\n        \"const\": tk_const, \"var\": tk_var, \"call\": tk_call, \"begin\": tk_begin, \"end\": tk_end, \"procedure\": tk_procedure,\n        \"if\": tk_if, \"then\": tk_then, \"while\": tk_while, \"do\": tk_do, \"odd\": tk_odd\n    }\n\n    #\n    # PL/0 symbols\n    #\n    symbols = { \n        tk_const: \"const\", tk_var: \"var\", tk_procedure: \"procedure\", tk_equal: \"=\", tk_eoc: ';', tk_comma: ',', tk_point: \".\",\n        tk_assign: \":=\", tk_call: \"call\", tk_input: \"?\", tk_output: \"!\", tk_begin: \"begin\", tk_end: \"end\", tk_if: \"if\", tk_then: \"then\",\n        tk_while: \"while\", tk_do: \"do\", tk_odd: \"odd\", tk_equal: \"=\", tk_sup: \">\", tk_inf: \"<\", tk_supeq: \">=\", tk_infeq: \"<=\",\n        tk_diff: \"#\", tk_plus: \"+\", tk_minus: \"-\", tk_mul: \"*\", tk_div: \"/\", tk_open: \"(\", tk_close: \")\", tk_number:\"Number\",\n        tk_ident: \"Identifier\"\n    }\n\n    #\n    # PL/0 operators\n    #\n    tk_operators = [tk_equal, tk_diff, tk_inf, tk_infeq, tk_sup, tk_supeq ]\n\n    def __init__(self, content):\n        self.symbol = self.tk_none  # Current symbol\n        self.next_char = None       # Next character\n        self.attr = None            # Attribute for symbol\n        self.next_token = None      # Next token\n        self.line = 0               # Line number\n        self.errline = 0            # Error line number\n        self.tkline = 0             # Token line number\n        self.buffer = \"\"            # Buffer for parsing\n        self.content = content      # The program to parse\n\n    # Return next characters, by default ignore end of line \n    def get_char(self, ig_eol=True):\n\n        if self.next_char == self.tk_eol and ig_eol == True:\n            self.line += 1\n            self.next_char = None\n\n        if self.next_char != None:  \n            if self.next_char == self.tk_eol:\n                self.line += 1          \n            tmp = self.next_char\n            self.next_char = None\n            return tmp                        \n\n        while len(self.buffer) == 0:\n            # Next line or end of file\n            if self.line < len(self.content):\n                self.buffer = self.content[self.line].strip()\n                self.line += 1\n                if not ig_eol and len(self.buffer) != 0:\n                    return self.tk_eol\n            else:\n                return None\n        \n        char = self.buffer[0]\n        self.buffer = self.buffer[1:]\n\n        return char\n\n    # Push back a character to be used as next char for get_char\n    def return_char(self, c):\n        if c == self.tk_eol:\n            self.line -= 1;\n        self.next_char = c\n\n    # Return attribute of the symbol\n    def get_attribute(self):\n        return self.attr\n\n    # Return next token\n    def get_token(self):\n        if self.next_token != None:\n            tmp = self.next_token\n            self.next_token = None\n            return tmp\n        \n        c = self.get_char()\n\n        if c == None:\n            return self.tk_eof\n        elif c in [ ' ', '\\t' ]:\n            return self.get_token()\n        elif c == '(':\n            return self.tk_open\n        elif c == ')':\n            return self.tk_close\n        elif c == ':':\n            c = self.get_char()\n            if c == '=':\n                return self.tk_assign\n            return self.tk_none\n        elif c == '=':\n            return self.tk_equal\n        elif c == ',':\n            return self.tk_comma\n        elif c == ';':\n            return self.tk_eoc\n        elif c == '.':\n            return self.tk_point\n        elif c == '?':\n            return self.tk_input\n        elif c == '!':\n            return self.tk_output\n        elif c == '>':\n            c = self.get_char()\n            if c == '=':\n                return self.tk_supeq\n            else:\n                self.return_char(c)\n                return self.tk_sup\n        elif c == '<':\n            c = self.get_char()\n            if c == '=':\n                return self.tk_infeq\n            else:\n                self.return_char(c)\n                return self.tk_inf\n        elif c == '#':\n            return self.tk_diff\n        elif c == '+':\n            return self.tk_plus\n        elif c == '-':\n            return self.tk_minus\n        elif c == '*':\n            return self.tk_mul\n        elif c == '/':\n            return self.tk_div\n        elif c.isdigit():\n            self.return_char(c)\n            self.attr = self.get_number()\n            return self.tk_number\n        else:\n            self.return_char(c)\n            line = self.line\n            word = self.get_word()\n            self.tkline = line\n            # Check if the word is a reserved keyword\n            if word.lower() in self.keywords.keys():\n                return self.keywords[word.lower()]\n            else:\n                # Otherwise this is an identifier\n                self.attr = word\n                return self.tk_ident\n\n    # Return a token to be used next time by get_token            \n    def return_token(self, token):\n        self.next_token = token\n\n    # Parse a word\n    def get_word(self):\n        word = \"\"\n        while True:\n            c = self.get_char(False)            \n            if c != None and c != self.tk_eol and c.isalnum():\n                word += c\n            else:\n                self.return_char(c)\n                return word\n\n    # Parse a number\n    def get_number(self):\n        num = \"\"\n        while True:\n            c = self.get_char(False)\n            if c != None and c != self.tk_eol and c.isdigit():\n                num += c\n            else:\n                self.return_char(c)\n                return int(num)\n    \n    # Commit usage of a token\n    def commit_token(self):\n        self.tkline = self.line\n        self.errline = self.tkline\n\n    # Consume a token, so get a token or raise an exception \n    def consume(self, token):\n        tk = self.get_token()    \n\n        if tk != token:\n            raise CompilationException(f\"Line {self.errline}: {self.symbols[token]} missing\")\n        \n        self.errline = self.tkline\n\n# -------------------------------------------------------------------\n#\n# PL/0 Compiler\n#\n# -------------------------------------------------------------------\n        \nclass PL0_Compiler:\n    \n    # Variables, procedures and constants\n    PL_VARS = {}\n    PL_PROCS = {}\n    PL_CONSTS = {}\n    \n    STACK_SHIFT = 3\n\n    def __init__(self, content):\n        self.parser = PL0_Parser(content)   # The parser\n        self.PL_IDX = 0                     # Index of instruction\n        self.pl_instr = []                  # The compiled code\n\n    # Add an instruction to the code\n    # Each instruction is a tuple ( instruction code, level, argument )\n    def add_pl_instr(self, instruction, level, arg):        \n        self.pl_instr.append( (instruction, level, arg ) )\n        self.PL_IDX += 1\n\n    # Create an empty instruction which will be updated later on\n    def reserve_pl_instr(self):\n        self.pl_instr.append( None )\n        tmp = self.PL_IDX\n        self.PL_IDX += 1\n        return tmp\n    \n    # Fix an empty PL instruction by a real one\n    def fixup_pl_instr(self, idx, instruction, level, arg):\n        self.pl_instr[idx] = ( instruction, level, arg )\n\n    # Return a const value\n    def get_const_value(self, fullname):\n\n        mylevel = fullname.count(':')\n       \n        while True:\n            if fullname in self.PL_CONSTS.keys():\n                return mylevel-fullname.count(':'), self.PL_CONSTS[fullname]\n            \n            if fullname.count(':') == 1:\n                return None, None\n            \n            last = fullname.rfind(\":\") \n            previous = fullname[:fullname.rfind(\":\", 0, last)]\n            fullname = previous + fullname[last:]\n\n    # Return a variable address and level\n    def get_var_addr(self, fullname):\n\n        mylevel = fullname.count(':')\n        \n        while True:\n        \n            if fullname in self.PL_VARS.keys():\n                return mylevel-fullname.count(':'), self.PL_VARS[fullname] + self.STACK_SHIFT\n            \n            if fullname.count(':') == 1:\n                raise CompilationException(f\"Line {self.parser.line}: Unknown var\")\n            \n            last = fullname.rfind(\":\") \n            previous = fullname[:fullname.rfind(\":\", 0, last)]\n            fullname = previous + fullname[last:]                    \n    \n    # Return a procedure address and level\n    def get_proc_addr(self, fullname):\n\n       \n        while True:\n            if fullname in self.PL_PROCS.keys():\n                return fullname.count(':')-1, self.PL_PROCS[fullname]\n            \n            if fullname.count(':') == 1:\n                raise CompilationException(f\"Line {self.parser.line}: Unknown procedure\")      \n                 \n            last = fullname.rfind(\":\") \n            previous = fullname[:fullname.rfind(\":\", 0, last)]\n            fullname = previous + fullname[last:] \n\n    # Define number of variables in this scope\n    def get_var_addr_number(self, scopename):\n\n        level = scopename.count(':')\n        nb_var = 0\n        for v in self.PL_VARS.keys():\n            if v.count(':')-1 == level and len(v) > len(scopename):\n                if v.startswith(scopename+\":\"):          \n                    nb_var += 1\n        return nb_var\n\n    #\n    # Parse a condition section:\n    # condition = \"odd\" expression |\n    #             expression (\"=\"|\"#\"|\"<\"|\"<=\"|\">\"|\">=\") expression\n    #\n    def parse_condition(self, pname):\n               \n        conditions = { self.parser.tk_equal: PL_OP_EQU, self.parser.tk_diff: PL_OP_DIF, self.parser.tk_inf: PL_OP_INF, self.parser.tk_infeq: PL_OP_IEQ, \n                       self.parser.tk_sup: PL_OP_SUP, self.parser.tk_supeq: PL_OP_SEQ }\n        \n        tk = self.parser.get_token()\n        if tk == self.parser.tk_odd:\n            self.parse_expression(pname)\n            self.add_pl_instr(PL_OPR, 0, PL_OP_ODD)\n        else:\n            self.parser.return_token(tk)\n            self.parse_expression(pname)\n            op = self.parser.get_token()\n            if op not in self.parser.tk_operators:\n                raise CompilationException(f\"Line {self.parser.line}: Invalid expr\")\n            self.parse_expression(pname)\n            self.add_pl_instr(PL_OPR, 0, conditions[op])\n\n    #\n    # Parse a factor section:\n    # factor = ident | number | \"(\" expression \")\";\n    #\n    def parse_factor(self, pname):\n        tk = self.parser.get_token()\n        if tk == self.parser.tk_open:\n            self.parse_expression(pname)\n            self.parser.consume(self.parser.tk_close)\n        else:\n            if tk not in [ self.parser.tk_ident, self.parser.tk_number ]:\n                raise CompilationException(f\"Line {self.parser.line}: Invalid expr\")\n            if tk == self.parser.tk_number:\n                self.add_pl_instr(PL_LIT, 0, self.parser.get_attribute())\n            else:\n                ident = pname + \":\" + self.parser.get_attribute()\n                levelc, val = self.get_const_value(ident)\n                try:\n                    levelv, pos = self.get_var_addr(ident)\n                except:\n                    levelv = None\n\n                if levelc == None and levelv == None:\n                    raise CompilationException(f\"Line {self.parser.line}: Unknown variable\")\n                \n                if levelc != None and levelv != None:\n                    if levelc > levelv:\n                        levelc = None\n                    else:\n                        levelv = None\n\n                if levelc != None:\n                    self.add_pl_instr(PL_LIT, 0, val)\n                else:\n                    self.add_pl_instr(PL_LOD, levelv, pos)\n            \n    #\n    # Parse a term section:\n    # term = factor {(\"*\"|\"/\") factor};\n    #\n    def parse_term(self, pname):\n        op = None\n        while True:\n            self.parse_factor(pname)\n            if op != None:\n                if op == self.parser.tk_mul:\n                    self.add_pl_instr(PL_OPR, 0, PL_OP_MUL)\n                else:\n                    self.add_pl_instr(PL_OPR, 0, PL_OP_DIV)                    \n            tk = self.parser.get_token()\n            if tk not in [ self.parser.tk_mul, self.parser.tk_div ]:\n                self.parser.return_token(tk)\n                break\n            op = tk\n    \n    #\n    # Parse an expression section:\n    # expression = [ \"+\"|\"-\"] term { (\"+\"|\"-\") term};        \n    #\n    def parse_expression(self, pname):\n        neg = False\n        op = None\n        tk = self.parser.get_token()\n        if tk in [ self.parser.tk_plus, self.parser.tk_minus ]:\n            if tk == self.parser.tk_minus:\n                neg = True\n        else:\n            self.parser.return_token(tk)\n        \n        while True:\n            self.parse_term(pname)\n            \n            if neg:\n                self.add_pl_instr(PL_OPR, 0, PL_OP_NEG)\n                neg = False\n\n            if op != None:\n                if op == self.parser.tk_plus:\n                    self.add_pl_instr(PL_OPR, 0, PL_OP_ADD)\n                else:\n                    self.add_pl_instr(PL_OPR, 0, PL_OP_SUB)\n\n            tk = self.parser.get_token()\n            if tk not in [ self.parser.tk_plus, self.parser.tk_minus ]:\n                self.parser.return_token(tk)\n                break\n            op = tk\n            \n    #\n    # Parse a const section:\n    # \"const\" ident \"=\" number {\",\" ident \"=\" number} \";\"\n    #\n    def parse_const(self, pname):\n        \n        while True:\n            self.parser.consume(self.parser.tk_ident)\n            ident = pname + \":\" + self.parser.get_attribute()\n\n            self.parser.consume(self.parser.tk_equal)\n\n            self.parser.consume(self.parser.tk_number)\n            number = self.parser.get_attribute()\n\n            if ident in self.PL_CONSTS.keys():\n                raise CompilationException(f\"Line {self.parser.line}: const already defined\")\n            \n            self.PL_CONSTS[ident] = number\n            \n            tk = self.parser.get_token()\n            if tk != self.parser.tk_comma:\n                self.parser.return_token(tk)\n                break\n            \n        self.parser.consume(self.parser.tk_eoc)\n\n    #\n    # Parse a var section:\n    # \"var\" ident {\",\" ident} \";\"\n    #\n    def parse_var(self, pname):\n\n        while True:\n\n            self.parser.consume(self.parser.tk_ident)\n            ident = pname + \":\" + self.parser.get_attribute()            \n\n            if ident in self.PL_VARS.keys():\n                raise CompilationException(f\"Line {self.parser.line}: var already defined\")\n                                        \n            self.PL_VARS[ident] = self.get_var_addr_number(pname)\n\n            tk = self.parser.get_token()\n            if tk != self.parser.tk_comma:\n                self.parser.return_token(tk)\n                break\n        \n        self.parser.consume(self.parser.tk_eoc)\n\n    #\n    # Parse a procedure section:\n    # \"procedure\" ident \";\" block \";\"\n    #\n    def parse_procedure(self, pname, level):\n        self.parser.consume(self.parser.tk_ident)\n        ident = pname + \":\" + self.parser.get_attribute()\n        \n        if ident in self.PL_PROCS.keys():\n            raise CompilationException(f\"Line {self.parser.line}: procedure already defined\")\n\n        self.PL_PROCS[ident] = self.PL_IDX\n\n        self.parser.consume(self.parser.tk_eoc)\n\n        self.parse_block(ident, level+1)\n\n        self.parser.consume(self.parser.tk_eoc)\n\n        self.add_pl_instr(PL_OPR, 0, PL_OP_RET)\n\n    # \n    # Parse input section:\n    # \"?\" ident\n    #\n    def parse_input(self, pname, level):\n        self.parser.consume(self.parser.tk_ident)\n        ident = pname + \":\" + self.parser.get_attribute()\n\n        level, pos = self.get_var_addr(ident)\n\n        # opr 0, PL_OP_IN\n        self.add_pl_instr(PL_OPR, 0, PL_OP_IN)\n\n        # sto level, a\n        self.add_pl_instr(PL_STO, level, pos)\n        \n\n    #\n    # Parse output section:\n    # \"!\" expression\n    #\n    def parse_output(self, pname):        \n\n        self.parse_expression(pname)\n\n        # opr 0, PL_OP_OUT\n        self.add_pl_instr(PL_OPR, 0, PL_OP_OUT)\n\n    #\n    # Parse a call section:\n    # \"call\" ident\n    #\n    def parse_call(self, pname, level):\n\n        self.parser.consume(self.parser.tk_ident)\n        ident = pname + \":\" + self.parser.get_attribute()\n        self.parser.commit_token()\n\n        lproc, proc = self.get_proc_addr(ident)\n        \n        self.add_pl_instr(PL_CAL, level-lproc, proc)\n\n    #\n    # Parse begin section:\n    # \"begin\" statement { \";\" statement } \"end\"\n    #\n    def parse_begin(self, pname, level, block):\n\n        # Parse statement content\n        while True:\n            self.parse_statement(pname, level, block)\n\n            # Next token is either a statement, possibly a ; and a end\n            tk = self.parser.get_token()\n            if tk == self.parser.tk_eoc:\n                tk = self.parser.get_token()\n                self.parser.return_token(tk)\n                if tk != self.parser.tk_end:                    \n                    continue\n                else:\n                    break\n                            \n            elif tk == self.parser.tk_end:\n                self.parser.return_token(tk)\n                break\n\n        self.parser.consume(self.parser.tk_end)\n\n    #\n    # Parse a if section:\n    # \"if\" condition \"then\" statement \n    #\n    def parse_if(self, pname, level):\n\n        self.parser.commit_token()\n\n        self.parse_condition(pname)\n\n        tmp_idx = self.reserve_pl_instr()\n        \n        self.parser.consume(self.parser.tk_then)\n\n        self.parse_statement(pname, level)\n\n        self.fixup_pl_instr(tmp_idx, PL_JPC, 0, self.PL_IDX)\n\n    #\n    # Parse a while section:\n    # \"while\" condition \"do\" statement\n    #\n    def parse_while(self, pname, level):\n\n        idx = self.PL_IDX\n        \n        self.parser.commit_token()\n        \n        self.parse_condition(pname)\n\n        tmp_idx = self.reserve_pl_instr()\n\n        self.parser.consume(self.parser.tk_do)\n\n        self.parse_statement(pname, level)\n\n        self.fixup_pl_instr(tmp_idx, PL_JPC, 0, self.PL_IDX+1)\n\n        self.add_pl_instr(PL_JMP, 0, idx)\n\n    #\n    # Parse an assignment section:\n    # ident \":=\" expression\n    #\n    def parse_assign(self, pname):\n        \n        self.parser.consume(self.parser.tk_ident)\n        ident = pname + \":\" + self.parser.get_attribute()\n\n        levelc, val = self.get_const_value(ident)\n        level, pos = self.get_var_addr(ident)\n\n        if levelc != None:\n            if levelc < level:\n                raise CompilationException(f\"Line {self.parser.line}: Invalid statement\")\n\n        self.parser.consume(self.parser.tk_assign)\n\n        self.parse_expression(pname)\n\n        self.add_pl_instr(PL_STO, level, pos)\n\n    #\n    # Parse a statement section:\n    # statement = [ ident \":=\" expression | \"call\" ident \n    #              | \"?\" ident | \"!\" expression \n    #              | \"begin\" statement {\";\" statement } \"end\" \n    #              | \"if\" condition \"then\" statement \n    #              | \"while\" condition \"do\" statement ]\n    #\n    def parse_statement(self,  pname, level, block=False):\n        tk = self.parser.get_token()\n        \n        # Increase stack shift + nb vars        \n        if block:\n            self.add_pl_instr(PL_INT, 0, self.STACK_SHIFT + self.get_var_addr_number(pname))\n\n        # \"?\"\n        if tk == self.parser.tk_input:\n            self.parse_input(pname, level)\n        \n        # \"!\"\n        elif tk == self.parser.tk_output:\n            self.parse_output(pname)\n        \n        # \"call\"\n        elif tk == self.parser.tk_call:\n            self.parse_call(pname, level)\n        \n        # \"begin\" \n        elif tk == self.parser.tk_begin:\n            self.parse_begin(pname, level, False)\n        \n        # \"if\"\n        elif tk == self.parser.tk_if:\n            self.parse_if(pname, level)\n        \n        # \"while\"\n        elif tk == self.parser.tk_while:\n            self.parse_while(pname, level)\n        \n        # assignment\n        else:\n            self.parser.return_token(tk)\n            self.parse_assign(pname)\n\n    #\n    # Parse a block section:\n    # block = [ \"const\" ident \"=\" number {\",\" ident \"=\" number} \";\"]\n    #         [ \"var\" ident {\",\" ident} \";\"]\n    #         { \"procedure\" ident \";\" block \";\" } statement\n    #\n    # For all functions pname is the current procedure name, level is the nesting level\n    # a 3rd paramter is used for statement which indicates if this statement is inside\n    # a block     \n    #\n    def parse_block(self, pname=\"\", level=0):\n\n        fixup = self.reserve_pl_instr()\n\n        token = self.parser.get_token()\n\n        # Is there const ?\n        if token == self.parser.tk_const:\n            self.parse_const(pname)\n            token = self.parser.get_token()\n\n        # Is there var ?\n        if token == self.parser.tk_var:\n            self.parse_var(pname)\n            token = self.parser.get_token()\n        \n        # Is there procedure ?\n        if token == self.parser.tk_procedure:\n            while True:\n                self.parse_procedure(pname, level)\n                token = self.parser.get_token()\n                if token != self.parser.tk_procedure:                    \n                    break        \n        \n        self.parser.return_token(token)\n\n        self.fixup_pl_instr(fixup, PL_JMP, 0, self.PL_IDX)\n\n        self.parse_statement(pname, level, True)\n\n    # \n    # Parse a program section:\n    # program = block \".\" \n    #\n    def parse_program(self):\n        # We start a level 0 and with the main block\n        self.parse_block()\n        self.parser.consume(self.parser.tk_point)\n\n        self.add_pl_instr(PL_OPR, 0, PL_OP_RET)\n\n    # Compile a PL/0 program\n    def compile(self, show=False, idx=True):\n        try:\n            self.parse_program()\n            \n            if show:\n                lnumber = 0\n                for instr, level, arg in self.pl_instr:            \n                    if idx:\n                        print(f\"{str(lnumber):3s}    \", end=\"\")\n                        lnumber += 1\n                    if instr == PL_LIT:\n                        print(f\"lit {level}, {str(arg)}\")\n                    elif instr == PL_OPR:\n                        print(f\"opr 0, {str(arg)}\")                \n                    elif instr == PL_LOD:\n                        print(f\"lod {level}, {str(arg)}\")\n                    elif instr == PL_STO:\n                        print(f\"sto {level}, {str(arg)}\")\n                    elif instr == PL_CAL:\n                        print(f\"cal {level}, {str(arg)}\")\n                    elif instr == PL_INT:\n                        print(f\"int 0, {str(arg)}\")\n                    elif instr == PL_JMP:\n                        print(f\"jmp 0, {str(arg)}\")\n                    elif instr == PL_JPC:                \n                        print(f\"jpc 0, {str(arg)}\")\n\n            return self.pl_instr\n                    \n        except CompilationException as exc:\n            print(exc)\n            return None\n\nlines = []\nm = int(input())\nfor i in range(m):\n    lines.append(input())\n\ncompiler = PL0_Compiler(lines)\ncompiler.compile(True, False)    \n",
      "statement": "In memory of Niklaus Wirth (1934-2024).\n\nIn this part of the puzzle you will develop a compiler which produces PL/0 instructions.\n\nPL/0 language was introduced in the book, Algorithms + Data Structures = Programs, by Niklaus Wirth. He is also the creator of Pascal, so do not be surprised to find some Pascal flavors in PL/0.\n\n<<Grammar>>\nHere is the EBNF definition of the PL/0 grammar:\n`program = block \".\"\n\nblock = [ \"const\" ident \"=\" number { \",\" ident \"=\" number } \";\" ]\n        [ \"var\" ident { \",\" ident } \";\" ]\n        { \"procedure\" ident \";\" block \";\" } statement\n\nstatement = [ ident \":=\" expr | \"call\" ident\n              | \"?\" ident | \"!\" expr\n              | \"begin\" statement { \";\" statement } \"end\"\n              | \"if\" condition \"then\" statement\n              | \"while\" condition \"do\" statement ]\n\ncondition = \"odd\" expr |\n            expr ( \"=\" | \"#\" | \"<\" | \"<=\" | \">\" | \">=\" ) expr\n\nexpr = [ \"+\" | \"-\" ] term { ( \"+\" | \"-\" ) term }\n\nterm = factor { ( \"*\" | \"/\" ) factor }\n\nfactor = ident | number | \"(\" expr \")\"`\n{{#}} means not equal.\n{{!}} prints a value.\n{{?}} gets a value from inputs.\n\nPL/0 is not case-sensitive for keywords.\n\n[[number]] is a non-negative integer.\n\n[[ident]] is used to name a const, var or procedure. It is alphanumerical, case-sensitive and does not start with a digit. [[ident]] is visible in the block where it is defined and all the <<nested>> blocks. [[ident]] can be overloaded with a new definition in a <<nested>> block, without affecting [[ident]] in the <<nesting>> blocks.\n\n<<Error messages>>\nIf an error occurs, you need to print an error message:\n{{Line}} [[x]]{{:}} [[msg]]\n\n• [[x]] is program line number of error\n• [[msg]] is one of the following:\n> {{[[s]] missing}}\n> {{Invalid [[w]]}}\n> {{Unknown var}}\n> {{[[elt]] already defined}}\n• [[w]] is {{expr}}/{{statement}} \n• [[s]] is {{;}}/{{then}}/{{do}}\n• [[elt]] is {{const}}/{{var}}/{{procedure}}\n\nIf the error is an unknown variable or an element already defined, the line containing such variable or element is considered to contain the error; otherwise, the line containing the last valid token is deemed to contain the error.\n\n<<Levels and addresses>>\nEach block of PL/0 defines a level. The main block (and the variables defined there) is level 0. A procedure block defined in the main block is level 1, and one defined in level 1 is level 2, and so on.\n\nA single stack is used for pushing and popping values. Each time a block is called, part of the stack (called a frame) is allocated to it, including 3 spaces reserved for the PL/0 processor, and 1 space for each variable (no allocation for constants). Relative address (index) is used for each frame, starting from {{0}}.\n\n<<Instructions>>\n8 instructions are available in PL/0. In the explanation below, [[l]] is the absolute difference in nesting levels between an [[ident]] definition and its usage, and [[a]] is a non-negative integer.\n\n{{lit 0,}} [[a]] pushes constant [[a]] onto the stack.\n\n{{opr 0,}} [[a]] executes operation [[a]] ({{0}} to {{14}}):\n{{0}} returns from a procedure call or ends the program.\nmath operations: {{1}} neg (negative), {{2}} +, {{3}} -, {{4}} *, {{5}} / (floor division)\ncomparison operations: {{6}} odd, {{7}} =, {{8}} #, {{9}} <, {{10}} >=, {{11}} >, {{12}} <=\nIO operations: {{13}} pops the stack and prints the popped value, {{14}} gets an input value and pushes it onto the stack.\nFor {{1}} to {{12}}, arguments are popped from the stack (1 argument for {{neg}} and {{odd}}, 2 for others), math/comparison is performed and the result is pushed onto the stack. For {{6}} to {{12}}, the result is either {{1}} for True or {{0}} for False.\n\n{{jmp 0,}} [[a]] jumps to instruction at position (i.e. line number) [[a]].\n\n{{jpc 0,}} [[a]] conditional jump. The stack is popped, and if the popped value is {{0}} then jump to instruction at position [[a]].\n\n{{cal}} [[l]]{{,}} [[a]] calls procedure at instruction position [[a]] [[l]] levels up.\n\n{{int 0,}} [[a]] allocates space in the stack. [[a]] is the number of spaces, i.e. 3 plus 1 for each variable as explained above.\n\n{{lod}} [[l]]{{,}} [[a]] copies the value at stack relative address [[a]] [[l]] levels up, and pushes it onto the stack.\n\n{{sto}} [[l]]{{,}} [[a]] pops the stack and stores the popped value at stack relative address [[a]] [[l]] levels up.\n\n<<Instruction generation rules>>\nInstructions should be generated following the program order.\n\n<<expr>> such as {{2 + 1}} and <<condition>> such as {{if a < 0 then}} are compiled by pushing the arguments onto the stack (first operand is pushed first) and then applying the operator.\n\nIn an if/then statement, we use a conditional jump ({{jpc}}) for control flow.\n\n<<Every>> block starts with {{jmp}} to jump over all instructions of nested procedures (if any) to an {{int}} instruction used to allocate stack space.\n\nProgram lines (i.e. input) are counted starting from {{1}}. Instruction lines (i.e. output) are counted starting from {{0}}, ignoring nesting level.",
      "testCases": [
        {
          "title": "Simple example",
          "isTest": true,
          "testIn": "3\nconst k=5;\nvar i;\nbegin i := k; !i end.",
          "testOut": "jmp 0, 1\nint 0, 4\nlit 0, 5\nsto 0, 3\nlod 0, 3\nopr 0, 13\nopr 0, 0",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Simple validator",
          "isTest": false,
          "testIn": "6\nvar i;\nbegin\n    i := 1;\n    ! i;\n    ! (2 * 2 - 5)\nend.",
          "testOut": "jmp 0, 1\nint 0, 4\nlit 0, 1\nsto 0, 3\nlod 0, 3\nopr 0, 13\nlit 0, 2\nlit 0, 2\nopr 0, 4\nlit 0, 5\nopr 0, 3\nopr 0, 13\nopr 0, 0",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "While and If",
          "isTest": true,
          "testIn": "15\nVAR\n    INPUT, COUNT;\nBEGIN\n COUNT := +2;\n WHILE COUNT # 0 DO\n BEGIN\n   COUNT := COUNT - 1;\n   ? INPUT;\n   IF INPUT < 10 THEN \n      WHILE INPUT < 10 DO\n        ! INPUT;\n   IF INPUT >= 10 THEN\n     ! -1\n  END\nEND.",
          "testOut": "jmp 0, 1\nint 0, 5\nlit 0, 2\nsto 0, 4\nlod 0, 4\nlit 0, 0\nopr 0, 8\njpc 0, 33\nlod 0, 4\nlit 0, 1\nopr 0, 3\nsto 0, 4\nopr 0, 14\nsto 0, 3\nlod 0, 3\nlit 0, 10\nopr 0, 9\njpc 0, 25\nlod 0, 3\nlit 0, 10\nopr 0, 9\njpc 0, 25\nlod 0, 3\nopr 0, 13\njmp 0, 18\nlod 0, 3\nlit 0, 10\nopr 0, 10\njpc 0, 32\nlit 0, 1\nopr 0, 1\nopr 0, 13\njmp 0, 4\nopr 0, 0",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "While and If validator",
          "isTest": false,
          "testIn": "17\nvar a, b, c, d, e;\n\nbegin\n    ? a;\n    ? b;    \n    d := 2;\n    while d > 0 do\n    begin\n        ? c;\n        if c = 1 then\n            e := a + b;\n        if c # 1 then\n            e := a - b;\n        ! e;\n        d := d - 1\n    end\nend.",
          "testOut": "jmp 0, 1\nint 0, 8\nopr 0, 14\nsto 0, 3\nopr 0, 14\nsto 0, 4\nlit 0, 2\nsto 0, 6\nlod 0, 6\nlit 0, 0\nopr 0, 11\njpc 0, 37\nopr 0, 14\nsto 0, 5\nlod 0, 5\nlit 0, 1\nopr 0, 7\njpc 0, 22\nlod 0, 3\nlod 0, 4\nopr 0, 2\nsto 0, 7\nlod 0, 5\nlit 0, 1\nopr 0, 8\njpc 0, 30\nlod 0, 3\nlod 0, 4\nopr 0, 3\nsto 0, 7\nlod 0, 7\nopr 0, 13\nlod 0, 6\nlit 0, 1\nopr 0, 3\nsto 0, 6\njmp 0, 8\nopr 0, 0",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "Procedure",
          "isTest": true,
          "testIn": "33\nconst max = 100;\nvar arg, ret;\n\nprocedure isprime;\nvar i;\nbegin\n\tret := 1;\n\ti := 2;\n\twhile i < arg do\n\tbegin\n\t\tif arg / i * i = arg then\n\t\tbegin\n\t\t\tret := 0;\n\t\t\ti := arg\n\t\tend;\n\t\ti := i + 1\n\tend\nend;\n\nprocedure primes;\nbegin\n\t? arg;\n\twhile arg < max do\n\tbegin\n\t\tcall isprime;\n\t\tif ret = 1 then !arg;\n\t\targ := arg + 1\n\tend\nend;\n\nbegin\n\tcall primes\nend.",
          "testOut": "jmp 0, 50\njmp 0, 2\nint 0, 4\nlit 0, 1\nsto 1, 4\nlit 0, 2\nsto 0, 3\nlod 0, 3\nlod 1, 3\nopr 0, 9\njpc 0, 28\nlod 1, 3\nlod 0, 3\nopr 0, 5\nlod 0, 3\nopr 0, 4\nlod 1, 3\nopr 0, 7\njpc 0, 23\nlit 0, 0\nsto 1, 4\nlod 1, 3\nsto 0, 3\nlod 0, 3\nlit 0, 1\nopr 0, 2\nsto 0, 3\njmp 0, 7\nopr 0, 0\njmp 0, 30\nint 0, 3\nopr 0, 14\nsto 1, 3\nlod 1, 3\nlit 0, 100\nopr 0, 9\njpc 0, 49\ncal 1, 1\nlod 1, 4\nlit 0, 1\nopr 0, 7\njpc 0, 44\nlod 1, 3\nopr 0, 13\nlod 1, 3\nlit 0, 1\nopr 0, 2\nsto 1, 3\njmp 0, 33\nopr 0, 0\nint 0, 5\ncal 0, 29\nopr 0, 0",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Procedure validator",
          "isTest": false,
          "testIn": "16\nVAR x, squ;\n\nPROCEDURE square;\nBEGIN\n   squ := x * x\nEND;\n\nBEGIN\n   x := +1;\n   WHILE x <= 10 DO\n   BEGIN\n      CALL square;\n      ! squ;\n      x := x + 1\n   END\nEND.",
          "testOut": "jmp 0, 8\njmp 0, 2\nint 0, 3\nlod 1, 3\nlod 1, 3\nopr 0, 4\nsto 1, 4\nopr 0, 0\nint 0, 5\nlit 0, 1\nsto 0, 3\nlod 0, 3\nlit 0, 10\nopr 0, 12\njpc 0, 23\ncal 0, 1\nlod 0, 4\nopr 0, 13\nlod 0, 3\nlit 0, 1\nopr 0, 2\nsto 0, 3\njmp 0, 11\nopr 0, 0",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "Unknown variable",
          "isTest": true,
          "testIn": "3\nbegin\n    i := 0\nend.",
          "testOut": "Line 2: Unknown var",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Unknown variable validator",
          "isTest": false,
          "testIn": "3\nvar i;\nbegin j := i\nend.",
          "testOut": "Line 2: Unknown var",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "; missing",
          "isTest": true,
          "testIn": "10\nvar i;\n\nprocedure sub\nbegin\n    i := 0\nend;\n\nbegin\n    call sub\nend.",
          "testOut": "Line 3: ; missing",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "; missing validator",
          "isTest": false,
          "testIn": "10\nvar i;\n\nprocedure sub;\nbegin\n    i := 0\nend\n\nbegin\n    call sub\nend.",
          "testOut": "Line 6: ; missing",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "Invalid expression",
          "isTest": true,
          "testIn": "5\nconst k = 10;\nvar i;\nbegin\n    i := ( 2 * k * -5 ) / 3\nend.",
          "testOut": "Line 4: Invalid expr",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Invalid expression validator",
          "isTest": false,
          "testIn": "6\nconst k = 10;\nvar i;\nbegin\n    while i < -2 + k * -5 do\n        !i\nend.",
          "testOut": "Line 4: Invalid expr",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "Missing symbol",
          "isTest": true,
          "testIn": "5\nvar i;\nbegin\n    ? i;\n    if i < 10 !0\nend.",
          "testOut": "Line 4: then missing",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Missing symbol validator",
          "isTest": false,
          "testIn": "6\nconst k = 10;\nvar i;\nbegin\n    while i < k \n        !i\nend.",
          "testOut": "Line 4: do missing",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "Already exist",
          "isTest": true,
          "testIn": "17\nvar i;\n\nprocedure p;\nvar\n    i;\nbegin\n    i := 0\nend;\n\nprocedure p;\nbegin\n    i != 1\nend;\n\nbegin\n    call p\nend.",
          "testOut": "Line 10: procedure already defined",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Already exist validator",
          "isTest": false,
          "testIn": "17\nconst k=10;\nvar i;\n\nprocedure sub;\nconst k=100;\nbegin\n    i := k\nend;\n\nprocedure sub;\nbegin\n    i != 0\nend;\n\nbegin\n    call sub\nend.",
          "testOut": "Line 10: procedure already defined",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "Constant already exist",
          "isTest": true,
          "testIn": "10\nconst \n    k890 = 10,\n    k890 = 30;\n\nvar i;\n\nbegin\n    WHILE i < k DO\n        !i\nend.",
          "testOut": "Line 3: const already defined",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Constant already exist validator",
          "isTest": false,
          "testIn": "11\nvar i;\n\nprocedure sub;\nconst k=1, k=2;\nbegin\n    i := 0\nend\n\nbegin\n    call sub\nend.",
          "testOut": "Line 4: const already defined",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "Variable already exist",
          "isTest": true,
          "testIn": "11\nvar \n    i, i;\n\nprocedure sub;\nbegin\n    i := 0\nend\n\nbegin\n    call sub\nend.",
          "testOut": "Line 2: var already defined",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Variable already exist validator",
          "isTest": false,
          "testIn": "3\nvar i, j, j;\nbegin j := i\nend.",
          "testOut": "Line 1: var already defined",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "Invalid statement",
          "isTest": true,
          "testIn": "13\nvar i;\n\nprocedure sub;\nconst i = 2;\nbegin\n  i := 7\nend;\n\nbegin\n    i := 0;\n    call sub;\n    ! i\nend.",
          "testOut": "Line 6: Invalid statement",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Invalid statement validator",
          "isTest": false,
          "testIn": "13\nvar i, k;\n\nprocedure sub;\nconst i=5;\nbegin\n  i := k\nend;\n\nbegin\n  ?i;\n  call sub;\n  !i\nend.",
          "testOut": "Line 6: Invalid statement",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "Odd or Neg",
          "isTest": true,
          "testIn": "9\nvar i, j;\n\nbegin\n    ? i;\n    j := i;\n    if odd i then\n        j := -i;\n    ! j\nend.",
          "testOut": "jmp 0, 1\nint 0, 5\nopr 0, 14\nsto 0, 3\nlod 0, 3\nsto 0, 4\nlod 0, 3\nopr 0, 6\njpc 0, 12\nlod 0, 3\nopr 0, 1\nsto 0, 4\nlod 0, 4\nopr 0, 13\nopr 0, 0",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Odd or Neg validator",
          "isTest": false,
          "testIn": "11\nvar i;\n\nbegin\n    i := 10;\n    while i >= 0 do\n    begin        \n        if odd i then\n            ! -i;\n        i := i - 1\n    end\nend.",
          "testOut": "jmp 0, 1\nint 0, 4\nlit 0, 10\nsto 0, 3\nlod 0, 3\nlit 0, 0\nopr 0, 10\njpc 0, 19\nlod 0, 3\nopr 0, 6\njpc 0, 14\nlod 0, 3\nopr 0, 1\nopr 0, 13\nlod 0, 3\nlit 0, 1\nopr 0, 3\nsto 0, 3\njmp 0, 4\nopr 0, 0",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "Scope",
          "isTest": true,
          "testIn": "28\nconst \n    k = 10,\n    in = 100;\nvar \n    i;\n\n    procedure sub;\n    const \n        i = 5;\n    var k;\n        procedure in;\n        const sub=4;\n        var i;\n        begin\n            i := sub;\n            ! i\n        end;\n    begin\n        call in;\n        k := i;\n        ! k\n    end;\n\nbegin\n    i := k;\n    call sub;\n    ! i\nend.",
          "testOut": "jmp 0, 16\njmp 0, 9\njmp 0, 3\nint 0, 4\nlit 0, 4\nsto 0, 3\nlod 0, 3\nopr 0, 13\nopr 0, 0\nint 0, 4\ncal 0, 2\nlit 0, 5\nsto 0, 3\nlod 0, 3\nopr 0, 13\nopr 0, 0\nint 0, 4\nlit 0, 10\nsto 0, 3\ncal 0, 1\nlod 0, 3\nopr 0, 13\nopr 0, 0",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Scope validator",
          "isTest": false,
          "testIn": "28\nconst \n    k = 10;\nvar \n    i;\n\n    procedure sub;\n    const i = 9;\n    var k;\n    \n        procedure inside;\n        var \n            sub;\n        begin\n            sub := k;\n            ! sub\n        end;\n\n    begin\n        k := i;\n        call inside;\n        ! k\n    end;\n\nbegin\n    i := k;\n    call sub;\n    ! i\nend.",
          "testOut": "jmp 0, 16\njmp 0, 9\njmp 0, 3\nint 0, 4\nlod 1, 3\nsto 0, 3\nlod 0, 3\nopr 0, 13\nopr 0, 0\nint 0, 4\nlit 0, 9\nsto 0, 3\ncal 0, 2\nlod 0, 3\nopr 0, 13\nopr 0, 0\nint 0, 4\nlit 0, 10\nsto 0, 3\ncal 0, 1\nlod 0, 3\nopr 0, 13\nopr 0, 0",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "No BEGIN",
          "isTest": true,
          "testIn": "10\nconst k=5, l=8;\n\nPROCEDURE run;\nVAR I;\nWHILE I <= k DO I := I - 1;\n\nprocedure print;\n! ( k * l );\n\ncall print.",
          "testOut": "jmp 0, 20\njmp 0, 2\nint 0, 4\nlod 0, 3\nlit 0, 5\nopr 0, 12\njpc 0, 12\nlod 0, 3\nlit 0, 1\nopr 0, 3\nsto 0, 3\njmp 0, 3\nopr 0, 0\njmp 0, 14\nint 0, 3\nlit 0, 5\nlit 0, 8\nopr 0, 4\nopr 0, 13\nopr 0, 0\nint 0, 3\ncal 0, 13\nopr 0, 0",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "No BEGIN validator",
          "isTest": false,
          "testIn": "19\nvar i, j;\n\nprocedure print;\n! i;\n\nprocedure add;\nconst k = 10, j = 8;\ni := i + j + k;\n\nprocedure ask;\nbegin\n    ? i;\n    ? j;\n    call add;\n    call print;\n    if i < j then while i < j do i := i + 1\nend;\n\ncall ask.",
          "testOut": "jmp 0, 37\njmp 0, 2\nint 0, 3\nlod 1, 3\nopr 0, 13\nopr 0, 0\njmp 0, 7\nint 0, 3\nlod 1, 3\nlit 0, 8\nopr 0, 2\nlit 0, 10\nopr 0, 2\nsto 1, 3\nopr 0, 0\njmp 0, 16\nint 0, 3\nopr 0, 14\nsto 1, 3\nopr 0, 14\nsto 1, 4\ncal 1, 6\ncal 1, 1\nlod 1, 3\nlod 1, 4\nopr 0, 9\njpc 0, 36\nlod 1, 3\nlod 1, 4\nopr 0, 9\njpc 0, 36\nlod 1, 3\nlit 0, 1\nopr 0, 2\nsto 1, 3\njmp 0, 27\nopr 0, 0\nint 0, 5\ncal 0, 15\nopr 0, 0",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "Crazy format",
          "isTest": true,
          "testIn": "31\nconst I218=218;var i218;PROcedure other;begin i218:=-218 end; \nprocedure subI218; BEGIN\n    i218 := 2024;\n    Call\n    other;\n    While \n        -i218 # \n        ( \n            5 \n            +\n            23\n        )\n    Do       \n    i218 := I218 + i218;\n    if i218=0 then\n    i218 := \n    i218\n    -\n    1;\n    While i218 = I218 dO\n      if i218 > i218 THEN \n         WHILe i218 # 0 DO\n           if i218 = I218 tHEn \n              i218 \n              :=\n              0\nEND;\n\nbegin\n    CaLl subI218\nend.",
          "testOut": "jmp 0, 53\njmp 0, 2\nint 0, 3\nlit 0, 218\nopr 0, 1\nsto 1, 3\nopr 0, 0\njmp 0, 8\nint 0, 3\nlit 0, 2024\nsto 1, 3\ncal 1, 1\nlod 1, 3\nopr 0, 1\nlit 0, 5\nlit 0, 23\nopr 0, 2\nopr 0, 8\njpc 0, 24\nlit 0, 218\nlod 1, 3\nopr 0, 2\nsto 1, 3\njmp 0, 12\nlod 1, 3\nlit 0, 0\nopr 0, 7\njpc 0, 32\nlod 1, 3\nlit 0, 1\nopr 0, 3\nsto 1, 3\nlod 1, 3\nlit 0, 218\nopr 0, 7\njpc 0, 52\nlod 1, 3\nlod 1, 3\nopr 0, 11\njpc 0, 51\nlod 1, 3\nlit 0, 0\nopr 0, 8\njpc 0, 51\nlod 1, 3\nlit 0, 218\nopr 0, 7\njpc 0, 50\nlit 0, 0\nsto 1, 3\njmp 0, 40\njmp 0, 32\nopr 0, 0\nint 0, 4\ncal 0, 7\nopr 0, 0",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Crazy format validator",
          "isTest": false,
          "testIn": "22\nCONST k2000=10;\nVaR\ni,I;\nPROCedure div22145; begin \n!\n(\nk2000 / 22145\n+\n333\n) end;\nbegin\n? I\n;?i;\nIF \nI # i\nTHEN\nI := \n    I\n        -\n            2024;\nCALL div22145\nend.",
          "testOut": "jmp 0, 10\njmp 0, 2\nint 0, 3\nlit 0, 10\nlit 0, 22145\nopr 0, 5\nlit 0, 333\nopr 0, 2\nopr 0, 13\nopr 0, 0\nint 0, 5\nopr 0, 14\nsto 0, 4\nopr 0, 14\nsto 0, 3\nlod 0, 4\nlod 0, 3\nopr 0, 8\njpc 0, 23\nlod 0, 4\nlit 0, 2024\nopr 0, 3\nsto 0, 4\ncal 0, 1\nopr 0, 0",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "Nested procedures",
          "isTest": true,
          "testIn": "41\nvar i;\n\nprocedure f;\nbegin\n    i := i + 1\nend;\n\nprocedure g;\nvar j;\n\n    procedure k;\n    begin\n        j := i;\n        i := - 64 - j; \n        call f   \n    end;\n\n    procedure m;\n    begin\n        i := i - 1;\n        call k\n    end;\n\nbegin\n    i := i + 2;\n    call f;\n    call m\nend;\n\nprocedure h;\nbegin\n    i := i + 3;\n    call g\nend;\n\nbegin\n    ? i;\n    call h;\n    call g;\n    ! i*2\nend.",
          "testOut": "jmp 0, 44\njmp 0, 2\nint 0, 3\nlod 1, 3\nlit 0, 1\nopr 0, 2\nsto 1, 3\nopr 0, 0\njmp 0, 28\njmp 0, 10\nint 0, 3\nlod 2, 3\nsto 1, 3\nlit 0, 64\nopr 0, 1\nlod 1, 3\nopr 0, 3\nsto 2, 3\ncal 2, 1\nopr 0, 0\njmp 0, 21\nint 0, 3\nlod 2, 3\nlit 0, 1\nopr 0, 3\nsto 2, 3\ncal 1, 9\nopr 0, 0\nint 0, 4\nlod 1, 3\nlit 0, 2\nopr 0, 2\nsto 1, 3\ncal 1, 1\ncal 0, 20\nopr 0, 0\njmp 0, 37\nint 0, 3\nlod 1, 3\nlit 0, 3\nopr 0, 2\nsto 1, 3\ncal 1, 8\nopr 0, 0\nint 0, 4\nopr 0, 14\nsto 0, 3\ncal 0, 36\ncal 0, 8\nlod 0, 3\nlit 0, 2\nopr 0, 4\nopr 0, 13\nopr 0, 0",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Nested procedures validator",
          "isTest": false,
          "testIn": "39\nvar\n    i, j;\n\nprocedure reset;\nbegin i := 0; j := 0 end;\n\nprocedure out;\nconst k = 3;\n\n    procedure insidebis;\n    var thx5DN1L;\n    begin\n        call reset;\n        thx5DN1L := k * k;\n        j := - thx5DN1L\n    end;\n\n    procedure inside;\n    var l;\n    begin\n        call insidebis;\n        l := k + i;        \n        j := - 831 - l\n    end;\n\nbegin\n    if i # -j then\n    begin\n      j := 3;\n      call inside\n    end\nend;\n\nbegin\n    i := -777;\n    j := 2;\n    call out;\n    ! j\nend.",
          "testOut": "jmp 0, 43\njmp 0, 2\nint 0, 3\nlit 0, 0\nsto 1, 3\nlit 0, 0\nsto 1, 4\nopr 0, 0\njmp 0, 33\njmp 0, 10\nint 0, 4\ncal 2, 1\nlit 0, 3\nlit 0, 3\nopr 0, 4\nsto 0, 3\nlod 0, 3\nopr 0, 1\nsto 2, 4\nopr 0, 0\njmp 0, 21\nint 0, 4\ncal 1, 9\nlit 0, 3\nlod 2, 3\nopr 0, 2\nsto 0, 3\nlit 0, 831\nopr 0, 1\nlod 0, 3\nopr 0, 3\nsto 2, 4\nopr 0, 0\nint 0, 3\nlod 1, 3\nlod 1, 4\nopr 0, 1\nopr 0, 8\njpc 0, 42\nlit 0, 3\nsto 1, 4\ncal 0, 20\nopr 0, 0\nint 0, 5\nlit 0, 777\nopr 0, 1\nsto 0, 3\nlit 0, 2\nsto 0, 4\ncal 0, 8\nlod 0, 4\nopr 0, 13\nopr 0, 0",
          "isValidator": true,
          "needValidation": true
        }
      ],
      "difficulty": "hard",
      "constraints": "0 <= [[N]] < 100\nEach line of PL/0 program is maximum 100 characters length.\n\nAll math and comparison operations work from left to right (e.g. there won't be cases like 2 + 7 * 9).",
      "coverBinaryId": 118005869350985,
      "stubGenerator": "read N:int\nloop N read LINES:string(100)\nwrite answer",
      "inputDescription": "<<Line 1:>> An integer [[N]] the number of lines in the PL/0 program\n<<Next [[N]] lines:>> Strings of PL/0 program (some lines may begin with spaces or tabs).",
      "solutionLanguage": "Python3",
      "outputDescription": "The PL/0 instructions (one per line) of the given program, or an error message."
    },
    "draft": false,
    "readyForModeration": true,
    "statementHTML": "<div class=\"statement-body\">\n<div class=\"statement-section statement-goal\">\n   <h2><span class=\"icon icon-goal\">&nbsp;</span><span>Goal </span></h2>\n   <span class=\"question-statement\">In memory of Niklaus Wirth (1934-2024).<br><br>In this part of the puzzle you will develop a compiler which produces PL/0 instructions.<br><br>PL/0 language was introduced in the book, Algorithms + Data Structures = Programs, by Niklaus Wirth. He is also the creator of Pascal, so do not be surprised to find some Pascal flavors in PL/0.<br><br><strong>Grammar</strong><br>Here is the EBNF definition of the PL/0 grammar:<br><pre style=\"font-family: monospace\">program = block &quot;.&quot;<br><br>block = [ &quot;const&quot; ident &quot;=&quot; number { &quot;,&quot; ident &quot;=&quot; number } &quot;;&quot; ]<br>        [ &quot;var&quot; ident { &quot;,&quot; ident } &quot;;&quot; ]<br>        { &quot;procedure&quot; ident &quot;;&quot; block &quot;;&quot; } statement<br><br>statement = [ ident &quot;:=&quot; expr | &quot;call&quot; ident<br>              | &quot;?&quot; ident | &quot;!&quot; expr<br>              | &quot;begin&quot; statement { &quot;;&quot; statement } &quot;end&quot;<br>              | &quot;if&quot; condition &quot;then&quot; statement<br>              | &quot;while&quot; condition &quot;do&quot; statement ]<br><br>condition = &quot;odd&quot; expr |<br>            expr ( &quot;=&quot; | &quot;#&quot; | &quot;&lt;&quot; | &quot;&lt;=&quot; | &quot;&gt;&quot; | &quot;&gt;=&quot; ) expr<br><br>expr = [ &quot;+&quot; | &quot;-&quot; ] term { ( &quot;+&quot; | &quot;-&quot; ) term }<br><br>term = factor { ( &quot;*&quot; | &quot;/&quot; ) factor }<br><br>factor = ident | number | &quot;(&quot; expr &quot;)&quot;</pre><br><const>#</const> means not equal.<br><const>!</const> prints a value.<br><const>?</const> gets a value from inputs.<br><br>PL/0 is not case-sensitive for keywords.<br><br><var>number</var> is a non-negative integer.<br><br><var>ident</var> is used to name a const, var or procedure. It is alphanumerical, case-sensitive and does not start with a digit. <var>ident</var> is visible in the block where it is defined and all the <strong>nested</strong> blocks. <var>ident</var> can be overloaded with a new definition in a <strong>nested</strong> block, without affecting <var>ident</var> in the <strong>nesting</strong> blocks.<br><br><strong>Error messages</strong><br>If an error occurs, you need to print an error message:<br><const>Line</const> <var>x</var><const>:</const> <var>msg</var><br><br>&bull; <var>x</var> is program line number of error<br>&bull; <var>msg</var> is one of the following:<br>&gt; <const><var>s</var> missing</const><br>&gt; <const>Invalid <var>w</var></const><br>&gt; <const>Unknown var</const><br>&gt; <const><var>elt</var> already defined</const><br>&bull; <var>w</var> is <const>expr</const>/<const>statement</const> <br>&bull; <var>s</var> is <const>;</const>/<const>then</const>/<const>do</const><br>&bull; <var>elt</var> is <const>const</const>/<const>var</const>/<const>procedure</const><br><br>If the error is an unknown variable or an element already defined, the line containing such variable or element is considered to contain the error; otherwise, the line containing the last valid token is deemed to contain the error.<br><br><strong>Levels and addresses</strong><br>Each block of PL/0 defines a level. The main block (and the variables defined there) is level 0. A procedure block defined in the main block is level 1, and one defined in level 1 is level 2, and so on.<br><br>A single stack is used for pushing and popping values. Each time a block is called, part of the stack (called a frame) is allocated to it, including 3 spaces reserved for the PL/0 processor, and 1 space for each variable (no allocation for constants). Relative address (index) is used for each frame, starting from <const>0</const>.<br><br><strong>Instructions</strong><br>8 instructions are available in PL/0. In the explanation below, <var>l</var> is the absolute difference in nesting levels between an <var>ident</var> definition and its usage, and <var>a</var> is a non-negative integer.<br><br><const>lit 0,</const> <var>a</var> pushes constant <var>a</var> onto the stack.<br><br><const>opr 0,</const> <var>a</var> executes operation <var>a</var> (<const>0</const> to <const>14</const>):<br><const>0</const> returns from a procedure call or ends the program.<br>math operations: <const>1</const> neg (negative), <const>2</const> +, <const>3</const> -, <const>4</const> *, <const>5</const> / (floor division)<br>comparison operations: <const>6</const> odd, <const>7</const> =, <const>8</const> #, <const>9</const> &lt;, <const>10</const> &gt;=, <const>11</const> &gt;, <const>12</const> &lt;=<br>IO operations: <const>13</const> pops the stack and prints the popped value, <const>14</const> gets an input value and pushes it onto the stack.<br>For <const>1</const> to <const>12</const>, arguments are popped from the stack (1 argument for <const>neg</const> and <const>odd</const>, 2 for others), math/comparison is performed and the result is pushed onto the stack. For <const>6</const> to <const>12</const>, the result is either <const>1</const> for True or <const>0</const> for False.<br><br><const>jmp 0,</const> <var>a</var> jumps to instruction at position (i.e. line number) <var>a</var>.<br><br><const>jpc 0,</const> <var>a</var> conditional jump. The stack is popped, and if the popped value is <const>0</const> then jump to instruction at position <var>a</var>.<br><br><const>cal</const> <var>l</var><const>,</const> <var>a</var> calls procedure at instruction position <var>a</var> <var>l</var> levels up.<br><br><const>int 0,</const> <var>a</var> allocates space in the stack. <var>a</var> is the number of spaces, i.e. 3 plus 1 for each variable as explained above.<br><br><const>lod</const> <var>l</var><const>,</const> <var>a</var> copies the value at stack relative address <var>a</var> <var>l</var> levels up, and pushes it onto the stack.<br><br><const>sto</const> <var>l</var><const>,</const> <var>a</var> pops the stack and stores the popped value at stack relative address <var>a</var> <var>l</var> levels up.<br><br><strong>Instruction generation rules</strong><br>Instructions should be generated following the program order.<br><br><strong>expr</strong> such as <const>2 + 1</const> and <strong>condition</strong> such as <const>if a &lt; 0 then</const> are compiled by pushing the arguments onto the stack (first operand is pushed first) and then applying the operator.<br><br>In an if/then statement, we use a conditional jump (<const>jpc</const>) for control flow.<br><br><strong>Every</strong> block starts with <const>jmp</const> to jump over all instructions of nested procedures (if any) to an <const>int</const> instruction used to allocate stack space.<br><br>Program lines (i.e. input) are counted starting from <const>1</const>. Instruction lines (i.e. output) are counted starting from <const>0</const>, ignoring nesting level.</span>\n</div>\n<div class=\"statement-section statement-protocol\">\n   <div class=\"blk\">\n      <div class=\"title\">Input</div>\n      <div class=\"question-statement-input\"><strong>Line 1:</strong> An integer <var>N</var> the number of lines in the PL/0 program<br><strong>Next <var>N</var> lines:</strong> Strings of PL/0 program (some lines may begin with spaces or tabs).</div>\n   </div>\n   <div class=\"blk\">\n      <div class=\"title\">Output</div>\n      <div class=\"question-statement-output\">The PL/0 instructions (one per line) of the given program, or an error message.</div>\n   </div>\n   <div class=\"blk\">\n      <div class=\"title\">Constraints</div>\n      <div class=\"question-statement-constraints\">0 &lt;= <var>N</var> &lt; 100<br>Each line of PL/0 program is maximum 100 characters length.<br><br>All math and comparison operations work from left to right (e.g. there won't be cases like 2 + 7 * 9).</div>\n   </div>\n   <div class=\"blk\">\n      <div class=\"title\">Example</div>\n      <div class=\"statement-inout\">\n         <div class=\"statement-inout-in\">\n            <div class=\"title\">Input</div>\n            <pre class=\"question-statement-example-in\">3\nconst k=5;\nvar i;\nbegin i := k; !i end.</pre>\n         </div>\n         <div class=\"statement-inout-out\">\n            <div class=\"title\">Output</div>\n            <pre class=\"question-statement-example-out\">jmp 0, 1\nint 0, 4\nlit 0, 5\nsto 0, 3\nlod 0, 3\nopr 0, 13\nopr 0, 0</pre>\n         </div>\n      </div>\n   </div>\n</div>"
  },
  "validatedFor": 51681338300,
  "avatar": 117815661507237,
  "commentCount": 114,
  "upVotes": 17,
  "downVotes": 2,
  "validateAction": {
    "actionId": 955209,
    "progress": 1,
    "alreadyDone": false
  },
  "statusHistory": [
    {
      "status": "REFUSED",
      "date": 1711976737000,
      "data": {
        "author": "SYSTEM",
        "reason": "INACTIVITY"
      }
    },
    {
      "status": "PENDING",
      "date": 1711979290992,
      "data": {
        "author": "ACTION",
        "reason": "EDIT"
      }
    },
    {
      "status": "REFUSED",
      "date": 1714572337001,
      "data": {
        "author": "SYSTEM",
        "reason": "INACTIVITY"
      }
    },
    {
      "status": "PENDING",
      "date": 1716701051832,
      "data": {
        "author": "ACTION",
        "reason": "EDIT"
      }
    },
    {
      "status": "ACCEPTED",
      "date": 1719047444519,
      "data": {
        "author": "ACTION"
      }
    }
  ],
  "editable": true,
  "draft": false,
  "readyForModeration": true
}