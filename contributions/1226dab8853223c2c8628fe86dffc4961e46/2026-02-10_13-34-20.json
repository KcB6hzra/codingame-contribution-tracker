{
  "id": 1226,
  "activeVersion": 52,
  "score": 20,
  "votableId": 7279770,
  "codingamerId": 878974,
  "views": 1092,
  "commentableId": 7217506,
  "title": "Ring the bells",
  "status": "ACCEPTED",
  "type": "PUZZLE_INOUT",
  "nickname": "nicola",
  "publicHandle": "1226dab8853223c2c8628fe86dffc4961e46",
  "codingamerHandle": "21bf42f790de293c3aef398f18cd2627479878",
  "lastVersion": {
    "version": 52,
    "autocloseTime": 1623957005005,
    "data": {
      "title": "Ring the bells",
      "topics": [
        {
          "id": 104,
          "handle": "group-theory",
          "category": "ADVANCED",
          "labelMap": {
            "1": "Group theory",
            "2": "Group theory"
          },
          "puzzleCount": 2,
          "parentTopicId": 93
        },
        {
          "id": 70,
          "handle": "permutations",
          "category": "INTERMEDIATE",
          "labelMap": {
            "1": "Permutations",
            "2": "Permutations"
          },
          "pageTitle": "Permutations: exercises and theory",
          "puzzleCount": 5,
          "parentTopicId": 41,
          "contentDetailsId": 103
        },
        {
          "labelMap": {
            "2": "Lexicographic order"
          }
        }
      ],
      "solution": "p=input()[1:-1].split(\")(\")\npp=[[int(i) for i in l.split()] for l in p][::-1]\np=[]\nfor l in pp:\n    if l:\n        p+=[l+[l[0]]]\nif not p:\n    p=[[1,1]]\nm=max(max(l) for l in p)\nd={i:i for i in range(1,m+1)}\n\nfor e in range(1,m+1):\n    ee=e\n    for l in p:\n        if ee in l:\n            ee=l[l.index(ee)+1]\n    d[e]=ee\n\ns=set(range(1,m+1))\nr=[]\n\nwhile s:\n    n=[]\n    e=min(s)\n    while e not in n:\n        s-={e}\n        n.append(e)\n        e=d[e]\n    if len(n)>1:\n        r.append(str(tuple(n)).replace(\",\",\"\"))\n\nif r:\n    print(\"\".join(r))\nelse:\n    print(\"()\")",
      "statement": "If you have 4 bells (say {{1}}, {{2}}, {{3}} and {{4}}), you can ring them in 24 ways: for example, {{1}}, {{2}}, {{4}} then {{3}}: {{1 2 4 3}} or {{3}}, {{1}}, {{2}} then {{4}}: {{3 1 2 4}}. You can ring the 24 melodies one by one; but how can someone (a monk or a priest) learn the full pattern of 24 melodies? They have developed mnemotechnical ways to remember them all and not to forget even one with what we call mathematical permutations.\n<<Plain Bob Minimus>> is such an algorithm. Here is its beginning:\n`{{1 2 3 4}}→{{2 1 4 3}}→{{2 4 1 3}}→{{4 2 3 1}}→{{4 3 2 1}}→{{3 4 1 2}}`\nA permutation of a set is a bijection (a one-to-one function) from the set onto itself, like a shuffle of the elements of the set. \nWe can describe <<Plain Bob Minimus>>’ permutations as [[(1 2)(3 4)]]→[[(1 4)]]→[[(2 4)(1 3)]]→[[(2 3)]]→[[(4 3)(2 1)]].\nFirst, [[(1 2)(3 4)]] exchanges the bells {{1}} and {{2}}, {{3}} and {{4}}.\nThen [[(1 4)]] exchanges the bells {{1}} and {{4}}.\nThen [[(2 4)(1 3)]] exchanges the bells {{2}} and {{4}}, {{1}} and {{3}}. And so on.\nIn blue, it’s a list of bells, a melody with four bells. In yellow, it’s the permutation that rearranges the bells from a melody to the next melody.\n\nA permutation can move more than two bells. [[(1 4 5)]] is the permutation that sends {{1}}→{{4}}, {{4}}→{{5}} and {{5}}→{{1}} and does not move neither {{2}} nor {{3}} nor any other number (it’s a 3-cycle).\n\nBeware, because permutations are functions, <<you must compute them from right to left>>.\n\nYou have to <<print the resulting permutation>> from a succession of permutations, that is a product of disjoint cycles (no number may appear in more than one cycle).\n\nNote that [[(1 4)(2 3)]] = [[(4 1)(2 3)]] = [[(3 2)(4 1)]] and so on. Write down the first in the lexicographic order where [[(1 4)(2 3)]]<[[(3 2)(4 1)]]<[[(4 1)(2 3)]].\nDon’t print the 1-cycle permutations like [[(1)]] or [[(3)]] that move nothing in the decomposition even if they might be present as input. There might be only one permutation and the result might be the original. If the permutation moves nothing, print [[()]] (two parentheses).\nLook at the examples below.\n\nExample, [[(1 3)(1 2 3)(1 3)]]:\n{{1}}→3 then 3→1 then 1→{{3}}\n{{2}}→2 then 2→3 then 3→{{1}}\n{{3}}→1 then 1→2 then 2→{{2}}\nConclusion, [[(1 3)(1 2 3)(1 3)]] = [[(1 3 2)]] (a 3-cycle).\n\nThe last example, [[(1 2 3)(1 4 3)]]:\n{{1}}→4 then 4→{{4}}\n{{2}}→2 then 2→{{3}}\n{{3}}→1 then 1→{{2}}\n{{4}}→3 then 3→{{1}}\nConclusion, [[(1 2 3)(1 4 3)]] = [[(1 4)(2 3)]] (two disjoint 2-cycle).",
      "testCases": [
        {
          "title": "Two transpositions",
          "isTest": true,
          "testIn": "(1 2)(2 3)",
          "testOut": "(1 2 3)",
          "isValidator": false,
          "needValidation": false
        },
        {
          "title": "Two transpositions",
          "isTest": false,
          "testIn": "(1 3)(1 2)",
          "testOut": "(1 2 3)",
          "isValidator": true,
          "needValidation": false
        },
        {
          "title": "Conjugate of 3-cycle",
          "isTest": true,
          "testIn": "(1 3)(1 2 3)(1 3)",
          "testOut": "(1 3 2)",
          "isValidator": false,
          "needValidation": false
        },
        {
          "title": "Conjugate of 2-cycle",
          "isTest": false,
          "testIn": "(1 2 3)(2 1)(1 3 2)",
          "testOut": "(2 3)",
          "isValidator": true,
          "needValidation": false
        },
        {
          "title": "Two transpositions",
          "isTest": true,
          "testIn": "(1 2 3)(1 4 3)",
          "testOut": "(1 4)(2 3)",
          "isValidator": false,
          "needValidation": false
        },
        {
          "title": "Two transpositions",
          "isTest": false,
          "testIn": "(1 2 3 4)(2 1 4)(1 3 2 4)",
          "testOut": "(1 4)(2 3)",
          "isValidator": true,
          "needValidation": false
        },
        {
          "title": "Null permutation",
          "isTest": true,
          "testIn": "(1 2 3)(1 3 2)",
          "testOut": "()",
          "isValidator": false,
          "needValidation": false
        },
        {
          "title": "Null permutation",
          "isTest": false,
          "testIn": "(1 2 3 4)(1 4)(1 3 2 4)(1 4)",
          "testOut": "()",
          "isValidator": true,
          "needValidation": false
        },
        {
          "title": "Same permutation",
          "isTest": true,
          "testIn": "(3 1 2)",
          "testOut": "(1 2 3)",
          "isValidator": false,
          "needValidation": false
        },
        {
          "title": "Same permutation",
          "isTest": false,
          "testIn": "(3 4)(2 1)",
          "testOut": "(1 2)(3 4)",
          "isValidator": true,
          "needValidation": false
        },
        {
          "title": "1-cycle",
          "isTest": true,
          "testIn": "(1)(3 2 4)(2)(1 4)",
          "testOut": "(1 3 2 4)",
          "isValidator": false,
          "needValidation": false
        },
        {
          "title": "Only 1-cycle",
          "isTest": false,
          "testIn": "(1)(3)(4)(2)",
          "testOut": "()",
          "isValidator": true,
          "needValidation": false
        },
        {
          "title": "Empty permutation",
          "isTest": true,
          "testIn": "()",
          "testOut": "()",
          "isValidator": false,
          "needValidation": false
        },
        {
          "title": "Empty dempty",
          "isTest": false,
          "testIn": "()()",
          "testOut": "()",
          "isValidator": true,
          "needValidation": false
        },
        {
          "title": "All cases",
          "isTest": true,
          "testIn": "(1 4 5)()(2 3 4)(2)(2 5 3)",
          "testOut": "(1 4 2)",
          "isValidator": false,
          "needValidation": false
        },
        {
          "title": "All cases",
          "isTest": false,
          "testIn": "(1 5 4)(5)()(1 3 4)(2 1 3)()",
          "testOut": "(2 3)(4 5)",
          "isValidator": true,
          "needValidation": false
        },
        {
          "title": "Plain Bob Minimus (3 moves)",
          "isTest": true,
          "testIn": "(1 4)(2 4)(1 3)(2 3)(4 3)(1 2)",
          "testOut": "(1 4)(2 3)",
          "isValidator": false,
          "needValidation": false
        },
        {
          "title": "Plain Bob Minimus (5 moves)",
          "isTest": false,
          "testIn": "(1 2)(3 4)(1 4)(2 4)(1 3)(2 3)(4 3)(1 2)",
          "testOut": "(1 3)(2 4)",
          "isValidator": true,
          "needValidation": false
        }
      ],
      "difficulty": "medium",
      "constraints": "The input is properly formatted (no unpaired parentheses, etc.)\n1≤[[input]]≤5",
      "coverBinaryId": 49459542817707,
      "stubGenerator": "read permutation:string(40)\nwrite result",
      "inputDescription": "<<Single line>> The succession of permutations.",
      "solutionLanguage": "Python3",
      "outputDescription": "<<Single line>> The result of their product."
    },
    "draft": false,
    "readyForModeration": true,
    "statementHTML": "<div class=\"statement-body\">\n<div class=\"statement-section statement-goal\">\n   <h2><span class=\"icon icon-goal\">&nbsp;</span><span>Goal </span></h2>\n   <span class=\"question-statement\">If you have 4 bells (say <const>1</const>, <const>2</const>, <const>3</const> and <const>4</const>), you can ring them in 24 ways: for example, <const>1</const>, <const>2</const>, <const>4</const> then <const>3</const>: <const>1 2 4 3</const> or <const>3</const>, <const>1</const>, <const>2</const> then <const>4</const>: <const>3 1 2 4</const>. You can ring the 24 melodies one by one; but how can someone (a monk or a priest) learn the full pattern of 24 melodies? They have developed mnemotechnical ways to remember them all and not to forget even one with what we call mathematical permutations.<br><strong>Plain Bob Minimus</strong> is such an algorithm. Here is its beginning:<br><pre style=\"font-family: monospace\"><const>1 2 3 4</const>&rarr;<const>2 1 4 3</const>&rarr;<const>2 4 1 3</const>&rarr;<const>4 2 3 1</const>&rarr;<const>4 3 2 1</const>&rarr;<const>3 4 1 2</const></pre><br>A permutation of a set is a bijection (a one-to-one function) from the set onto itself, like a shuffle of the elements of the set. <br>We can describe <strong>Plain Bob Minimus</strong>&rsquo; permutations as <var>(1 2)(3 4)</var>&rarr;<var>(1 4)</var>&rarr;<var>(2 4)(1 3)</var>&rarr;<var>(2 3)</var>&rarr;<var>(4 3)(2 1)</var>.<br>First, <var>(1 2)(3 4)</var> exchanges the bells <const>1</const> and <const>2</const>, <const>3</const> and <const>4</const>.<br>Then <var>(1 4)</var> exchanges the bells <const>1</const> and <const>4</const>.<br>Then <var>(2 4)(1 3)</var> exchanges the bells <const>2</const> and <const>4</const>, <const>1</const> and <const>3</const>. And so on.<br>In blue, it&rsquo;s a list of bells, a melody with four bells. In yellow, it&rsquo;s the permutation that rearranges the bells from a melody to the next melody.<br><br>A permutation can move more than two bells. <var>(1 4 5)</var> is the permutation that sends <const>1</const>&rarr;<const>4</const>, <const>4</const>&rarr;<const>5</const> and <const>5</const>&rarr;<const>1</const> and does not move neither <const>2</const> nor <const>3</const> nor any other number (it&rsquo;s a 3-cycle).<br><br>Beware, because permutations are functions, <strong>you must compute them from right to left</strong>.<br><br>You have to <strong>print the resulting permutation</strong> from a succession of permutations, that is a product of disjoint cycles (no number may appear in more than one cycle).<br><br>Note that <var>(1 4)(2 3)</var> = <var>(4 1)(2 3)</var> = <var>(3 2)(4 1)</var> and so on. Write down the first in the lexicographic order where <var>(1 4)(2 3)</var>&lt;<var>(3 2)(4 1)</var>&lt;<var>(4 1)(2 3)</var>.<br>Don&rsquo;t print the 1-cycle permutations like <var>(1)</var> or <var>(3)</var> that move nothing in the decomposition even if they might be present as input. There might be only one permutation and the result might be the original. If the permutation moves nothing, print <var>()</var> (two parentheses).<br>Look at the examples below.<br><br>Example, <var>(1 3)(1 2 3)(1 3)</var>:<br><const>1</const>&rarr;3 then 3&rarr;1 then 1&rarr;<const>3</const><br><const>2</const>&rarr;2 then 2&rarr;3 then 3&rarr;<const>1</const><br><const>3</const>&rarr;1 then 1&rarr;2 then 2&rarr;<const>2</const><br>Conclusion, <var>(1 3)(1 2 3)(1 3)</var> = <var>(1 3 2)</var> (a 3-cycle).<br><br>The last example, <var>(1 2 3)(1 4 3)</var>:<br><const>1</const>&rarr;4 then 4&rarr;<const>4</const><br><const>2</const>&rarr;2 then 2&rarr;<const>3</const><br><const>3</const>&rarr;1 then 1&rarr;<const>2</const><br><const>4</const>&rarr;3 then 3&rarr;<const>1</const><br>Conclusion, <var>(1 2 3)(1 4 3)</var> = <var>(1 4)(2 3)</var> (two disjoint 2-cycle).</span>\n</div>\n<div class=\"statement-section statement-protocol\">\n   <div class=\"blk\">\n      <div class=\"title\">Input</div>\n      <div class=\"question-statement-input\"><strong>Single line</strong> The succession of permutations.</div>\n   </div>\n   <div class=\"blk\">\n      <div class=\"title\">Output</div>\n      <div class=\"question-statement-output\"><strong>Single line</strong> The result of their product.</div>\n   </div>\n   <div class=\"blk\">\n      <div class=\"title\">Constraints</div>\n      <div class=\"question-statement-constraints\">The input is properly formatted (no unpaired parentheses, etc.)<br>1&le;<var>input</var>&le;5</div>\n   </div>\n   <div class=\"blk\">\n      <div class=\"title\">Example</div>\n      <div class=\"statement-inout\">\n         <div class=\"statement-inout-in\">\n            <div class=\"title\">Input</div>\n            <pre class=\"question-statement-example-in\">(1 2)(2 3)</pre>\n         </div>\n         <div class=\"statement-inout-out\">\n            <div class=\"title\">Output</div>\n            <pre class=\"question-statement-example-out\">(1 2 3)</pre>\n         </div>\n      </div>\n   </div>\n</div>"
  },
  "validatedFor": 147242499256,
  "avatar": 26090852120005,
  "commentCount": 39,
  "upVotes": 30,
  "downVotes": 10,
  "validateAction": {
    "actionId": 562143,
    "progress": 1,
    "alreadyDone": false
  },
  "statusHistory": [
    {
      "status": "REFUSED",
      "date": 1571242995996,
      "data": {
        "author": "SYSTEM",
        "reason": "INACTIVITY"
      }
    },
    {
      "status": "PENDING",
      "date": 1598980224621,
      "data": {
        "author": "ACTION",
        "reason": "EDIT"
      }
    },
    {
      "status": "REFUSED",
      "date": 1601575536999,
      "data": {
        "author": "SYSTEM",
        "reason": "INACTIVITY"
      }
    },
    {
      "status": "PENDING",
      "date": 1601657703138,
      "data": {
        "author": "ACTION",
        "reason": "EDIT"
      }
    },
    {
      "status": "REFUSED",
      "date": 1604250336999,
      "data": {
        "author": "SYSTEM",
        "reason": "INACTIVITY"
      }
    },
    {
      "status": "PENDING",
      "date": 1621365005004,
      "data": {
        "author": "ACTION",
        "reason": "EDIT"
      }
    },
    {
      "status": "ACCEPTED",
      "date": 1623487959353,
      "data": {
        "author": "ACTION"
      }
    }
  ],
  "editable": true,
  "draft": false,
  "readyForModeration": true
}