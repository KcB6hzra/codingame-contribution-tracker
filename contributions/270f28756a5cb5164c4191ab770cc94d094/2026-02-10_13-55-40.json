{
  "id": 270,
  "activeVersion": 17,
  "score": 7,
  "votableId": 2208073,
  "codingamerId": 1140484,
  "views": 205,
  "commentableId": 2157178,
  "title": "XML MDF-2016",
  "status": "ACCEPTED",
  "type": "PUZZLE_INOUT",
  "nickname": "NikoNikoSuru",
  "publicHandle": "270f28756a5cb5164c4191ab770cc94d094",
  "codingamerHandle": "e30440b1354292912c058b8fbfba20674840411",
  "lastVersion": {
    "version": 17,
    "data": {
      "title": "XML MDF-2016",
      "topics": [
        {
          "id": 73,
          "handle": "strings",
          "category": "FUNDAMENTALS",
          "labelMap": {
            "1": "Chaînes de caractères",
            "2": "Strings"
          },
          "pageTitle": "Strings: exercises and theory",
          "puzzleCount": 23,
          "parentTopicId": 41,
          "contentDetailsId": 73
        },
        {
          "id": 67,
          "handle": "parsing",
          "category": "FUNDAMENTALS",
          "labelMap": {
            "1": "Parsing",
            "2": "Parsing"
          },
          "pageTitle": "Parsing: exercises and theory",
          "puzzleCount": 10,
          "parentTopicId": 41,
          "contentDetailsId": 102
        }
      ],
      "solution": "trait Token\ncase class Opening(letter: Char) extends Token\ncase class Closing(letter: Char) extends Token\n\nobject Solution extends App {\n    val input = readLine\n\n    def tokenize(text: List[Char]): List[Token] = text match {\n      case '-' :: letter :: rest => Closing(letter) :: tokenize(rest)\n      case letter :: rest => Opening(letter) :: tokenize(rest)\n      case Nil => Nil\n    }\n\n    def computeWeights(tokens: List[Token]): Map[Char, Double] = {\n      (tokens.foldLeft(1, Map.empty[Char, Double].withDefaultValue(0.0)) {\n        case ((depth, weights), token) =>\n          token match {\n            case Opening(letter) => (depth + 1, weights.updated(letter, weights(letter) + 1.0 / depth))\n            case Closing(letter) => (depth - 1, weights)\n          }\n      })._2\n    }\n\n    val output = computeWeights(tokenize(input.toList))\n        .toList\n        .minBy(_.swap)(Ordering.Tuple2(Ordering[Double].reverse, Ordering[Char]))\n        ._1\n\n    println(output)\n}\n",
      "statement": "In this challenge, a data format that is a simplified version of XML is used. Tags are identified by a lowercase English letter. A start tag is represented by that single letter, and the closing tag is represented by the {{-}} character, followed by that letter.\n\nFor example, the string {{ab-bcd-d-c-ae-e}} is the equivalent of {{<a> <b> </ b> <c> <d> </ d> </ c> </a> <e> </ e>}} in XML. The supplied string will always be properly formed.\n\nNow we define the depth of a tag as 1 + the number of tags in which it is nested.\n\nIn the previous example:\n{{a}} and {{e}} have a depth of 1,\n{{b}} and {{c}} have a depth of 2\nand {{d}} has a depth of 3.\n\n\nThe weight of a tag name is defined as the sum of the reciprocals of the depths of each of its occurrences.\n\nFor example, in the chain {{a-abab-b-a-b}}, there are:\n- Two tags {{a}} with depths of 1 and 2\n- Two tags {{b}} with depths of 1 and 3.\n\nthus the weight of {{a}} is (1/1) + (1/2) = 1.5 and the weight of {{b}} is (1/1) + (1/3) = 1.33.\n\nIn this challenge you must determine the letter of the tag with the greatest weight in the string argument.",
      "testCases": [
        {
          "title": "Only one",
          "isTest": true,
          "testIn": "aa-aa-a-a",
          "testOut": "a",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Only one",
          "isTest": false,
          "testIn": "bb-bb-b-b",
          "testOut": "b",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "Nested might lose",
          "isTest": true,
          "testIn": "ab-b-a",
          "testOut": "a",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Nested might lose",
          "isTest": false,
          "testIn": "ba-a-b",
          "testOut": "b",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "Several nested might win",
          "isTest": true,
          "testIn": "ab-bb-bb-b-a",
          "testOut": "b",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Several nested might win",
          "isTest": false,
          "testIn": "ba-aa-aa-a-b",
          "testOut": "a",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "Several deeper nested might win too",
          "isTest": true,
          "testIn": "abc-cc-c-bc-cc-c-a",
          "testOut": "c",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Several deeper nested might win too",
          "isTest": false,
          "testIn": "abcd-dd-d-c-bd-dd-d-a",
          "testOut": "d",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "Only one shall win",
          "isTest": true,
          "testIn": "abc-cc-cc-cc-c-bd-dd-d-a",
          "testOut": "c",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Only one shall win",
          "isTest": false,
          "testIn": "abx-xx-xx-xx-x-bd-dd-d-a",
          "testOut": "x",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "Size should not matter",
          "isTest": true,
          "testIn": "nu-u-nim-mo-o-irjlncx-xzd-d-z-cg-gma-a-m-n-l-j-rff-f-fo-onkbwn-nf-f-wra-a-rlbaf-ftesov-v-o-sld-d-l-e-t-a-b-lch-ha-aw-w-c-bxt-t-x-k-net-t-eoif-f-i-ofe-eka-a-kc-c-fyvv-v-v-yx-xsjuuaf-fd-d-a-u-u-j-suewunq-q-n-u-w-er-rmd-dum-mhq-quo-o-utip-p-ivgcm-m-cg-g-gt-t-v-t-h-u-m-u",
          "testOut": "f",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Size should not matter",
          "isTest": false,
          "testIn": "nu-u-nim-mo-o-irjlncx-xzd-d-z-cg-gma-a-m-n-l-j-rqq-q-qo-onkbwn-nq-q-wra-a-rlbaq-qtesov-v-o-sld-d-l-e-t-a-b-lch-ha-aw-w-c-bxt-t-x-k-net-t-eoiq-q-i-oqe-eka-a-kc-c-qyvv-v-v-yx-xsjuuaq-qd-d-a-u-u-j-suewunf-f-n-u-w-er-rmd-dum-mhf-fuo-o-utip-p-ivgcm-m-cg-g-gt-t-v-t-h-u-m-u",
          "testOut": "q",
          "isValidator": true,
          "needValidation": true
        }
      ],
      "difficulty": "easy",
      "constraints": "1 ≤ length of [[sequence]] ≤ 300",
      "stubGenerator": "read sequence:string(1024)\nwrite answer",
      "inputDescription": "On a single line, a properly formed string [[sequence]] representing nested tags.",
      "solutionLanguage": "Scala",
      "outputDescription": "The letter corresponding to greatest weight tag name. If two tag names have the same weight, display the smallest in alphabetical order."
    },
    "draft": false,
    "readyForModeration": true,
    "statementHTML": "<div class=\"statement-body\">\n<div class=\"statement-section statement-goal\">\n   <h2><span class=\"icon icon-goal\">&nbsp;</span><span>Goal </span></h2>\n   <span class=\"question-statement\">In this challenge, a data format that is a simplified version of XML is used. Tags are identified by a lowercase English letter. A start tag is represented by that single letter, and the closing tag is represented by the <const>-</const> character, followed by that letter.<br><br>For example, the string <const>ab-bcd-d-c-ae-e</const> is the equivalent of <const>&lt;a&gt; &lt;b&gt; &lt;/ b&gt; &lt;c&gt; &lt;d&gt; &lt;/ d&gt; &lt;/ c&gt; &lt;/a&gt; &lt;e&gt; &lt;/ e&gt;</const> in XML. The supplied string will always be properly formed.<br><br>Now we define the depth of a tag as 1 + the number of tags in which it is nested.<br><br>In the previous example:<br><const>a</const> and <const>e</const> have a depth of 1,<br><const>b</const> and <const>c</const> have a depth of 2<br>and <const>d</const> has a depth of 3.<br><br><br>The weight of a tag name is defined as the sum of the reciprocals of the depths of each of its occurrences.<br><br>For example, in the chain <const>a-abab-b-a-b</const>, there are:<br>- Two tags <const>a</const> with depths of 1 and 2<br>- Two tags <const>b</const> with depths of 1 and 3.<br><br>thus the weight of <const>a</const> is (1/1) + (1/2) = 1.5 and the weight of <const>b</const> is (1/1) + (1/3) = 1.33.<br><br>In this challenge you must determine the letter of the tag with the greatest weight in the string argument.</span>\n</div>\n<div class=\"statement-section statement-protocol\">\n   <div class=\"blk\">\n      <div class=\"title\">Input</div>\n      <div class=\"question-statement-input\">On a single line, a properly formed string <var>sequence</var> representing nested tags.</div>\n   </div>\n   <div class=\"blk\">\n      <div class=\"title\">Output</div>\n      <div class=\"question-statement-output\">The letter corresponding to greatest weight tag name. If two tag names have the same weight, display the smallest in alphabetical order.</div>\n   </div>\n   <div class=\"blk\">\n      <div class=\"title\">Constraints</div>\n      <div class=\"question-statement-constraints\">1 &le; length of <var>sequence</var> &le; 300</div>\n   </div>\n   <div class=\"blk\">\n      <div class=\"title\">Example</div>\n      <div class=\"statement-inout\">\n         <div class=\"statement-inout-in\">\n            <div class=\"title\">Input</div>\n            <pre class=\"question-statement-example-in\">aa-aa-a-a</pre>\n         </div>\n         <div class=\"statement-inout-out\">\n            <div class=\"title\">Output</div>\n            <pre class=\"question-statement-example-out\">a</pre>\n         </div>\n      </div>\n   </div>\n</div>"
  },
  "validatedFor": 307215772543,
  "commentCount": 9,
  "upVotes": 7,
  "downVotes": 0,
  "validateAction": {
    "actionId": 404,
    "progress": 1,
    "alreadyDone": false
  },
  "statusHistory": [],
  "editable": true,
  "draft": false,
  "readyForModeration": true
}