{
  "id": 52518,
  "activeVersion": 41,
  "score": 7,
  "votableId": 28859122,
  "codingamerId": 4806550,
  "views": 355,
  "commentableId": 28727834,
  "title": "Euclid's algorithm with complex numbers",
  "status": "ACCEPTED",
  "type": "PUZZLE_INOUT",
  "nickname": "Rafarafa",
  "publicHandle": "52518e3c281414497c4f1f13bc85c49c42785",
  "codingamerHandle": "68977779383d7e4ea558c7a5446487f40556084",
  "lastVersion": {
    "version": 41,
    "autocloseTime": 1690443552458,
    "data": {
      "title": "Euclid's algorithm with complex numbers",
      "topics": [
        {
          "id": 71,
          "handle": "recursion",
          "category": "FUNDAMENTALS",
          "labelMap": {
            "1": "RÃ©cursion",
            "2": "Recursion"
          },
          "pageTitle": "Recursion: exercises and theory",
          "puzzleCount": 32,
          "parentTopicId": 41,
          "contentDetailsId": 77
        },
        {
          "id": 94,
          "handle": "mathematics",
          "category": "INTERMEDIATE",
          "labelMap": {
            "1": "Mathematics",
            "2": "Mathematics"
          },
          "puzzleCount": 52,
          "parentTopicId": 93
        },
        {
          "labelMap": {
            "2": "Complex Numbers"
          }
        }
      ],
      "solution": "#include <iostream>\n#include <complex>\n#include <iostream>\n\nusing namespace std;\n\n\nvoid fmt(const complex<float>& z) {\n    float y = z.imag();\n    float x = z.real();\n\n    if (x == 0) {\n        // To prevent weird stuff like -0j\n        printf(\"%.0fj\", y != 0 ? y : 0);\n    } else {\n        if (y > 0) printf(\"(%.0f+%.0fj)\", x, y);\n        else if (y < 0) printf(\"(%.0f-%.0fj)\", x, -y);\n        else printf(\"(%.0f+0j)\", x);\n    } \n}\n\nfloat closest(float n) {\n    float c = ceil(n);\n    float f = floor(n);\n    float d = abs(n - c);\n\n    return d <= 0.5 ? c : f;\n}\n\ncomplex<float> gcd(complex<float> z1, complex<float> z2) {\n    complex<float> z = z1 / z2;\n\n    float y = z.imag();\n    float x = z.real();\n    float cy = closest(y);\n    float cx = closest(x);\n\n    complex<float> q (cx, cy);\n    complex<float> r = z1 - z2 * q;\n    \n    fmt(z1); cout << \" = \"; \n    fmt(z2); cout << \" * \";\n    fmt(q);  cout << \" + \";\n    fmt(r);  cout << endl;\n    \n    return r.real() == 0 && r.imag() == 0 ? z2 : gcd(z2, r);\n}\n\nint main()\n{\n    float xa, ya, xb, yb;\n    cin >> xa >> ya >> xb >> yb;\n    complex<float> z1 (xa, ya), z2 (xb, yb);\n    complex<float> _gcd = gcd(z1, z2);\n    cout << \"GCD(\"; fmt(z1);\n    cout << \", \"; fmt(z2);\n    cout << \") = \"; fmt(_gcd);\n}",
      "statement": "This puzzle assumes that you have solved: {{https://www.codingame.com/training/easy/euclids-algorithm}}, or simply that you know how the GCD works for integers.\n\nNone of the math is explained nor needed. For those interested the references are at the bottom.\n\nYou will have to implement an analog of the euclidian division for Gaussian integers (complex numbers of the form <<x + iy>> with <<x>> and <<y>> integers). The pseudocode:\n\nYou are given two Gaussian integers [[a]] and [[b]]:\n<<1:>> Compute [[a/b]] = x + iy.\n<<2:>> Find the closest integer [[cx]] to [[x]] and [[cy]] to [[y]]. <<*>>\n<<3:>> The quotient [[q]] is then [[cx + icy]].\n<<4:>> The rest [[r]] is just [[a]] - [[q]] * [[b]].\n\nYou can now compute the GCD of [[a]] and [[b]]. Print the steps in the suitable format. <<**>>\n\n<<*>> If there are two possible choices pick the highest one. That is, if [[x]] = {{0.5}}, pick {{1}}. If [[x]] = {{-1.5}}, pick {{-1}} etc.\n<<**>> This puzzle follows the Python conventions for printing complex numbers. The tests are more telling than a detailed explanation.\n\n<<Reference:>> https://www.cut-the-knot.org/arithmetic/int_domain4.shtml",
      "testCases": [
        {
          "title": "1. 2 is not prime",
          "isTest": true,
          "testIn": "2 0\n1 -1",
          "testOut": "(2+0j) = (1-1j) * (1+1j) + 0j\nGCD((2+0j), (1-1j)) = (1-1j)",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "1. Nor 5",
          "isTest": false,
          "testIn": "5 0\n1 -2",
          "testOut": "(5+0j) = (1-2j) * (1+2j) + 0j\nGCD((5+0j), (1-2j)) = (1-2j)",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "2. Random",
          "isTest": true,
          "testIn": "-38 -26\n-43 -7",
          "testOut": "(-38-26j) = (-43-7j) * (1+0j) + (5-19j)\n(-43-7j) = (5-19j) * -2j + (-5+3j)\n(5-19j) = (-5+3j) * (-2+2j) + (1-3j)\n(-5+3j) = (1-3j) * (-1-1j) + (-1+1j)\n(1-3j) = (-1+1j) * (-2+1j) + 0j\nGCD((-38-26j), (-43-7j)) = (-1+1j)",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "2. Random val",
          "isTest": false,
          "testIn": "43 11\n-32 26",
          "testOut": "(43+11j) = (-32+26j) * (-1-1j) + (-15+5j)\n(-32+26j) = (-15+5j) * (2-1j) + (-7+1j)\n(-15+5j) = (-7+1j) * (2+0j) + (-1+3j)\n(-7+1j) = (-1+3j) * (1+2j) + 0j\nGCD((43+11j), (-32+26j)) = (-1+3j)",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "3. Don't sort",
          "isTest": true,
          "testIn": "-6 27\n-37 25",
          "testOut": "(-6+27j) = (-37+25j) * 0j + (-6+27j)\n(-37+25j) = (-6+27j) * (1+1j) + (-4+4j)\n(-6+27j) = (-4+4j) * (4-3j) + (-2-1j)\n(-4+4j) = (-2-1j) * (1-2j) + 1j\n(-2-1j) = 1j * (-1+2j) + 0j\nGCD((-6+27j), (-37+25j)) = 1j",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "3. Don't sort val",
          "isTest": false,
          "testIn": "8 3\n36 -23",
          "testOut": "(8+3j) = (36-23j) * 0j + (8+3j)\n(36-23j) = (8+3j) * (3-4j) + 0j\nGCD((8+3j), (36-23j)) = (8+3j)",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "4. Rounding",
          "isTest": true,
          "testIn": "28 40\n-18 -24",
          "testOut": "(28+40j) = (-18-24j) * (-2+0j) + (-8-8j)\n(-18-24j) = (-8-8j) * (3+0j) + (6+0j)\n(-8-8j) = (6+0j) * (-1-1j) + (-2-2j)\n(6+0j) = (-2-2j) * (-1+2j) + 2j\n(-2-2j) = 2j * (-1+1j) + 0j\nGCD((28+40j), (-18-24j)) = 2j",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "4. Rounding  + Don't sort val",
          "isTest": false,
          "testIn": "-10 10\n-46 25",
          "testOut": "(-10+10j) = (-46+25j) * 0j + (-10+10j)\n(-46+25j) = (-10+10j) * (4+1j) + (4-5j)\n(-10+10j) = (4-5j) * (-2+0j) + (-2+0j)\n(4-5j) = (-2+0j) * (-2+3j) + 1j\n(-2+0j) = 1j * 2j + 0j\nGCD((-10+10j), (-46+25j)) = 1j",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "5. Big",
          "isTest": true,
          "testIn": "-13 -39\n-5 35",
          "testOut": "(-13-39j) = (-5+35j) * (-1+1j) + (17+1j)\n(-5+35j) = (17+1j) * 2j + (-3+1j)\n(17+1j) = (-3+1j) * (-5-2j) + 0j\nGCD((-13-39j), (-5+35j)) = (-3+1j)",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "5. Big val",
          "isTest": false,
          "testIn": "32 733\n-351 -455",
          "testOut": "(32+733j) = (-351-455j) * (-1-1j) + (136-73j)\n(-351-455j) = (136-73j) * (-1-4j) + (77+16j)\n(136-73j) = (77+16j) * (2-1j) + (-34-28j)\n(77+16j) = (-34-28j) * (-2+1j) + (-19-6j)\n(-34-28j) = (-19-6j) * (2+1j) + (-2+3j)\n(-19-6j) = (-2+3j) * (2+5j) + -2j\n(-2+3j) = -2j * (-1-1j) + 1j\n-2j = 1j * (-2+0j) + 0j\nGCD((32+733j), (-351-455j)) = 1j",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "6. Bigger",
          "isTest": true,
          "testIn": "-5612 -2269\n-250 940",
          "testOut": "(-5612-2269j) = (-250+940j) * (-1+6j) + (-222+171j)\n(-250+940j) = (-222+171j) * (3-2j) + (74-17j)\n(-222+171j) = (74-17j) * (-3+2j) + (-34-28j)\n(74-17j) = (-34-28j) * (-1+1j) + (12-11j)\n(-34-28j) = (12-11j) * -3j + (-1+8j)\n(12-11j) = (-1+8j) * (-2-1j) + (2+4j)\n(-1+8j) = (2+4j) * (2+1j) + (-1-2j)\n(2+4j) = (-1-2j) * (-2+0j) + 0j\nGCD((-5612-2269j), (-250+940j)) = (-1-2j)",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "6. Bigger val",
          "isTest": false,
          "testIn": "-250 940\n-222 171",
          "testOut": "(-250+940j) = (-222+171j) * (3-2j) + (74-17j)\n(-222+171j) = (74-17j) * (-3+2j) + (-34-28j)\n(74-17j) = (-34-28j) * (-1+1j) + (12-11j)\n(-34-28j) = (12-11j) * -3j + (-1+8j)\n(12-11j) = (-1+8j) * (-2-1j) + (2+4j)\n(-1+8j) = (2+4j) * (2+1j) + (-1-2j)\n(2+4j) = (-1-2j) * (-2+0j) + 0j\nGCD((-250+940j), (-222+171j)) = (-1-2j)",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "7. Care even rounding",
          "isTest": true,
          "testIn": "19 8\n-1 -7",
          "testOut": "(19+8j) = (-1-7j) * (-1+3j) + (-3+4j)\n(-1-7j) = (-3+4j) * (-1+1j) + 0j\nGCD((19+8j), (-1-7j)) = (-3+4j)",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "7. Care even rounding val",
          "isTest": false,
          "testIn": "9436 1127\n-1395 935",
          "testOut": "(9436+1127j) = (-1395+935j) * (-4-4j) + (116-713j)\n(-1395+935j) = (116-713j) * (-2-2j) + (263-259j)\n(116-713j) = (263-259j) * (2-1j) + (-151+68j)\n(263-259j) = (-151+68j) * (-2+1j) + (29+28j)\n(-151+68j) = (29+28j) * (-2+4j) + (19+8j)\n(29+28j) = (19+8j) * (2+1j) + (-1-7j)\n(19+8j) = (-1-7j) * (-1+3j) + (-3+4j)\n(-1-7j) = (-3+4j) * (-1+1j) + 0j\nGCD((9436+1127j), (-1395+935j)) = (-3+4j)",
          "isValidator": true,
          "needValidation": true
        }
      ],
      "difficulty": "easy",
      "constraints": "[[xa]], [[ya]], [[xb]] and [[yb]] are all between {{-10000}} and {{10000}} included.",
      "coverBinaryId": 107335306230619,
      "stubGenerator": "read xa:int ya:int\nread xb:int yb:int\n\nwrite The steps of the GCD calculation",
      "inputDescription": "<<Line 1:>> A space separated string containing two integers, the first representing the real part [[xa]] and the second the imaginary part [[ya]] of a Gaussian integer [[a]].\n<<Line 2:>> A space separated string containing two integers, the first representing the real part [[xb]] and the second the imaginary part [[yb]] of a Gaussian integer [[b]].",
      "solutionLanguage": "C++",
      "outputDescription": "The steps of the GCD computation of [[a]] and [[b]] in the suitable format. This puzzle follows the Python conventions for printing complex numbers."
    },
    "draft": false,
    "readyForModeration": true,
    "statementHTML": "<div class=\"statement-body\">\n<div class=\"statement-section statement-goal\">\n   <h2><span class=\"icon icon-goal\">&nbsp;</span><span>Goal </span></h2>\n   <span class=\"question-statement\">This puzzle assumes that you have solved: <const>https://www.codingame.com/training/easy/euclids-algorithm</const>, or simply that you know how the GCD works for integers.<br><br>None of the math is explained nor needed. For those interested the references are at the bottom.<br><br>You will have to implement an analog of the euclidian division for Gaussian integers (complex numbers of the form <strong>x + iy</strong> with <strong>x</strong> and <strong>y</strong> integers). The pseudocode:<br><br>You are given two Gaussian integers <var>a</var> and <var>b</var>:<br><strong>1:</strong> Compute <var>a/b</var> = x + iy.<br><strong>2:</strong> Find the closest integer <var>cx</var> to <var>x</var> and <var>cy</var> to <var>y</var>. <strong>*</strong><br><strong>3:</strong> The quotient <var>q</var> is then <var>cx + icy</var>.<br><strong>4:</strong> The rest <var>r</var> is just <var>a</var> - <var>q</var> * <var>b</var>.<br><br>You can now compute the GCD of <var>a</var> and <var>b</var>. Print the steps in the suitable format. <strong>**</strong><br><br><strong>*</strong> If there are two possible choices pick the highest one. That is, if <var>x</var> = <const>0.5</const>, pick <const>1</const>. If <var>x</var> = <const>-1.5</const>, pick <const>-1</const> etc.<br><strong>**</strong> This puzzle follows the Python conventions for printing complex numbers. The tests are more telling than a detailed explanation.<br><br><strong>Reference:</strong> https://www.cut-the-knot.org/arithmetic/int_domain4.shtml</span>\n</div>\n<div class=\"statement-section statement-protocol\">\n   <div class=\"blk\">\n      <div class=\"title\">Input</div>\n      <div class=\"question-statement-input\"><strong>Line 1:</strong> A space separated string containing two integers, the first representing the real part <var>xa</var> and the second the imaginary part <var>ya</var> of a Gaussian integer <var>a</var>.<br><strong>Line 2:</strong> A space separated string containing two integers, the first representing the real part <var>xb</var> and the second the imaginary part <var>yb</var> of a Gaussian integer <var>b</var>.</div>\n   </div>\n   <div class=\"blk\">\n      <div class=\"title\">Output</div>\n      <div class=\"question-statement-output\">The steps of the GCD computation of <var>a</var> and <var>b</var> in the suitable format. This puzzle follows the Python conventions for printing complex numbers.</div>\n   </div>\n   <div class=\"blk\">\n      <div class=\"title\">Constraints</div>\n      <div class=\"question-statement-constraints\"><var>xa</var>, <var>ya</var>, <var>xb</var> and <var>yb</var> are all between <const>-10000</const> and <const>10000</const> included.</div>\n   </div>\n   <div class=\"blk\">\n      <div class=\"title\">Example</div>\n      <div class=\"statement-inout\">\n         <div class=\"statement-inout-in\">\n            <div class=\"title\">Input</div>\n            <pre class=\"question-statement-example-in\">2 0\n1 -1</pre>\n         </div>\n         <div class=\"statement-inout-out\">\n            <div class=\"title\">Output</div>\n            <pre class=\"question-statement-example-out\">(2+0j) = (1-1j) * (1+1j) + 0j\nGCD((2+0j), (1-1j)) = (1-1j)</pre>\n         </div>\n      </div>\n   </div>\n</div>"
  },
  "validatedFor": 82676918819,
  "avatar": 80946308795008,
  "commentCount": 27,
  "upVotes": 8,
  "downVotes": 1,
  "validateAction": {
    "actionId": 821981,
    "progress": 1,
    "alreadyDone": false
  },
  "statusHistory": [
    {
      "status": "REFUSED",
      "date": 1683241537000,
      "data": {
        "author": "SYSTEM",
        "reason": "INACTIVITY"
      }
    },
    {
      "status": "PENDING",
      "date": 1687851552458,
      "data": {
        "author": "ACTION",
        "reason": "EDIT"
      }
    },
    {
      "status": "ACCEPTED",
      "date": 1688052317694,
      "data": {
        "author": "ACTION"
      }
    }
  ],
  "editable": true,
  "draft": false,
  "readyForModeration": true
}