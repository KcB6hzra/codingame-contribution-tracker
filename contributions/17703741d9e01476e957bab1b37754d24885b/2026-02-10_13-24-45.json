{
  "id": 17703,
  "activeVersion": 7,
  "score": 12,
  "votableId": 23748541,
  "codingamerId": 1709071,
  "views": 257,
  "commentableId": 23633619,
  "title": "Ted's compiler",
  "status": "ACCEPTED",
  "type": "PUZZLE_INOUT",
  "nickname": "MAWAAW",
  "publicHandle": "17703741d9e01476e957bab1b37754d24885b",
  "codingamerHandle": "4e5a8dd7ed2c82fa5ec656f0b64af1481709071",
  "lastVersion": {
    "version": 7,
    "autocloseTime": 1657982138848,
    "data": {
      "title": "Ted's compiler",
      "topics": [
        {
          "id": 67,
          "handle": "parsing",
          "category": "FUNDAMENTALS",
          "labelMap": {
            "1": "Parsing",
            "2": "Parsing"
          },
          "pageTitle": "Parsing: exercises and theory",
          "puzzleCount": 24,
          "parentTopicId": 41,
          "contentDetailsId": 102
        },
        {
          "labelMap": {
            "2": "parenthesis"
          }
        }
      ],
      "solution": "import sys\nimport math\n\nline = input()\n\nstack = []\nanswer = 0\nfor i in range(len(line)):\n    char = line[i]\n    if char == \"<\":\n        stack.append(char)\n    else:\n        if not stack:\n            break\n        stack.pop()\n        if not stack:\n            answer = i+1\nprint(answer)",
      "statement": "Ted wants to develop a compiler and knows that one of the most important elements in a compiler is its <<parser>>\n\nParsing, syntax analysis, or syntactic analysis is the process of analyzing a string of symbols, either in natural language, computer languages or data structures, conforming to the rules of a formal grammar.\n\nhttps://en.wikipedia.org/wiki/Parsing\n\nToday, Ted is concerned with an abstract instruction which is composed of the characters {{<}} and {{>}} , which he will use on the design of his language, T++ :D.\n\nHe understand that, for an expression to be valid, a {{<}} symbol must always have a matching {{>}} character somewhere (nested expression are valid) after it. In addition, each {{>}} symbol must exactly match a {{<}} symbol.\n\nSo, for instance, the instructions:\n\n{{<<<<>>>>}}\n\n{{<>}}\n\n{{<><>}}\n\nare all valid. While:\n\n{{>>}}\n\n{{><><}}\n\nare not.\n\n<<Given expression which represent some instructions to be analyzed by Ted's compiler, you should tell the length of the longest prefix of this expression that is valid, or 0 if there is not such a prefix.>>",
      "testCases": [
        {
          "title": "Example",
          "isTest": true,
          "testIn": "<<>>>",
          "testOut": "4",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Validator 1",
          "isTest": false,
          "testIn": "<><><>><>",
          "testOut": "6",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "Short string",
          "isTest": true,
          "testIn": "<>",
          "testOut": "2",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Validator 2",
          "isTest": false,
          "testIn": "<<>>>",
          "testOut": "4",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "Not good",
          "isTest": true,
          "testIn": "><<>>",
          "testOut": "0",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Validator 3",
          "isTest": false,
          "testIn": ">>><><<<",
          "testOut": "0",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "Well formatted",
          "isTest": true,
          "testIn": "<<<<>>><<<>><<><>>>>",
          "testOut": "20",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Validator 4",
          "isTest": false,
          "testIn": "<<<<<<<>>><<<>><<><>>>>>>>",
          "testOut": "26",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "Long string",
          "isTest": true,
          "testIn": "<><><><<<<>>>>>>><<<<>>>><><><>><<<<>>>><>>><><<<<>>>><><><>><<<><<<<>>>><><><>><<<><><><><><<<<>>>>",
          "testOut": "14",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Validator 5",
          "isTest": false,
          "testIn": "<><><>><<<<>>>><><><>><<<<>>>><><><><<<<>>>>><><><>><<<<>>>><><>><<<<>>>><><><>><<<<>>>><><><><<<<>>>>",
          "testOut": "6",
          "isValidator": true,
          "needValidation": true
        }
      ],
      "difficulty": "easy",
      "constraints": "1 ≤ The length of [[line]] ≤ 100",
      "stubGenerator": "read line:string(1000)\n\nwrite answer",
      "inputDescription": "Input will consist of a single [[line]], representing a possible expression in T++.",
      "solutionLanguage": "Python3",
      "outputDescription": "You should output the [[length]] of the longest prefix that is valid or {{0}} if there is not such a prefix"
    },
    "draft": false,
    "readyForModeration": true,
    "statementHTML": "<div class=\"statement-body\">\n<div class=\"statement-section statement-goal\">\n   <h2><span class=\"icon icon-goal\">&nbsp;</span><span>Goal </span></h2>\n   <span class=\"question-statement\">Ted wants to develop a compiler and knows that one of the most important elements in a compiler is its <strong>parser</strong><br><br>Parsing, syntax analysis, or syntactic analysis is the process of analyzing a string of symbols, either in natural language, computer languages or data structures, conforming to the rules of a formal grammar.<br><br>https://en.wikipedia.org/wiki/Parsing<br><br>Today, Ted is concerned with an abstract instruction which is composed of the characters <const>&lt;</const> and <const>&gt;</const> , which he will use on the design of his language, T++ :D.<br><br>He understand that, for an expression to be valid, a <const>&lt;</const> symbol must always have a matching <const>&gt;</const> character somewhere (nested expression are valid) after it. In addition, each <const>&gt;</const> symbol must exactly match a <const>&lt;</const> symbol.<br><br>So, for instance, the instructions:<br><br><const><strong>&lt;&lt;</strong>&gt;&gt;</const><br><br><const>&lt;&gt;</const><br><br><const>&lt;&gt;&lt;&gt;</const><br><br>are all valid. While:<br><br><const>&gt;&gt;</const><br><br><const>&gt;&lt;&gt;&lt;</const><br><br>are not.<br><br><strong>Given expression which represent some instructions to be analyzed by Ted's compiler, you should tell the length of the longest prefix of this expression that is valid, or 0 if there is not such a prefix.</strong></span>\n</div>\n<div class=\"statement-section statement-protocol\">\n   <div class=\"blk\">\n      <div class=\"title\">Input</div>\n      <div class=\"question-statement-input\">Input will consist of a single <var>line</var>, representing a possible expression in T++.</div>\n   </div>\n   <div class=\"blk\">\n      <div class=\"title\">Output</div>\n      <div class=\"question-statement-output\">You should output the <var>length</var> of the longest prefix that is valid or <const>0</const> if there is not such a prefix</div>\n   </div>\n   <div class=\"blk\">\n      <div class=\"title\">Constraints</div>\n      <div class=\"question-statement-constraints\">1 &le; The length of <var>line</var> &le; 100</div>\n   </div>\n   <div class=\"blk\">\n      <div class=\"title\">Example</div>\n      <div class=\"statement-inout\">\n         <div class=\"statement-inout-in\">\n            <div class=\"title\">Input</div>\n            <pre class=\"question-statement-example-in\">&lt;&lt;&gt;&gt;&gt;</pre>\n         </div>\n         <div class=\"statement-inout-out\">\n            <div class=\"title\">Output</div>\n            <pre class=\"question-statement-example-out\">4</pre>\n         </div>\n      </div>\n   </div>\n</div>"
  },
  "validatedFor": 114922915106,
  "avatar": 9382042427281,
  "commentCount": 14,
  "upVotes": 13,
  "downVotes": 1,
  "validateAction": {
    "actionId": 674630,
    "progress": 1,
    "alreadyDone": false
  },
  "statusHistory": [
    {
      "status": "REFUSED",
      "date": 1655384737002,
      "data": {
        "author": "SYSTEM",
        "reason": "INACTIVITY"
      }
    },
    {
      "status": "PENDING",
      "date": 1655390138848,
      "data": {
        "author": "ACTION",
        "reason": "EDIT"
      }
    },
    {
      "status": "ACCEPTED",
      "date": 1655806968974,
      "data": {
        "author": "ACTION"
      }
    }
  ],
  "editable": true,
  "draft": false,
  "readyForModeration": true
}