{
  "id": 5076,
  "activeVersion": 13,
  "score": 45,
  "votableId": 13924793,
  "codingamerId": 1443538,
  "views": 1729,
  "commentableId": 13847091,
  "title": "Atari Go",
  "status": "ACCEPTED",
  "type": "PUZZLE_MULTI",
  "nickname": "Tux4711",
  "publicHandle": "507644dbe6bc6fc318eeaa25e26e48954355",
  "codingamerHandle": "a9f4f4250f0d322ce4853c1cf536ad228353441",
  "lastVersion": {
    "version": 13,
    "autocloseTime": 1598596643528,
    "data": {
      "title": "Atari Go",
      "topics": [
        {
          "id": 107,
          "handle": "classic-board-games",
          "labelMap": {
            "1": "Classic board games",
            "2": "Classic board games"
          },
          "puzzleCount": 8,
          "parentTopicId": 93
        },
        {
          "id": 83,
          "handle": "minimax",
          "labelMap": {
            "1": "Minimax",
            "2": "Minimax"
          },
          "pageTitle": "Minimax: exercises and theory",
          "puzzleCount": 13,
          "parentTopicId": 42,
          "contentDetailsId": 93
        }
      ],
      "refereeMd5": "1443538/4486825be1d8a0b2b405402b7edeab4b",
      "testHandle": "842532561d8500d879aefee86ddc0b779851c3",
      "viewerCode": "var Drawer=function(t){var e={};function n(r){if(e[r])return e[r].exports;var o=e[r]={i:r,l:!1,exports:{}};return t[r].call(o.exports,o,o.exports,n),o.l=!0,o.exports}return n.m=t,n.c=e,n.d=function(t,e,r){n.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:r})},n.r=function(t){\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(t,\"__esModule\",{value:!0})},n.t=function(t,e){if(1&e&&(t=n(t)),8&e)return t;if(4&e&&\"object\"==typeof t&&t&&t.__esModule)return t;var r=Object.create(null);if(n.r(r),Object.defineProperty(r,\"default\",{enumerable:!0,value:t}),2&e&&\"string\"!=typeof t)for(var o in t)n.d(r,o,function(e){return t[e]}.bind(null,o));return r},n.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return n.d(e,\"a\",e),e},n.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},n.p=\"\",n(n.s=0)}([function(t,e,n){\"use strict\";n.r(e),n.d(e,\"Drawer\",(function(){return Mn}));var r={baseUrl:\"https://cdn-games.codingame.com/community/1443538-1590321517105/\",images:{\"logoCG.png\":\"8ea9da90d5959c7b5b6dc625fbc57c9a5e086270fd1c40e5de5bc32d6ce7355d.png\",\"background_points.png\":\"b6c811c7bc62af976c22861d6b4a0351dfd17d2ee0e08fd89565c54eb2a3a254.png\",\"go_board_13x13.png\":\"f37913ec8c60df44f0430606ed7a3abf9c305ac672a060eab9448c79f11748fb.png\",\"go_board_19x19.png\":\"1ca8f685b83a6204840afbface70c67a2c0c7350d1c5d6c4de3f9c09a0c67bb9.png\",\"background.jpg\":\"77415a9c8e43504a9d8b8378903f786311923c06b3b11a268fd3e78d24509444.jpg\",\"welcome.png\":\"21d60dc5f7341ec76ece0dc342eae1808eb3147eee1ff8d457207f50e7e36132.png\",\"go_stone_white.png\":\"f76b01684e59ce3e1e9d9b6a517c5d155d7fd4df58640e961b77e2024be3e22b.png\",\"go_board_9x9.png\":\"03d6165f8d28f53579748bf8b98a30e6205f253f226cefe1f6355dc2df224062.png\",\"go_stone_black.png\":\"31e38cd7e52e83df774810ea96f0e38179205104188668261f4b4269b55a69cf.png\",\"logo.png\":\"67db39d8eea83cf1ae98792b8fd1e377cf3d2cdcd6d173e33bbaf1b890c08502.png\"},sprites:[],fonts:[]};function o(t,e,n){return t<=e?t+(e-t)*n:e+(t-e)*(1-n)}function i(t,e,n){return Math.min(1,Math.max(0,(n-(r=t))/(e-r)));var r}function a(t,e,n,r,o){return o=o||0,Math.min(n/(t+o),r/(e+o))}function s(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}var c=[],u=[],l=function(){function t(){!function(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}(this,t)}var e,n;return e=t,n=[{key:\"listen\",value:function(t){if(\"function\"!=typeof t)throw new TypeError(t+\" is not a function\");u.push(t)}},{key:\"push\",value:function(t){c.push(t),u.forEach((function(e){return e(t)}))}}],null&&s(e.prototype,null),n&&s(e,n),t}();function f(t){return(f=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&\"function\"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?\"symbol\":typeof t})(t)}function y(t){var e=b();return function(){var n,r,o,i=d(t);return r=this,!(o=e?(n=d(this).constructor,Reflect.construct(i,arguments,n)):i.apply(this,arguments))||\"object\"!==f(o)&&\"function\"!=typeof o?function(t){if(void 0!==t)return t;throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\")}(r):o}}function p(t){var e=\"function\"==typeof Map?new Map:void 0;return(p=function(t){if(null===t||(n=t,-1===Function.toString.call(n).indexOf(\"[native code]\")))return t;var n;if(\"function\"!=typeof t)throw new TypeError(\"Super expression must either be null or a function\");if(void 0!==e){if(e.has(t))return e.get(t);e.set(t,r)}function r(){return h(t,arguments,d(this).constructor)}return r.prototype=Object.create(t.prototype,{constructor:{value:r,enumerable:!1,writable:!0,configurable:!0}}),g(r,t)})(t)}function h(t,e,n){return(h=b()?Reflect.construct:function(t,e,n){var r=[null];r.push.apply(r,e);var o=new(Function.bind.apply(t,r));return n&&g(o,n.prototype),o}).apply(null,arguments)}function b(){if(\"undefined\"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if(\"function\"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],(function(){}))),!0}catch(t){return!1}}function g(t,e){return(g=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t})(t,e)}function d(t){return(d=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}var v=function(){!function(t,e){if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function\");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&g(t,e)}(e,p(Error));var t=y(e);function e(n,r){var o;return function(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}(this,e),(o=t.call(this,\"Invalid color token: there is no player at index \".concat(n,\". Make sure to use getColorToken() if you want the color of a specific player.\"))).playerIdx=n,o.cause=r,o.name=\"InvalidPlayerColorTokenError\",o}return e}();function x(t,e){var n,r=Object.keys(t);return Object.getOwnPropertySymbols&&(n=Object.getOwnPropertySymbols(t),e&&(n=n.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),r.push.apply(r,n)),r}function m(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?x(Object(n),!0).forEach((function(e){var r,o,i;r=t,i=n[o=e],o in r?Object.defineProperty(r,o,{value:i,enumerable:!0,configurable:!0,writable:!0}):r[o]=i})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):x(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}function w(t,e,n){return n<1?t:e}var _={type:Number,lerpMethod:function(t,e,n){if(null===e)return null;var r={r:(16711680&t)>>16,g:(65280&t)>>8,b:255&t},i={r:(16711680&e)>>16,g:(65280&e)>>8,b:255&e};return o(r.r,i.r,n)<<16|o(r.g,i.g,n)<<8|o(r.b,i.b,n)},convert:function(t,e){var n=-(t+1);try{return t<0?e.players[n].color:t}catch(t){return l.push(new v(n)),16777215}}},S={type:String,lerpMethod:w,convert:R},C={type:Number,lerpMethod:function(t,e,n,r){for(;e>t+Math.PI;)e-=2*Math.PI;for(;e<t-Math.PI;)e+=2*Math.PI;return(void 0!==r&&Math.abs(e-t)>r?e:t+(e-t)*n)%(2*Math.PI)},convert:function(t){return t*Math.PI/180}},O={type:Number,lerpMethod:w},U={type:function(t){return\"1\"===t},lerpMethod:w},k={type:Number,lerpMethod:function(t,e,n){return e<t?e:o(t,e,n)}},T={default:{type:Number,lerpMethod:o},visible:U,rotation:C,skewX:C,skewY:C,fillColor:_,lineColor:_,strokeColor:_,tint:_,animationProgressTime:k,maxWidth:O,mask:O,baseWidth:O,baseHeight:O,image:S,images:S,scaleMode:S,restarted:{type:String,convert:function(t,e,n,r){return t?{date:n.date+r*n.frameDuration}:null},lerpMethod:w},playing:U,duration:O,blendMode:O,loop:U,text:m(m({},S),{},{convert:function(t,e){t=R(t);for(var n=/\\$(\\d)/g,r=n.exec(t),o=\"\",i=0;r;)r[1]<e.players.length&&(o+=t.substring(i,r.index),o+=e.players[+r[1]].name),i=r.index+r[0].length,r=n.exec(t);return o+t.substring(i)}}),textAlign:m(m({},S),{},{convert:function(t){return{0:\"left\",1:\"center\",2:\"right\"}[t]}}),fontFamily:S,fontWeight:S,children:m(m({},S),{},{convert:function(t){return t?t.split(\",\").map((function(t){return+t})):[]}}),points:m(m({},S),{},{convert:function(t){return t?t.split(\",\").map((function(t){return parseInt(t)})):[]},lerpMethod:function(t,e,n){return t.length===e.length?t.map((function(t,r){return o(t,e[r],n)})):w(t,e,n)}})};function R(t){var e=t.split(\"\\\\'\").join(\"'\");return e.includes(\" \")||e.includes(\";\")||e.includes(\"\\n\")?e.slice(1,e.length-1):e}function P(t,e){var n,r=Object.keys(t);return Object.getOwnPropertySymbols&&(n=Object.getOwnPropertySymbols(t),e&&(n=n.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),r.push.apply(r,n)),r}function E(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?P(Object(n),!0).forEach((function(e){var r,o,i;r=t,i=n[o=e],o in r?Object.defineProperty(r,o,{value:i,enumerable:!0,configurable:!0,writable:!0}):r[o]=i})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):P(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}function j(t,e){(null==e||e>t.length)&&(e=t.length);for(var n=0,r=new Array(e);n<e;n++)r[n]=t[n];return r}function D(t){return(D=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&\"function\"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?\"symbol\":typeof t})(t)}function A(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}var F=function(){function t(){!function(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}(this,t),this.defaultState={x:0,y:0,scaleX:1,scaleY:1,skewX:0,skewY:0,zIndex:0,alpha:1,visible:!1,rotation:0,mask:-1},this.states={}}var e,n,r;return e=t,r=[{key:\"createState\",value:function(t,e,n){var r=2<arguments.length&&void 0!==n?n:{};return E(E({t:0<arguments.length&&void 0!==t?t:1},1<arguments.length&&void 0!==e?e:{}),{},{curve:r})}}],(n=[{key:\"init\",value:function(){this.properties=Object.keys(this.defaultState),this.initDisplay(),this.currentState=Object.assign({},this.defaultState),\"object\"===D(this.graphics)&&this.container.addChild(this.graphics)}},{key:\"setHidden\",value:function(t){this.hide=t,this.container.visible=this.currentState.visible&&!this.hide}},{key:\"addState\",value:function(e,n,r){this.states[r]||(this.states[r]=[]);var o=t.createState(e,n.values,n.curve),i=this.states[r].find((function(t){return t.t===e}));i&&0===Object.keys(o.curve).length&&(o.curve=i.curve),i?(M(o)||M(i)||l.push(new Error(\"Different updates for same t \"+e)),Object.assign(i,o)):this.states[r].push(o)}},{key:\"set\",value:function(t,e,n){this.addState(t,e,n)}},{key:\"render\",value:function(t,e,n){var r=this.states[e.number];this.container.visible=!1;var o,a=null,s=1;if(r&&r.length){for(var c=0;c<r.length-1&&r[c].t<t;)c++;if(a=r[c-1],o=r[c],a)s=i(a.t,o.t,t);else{var u=Object.keys(this.states),l=u.indexOf(e.number.toString())-1;for(-1===l&&(l=u.length-1);0<=l&&u[l]>=e.number;)l--;var f=this.states[u[l]]||[];s=!(a=f[f.length-1])&&t>=o.t?(a=o,1):i(0,o.t,t)}}else{for(var y=Object.keys(this.states),p=y.length-1;0<=p&&y[p]>e.number;)p--;var h=this.states[y[p]];null!=h?o=a=h[h.length-1]:Object.assign(this.currentState,this.defaultState)}if(a){var b,g={},d=Object.assign({},this.currentState),v=function(t,e){var n;if(\"undefined\"==typeof Symbol||null==t[Symbol.iterator]){if(Array.isArray(t)||(n=function(t,e){if(t){if(\"string\"==typeof t)return j(t,e);var n=Object.prototype.toString.call(t).slice(8,-1);return\"Object\"===n&&t.constructor&&(n=t.constructor.name),\"Map\"===n||\"Set\"===n?Array.from(t):\"Arguments\"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)?j(t,e):void 0}}(t))||e&&t&&\"number\"==typeof t.length){n&&(t=n);var r=0,o=function(){};return{s:o,n:function(){return r>=t.length?{done:!0}:{done:!1,value:t[r++]}},e:function(t){throw t},f:o}}throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\")}var i,a=!0,s=!1;return{s:function(){n=t[Symbol.iterator]()},n:function(){var t=n.next();return a=t.done,t},e:function(t){s=!0,i=t},f:function(){try{a||null==n.return||n.return()}finally{if(s)throw i}}}}(this.properties);try{for(v.s();!(b=v.n()).done;){var x=b.value,m=(T[x]||T.default).lerpMethod,w=o.curve[x]||function(t){return t},_=m(a[x],o[x],w(s));_!==this.currentState[x]&&(g[x]=!0,d[x]=_)}}catch(t){v.e(t)}finally{v.f()}this.updateDisplay(d,g,n,e,t),Object.assign(this.currentState,d),this.container.visible=this.container._visible,g.children&&(n.mustResetTree=!0,\"function\"==typeof this.postUpdate&&n.updatedBuffers.push(this)),g.zIndex&&(n.mustResort=!0),g.mask&&(n.maskUpdates[this.id]=d.mask),0!==Object.keys(g).length&&this.parent&&this.parent.notifyChange()}}},{key:\"notifyChange\",value:function(){this.parent&&this.parent.notifyChange()}},{key:\"initDisplay\",value:function(){this.container=new PIXI.Container,this.container.zIndex=this.defaultState.zIndex,this.container.id=this.id,this.container._visible=this.defaultState.visible}},{key:\"updateDisplay\",value:function(t,e,n){this.container.zIndex=t.zIndex,this.container.alpha=t.alpha,(e.x||e.y)&&this.container.position.set(t.x*n.toWorldUnits,t.y*n.toWorldUnits),(e.scaleX||e.scaleY)&&this.container.scale.set(t.scaleX||1e-8,t.scaleY||1e-8),this.container.rotation=t.rotation,this.container._visible=t.visible&&!this.hide,this.container.skew.set(t.skewX,t.skewY)}}])&&A(e.prototype,n),r&&A(e,r),t}();function M(t){return Object.keys(t).length===Object.keys(F.createState()).length}function I(t){return(I=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&\"function\"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?\"symbol\":typeof t})(t)}function Y(t,e,n){return(Y=\"undefined\"!=typeof Reflect&&Reflect.get?Reflect.get:function(t,e,n){var r=function(t,e){for(;!Object.prototype.hasOwnProperty.call(t,e)&&null!==(t=z(t)););return t}(t,e);if(r){var o=Object.getOwnPropertyDescriptor(r,e);return o.get?o.get.call(n):o.value}})(t,e,n||t)}function W(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}function X(t,e,n){return e&&W(t.prototype,e),n&&W(t,n),t}function K(t,e){return(K=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t})(t,e)}function z(t){return(z=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}var L=function(){!function(t,e){if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function\");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&K(t,e)}(e,F);var t=function(t){var e=function(){if(\"undefined\"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if(\"function\"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],(function(){}))),!0}catch(t){return!1}}();return function(){var n,r,o,i=z(t);return r=this,!(o=e?(n=z(this).constructor,Reflect.construct(i,arguments,n)):i.apply(this,arguments))||\"object\"!==I(o)&&\"function\"!=typeof o?function(t){if(void 0!==t)return t;throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\")}(r):o}}(e);function e(){var n;return function(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}(this,e),n=t.call(this),Object.assign(n.defaultState,{fillColor:e.defaultFillColor(),lineWidth:e.defaultLineWidth(),lineColor:e.defaultLineColor(),fillAlpha:e.defaultFillAlpha(),lineAlpha:e.defaultLineAlpha(),blendMode:PIXI.BLEND_MODES.NORMAL}),n}return X(e,null,[{key:\"defaultLineWidth\",value:function(){return 0}},{key:\"defaultFillColor\",value:function(){return 16777215}},{key:\"defaultLineColor\",value:function(){return 0}},{key:\"defaultLineAlpha\",value:function(){return 1}},{key:\"defaultFillAlpha\",value:function(){return 1}}]),X(e,[{key:\"initDisplay\",value:function(){Y(z(e.prototype),\"initDisplay\",this).call(this),this.graphics=new PIXI.Graphics,this.graphics.lineStyle(this.defaultState.lineWidth,this.defaultState.lineColor,this.defaultState.lineAlpha),null!==this.defaultState.fillColor&&this.graphics.beginFill(this.defaultState.fillColor,this.defaultState.fillAlpha)}},{key:\"updateDisplay\",value:function(t,n,r){Y(z(e.prototype),\"updateDisplay\",this).call(this,t,n,r),this.graphics.blendMode=t.blendMode}}]),e}();function G(t){return(G=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&\"function\"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?\"symbol\":typeof t})(t)}function H(t,e,n){return(H=\"undefined\"!=typeof Reflect&&Reflect.get?Reflect.get:function(t,e,n){var r=function(t,e){for(;!Object.prototype.hasOwnProperty.call(t,e)&&null!==(t=V(t)););return t}(t,e);if(r){var o=Object.getOwnPropertyDescriptor(r,e);return o.get?o.get.call(n):o.value}})(t,e,n||t)}function B(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}function N(t,e,n){return e&&B(t.prototype,e),n&&B(t,n),t}function q(t,e){return(q=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t})(t,e)}function V(t){return(V=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}var J=function(){!function(t,e){if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function\");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&q(t,e)}(e,L);var t=function(t){var e=function(){if(\"undefined\"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if(\"function\"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],(function(){}))),!0}catch(t){return!1}}();return function(){var n,r,o,i=V(t);return r=this,!(o=e?(n=V(this).constructor,Reflect.construct(i,arguments,n)):i.apply(this,arguments))||\"object\"!==G(o)&&\"function\"!=typeof o?function(t){if(void 0!==t)return t;throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\")}(r):o}}(e);function e(){var n;return function(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}(this,e),(n=t.call(this)).defaultState.radius=e.defaultRadius(),n}return N(e,null,[{key:\"defaultRadius\",value:function(){return 100}}]),N(e,[{key:\"initDisplay\",value:function(){H(V(e.prototype),\"initDisplay\",this).call(this),this.graphics.drawCircle(0,0,this.defaultState.radius),null!==this.defaultState.fillColor&&this.graphics.endFill()}},{key:\"updateDisplay\",value:function(t,n,r){H(V(e.prototype),\"updateDisplay\",this).call(this,t,n,r),(n.radius||n.lineColor||n.lineWidth||n.fillColor||n.fillAlpha||n.lineAlpha)&&(this.graphics.clear(),null!==t.fillColor&&this.graphics.beginFill(t.fillColor,t.fillAlpha),this.graphics.lineStyle(t.lineWidth,t.lineColor),this.graphics.drawCircle(0,0,t.radius*r.toWorldUnits),null!==t.fillColor&&this.graphics.endFill())}}]),e}();function Q(t){return(Q=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&\"function\"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?\"symbol\":typeof t})(t)}function Z(t,e,n){return(Z=\"undefined\"!=typeof Reflect&&Reflect.get?Reflect.get:function(t,e,n){var r=function(t,e){for(;!Object.prototype.hasOwnProperty.call(t,e)&&null!==(t=rt(t)););return t}(t,e);if(r){var o=Object.getOwnPropertyDescriptor(r,e);return o.get?o.get.call(n):o.value}})(t,e,n||t)}function tt(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}function et(t,e,n){return e&&tt(t.prototype,e),n&&tt(t,n),t}function nt(t,e){return(nt=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t})(t,e)}function rt(t){return(rt=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}var ot=function(){!function(t,e){if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function\");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&nt(t,e)}(e,L);var t=function(t){var e=function(){if(\"undefined\"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if(\"function\"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],(function(){}))),!0}catch(t){return!1}}();return function(){var n,r,o,i=rt(t);return r=this,!(o=e?(n=rt(this).constructor,Reflect.construct(i,arguments,n)):i.apply(this,arguments))||\"object\"!==Q(o)&&\"function\"!=typeof o?function(t){if(void 0!==t)return t;throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\")}(r):o}}(e);function e(){var n;return function(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}(this,e),(n=t.call(this)).defaultState.x2=e.defaultPosition(),n.defaultState.y2=e.defaultPosition(),n}return et(e,null,[{key:\"defaultPosition\",value:function(){return 100}}]),et(e,[{key:\"initDisplay\",value:function(){Z(rt(e.prototype),\"initDisplay\",this).call(this)}},{key:\"updateDisplay\",value:function(t,n,r){Z(rt(e.prototype),\"updateDisplay\",this).call(this,t,n,r),(n.lineWidth||n.lineColor||n.lineAlpha||n.x2||n.y2)&&(this.graphics.clear(),this.graphics.lineStyle(t.lineWidth,t.lineColor,t.lineAlpha),this.graphics.moveTo(0,0),this.graphics.lineTo(-this.container.x+t.x2*r.toWorldUnits,-this.container.y+t.y2*r.toWorldUnits))}}]),e}();function it(t){return(it=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&\"function\"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?\"symbol\":typeof t})(t)}function at(t,e,n){return(at=\"undefined\"!=typeof Reflect&&Reflect.get?Reflect.get:function(t,e,n){var r=function(t,e){for(;!Object.prototype.hasOwnProperty.call(t,e)&&null!==(t=lt(t)););return t}(t,e);if(r){var o=Object.getOwnPropertyDescriptor(r,e);return o.get?o.get.call(n):o.value}})(t,e,n||t)}function st(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}function ct(t,e,n){return e&&st(t.prototype,e),n&&st(t,n),t}function ut(t,e){return(ut=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t})(t,e)}function lt(t){return(lt=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}var ft=function(){!function(t,e){if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function\");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&ut(t,e)}(e,L);var t=function(t){var e=function(){if(\"undefined\"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if(\"function\"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],(function(){}))),!0}catch(t){return!1}}();return function(){var n,r,o,i=lt(t);return r=this,!(o=e?(n=lt(this).constructor,Reflect.construct(i,arguments,n)):i.apply(this,arguments))||\"object\"!==it(o)&&\"function\"!=typeof o?function(t){if(void 0!==t)return t;throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\")}(r):o}}(e);function e(){var n;return function(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}(this,e),n=t.call(this),Object.assign(n.defaultState,{width:e.defaultSideLength(),height:e.defaultSideLength()}),n}return ct(e,null,[{key:\"defaultSideLength\",value:function(){return 100}}]),ct(e,[{key:\"initDisplay\",value:function(){at(lt(e.prototype),\"initDisplay\",this).call(this),this.graphics.drawRect(0,0,this.defaultState.width,this.defaultState.height),this.graphics.endFill()}},{key:\"updateDisplay\",value:function(t,n,r){at(lt(e.prototype),\"updateDisplay\",this).call(this,t,n,r),(n.lineWidth||n.lineColor||n.width||n.height||n.lineAlpha||n.fillColor)&&(this.graphics.clear(),null!==t.fillColor&&this.graphics.beginFill(t.fillColor,t.fillAlpha),this.graphics.lineStyle(t.lineWidth,t.lineColor,t.lineAlpha),this.graphics.drawRect(0,0,t.width*r.toWorldUnits,t.height*r.toWorldUnits),null!==t.fillColor&&this.graphics.endFill())}}]),e}();function yt(t){return(yt=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&\"function\"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?\"symbol\":typeof t})(t)}function pt(t,e,n){return(pt=\"undefined\"!=typeof Reflect&&Reflect.get?Reflect.get:function(t,e,n){var r=function(t,e){for(;!Object.prototype.hasOwnProperty.call(t,e)&&null!==(t=dt(t)););return t}(t,e);if(r){var o=Object.getOwnPropertyDescriptor(r,e);return o.get?o.get.call(n):o.value}})(t,e,n||t)}function ht(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}function bt(t,e,n){return e&&ht(t.prototype,e),n&&ht(t,n),t}function gt(t,e){return(gt=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t})(t,e)}function dt(t){return(dt=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}var vt=function(){!function(t,e){if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function\");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&gt(t,e)}(e,F);var t=function(t){var e=function(){if(\"undefined\"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if(\"function\"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],(function(){}))),!0}catch(t){return!1}}();return function(){var n,r,o,i=dt(t);return r=this,!(o=e?(n=dt(this).constructor,Reflect.construct(i,arguments,n)):i.apply(this,arguments))||\"object\"!==yt(o)&&\"function\"!=typeof o?function(t){if(void 0!==t)return t;throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\")}(r):o}}(e);function e(){var n;return function(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}(this,e),n=t.call(this),Object.assign(n.defaultState,{anchorX:e.defaultAnchor(),anchorY:e.defaultAnchor(),blendMode:PIXI.BLEND_MODES.NORMAL,tint:16777215}),n}return bt(e,null,[{key:\"defaultAnchor\",value:function(){return 0}}]),bt(e,[{key:\"initDisplay\",value:function(){pt(dt(e.prototype),\"initDisplay\",this).call(this)}},{key:\"updateDisplay\",value:function(t,n,r){pt(dt(e.prototype),\"updateDisplay\",this).call(this,t,n,r),this.graphics.anchor.set(t.anchorX,t.anchorY),this.graphics.blendMode=t.blendMode,this.graphics.tint=t.tint}}]),e}();function xt(t){return(xt=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&\"function\"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?\"symbol\":typeof t})(t)}function mt(t){var e=\"function\"==typeof Map?new Map:void 0;return(mt=function(t){if(null===t||(n=t,-1===Function.toString.call(n).indexOf(\"[native code]\")))return t;var n;if(\"function\"!=typeof t)throw new TypeError(\"Super expression must either be null or a function\");if(void 0!==e){if(e.has(t))return e.get(t);e.set(t,r)}function r(){return wt(t,arguments,Ct(this).constructor)}return r.prototype=Object.create(t.prototype,{constructor:{value:r,enumerable:!1,writable:!0,configurable:!0}}),St(r,t)})(t)}function wt(t,e,n){return(wt=_t()?Reflect.construct:function(t,e,n){var r=[null];r.push.apply(r,e);var o=new(Function.bind.apply(t,r));return n&&St(o,n.prototype),o}).apply(null,arguments)}function _t(){if(\"undefined\"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if(\"function\"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],(function(){}))),!0}catch(t){return!1}}function St(t,e){return(St=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t})(t,e)}function Ct(t){return(Ct=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}var Ot=function(){!function(t,e){if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function\");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&St(t,e)}(e,mt(Error));var t=function(t){var e=_t();return function(){var n,r,o,i=Ct(t);return r=this,!(o=e?(n=Ct(this).constructor,Reflect.construct(i,arguments,n)):i.apply(this,arguments))||\"object\"!==xt(o)&&\"function\"!=typeof o?function(t){if(void 0!==t)return t;throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\")}(r):o}}(e);function e(n,r){var o;return function(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}(this,e),(o=t.call(this,'Could not find image: \"'+n+'\". Make sure it is in your assets folder and is spelled correctly.')).image=n,o.cause=r,o.name=\"MissingImageError\",o}return e}();function Ut(t){return(Ut=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&\"function\"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?\"symbol\":typeof t})(t)}function kt(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}function Tt(t,e,n){return(Tt=\"undefined\"!=typeof Reflect&&Reflect.get?Reflect.get:function(t,e,n){var r=function(t,e){for(;!Object.prototype.hasOwnProperty.call(t,e)&&null!==(t=Pt(t)););return t}(t,e);if(r){var o=Object.getOwnPropertyDescriptor(r,e);return o.get?o.get.call(n):o.value}})(t,e,n||t)}function Rt(t,e){return(Rt=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t})(t,e)}function Pt(t){return(Pt=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}var Et=function(){!function(t,e){if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function\");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&Rt(t,e)}(r,vt);var t,e,n=function(t){var e=function(){if(\"undefined\"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if(\"function\"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],(function(){}))),!0}catch(t){return!1}}();return function(){var n,r,o,i=Pt(t);return r=this,!(o=e?(n=Pt(this).constructor,Reflect.construct(i,arguments,n)):i.apply(this,arguments))||\"object\"!==Ut(o)&&\"function\"!=typeof o?function(t){if(void 0!==t)return t;throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\")}(r):o}}(r);function r(){var t;return function(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}(this,r),t=n.call(this),Object.assign(t.defaultState,{image:null,baseWidth:null,baseHeight:null,scaleMode:\"LINEAR\"}),t.missingTextures={},t}return t=r,(e=[{key:\"updateDisplay\",value:function(t,e,n){if(Tt(Pt(r.prototype),\"updateDisplay\",this).call(this,t,e,n),e.image)try{null!==t.image?this.graphics.texture=PIXI.Texture.fromFrame(t.image):this.graphics.texture=PIXI.Texture.EMPTY,this.graphics.texture.baseTexture.scaleMode=PIXI.SCALE_MODES[t.scaleMode]}catch(e){this.missingTextures[t.image]||(this.missingTextures[t.image]=!0,l.push(new Ot(t.image,e)))}e.baseWidth&&(this.graphics.width=t.baseWidth),e.baseHeight&&(this.graphics.height=t.baseHeight)}}])&&kt(t.prototype,e),r}();function jt(t){return(jt=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&\"function\"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?\"symbol\":typeof t})(t)}function Dt(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}function At(t,e,n){return(At=\"undefined\"!=typeof Reflect&&Reflect.get?Reflect.get:function(t,e,n){var r=function(t,e){for(;!Object.prototype.hasOwnProperty.call(t,e)&&null!==(t=Mt(t)););return t}(t,e);if(r){var o=Object.getOwnPropertyDescriptor(r,e);return o.get?o.get.call(n):o.value}})(t,e,n||t)}function Ft(t,e){return(Ft=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t})(t,e)}function Mt(t){return(Mt=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}var It=function(){!function(t,e){if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function\");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&Ft(t,e)}(r,Et);var t,e,n=function(t){var e=function(){if(\"undefined\"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if(\"function\"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],(function(){}))),!0}catch(t){return!1}}();return function(){var n,r,o,i=Mt(t);return r=this,!(o=e?(n=Mt(this).constructor,Reflect.construct(i,arguments,n)):i.apply(this,arguments))||\"object\"!==jt(o)&&\"function\"!=typeof o?function(t){if(void 0!==t)return t;throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\")}(r):o}}(r);function r(){return function(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}(this,r),n.apply(this,arguments)}return t=r,(e=[{key:\"initDisplay\",value:function(){At(Mt(r.prototype),\"initDisplay\",this).call(this),null===this.defaultState.image?this.graphics=new PIXI.Sprite(PIXI.Texture.EMPTY):this.graphics=PIXI.Sprite.fromFrame(this.defaultState.image)}}])&&Dt(t.prototype,e),r}();function Yt(t,e){if(t.width>e)for(;3<t.text.length&&t.width>e;)t.text=t.text.slice(0,-4)+\"...\"}function Wt(t){return(Wt=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&\"function\"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?\"symbol\":typeof t})(t)}function Xt(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}function Kt(t,e,n){return(Kt=\"undefined\"!=typeof Reflect&&Reflect.get?Reflect.get:function(t,e,n){var r=function(t,e){for(;!Object.prototype.hasOwnProperty.call(t,e)&&null!==(t=Lt(t)););return t}(t,e);if(r){var o=Object.getOwnPropertyDescriptor(r,e);return o.get?o.get.call(n):o.value}})(t,e,n||t)}function zt(t,e){return(zt=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t})(t,e)}function Lt(t){return(Lt=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}var Gt=function(){!function(t,e){if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function\");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&zt(t,e)}(r,vt);var t,e,n=function(t){var e=function(){if(\"undefined\"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if(\"function\"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],(function(){}))),!0}catch(t){return!1}}();return function(){var n,r,o,i=Lt(t);return r=this,!(o=e?(n=Lt(this).constructor,Reflect.construct(i,arguments,n)):i.apply(this,arguments))||\"object\"!==Wt(o)&&\"function\"!=typeof o?function(t){if(void 0!==t)return t;throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\")}(r):o}}(r);function r(){var t;return function(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}(this,r),t=n.call(this),Object.assign(t.defaultState,{text:\"\",textAlign:\"left\",strokeColor:0,strokeThickness:0,fillColor:0,fontSize:26,fontFamily:\"Lato\",fontWeight:\"normal\",maxWidth:0}),t}return t=r,(e=[{key:\"initDisplay\",value:function(){Kt(Lt(r.prototype),\"initDisplay\",this).call(this),this.graphics=new PIXI.Text(this.defaultState.text,{align:this.defaultState.textAlign,fontSize:this.defaultState.fontSize+\"px\",fontFamily:this.defaultState.fontFamily,fill:this.defaultState.fillColor})}},{key:\"updateDisplay\",value:function(t,e,n){Kt(Lt(r.prototype),\"updateDisplay\",this).call(this,t,e,n),this.graphics.style.align=t.textAlign,this.graphics.style.stroke=t.strokeColor,this.graphics.style.strokeThickness=t.strokeThickness,this.graphics.style.fill=t.fillColor,this.graphics.style.fontSize=t.fontSize||1,this.graphics.style.fontFamily=t.fontFamily,this.graphics.style.fontWeight=t.fontWeight,(e.text||e.strokeThickness||e.fontSize||e.fontFamily||e.fontWeight||e.maxWidth||e.maxWidth)&&(this.graphics.text=t.text,t.maxWidth&&Yt(this.graphics,t.maxWidth))}}])&&Xt(t.prototype,e),r}();function Ht(t){return(Ht=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&\"function\"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?\"symbol\":typeof t})(t)}function Bt(t){var e=\"function\"==typeof Map?new Map:void 0;return(Bt=function(t){if(null===t||(n=t,-1===Function.toString.call(n).indexOf(\"[native code]\")))return t;var n;if(\"function\"!=typeof t)throw new TypeError(\"Super expression must either be null or a function\");if(void 0!==e){if(e.has(t))return e.get(t);e.set(t,r)}function r(){return Nt(t,arguments,Vt(this).constructor)}return r.prototype=Object.create(t.prototype,{constructor:{value:r,enumerable:!1,writable:!0,configurable:!0}}),qt(r,t)})(t)}function Nt(t,e,n){return(Nt=$t()?Reflect.construct:function(t,e,n){var r=[null];r.push.apply(r,e);var o=new(Function.bind.apply(t,r));return n&&qt(o,n.prototype),o}).apply(null,arguments)}function $t(){if(\"undefined\"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if(\"function\"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],(function(){}))),!0}catch(t){return!1}}function qt(t,e){return(qt=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t})(t,e)}function Vt(t){return(Vt=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}var Jt=function(){!function(t,e){if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function\");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&qt(t,e)}(e,Bt(Error));var t=function(t){var e=$t();return function(){var n,r,o,i=Vt(t);return r=this,!(o=e?(n=Vt(this).constructor,Reflect.construct(i,arguments,n)):i.apply(this,arguments))||\"object\"!==Ht(o)&&\"function\"!=typeof o?function(t){if(void 0!==t)return t;throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\")}(r):o}}(e);function e(n,r){var o;return function(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}(this,e),(o=t.call(this,'Could not find font: \"'+n+'\". Make sure it is in your assets folder and is spelled correctly.')).font=n,o.cause=r,o.name=\"MissingBitmapFontError\",o}return e}();function Qt(t){return(Qt=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&\"function\"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?\"symbol\":typeof t})(t)}function Zt(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}function te(t,e,n){return(te=\"undefined\"!=typeof Reflect&&Reflect.get?Reflect.get:function(t,e,n){var r=function(t,e){for(;!Object.prototype.hasOwnProperty.call(t,e)&&null!==(t=ne(t)););return t}(t,e);if(r){var o=Object.getOwnPropertyDescriptor(r,e);return o.get?o.get.call(n):o.value}})(t,e,n||t)}function ee(t,e){return(ee=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t})(t,e)}function ne(t){return(ne=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}var re=function(){!function(t,e){if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function\");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&ee(t,e)}(r,F);var t,e,n=function(t){var e=function(){if(\"undefined\"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if(\"function\"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],(function(){}))),!0}catch(t){return!1}}();return function(){var n,r,o,i=ne(t);return r=this,!(o=e?(n=ne(this).constructor,Reflect.construct(i,arguments,n)):i.apply(this,arguments))||\"object\"!==Qt(o)&&\"function\"!=typeof o?function(t){if(void 0!==t)return t;throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\")}(r):o}}(r);function r(){var t;return function(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}(this,r),t=n.call(this),Object.assign(t.defaultState,{text:\"\",textAlign:\"left\",fontSize:26,fontFamily:null,anchorX:vt.defaultAnchor(),anchorY:vt.defaultAnchor(),blendMode:PIXI.BLEND_MODES.NORMAL,tint:16777215,maxWidth:0}),t.missingFonts={},t}return t=r,(e=[{key:\"initDisplay\",value:function(){te(ne(r.prototype),\"initDisplay\",this).call(this),this.graphics=new PIXI.Container}},{key:\"updateDisplay\",value:function(t,e,n){te(ne(r.prototype),\"updateDisplay\",this).call(this,t,e,n),null!==t.fontFamily?PIXI.extras.BitmapText.fonts[t.fontFamily]?(0===this.graphics.children.length?(this.displayed=new PIXI.extras.BitmapText(\"\",{font:{size:t.fontSize||1,name:t.fontFamily}}),this.graphics.addChild(this.displayed)):this.displayed.font={size:t.fontSize||1,name:t.fontFamily},this.displayed.anchor.set(t.anchorX,t.anchorY),this.displayed.blendMode=t.blendMode,this.displayed.tint=t.tint,this.displayed.align=t.textAlign,(e.text||e.maxWidth||e.fontSize||e.fontFamily)&&(this.displayed.text=t.text,t.maxWidth&&Yt(this.displayed,t.maxWidth))):(this.missingFonts[t.fontFamily]||(this.missingFonts[t.fontFamily]=!0,l.push(new Jt(t.fontFamily))),this.graphics.removeChildren()):this.graphics.removeChildren()}}])&&Zt(t.prototype,e),r}();function oe(t){return(oe=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&\"function\"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?\"symbol\":typeof t})(t)}function ie(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}function ae(t,e,n){return(ae=\"undefined\"!=typeof Reflect&&Reflect.get?Reflect.get:function(t,e,n){var r=function(t,e){for(;!Object.prototype.hasOwnProperty.call(t,e)&&null!==(t=ce(t)););return t}(t,e);if(r){var o=Object.getOwnPropertyDescriptor(r,e);return o.get?o.get.call(n):o.value}})(t,e,n||t)}function se(t,e){return(se=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t})(t,e)}function ce(t){return(ce=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}var ue=function(){!function(t,e){if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function\");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&se(t,e)}(r,F);var t,e,n=function(t){var e=function(){if(\"undefined\"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if(\"function\"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],(function(){}))),!0}catch(t){return!1}}();return function(){var n,r,o,i=ce(t);return r=this,!(o=e?(n=ce(this).constructor,Reflect.construct(i,arguments,n)):i.apply(this,arguments))||\"object\"!==oe(o)&&\"function\"!=typeof o?function(t){if(void 0!==t)return t;throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\")}(r):o}}(r);function r(){var t;return function(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}(this,r),t=n.call(this),Object.assign(t.defaultState,{children:[]}),t}return t=r,(e=[{key:\"initDisplay\",value:function(){ae(ce(r.prototype),\"initDisplay\",this).call(this),this.graphics=new PIXI.Container}},{key:\"updateDisplay\",value:function(t,e,n){ae(ce(r.prototype),\"updateDisplay\",this).call(this,t,e,n)}},{key:\"childrenContainer\",get:function(){return this.graphics}}])&&ie(t.prototype,e),r}();function le(t){return(le=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&\"function\"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?\"symbol\":typeof t})(t)}function fe(t,e){return(fe=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t})(t,e)}function ye(t){return(ye=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}var pe=function(){!function(t,e){if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function\");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&fe(t,e)}(e,ue);var t=function(t){var e=function(){if(\"undefined\"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if(\"function\"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],(function(){}))),!0}catch(t){return!1}}();return function(){var n,r,o,i=ye(t);return r=this,!(o=e?(n=ye(this).constructor,Reflect.construct(i,arguments,n)):i.apply(this,arguments))||\"object\"!==le(o)&&\"function\"!=typeof o?function(t){if(void 0!==t)return t;throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\")}(r):o}}(e);function e(){return function(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}(this,e),t.apply(this,arguments)}return e}(),he=null,be=[];function ge(t){return(ge=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&\"function\"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?\"symbol\":typeof t})(t)}function de(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}function ve(t,e,n){return(ve=\"undefined\"!=typeof Reflect&&Reflect.get?Reflect.get:function(t,e,n){var r=function(t,e){for(;!Object.prototype.hasOwnProperty.call(t,e)&&null!==(t=me(t)););return t}(t,e);if(r){var o=Object.getOwnPropertyDescriptor(r,e);return o.get?o.get.call(n):o.value}})(t,e,n||t)}function xe(t,e){return(xe=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t})(t,e)}function me(t){return(me=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}var we=function(){!function(t,e){if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function\");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&xe(t,e)}(r,ue);var t,e,n=function(t){var e=function(){if(\"undefined\"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if(\"function\"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],(function(){}))),!0}catch(t){return!1}}();return function(){var n,r,o,i=me(t);return r=this,!(o=e?(n=me(this).constructor,Reflect.construct(i,arguments,n)):i.apply(this,arguments))||\"object\"!==ge(o)&&\"function\"!=typeof o?function(t){if(void 0!==t)return t;throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\")}(r):o}}(r);function r(){return function(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}(this,r),n.apply(this,arguments)}return t=r,(e=[{key:\"initDisplay\",value:function(){var t;ve(me(r.prototype),\"initDisplay\",this).call(this),this.gameTexture=PIXI.RenderTexture.create(1920,1080),t=this.gameTexture,be.push(t),this.graphics=new PIXI.Sprite(this.gameTexture),this.buffer=new PIXI.Container,this.needsRender=!0}},{key:\"postUpdate\",value:function(){this.needsRender&&(he.render(this.buffer,this.gameTexture),this.needsRender=!1)}},{key:\"notifyChange\",value:function(){this.needsRender=!0,this.parent&&this.parent.notifyChange()}},{key:\"childrenContainer\",get:function(){return this.buffer}}])&&de(t.prototype,e),r}();function _e(t){return(_e=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&\"function\"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?\"symbol\":typeof t})(t)}function Se(t,e){var n,r=Object.keys(t);return Object.getOwnPropertySymbols&&(n=Object.getOwnPropertySymbols(t),e&&(n=n.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),r.push.apply(r,n)),r}function Ce(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?Se(Object(n),!0).forEach((function(e){var r,o,i;r=t,i=n[o=e],o in r?Object.defineProperty(r,o,{value:i,enumerable:!0,configurable:!0,writable:!0}):r[o]=i})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):Se(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}function Oe(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}function Ue(t,e,n){return(Ue=\"undefined\"!=typeof Reflect&&Reflect.get?Reflect.get:function(t,e,n){var r=function(t,e){for(;!Object.prototype.hasOwnProperty.call(t,e)&&null!==(t=Te(t)););return t}(t,e);if(r){var o=Object.getOwnPropertyDescriptor(r,e);return o.get?o.get.call(n):o.value}})(t,e,n||t)}function ke(t,e){return(ke=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t})(t,e)}function Te(t){return(Te=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}var Re=function(){!function(t,e){if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function\");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&ke(t,e)}(r,vt);var t,e,n=function(t){var e=function(){if(\"undefined\"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if(\"function\"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],(function(){}))),!0}catch(t){return!1}}();return function(){var n,r,o,i=Te(t);return r=this,!(o=e?(n=Te(this).constructor,Reflect.construct(i,arguments,n)):i.apply(this,arguments))||\"object\"!==_e(o)&&\"function\"!=typeof o?function(t){if(void 0!==t)return t;throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\")}(r):o}}(r);function r(){var t;return function(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}(this,r),t=n.call(this),Object.assign(t.defaultState,{images:\"\",loop:!1,duration:1e3,playing:!0,restarted:null,animationProgress:0,date:0}),t}return t=r,(e=[{key:\"initDisplay\",value:function(){Ue(Te(r.prototype),\"initDisplay\",this).call(this),this.graphics=new PIXI.Sprite(PIXI.Texture.EMPTY)}},{key:\"addState\",value:function(t,e,n,o){Ue(Te(r.prototype),\"addState\",this).call(this,t,e,n);var i=this.states[n].find((function(e){return e.t===t})),a=o.date+o.frameDuration*t;i.date=a}},{key:\"updateDisplay\",value:function(t,e,n,o,i){if(Ue(Te(r.prototype),\"updateDisplay\",this).call(this,t,e,n),t.images){var a=t.images.split(\",\");if(0<=t.animationProgress){var s=o.date+o.frameDuration*i,c=Ce(Ce({},t),{},{date:s});this.computeAnimationProgressTime(t,c);var u=Math.floor(a.length*c.animationProgress),f=t.loop?a[u%a.length]:a[u]||a[a.length-1];try{this.graphics.texture=PIXI.Texture.fromFrame(f)}catch(t){l.push(new Ot(f,t))}}}else this.graphics.texture=PIXI.Texture.EMPTY}},{key:\"computeAnimationProgressTime\",value:function(t,e){e.restarted&&e.restarted.date===e.date?e.animationProgress=0:(e.animationProgress=t.animationProgress,t.playing&&(e.animationProgress+=(e.date-t.date)/t.duration))}}])&&Oe(t.prototype,e),r}();function Pe(t){return(Pe=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&\"function\"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?\"symbol\":typeof t})(t)}function Ee(t,e,n){return(Ee=\"undefined\"!=typeof Reflect&&Reflect.get?Reflect.get:function(t,e,n){var r=function(t,e){for(;!Object.prototype.hasOwnProperty.call(t,e)&&null!==(t=Fe(t)););return t}(t,e);if(r){var o=Object.getOwnPropertyDescriptor(r,e);return o.get?o.get.call(n):o.value}})(t,e,n||t)}function je(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}function De(t,e,n){return e&&je(t.prototype,e),n&&je(t,n),t}function Ae(t,e){return(Ae=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t})(t,e)}function Fe(t){return(Fe=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}var Me=function(){!function(t,e){if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function\");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&Ae(t,e)}(e,L);var t=function(t){var e=function(){if(\"undefined\"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if(\"function\"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],(function(){}))),!0}catch(t){return!1}}();return function(){var n,r,o,i=Fe(t);return r=this,!(o=e?(n=Fe(this).constructor,Reflect.construct(i,arguments,n)):i.apply(this,arguments))||\"object\"!==Pe(o)&&\"function\"!=typeof o?function(t){if(void 0!==t)return t;throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\")}(r):o}}(e);function e(){var n;return function(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}(this,e),n=t.call(this),Object.assign(n.defaultState,{width:e.defaultSideLength(),height:e.defaultSideLength(),radius:e.defaultRadius()}),n}return De(e,null,[{key:\"defaultSideLength\",value:function(){return 100}},{key:\"defaultRadius\",value:function(){return 20}}]),De(e,[{key:\"initDisplay\",value:function(){Ee(Fe(e.prototype),\"initDisplay\",this).call(this),this.graphics.drawRoundedRect(0,0,this.defaultState.width,this.defaultState.height,this.defaultState.radius),this.graphics.endFill()}},{key:\"updateDisplay\",value:function(t,n,r){Ee(Fe(e.prototype),\"updateDisplay\",this).call(this,t,n,r),(n.lineWidth||n.lineColor||n.lineAlpha||n.fillColor||n.radius||n.height||n.width)&&(this.graphics.clear(),null!==t.fillColor&&this.graphics.beginFill(t.fillColor,t.fillAlpha),this.graphics.lineStyle(t.lineWidth,t.lineColor,t.lineAlpha),this.graphics.drawRoundedRect(0,0,t.width*r.toWorldUnits,t.height*r.toWorldUnits,t.radius*r.toWorldUnits),null!==t.fillColor&&this.graphics.endFill())}}]),e}();function Ie(t){return(Ie=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&\"function\"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?\"symbol\":typeof t})(t)}function Ye(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}function We(t,e,n){return(We=\"undefined\"!=typeof Reflect&&Reflect.get?Reflect.get:function(t,e,n){var r=function(t,e){for(;!Object.prototype.hasOwnProperty.call(t,e)&&null!==(t=Ke(t)););return t}(t,e);if(r){var o=Object.getOwnPropertyDescriptor(r,e);return o.get?o.get.call(n):o.value}})(t,e,n||t)}function Xe(t,e){return(Xe=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t})(t,e)}function Ke(t){return(Ke=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}var ze=function(){!function(t,e){if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function\");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&Xe(t,e)}(r,L);var t,e,n=function(t){var e=function(){if(\"undefined\"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if(\"function\"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],(function(){}))),!0}catch(t){return!1}}();return function(){var n,r,o,i=Ke(t);return r=this,!(o=e?(n=Ke(this).constructor,Reflect.construct(i,arguments,n)):i.apply(this,arguments))||\"object\"!==Ie(o)&&\"function\"!=typeof o?function(t){if(void 0!==t)return t;throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\")}(r):o}}(r);function r(){var t;return function(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}(this,r),t=n.call(this),Object.assign(t.defaultState,{points:[]}),t}return t=r,(e=[{key:\"initDisplay\",value:function(){We(Ke(r.prototype),\"initDisplay\",this).call(this),this.graphics.endFill()}},{key:\"updateDisplay\",value:function(t,e,n){We(Ke(r.prototype),\"updateDisplay\",this).call(this,t,e,n),(e.lineWidth||e.lineColor||e.lineAlpha||e.fillColor||e.points)&&(this.graphics.clear(),null!==t.fillColor&&this.graphics.beginFill(t.fillColor,t.fillAlpha),this.graphics.lineStyle(t.lineWidth,t.lineColor,t.lineAlpha),this.graphics.drawPolygon(t.points.map((function(t){return t*n.toWorldUnits}))),null!==t.fillColor&&this.graphics.endFill())}}])&&Ye(t.prototype,e),r}();function Le(t){return(Le=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&\"function\"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?\"symbol\":typeof t})(t)}function Ge(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}function He(t,e,n){return(He=\"undefined\"!=typeof Reflect&&Reflect.get?Reflect.get:function(t,e,n){var r=function(t,e){for(;!Object.prototype.hasOwnProperty.call(t,e)&&null!==(t=Ne(t)););return t}(t,e);if(r){var o=Object.getOwnPropertyDescriptor(r,e);return o.get?o.get.call(n):o.value}})(t,e,n||t)}function Be(t,e){return(Be=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t})(t,e)}function Ne(t){return(Ne=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}var $e=function(){!function(t,e){if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function\");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&Be(t,e)}(r,Et);var t,e,n=function(t){var e=function(){if(\"undefined\"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if(\"function\"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],(function(){}))),!0}catch(t){return!1}}();return function(){var n,r,o,i=Ne(t);return r=this,!(o=e?(n=Ne(this).constructor,Reflect.construct(i,arguments,n)):i.apply(this,arguments))||\"object\"!==Le(o)&&\"function\"!=typeof o?function(t){if(void 0!==t)return t;throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\")}(r):o}}(r);function r(){var t;return function(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}(this,r),t=n.call(this),Object.assign(t.defaultState,{tileX:0,tileY:0,tileScaleX:1,tileScaleY:1}),t}return t=r,(e=[{key:\"initDisplay\",value:function(){He(Ne(r.prototype),\"initDisplay\",this).call(this),this.graphics=new PIXI.extras.TilingSprite(PIXI.Texture.EMPTY)}},{key:\"updateDisplay\",value:function(t,e,n){He(Ne(r.prototype),\"updateDisplay\",this).call(this,t,e,n),this.graphics.tilePosition.x=t.tileX,this.graphics.tilePosition.y=t.tileY,this.graphics.tileScale.x=t.tileScaleX,this.graphics.tileScale.y=t.tileScaleY}}])&&Ge(t.prototype,e),r}();function qe(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}var Ve=function(){function t(){!function(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}(this,t)}var e,n;return e=t,n=[{key:\"create\",value:function(t){var e={C:J,R:ft,L:ot,S:It,T:Gt,X:re,G:pe,B:we,A:Re,K:Me,P:ze,D:$e}[t];if(!e)throw new Error(\"Exception: entity type not found: \"+t);return new e}}],null&&qe(e.prototype,null),n&&qe(e,n),t}();function Je(t){var e=1.70158,n=0,r=1;return 0===t?0:1==(t/=1)?1:(n=n||.3,e=r<Math.abs(1)?(r=1,n/4):n/(2*Math.PI)*Math.asin(1/r),r*Math.pow(2,-10*t)*Math.sin((t-e)*(2*Math.PI)/n)+1)}function Qe(t){return t<.5?2*t*t:(4-2*t)*t-1}function Ze(t){return Math.pow(t,3)}function tn(t){return 1+Math.pow(t-1,3)}function en(t,e){(null==e||e>t.length)&&(e=t.length);for(var n=0,r=new Array(e);n<e;n++)r[n]=t[n];return r}function nn(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}function rn(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}function on(t,e,n){return e&&rn(t.prototype,e),n&&rn(t,n),t}var an={r:\"rotation\",R:\"radius\",X:\"x2\",Y:\"y2\",w:\"width\",h:\"height\",t:\"tint\",f:\"fillColor\",F:\"fillAlpha\",c:\"lineColor\",W:\"lineWidth\",A:\"lineAlpha\",a:\"alpha\",i:\"image\",S:\"strokeThickness\",sc:\"strokeColor\",ff:\"fontFamily\",s:\"fontSize\",fw:\"fontWeight\",T:\"text\",ta:\"textAlign\",ch:\"children\",sx:\"scaleX\",sy:\"scaleY\",ax:\"anchorX\",ay:\"anchorY\",kx:\"skewX\",ky:\"skewY\",v:\"visible\",z:\"zIndex\",b:\"blendMode\",I:\"images\",rs:\"restarted\",p:\"playing\",l:\"loop\",d:\"duration\",bw:\"baseWidth\",bh:\"baseHeight\",ps:\"points\",tx:\"tileX\",ty:\"tileY\",tsx:\"tileScaleX\",tsy:\"tileScaleY\",sm:\"scaleMode\"},sn=function(){function t(e,n){nn(this,t),this.id=++n.instanceCount,this.type=e[0]}return on(t,[{key:\"apply\",value:function(t){var e=Ve.create(this.type);e.id=this.id,t.set(this.id,e)}}]),t}(),cn=function(){function t(e,n){var o=function(t,e){return function(t){if(Array.isArray(t))return t}(t)||function(t,e){if(\"undefined\"!=typeof Symbol&&Symbol.iterator in Object(t)){var n=[],r=!0,o=!1,i=void 0;try{for(var a,s=t[Symbol.iterator]();!(r=(a=s.next()).done)&&(n.push(a.value),!e||n.length!==e);r=!0);}catch(t){o=!0,i=t}finally{try{r||null==s.return||s.return()}finally{if(o)throw i}}return n}}(t,e)||function(t,e){if(t){if(\"string\"==typeof t)return en(t,e);var n=Object.prototype.toString.call(t).slice(8,-1);return\"Object\"===n&&t.constructor&&(n=t.constructor.name),\"Map\"===n||\"Set\"===n?Array.from(t):\"Arguments\"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)?en(t,e):void 0}}(t,e)||function(){throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\")}()}(e,8),i=o[0],a=o[1],s=o[2],c=o[3],u=o[4],l=o[5],f=o[6],y=o[7];nn(this,t),this.loader=new PIXI.loaders.Loader,\"0\"===s&&(s=PIXI.utils.TextureCache[a].width),\"0\"===c&&(c=PIXI.utils.TextureCache[a].height);for(var p=0<y?y:f,h={frames:{},meta:{image:(r.baseUrl?r.baseUrl:\"\")+r.images[a]}},b=0;b<f;b++){var g=1<f?i+b:i;h.frames[g]={frame:{x:s*l+b%p*s,y:c*u+Math.floor(b/p)*c,w:s,h:c},sourceSize:{w:s,h:c},rotated:!1,trimmed:!1}}var d=\"data:text/json;charset=UTF-8,\"+JSON.stringify(h);PIXI.utils.TextureCache[d+\"_image\"]||this.loader.add(d,{crossOrigin:!0})}return on(t,[{key:\"apply\",value:function(){var t=this;if(0<Object.keys(this.loader.resources).length)return new Promise((function(e){t.loader.load(),t.loader.on(\"complete\",e)}))}}]),t}();function un(t){return function(t){if(Array.isArray(t))return ln(t)}(t)||function(t){if(\"undefined\"!=typeof Symbol&&Symbol.iterator in Object(t))return Array.from(t)}(t)||function(t,e){if(t){if(\"string\"==typeof t)return ln(t,e);var n=Object.prototype.toString.call(t).slice(8,-1);return\"Object\"===n&&t.constructor&&(n=t.constructor.name),\"Map\"===n||\"Set\"===n?Array.from(t):\"Arguments\"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)?ln(t,e):void 0}}(t)||function(){throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\")}()}function ln(t,e){(null==e||e>t.length)&&(e=t.length);for(var n=0,r=new Array(e);n<e;n++)r[n]=t[n];return r}function fn(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}var yn={C:sn,U:function(){function t(e,n,r){nn(this,t),this.id=+e[0],this.t=+e[1],this.params={},this.curve={};for(var o=2;o<e.length;){var i=an[e[o]]||e[o],a=T[i]||T.default,s=a.type(e[o+1]);\"function\"==typeof a.convert&&(s=a.convert(s,n,r,this.t));var c=t.curves[e[o+2]];this.params[i]=s,o+=2,c&&(this.curve[i]=c,o+=1)}}return on(t,null,[{key:\"curves\",get:function(){return{_:function(t){return t<1?0:1},\"\":Qe,\"\":Ze,\"\":tn,\"~\":Je,\"\":function(){return 1}}}}]),on(t,[{key:\"apply\",value:function(t,e){var n=t.get(this.id);n.addState(this.t,{values:this.params,curve:this.curve},e.number,e),n.stateAdded=!0}}]),t}(),L:cn};function pn(t,e){for(var n=[],r=\"\",o=0,i=\"\",a=!1;o<t.length;){var s=t[o++];s===e?a?r+=s:(n.push(r),r=\"\"):\"'\"===s&&\"\\\\\"!==i?(a=!a,r+=s):\"\\\\\"===i?r+=\"'\"===s?\"\\\\'\":\"\\\\\"+s:\"\\\\\"!==s&&(r+=s),i=s}return n.push(r),n}var hn=function(){function t(){!function(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}(this,t)}var e,n;return e=t,n=[{key:\"parse\",value:function(t,e,n){var r=[],o=pn(t,\"\\n\");for(var i in o){var a=yn[o[i][0]];if(!a)throw new Error(\"Unrecognised command : \"+o[i][0]);r=[].concat(un(r),un(function(t,e,n,r){var o=pn(e,\";\"),i=[];return o.forEach((function(e){return i.push(new t(pn(e,\" \"),n,r))})),i}(a,o[i].slice(1),e,n)))}return r}}],null&&fn(e.prototype,null),n&&fn(e,n),t}();function bn(t,e){(null==e||e>t.length)&&(e=t.length);for(var n=0,r=new Array(e);n<e;n++)r[n]=t[n];return r}function gn(t,e){var n,r=Object.keys(t);return Object.getOwnPropertySymbols&&(n=Object.getOwnPropertySymbols(t),e&&(n=n.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),r.push.apply(r,n)),r}function dn(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?gn(Object(n),!0).forEach((function(e){var r,o,i;r=t,i=n[o=e],o in r?Object.defineProperty(r,o,{value:i,enumerable:!0,configurable:!0,writable:!0}):r[o]=i})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):gn(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}function vn(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}var xn={},mn=function(){function t(e){!function(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}(this,t),this.entities=new Map,this.frames=[],this.loadingAssets=0,this.extrapolationMap={},this.globalData={toWorldUnits:1,mustResetTree:!0,mustResort:!0,maskUpdates:{},updatedBuffers:[],players:[],instanceCount:0},xn.entities=this.entities}var e,n,r;return e=t,r=[{key:\"name\",get:function(){return\"entitymodule\"}}],(n=[{key:\"handleFrameData\",value:function(t,e){var n,r=this;!e||(n=hn.parse(e,this.globalData,t))&&n.forEach((function(e){var n=e.apply(r.entities,t);n&&(r.loadingAssets++,n.then((function(){r.loadingAssets--})))}));var o=dn({},t);return o.previous=this.frames[this.frames.length-1]||o,this.extrapolate(o),o!==o.previous&&(o.previous.next=o),this.frames.push(o),o}},{key:\"lastElementOf\",value:function(t){return t[t.length-1]}},{key:\"extrapolate\",value:function(t){var e=this,n=t.number,r=t.previous.number;this.entities.forEach((function(o){var i,a;o.stateAdded&&(o.stateAdded=!1,o.states[n]||(o.states[n]=[]),e.extrapolationMap[o.id]||(e.extrapolationMap[o.id]=dn({},o.defaultState)),(i=o.states[n]).sort((function(t,e){return t.t-e.t})),i.length&&1===e.lastElementOf(i).t||o.addState(1,{},n,t),a=e.extrapolationMap[o.id],o.states[r]&&r!==n&&(a=o.states[r][o.states[r].length-1]),o.states[n]=i.map((function(t){var n=e.extrapolationMap[o.id]=dn(dn({},e.extrapolationMap[o.id]),t);return\"function\"==typeof o.computeAnimationProgressTime&&o.computeAnimationProgressTime(a,n),a=n})))}))}},{key:\"reinitScene\",value:function(t,e){this.globalData.toPixel=1920/e.width*e.oversampling,this.globalData.mustResetTree=!0,xn.container=this.container=t,this.entities.forEach((function(t){t.init()}))}},{key:\"sortChildren\",value:function(t){t.children.sort((function(t,e){return t.zIndex===e.zIndex?t.id-e.id:t.zIndex-e.zIndex}))}},{key:\"stillLoading\",value:function(){return 0<this.loadingAssets}},{key:\"updateScene\",value:function(t,e,n){var r=this;if(!this.stillLoading()){for(var o in this.entities.forEach((function(t){return t.render(n,e,r.globalData)})),this.globalData.mustResetTree&&(this.reconstructTree(),this.globalData.mustResetTree=!1,this.globalData.mustResort=!0),this.globalData.mustResort&&(this.resortTree(),this.globalData.mustResort=!1),this.globalData.maskUpdates){var i=this.entities.get(+o),a=this.globalData.maskUpdates[o];i.container.mask=-1===a?null:this.entities.get(a).graphics}var s,c=function(t,e){var n;if(\"undefined\"==typeof Symbol||null==t[Symbol.iterator]){if(Array.isArray(t)||(n=function(t,e){if(t){if(\"string\"==typeof t)return bn(t,e);var n=Object.prototype.toString.call(t).slice(8,-1);return\"Object\"===n&&t.constructor&&(n=t.constructor.name),\"Map\"===n||\"Set\"===n?Array.from(t):\"Arguments\"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)?bn(t,e):void 0}}(t))||e&&t&&\"number\"==typeof t.length){n&&(t=n);var r=0,o=function(){};return{s:o,n:function(){return r>=t.length?{done:!0}:{done:!1,value:t[r++]}},e:function(t){throw t},f:o}}throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\")}var i,a=!0,s=!1;return{s:function(){n=t[Symbol.iterator]()},n:function(){var t=n.next();return a=t.done,t},e:function(t){s=!0,i=t},f:function(){try{a||null==n.return||n.return()}finally{if(s)throw i}}}}(this.globalData.updatedBuffers);try{for(c.s();!(s=c.n()).done;)s.value.postUpdate()}catch(t){c.e(t)}finally{c.f()}this.globalData.maskUpdates={}}}},{key:\"resortTree\",value:function(){var t=this;this.entities.forEach((function(e){e instanceof ue&&t.sortChildren(e.childrenContainer)})),this.sortChildren(this.container)}},{key:\"reconstructTree\",value:function(){var t=this;this.container.removeChildren(),this.entities.forEach((function(e){e instanceof ue&&(e.childrenContainer.removeChildren(),e.currentState.children.forEach((function(n){var r=t.entities.get(n);e.childrenContainer.addChild(r.container),r.parent=e})))})),this.entities.forEach((function(e){e.container.parent||t.container.addChild(e.container)}))}},{key:\"handleGlobalData\",value:function(t,e){this.globalData.players=t;var n=e.width,r=e.height;this.globalData.toWorldUnits=a(n,r,1920,1080),xn.toWorldUnits=this.globalData.toWorldUnits,xn.hasOwnProperty(\"coeff\")||Object.defineProperty(xn,\"coeff\",{get:function(){var t='The \"coeff\" property of GraphicEntityModule\\'s API is deprecated, please use \"toWorldUnits\" instead',e=(new Error).stack;return console.groupCollapsed?(console.groupCollapsed(\"%cDeprecation Warning: %c%s\",\"color:#614108;background:#fffbe6\",\"font-weight:normal;color:#614108;background:#fffbe6\",t),console.warn(e),console.groupEnd()):console.warn(\"Deprecation Warning: \",t),xn.toWorldUnits}})}}])&&vn(e.prototype,n),r&&vn(e,r),t}(),wn={playerCount:2,logo:\"logo_start.png\",overlayAlpha:.4,agents:[{index:0,name:\"Alice\",avatar:\"https://www.codingame.com/servlet/fileservlet?id=16085713250612&format=viewer_avatar\",type:\"CODINGAMER\",color:\"#f9b700\",typeData:{me:!0,nickname:\"[CG]Nonofr\"}},{index:1,name:\"Bob\",avatar:\"https://www.codingame.com/servlet/fileservlet?id=16085756802960&format=viewer_avatar\",type:\"CODINGAMER\",color:\"#22a1e4\",typeData:{me:!0,nickname:\"[CG]Maxime\"}}],frames:['KEY_FRAME 0\\n{\"global\":{\"entitymodule\":{\"width\":1920,\"height\":1080}},\"frame\":{\"duration\":600,\"entitymodule\":[\"C S\",\"C S\",\"C S\",\"C R\",\"C R\",\"C T\",\"C S\",\"C G\",\"C R\",\"C R\",\"C T\",\"C S\",\"C G\",\"C G\",\"C L\",\"C L\",\"C L\",\"C L\",\"C G\",\"C L\",\"C L\",\"C L\",\"C L\",\"C G\",\"C L\",\"C L\",\"C L\",\"C L\",\"C G\",\"C L\",\"C L\",\"C L\",\"C L\",\"C G\",\"C L\",\"C L\",\"C L\",\"C L\",\"C G\",\"C L\",\"C L\",\"C L\",\"C L\",\"C G\",\"C L\",\"C L\",\"C L\",\"C L\",\"C G\",\"C L\",\"C L\",\"C L\",\"C L\",\"C G\",\"C L\",\"C L\",\"C L\",\"C L\",\"C G\",\"C L\",\"C L\",\"C L\",\"C L\",\"C S\",\"U 44 0.1 C 47,48,46,45 a 1\",\"U 49 0.1 C 53,50,52,51 a 1\",\"U 34 0.1 C 35,38,36,37 a 1\",\"U 59 0.1 C 63,60,61,62 a 1\",\"U 54 0.1 C 57,55,58,56 a 1\",\"U 19 0.1 C 20,21,22,23 a 1\",\"U 39 0.1 C 41,42,43,40 a 1\",\"U 24 0.1 C 25,28,26,27 a 1\",\"U 29 0.1 C 33,30,32,31 a 1\",\"U 35 1 x 870 y 270 Y 270 X 1050 c 16777215 W 3\",\"U 25 1 x 630 y 510 Y 510 X 810 c 16777215 W 3\",\"U 61 1 x 1110 y 810 Y 810 X 1290 c 16777215 W 3\",\"U 23 1 x 750 y 210 Y 390 X 750 c 16777215 W 3\",\"U 16 1 x 600 y 660 Y 660 X 1320 c 16365312 W 5\",\"U 42 1 x 930 y 450 Y 630 X 930 c 16777215 W 3\",\"U 22 1 x 690 y 210 Y 390 X 690 c 16777215 W 3\",\"U 8 1 C 6,7\",\"U 31 1 x 630 y 810 Y 810 X 810 c 16777215 W 3\",\"U 40 1 x 870 y 510 Y 510 X 1050 c 16777215 W 3\",\"U 7 1 bw 116 i $0 ay 0.5 ax 0.5 x 280 y 220 bh 116 z 20\",\"U 57 1 x 1170 y 450 Y 630 X 1170 c 16777215 W 3\",\"U 12 1 bw 116 i $1 ay 0.5 ax 0.5 x 1640 y 220 bh 116 z 20\",\"U 50 1 x 1110 y 270 Y 270 X 1290 c 16777215 W 3\",\"U 64 1 i board_border.png ay 0.5 ax 0.5 x 960 y 540\",\"U 26 1 x 630 y 570 Y 570 X 810 c 16777215 W 3\",\"U 37 1 x 930 y 210 Y 390 X 930 c 16777215 W 3\",\"U 43 1 x 990 y 450 Y 630 X 990 c 16777215 W 3\",\"U 6 1 f 16777215 ay 0.5 ax 0.5 x 280 y 340 s 40 T $0 z 20\",\"U 33 1 x 750 y 690 Y 870 X 750 c 16777215 W 3\",\"U 63 1 x 1230 y 690 Y 870 X 1230 c 16777215 W 3\",\"U 10 1 f 16777215 w 120 x 1580 y 160 W 0 h 120\",\"U 14 1 C 17,18,15,16\",\"U 30 1 x 630 y 750 Y 750 X 810 c 16777215 W 3\",\"U 17 1 x 840 y 180 Y 900 X 840 c 16365312 W 5\",\"U 11 1 f 16777215 ay 0.5 ax 0.5 x 1640 y 340 s 40 T $1 z 20\",\"U 55 1 x 1110 y 510 Y 510 X 1290 c 16777215 W 3\",\"U 3 1 i logoCG.png ay 0.5 ax 0.5 x 1640 y 915\",\"U 9 1 f -2 w 140 x 1570 y 150 W 0 h 140\",\"U 46 1 x 870 y 810 Y 810 X 1050 c 16777215 W 3\",\"U 27 1 x 690 y 450 Y 630 X 690 c 16777215 W 3\",\"U 45 1 x 870 y 750 Y 750 X 1050 c 16777215 W 3\",\"U 60 1 x 1110 y 750 Y 750 X 1290 c 16777215 W 3\",\"U 18 1 x 1080 y 180 Y 900 X 1080 c 16365312 W 5\",\"U 28 1 x 750 y 450 Y 630 X 750 c 16777215 W 3\",\"U 52 1 x 1170 y 210 Y 390 X 1170 c 16777215 W 3\",\"U 56 1 x 1110 y 570 Y 570 X 1290 c 16777215 W 3\",\"U 62 1 x 1170 y 690 Y 870 X 1170 c 16777215 W 3\",\"U 41 1 x 870 y 570 Y 570 X 1050 c 16777215 W 3\",\"U 48 1 x 990 y 690 Y 870 X 990 c 16777215 W 3\",\"U 5 1 f 16777215 w 120 x 220 y 160 W 0 h 120\",\"U 36 1 x 870 y 330 Y 330 X 1050 c 16777215 W 3\",\"U 1 1 i Background.jpg ay 0 ax 0\",\"U 20 1 x 630 y 270 Y 270 X 810 c 16777215 W 3\",\"U 13 1 C 12,11\",\"U 47 1 x 930 y 690 Y 870 X 930 c 16777215 W 3\",\"U 53 1 x 1230 y 210 Y 390 X 1230 c 16777215 W 3\",\"U 21 1 x 630 y 330 Y 330 X 810 c 16777215 W 3\",\"U 32 1 x 690 y 690 Y 870 X 690 c 16777215 W 3\",\"U 38 1 x 990 y 210 Y 390 X 990 c 16777215 W 3\",\"U 15 1 x 600 y 420 Y 420 X 1320 c 16365312 W 5\",\"U 4 1 f -1 w 140 x 210 y 150 W 0 h 140\",\"U 2 1 i logo.png ay 0.5 ax 0.5 x 280 y 915\",\"U 51 1 x 1110 y 330 Y 330 X 1290 c 16777215 W 3\",\"U 58 1 x 1230 y 450 Y 630 X 1230 c 16777215 W 3\"]}}\\n','KEY_FRAME 1\\n{\"entitymodule\":[\"C S\",\"U 44 0.1 a 0.5\",\"U 49 0.1 a 0.5\",\"U 59 0.1 C 63,60,61,65,62 a 0.5\",\"U 54 0.1 a 0.5\",\"U 19 0.1 a 0.5\",\"U 39 0.1 a 0.5\",\"U 24 0.1 a 0.5\",\"U 29 0.1 a 0.5\",\"U 65 0.2 bw 48 sx 0 i cross.png ay 0.5 sy 0 ax 0.5 x 1200 y 720 bh 48 t -1\",\"U 65 1 sx 1 ~ sy 1 ~\"]}\\n','KEY_FRAME 2\\n{\"entitymodule\":[\"C S\",\"U 34 0.1 C 35,38,36,66,37 a 0.5\",\"U 24 0.1 a 1\",\"U 66 0.2 bw 48 sx 0 i circle.png ay 0.5 sy 0 ax 0.5 x 900 y 300 bh 48 t -2\",\"U 66 1 sx 1 ~ sy 1 ~\"]}\\n','KEY_FRAME 3\\n{\"entitymodule\":[\"C S\",\"U 34 0.1 a 1\",\"U 24 0.1 C 67,25,28,26,27 a 0.5\",\"U 67 0.2 bw 48 sx 0 i cross.png ay 0.5 sy 0 ax 0.5 x 720 y 480 bh 48 t -1\",\"U 67 1 sx 1 ~ sy 1 ~\"]}\\n','KEY_FRAME 4\\n{\"entitymodule\":[\"C S\",\"U 34 0.1 C 35,38,36,66,37,68 a 0.5\",\"U 39 0.1 a 1\",\"U 68 0.2 bw 48 sx 0 i circle.png ay 0.5 sy 0 ax 0.5 x 960 y 300 bh 48 t -2\",\"U 68 1 sx 1 ~ sy 1 ~\"]}\\n','KEY_FRAME 5\\n{\"entitymodule\":[\"C S\",\"U 39 0.1 C 41,69,42,43,40\",\"U 69 0.2 bw 48 sx 0 i cross.png ay 0.5 sy 0 ax 0.5 x 960 y 540 bh 48 t -1\",\"U 69 1 sx 1 ~ sy 1 ~\"]}\\n','KEY_FRAME 6\\n{\"entitymodule\":[\"C S\",\"U 34 0.1 a 1\",\"U 39 0.1 C 41,69,70,42,43,40 a 0.5\",\"U 70 0.2 bw 48 sx 0 i circle.png ay 0.5 sy 0 ax 0.5 x 960 y 480 bh 48 t -2\",\"U 70 1 sx 1 ~ sy 1 ~\"]}\\n','KEY_FRAME 7\\n{\"entitymodule\":[\"C S\",\"U 34 0.1 C 35,38,36,66,37,68,71\",\"U 71 0.2 bw 48 sx 0 i cross.png ay 0.5 sy 0 ax 0.5 x 960 y 240 bh 48 t -1\",\"U 71 1 sx 1 ~ sy 1 ~\"]}\\n','KEY_FRAME 8\\n{\"entitymodule\":[\"C S\",\"U 34 0.1 C 35,38,72,36,66,37,68,71 a 0.5\",\"U 29 0.1 a 1\",\"U 72 0.2 bw 48 sx 0 i circle.png ay 0.5 sy 0 ax 0.5 x 900 y 360 bh 48 t -2\",\"U 72 1 sx 1 ~ sy 1 ~\"]}\\n','KEY_FRAME 9\\n{\"entitymodule\":[\"C S\",\"U 19 0.1 a 1\",\"U 29 0.1 C 33,30,32,73,31 a 0.5\",\"U 73 0.2 bw 48 sx 0 i cross.png ay 0.5 sy 0 ax 0.5 x 660 y 720 bh 48 t -1\",\"U 73 1 sx 1 ~ sy 1 ~\"]}\\n','KEY_FRAME 10\\n{\"entitymodule\":[\"C S\",\"U 34 0.1 a 1\",\"U 19 0.1 C 20,21,22,74,23 a 0.5\",\"U 74 0.2 bw 48 sx 0 i circle.png ay 0.5 sy 0 ax 0.5 x 720 y 240 bh 48 t -2\",\"U 74 1 sx 1 ~ sy 1 ~\"]}\\n','KEY_FRAME 11\\n{\"entitymodule\":[\"C S\",\"U 44 0.1 a 1\",\"U 34 0.1 C 35,38,72,36,66,75,37,68,71 a 0.5\",\"U 75 0.2 bw 48 sx 0 i cross.png ay 0.5 sy 0 ax 0.5 x 960 y 360 bh 48 t -1\",\"U 75 1 sx 1 ~ sy 1 ~\"]}\\n','KEY_FRAME 12\\n{\"entitymodule\":[\"C S\",\"U 44 0.1 C 47,48,76,46,45 a 0.5\",\"U 29 0.1 a 1\",\"U 76 0.2 bw 48 sx 0 i circle.png ay 0.5 sy 0 ax 0.5 x 900 y 840 bh 48 t -2\",\"U 76 1 sx 1 ~ sy 1 ~\"]}\\n','KEY_FRAME 13\\n{\"entitymodule\":[\"C S\",\"U 24 0.1 a 1\",\"U 29 0.1 C 33,30,77,32,73,31 a 0.5\",\"U 77 0.2 bw 48 sx 0 i cross.png ay 0.5 sy 0 ax 0.5 x 660 y 780 bh 48 t -1\",\"U 77 1 sx 1 ~ sy 1 ~\"]}\\n','KEY_FRAME 14\\n{\"entitymodule\":[\"C S\",\"U 19 0.1 a 1\",\"U 24 0.1 C 67,25,28,78,26,27 a 0.5\",\"U 78 0.2 bw 48 sx 0 i circle.png ay 0.5 sy 0 ax 0.5 x 660 y 480 bh 48 t -2\",\"U 78 1 sx 1 ~ sy 1 ~\"]}\\n','KEY_FRAME 15\\n{\"entitymodule\":[\"C S\",\"U 54 0.1 a 1\",\"U 19 0.1 C 20,21,22,74,79,23 a 0.5\",\"U 79 0.2 bw 48 sx 0 i cross.png ay 0.5 sy 0 ax 0.5 x 780 y 300 bh 48 t -1\",\"U 79 1 sx 1 ~ sy 1 ~\"]}\\n','KEY_FRAME 16\\n{\"entitymodule\":[\"C S\",\"U 34 0.1 a 1\",\"U 54 0.1 C 57,55,80,58,56 a 0.5\",\"U 80 0.2 bw 48 sx 0 i circle.png ay 0.5 sy 0 ax 0.5 x 1200 y 480 bh 48 t -2\",\"U 80 1 sx 1 ~ sy 1 ~\"]}\\n','KEY_FRAME 17\\n{\"entitymodule\":[\"C S\",\"U 34 0.1 C 35,81,38,72,36,66,75,37,68,71 a 0.5\",\"U 59 0.1 a 1\",\"U 81 0.2 bw 48 sx 0 i cross.png ay 0.5 sy 0 ax 0.5 x 1020 y 360 bh 48 t -1\",\"U 81 1 sx 1 ~ sy 1 ~\"]}\\n','KEY_FRAME 18\\n{\"entitymodule\":[\"C S\",\"U 59 0.1 C 63,60,82,61,65,62 a 0.5\",\"U 29 0.1 a 1\",\"U 82 0.2 bw 48 sx 0 i circle.png ay 0.5 sy 0 ax 0.5 x 1140 y 840 bh 48 t -2\",\"U 82 1 sx 1 ~ sy 1 ~\"]}\\n','KEY_FRAME 19\\n{\"entitymodule\":[\"C S\",\"U 44 0.1 a 1\",\"U 29 0.1 C 33,83,30,77,32,73,31 a 0.5\",\"U 83 0.2 bw 48 sx 0 i cross.png ay 0.5 sy 0 ax 0.5 x 720 y 840 bh 48 t -1\",\"U 83 1 sx 1 ~ sy 1 ~\"]}\\n','KEY_FRAME 20\\n{\"entitymodule\":[\"C S\",\"U 44 0.1 C 47,48,76,84,46,45 a 0.5\",\"U 34 0.1 a 1\",\"U 84 0.2 bw 48 sx 0 i circle.png ay 0.5 sy 0 ax 0.5 x 960 y 720 bh 48 t -2\",\"U 84 1 sx 1 ~ sy 1 ~\"]}\\n','KEY_FRAME 21\\n{\"entitymodule\":[\"C S\",\"U 34 0.1 C 35,81,85,38,72,36,66,75,37,68,71 a 0.5\",\"U 19 0.1 a 1\",\"U 85 0.2 bw 48 sx 0 i cross.png ay 0.5 sy 0 ax 0.5 x 900 y 240 bh 48 t -1\",\"U 85 1 sx 1 ~ sy 1 ~\"]}\\n','KEY_FRAME 22\\n{\"entitymodule\":[\"C S\",\"U 59 0.1 a 1\",\"U 19 0.1 C 20,21,22,74,79,86,23 a 0.5\",\"U 86 0.2 bw 48 sx 0 i circle.png ay 0.5 sy 0 ax 0.5 x 780 y 360 bh 48 t -2\",\"U 86 1 sx 1 ~ sy 1 ~\"]}\\n','KEY_FRAME 23\\n{\"entitymodule\":[\"C S\",\"U 44 0.1 a 1\",\"U 59 0.1 C 63,60,82,87,61,65,62 a 0.5\",\"U 87 0.2 bw 48 sx 0 i cross.png ay 0.5 sy 0 ax 0.5 x 1200 y 840 bh 48 t -1\",\"U 87 1 sx 1 ~ sy 1 ~\"]}\\n','KEY_FRAME 24\\n{\"entitymodule\":[\"C S\",\"U 44 0.1 C 47,48,88,76,84,46,45 a 0.5\",\"U 54 0.1 a 1\",\"U 88 0.2 bw 48 sx 0 i circle.png ay 0.5 sy 0 ax 0.5 x 1020 y 780 bh 48 t -2\",\"U 88 1 sx 1 ~ sy 1 ~\"]}\\n','KEY_FRAME 25\\n{\"entitymodule\":[\"C S\",\"U 54 0.1 C 57,89,55,80,58,56 a 0.5\",\"U 19 0.1 a 1\",\"U 89 0.2 bw 48 sx 0 i cross.png ay 0.5 sy 0 ax 0.5 x 1140 y 480 bh 48 t -1\",\"U 89 1 sx 1 ~ sy 1 ~\"]}\\n','KEY_FRAME 26\\n{\"entitymodule\":[\"C S\",\"U 19 0.1 C 20,21,22,74,79,86,90,23 a 0.5\",\"U 29 0.1 a 1\",\"U 90 0.2 bw 48 sx 0 i circle.png ay 0.5 sy 0 ax 0.5 x 660 y 360 bh 48 t -2\",\"U 90 1 sx 1 ~ sy 1 ~\"]}\\n','KEY_FRAME 27\\n{\"entitymodule\":[\"C S\",\"C S\",\"U 44 0.1 a 1\",\"U 49 0.1 a 1\",\"U 34 0.1 a 1\",\"U 59 0.1 a 1\",\"U 54 0.1 a 1\",\"U 19 0.1 a 1\",\"U 39 0.1 a 1\",\"U 24 0.1 a 1\",\"U 29 0.1 v false C 33,83,30,77,91,32,73,31\",\"U 91 0.2 bw 48 sx 0 i cross.png ay 0.5 sy 0 ax 0.5 x 660 y 840 bh 48 t -1\",\"U 92 0.2 bw 192 sx 0 i cross.png ay 0.5 sy 0 ax 0.5 x 720 y 780 bh 192 t -1\",\"U 91 1 sx 1 ~ sy 1 ~\",\"U 14 1 C 17,18,15,16,92\",\"U 92 1 sx 1 ~ sy 1 ~\"]}\\n','KEY_FRAME 28\\n{\"entitymodule\":[\"C S\",\"U 44 0.1 C 93,47,48,88,76,84,46,45\",\"U 49 0.1 a 0.5\",\"U 34 0.1 a 0.5\",\"U 59 0.1 a 0.5\",\"U 54 0.1 a 0.5\",\"U 19 0.1 a 0.5\",\"U 39 0.1 a 0.5\",\"U 24 0.1 a 0.5\",\"U 93 0.2 bw 48 sx 0 i circle.png ay 0.5 sy 0 ax 0.5 x 960 y 840 bh 48 t -2\",\"U 93 1 sx 1 ~ sy 1 ~\"]}\\n','KEY_FRAME 29\\n{\"entitymodule\":[\"C S\",\"U 44 0.1 C 93,47,48,88,76,84,94,46,45 a 0.5\",\"U 24 0.1 a 1\",\"U 94 0.2 bw 48 sx 0 i cross.png ay 0.5 sy 0 ax 0.5 x 900 y 780 bh 48 t -1\",\"U 94 1 sx 1 ~ sy 1 ~\"]}\\n','KEY_FRAME 30\\n{\"entitymodule\":[\"C S\",\"U 39 0.1 a 1\",\"U 24 0.1 C 95,67,25,28,78,26,27 a 0.5\",\"U 95 0.2 bw 48 sx 0 i circle.png ay 0.5 sy 0 ax 0.5 x 720 y 540 bh 48 t -2\",\"U 95 1 sx 1 ~ sy 1 ~\"]}\\n','KEY_FRAME 31\\n{\"entitymodule\":[\"C S\",\"U 49 0.1 a 1\",\"U 39 0.1 C 41,96,69,70,42,43,40 a 0.5\",\"U 96 0.2 bw 48 sx 0 i cross.png ay 0.5 sy 0 ax 0.5 x 1020 y 480 bh 48 t -1\",\"U 96 1 sx 1 ~ sy 1 ~\"]}\\n','KEY_FRAME 32\\n{\"entitymodule\":[\"C S\",\"U 49 0.1 C 53,50,52,51,97\",\"U 97 0.2 bw 48 sx 0 i circle.png ay 0.5 sy 0 ax 0.5 x 1260 y 240 bh 48 t -2\",\"U 97 1 sx 1 ~ sy 1 ~\"]}\\n','KEY_FRAME 33\\n{\"entitymodule\":[\"C S\",\"U 44 0.1 a 1\",\"U 49 0.1 C 53,50,52,98,51,97\",\"U 34 0.1 a 1\",\"U 59 0.1 a 1\",\"U 54 0.1 a 1\",\"U 19 0.1 a 1\",\"U 39 0.1 a 1\",\"U 24 0.1 a 1\",\"U 98 0.2 bw 48 sx 0 i cross.png ay 0.5 sy 0 ax 0.5 x 1140 y 360 bh 48 t -1\",\"U 98 1 sx 1 ~ sy 1 ~\"]}\\n','KEY_FRAME 34\\n{\"entitymodule\":[\"C S\",\"U 44 0.1 a 0.5\",\"U 49 0.1 a 0.5\",\"U 34 0.1 a 0.5\",\"U 59 0.1 C 63,60,82,87,61,99,65,62 a 0.5\",\"U 54 0.1 a 0.5\",\"U 19 0.1 a 0.5\",\"U 39 0.1 a 0.5\",\"U 99 0.2 bw 48 sx 0 i circle.png ay 0.5 sy 0 ax 0.5 x 1140 y 780 bh 48 t -2\",\"U 99 1 sx 1 ~ sy 1 ~\"]}\\n','KEY_FRAME 35\\n{\"entitymodule\":[\"C S\",\"U 44 0.1 a 1\",\"U 24 0.1 C 95,67,25,100,28,78,26,27 a 0.5\",\"U 100 0.2 bw 48 sx 0 i cross.png ay 0.5 sy 0 ax 0.5 x 720 y 600 bh 48 t -1\",\"U 100 1 sx 1 ~ sy 1 ~\"]}\\n','KEY_FRAME 36\\n{\"entitymodule\":[\"C S\",\"C S\",\"U 59 0.1 a 1\",\"U 101 0.2 bw 48 sx 0 i circle.png ay 0.5 sy 0 ax 0.5 x 1020 y 840 bh 48 t -2\",\"U 102 0.2 bw 192 sx 0 i circle.png ay 0.5 sy 0 ax 0.5 x 960 y 780 bh 192 t -2\",\"U 14 1 C 17,18,15,102,16,92\",\"U 44 1 v false C 93,47,48,88,101,76,84,94,46,45\",\"U 101 1 sx 1 ~ sy 1 ~\",\"U 102 1 sx 1 ~ sy 1 ~\"]}\\n','KEY_FRAME 37\\n{\"entitymodule\":[\"C S\",\"U 59 0.1 C 63,60,82,87,61,103,99,65,62 a 0.5\",\"U 54 0.1 a 1\",\"U 103 0.2 bw 48 sx 0 i cross.png ay 0.5 sy 0 ax 0.5 x 1260 y 780 bh 48 t -1\",\"U 103 1 sx 1 ~ sy 1 ~\"]}\\n','KEY_FRAME 38\\n{\"entitymodule\":[\"C S\",\"U 49 0.1 a 1\",\"U 34 0.1 a 1\",\"U 59 0.1 a 1\",\"U 54 0.1 C 104,57,89,55,80,58,56\",\"U 19 0.1 a 1\",\"U 39 0.1 a 1\",\"U 24 0.1 a 1\",\"U 104 0.2 bw 48 sx 0 i circle.png ay 0.5 sy 0 ax 0.5 x 1200 y 600 bh 48 t -2\",\"U 104 1 sx 1 ~ sy 1 ~\"]}\\n','KEY_FRAME 39\\n{\"entitymodule\":[\"C S\",\"U 49 0.1 a 0.5\",\"U 34 0.1 a 0.5\",\"U 59 0.1 a 0.5\",\"U 54 0.1 a 0.5\",\"U 19 0.1 C 20,21,22,74,79,86,90,23,105\",\"U 39 0.1 a 0.5\",\"U 24 0.1 a 0.5\",\"U 105 0.2 bw 48 sx 0 i cross.png ay 0.5 sy 0 ax 0.5 x 660 y 240 bh 48 t -1\",\"U 105 1 sx 1 ~ sy 1 ~\"]}\\n','KEY_FRAME 40\\n{\"entitymodule\":[\"C S\",\"U 49 0.1 a 1\",\"U 19 0.1 C 20,21,22,106,74,79,86,90,23,105 a 0.5\",\"U 106 0.2 bw 48 sx 0 i circle.png ay 0.5 sy 0 ax 0.5 x 780 y 240 bh 48 t -2\",\"U 106 1 sx 1 ~ sy 1 ~\"]}\\n','KEY_FRAME 41\\n{\"entitymodule\":[\"C S\",\"U 49 0.1 C 53,50,52,98,51,97,107 a 0.5\",\"U 34 0.1 a 1\",\"U 107 0.2 bw 48 sx 0 i cross.png ay 0.5 sy 0 ax 0.5 x 1200 y 240 bh 48 t -1\",\"U 107 1 sx 1 ~ sy 1 ~\"]}\\n','KEY_FRAME 42\\n{\"entitymodule\":[\"C S\",\"C S\",\"U 49 0.1 a 1\",\"U 109 0.2 bw 192 sx 0 i circle.png ay 0.5 sy 0 ax 0.5 x 960 y 300 bh 192 t -2\",\"U 108 0.2 bw 48 sx 0 i circle.png ay 0.5 sy 0 ax 0.5 x 1020 y 240 bh 48 t -2\",\"U 34 1 v false C 35,81,85,38,72,36,66,75,108,37,68,71\",\"U 14 1 C 17,109,18,15,102,16,92\",\"U 109 1 sx 1 ~ sy 1 ~\",\"U 108 1 sx 1 ~ sy 1 ~\"]}\\n','KEY_FRAME 43\\n{\"entitymodule\":[\"C S\",\"U 49 0.1 C 110,53,50,52,98,51,97,107 a 0.5\",\"U 19 0.1 a 1\",\"U 110 0.2 bw 48 sx 0 i cross.png ay 0.5 sy 0 ax 0.5 x 1140 y 240 bh 48 t -1\",\"U 110 1 sx 1 ~ sy 1 ~\"]}\\n','KEY_FRAME 44\\n{\"entitymodule\":[\"C S\",\"U 19 0.1 C 20,21,22,106,74,79,111,86,90,23,105 a 0.5\",\"U 24 0.1 a 1\",\"U 111 0.2 bw 48 sx 0 i circle.png ay 0.5 sy 0 ax 0.5 x 660 y 300 bh 48 t -2\",\"U 111 1 sx 1 ~ sy 1 ~\"]}\\n','KEY_FRAME 45\\n{\"entitymodule\":[\"C S\",\"U 59 0.1 a 1\",\"U 24 0.1 C 95,67,25,100,28,78,26,112,27 a 0.5\",\"U 112 0.2 bw 48 sx 0 i cross.png ay 0.5 sy 0 ax 0.5 x 780 y 600 bh 48 t -1\",\"U 112 1 sx 1 ~ sy 1 ~\"]}\\n','KEY_FRAME 46\\n{\"entitymodule\":[\"C S\",\"U 59 0.1 C 63,60,82,113,87,61,103,99,65,62 a 0.5\",\"U 39 0.1 a 1\",\"U 113 0.2 bw 48 sx 0 i circle.png ay 0.5 sy 0 ax 0.5 x 1200 y 780 bh 48 t -2\",\"U 113 1 sx 1 ~ sy 1 ~\"]}\\n','KEY_FRAME 47\\n{\"entitymodule\":[\"C S\",\"U 39 0.1 C 41,96,69,114,70,42,43,40 a 0.5\",\"U 24 0.1 a 1\",\"U 114 0.2 bw 48 sx 0 i cross.png ay 0.5 sy 0 ax 0.5 x 900 y 540 bh 48 t -1\",\"U 114 1 sx 1 ~ sy 1 ~\"]}\\n','KEY_FRAME 48\\n{\"entitymodule\":[\"C S\",\"U 49 0.1 a 1\",\"U 59 0.1 a 1\",\"U 54 0.1 a 1\",\"U 19 0.1 a 1\",\"U 39 0.1 a 1\",\"U 24 0.1 C 95,67,25,100,28,78,115,26,112,27\",\"U 115 0.2 bw 48 sx 0 i circle.png ay 0.5 sy 0 ax 0.5 x 660 y 600 bh 48 t -2\",\"U 115 1 sx 1 ~ sy 1 ~\"]}\\n','KEY_FRAME 49\\n{\"entitymodule\":[\"C S\",\"C S\",\"U 39 0.1 v false C 116,41,96,69,114,70,42,43,40\",\"U 116 0.2 bw 48 sx 0 i cross.png ay 0.5 sy 0 ax 0.5 x 900 y 600 bh 48 t -1\",\"U 117 0.2 bw 192 sx 0 i cross.png ay 0.5 sy 0 ax 0.5 x 960 y 540 bh 192 t -1\",\"U 117 1 sx 1 ~ sy 1 ~\",\"U 14 1 C 117,17,109,18,15,102,16,92\",\"U 116 1 sx 1 ~ sy 1 ~\"]}\\n','KEY_FRAME 50\\n{\"entitymodule\":[\"C S\",\"C S\",\"U 54 0.1 a 0.5\",\"U 19 0.1 a 0.5\",\"U 24 0.1 a 0.5\",\"U 118 0.2 bw 48 sx 0 i circle.png ay 0.5 sy 0 ax 0.5 x 1260 y 720 bh 48 t -2\",\"U 119 0.2 bw 192 sx 0 i circle.png ay 0.5 sy 0 ax 0.5 x 1200 y 780 bh 192 t -2\",\"U 14 1 C 117,17,109,18,15,102,16,92,119\",\"U 59 1 v false C 63,60,82,113,87,61,103,99,65,118,62\",\"U 118 1 sx 1 ~ sy 1 ~\",\"U 119 1 sx 1 ~ sy 1 ~\"]}\\n','KEY_FRAME 51\\n{\"entitymodule\":[\"C S\",\"U 49 0.1 C 110,53,50,52,98,51,97,107,120\",\"U 54 0.1 a 1\",\"U 19 0.1 a 1\",\"U 24 0.1 a 1\",\"U 120 0.2 bw 48 sx 0 i cross.png ay 0.5 sy 0 ax 0.5 x 1200 y 360 bh 48 t -1\",\"U 120 1 sx 1 ~ sy 1 ~\"]}\\n','KEY_FRAME 52\\n{\"entitymodule\":[\"C S\",\"C S\",\"U 19 0.1 v false C 20,21,22,106,74,79,121,111,86,90,23,105\",\"U 121 0.2 bw 48 sx 0 i circle.png ay 0.5 sy 0 ax 0.5 x 720 y 360 bh 48 t -2\",\"U 122 0.2 bw 192 sx 0 i circle.png ay 0.5 sy 0 ax 0.5 x 720 y 300 bh 192 t -2\",\"U 121 1 sx 1 ~ sy 1 ~\",\"U 14 1 C 117,17,109,18,15,102,122,16,92,119\",\"U 122 1 sx 1 ~ sy 1 ~\"]}\\n','KEY_FRAME 53\\n{\"entitymodule\":[\"C S\",\"U 54 0.1 a 0.5\",\"U 24 0.1 C 95,123,67,25,100,28,78,115,26,112,27 a 0.5\",\"U 123 0.2 bw 48 sx 0 i cross.png ay 0.5 sy 0 ax 0.5 x 780 y 480 bh 48 t -1\",\"U 123 1 sx 1 ~ sy 1 ~\"]}\\n','KEY_FRAME 54\\n{\"entitymodule\":[\"C S\",\"U 49 0.1 C 110,53,124,50,52,98,51,97,107,120 a 0.5\",\"U 24 0.1 a 1\",\"U 124 0.2 bw 48 sx 0 i circle.png ay 0.5 sy 0 ax 0.5 x 1140 y 300 bh 48 t -2\",\"U 124 1 sx 1 ~ sy 1 ~\"]}\\n','KEY_FRAME 55\\n{\"entitymodule\":[\"C S\",\"U 24 0.1 C 125,95,123,67,25,100,28,78,115,26,112,27\",\"U 125 0.2 bw 48 sx 0 i cross.png ay 0.5 sy 0 ax 0.5 x 660 y 540 bh 48 t -1\",\"U 125 1 sx 1 ~ sy 1 ~\"]}\\n','KEY_FRAME 56\\n{\"entitymodule\":[\"C S\",\"U 54 0.1 a 1\",\"U 24 0.1 C 95,25,78,26,112,27,125,123,67,100,28,115,126 a 0.5\",\"U 126 0.2 bw 48 sx 0 i circle.png ay 0.5 sy 0 ax 0.5 x 780 y 540 bh 48 t -2\",\"U 126 1 sx 1 ~ sy 1 ~\"]}\\n','KEY_FRAME 57\\n{\"entitymodule\":[\"C S\",\"U 49 0.1 a 1\",\"U 54 0.1 C 104,57,89,55,80,58,56,127 a 0.5\",\"U 127 0.2 bw 48 sx 0 i cross.png ay 0.5 sy 0 ax 0.5 x 1260 y 480 bh 48 t -1\",\"U 127 1 sx 1 ~ sy 1 ~\"]}\\n','KEY_FRAME 58\\n{\"entitymodule\":[\"C S\",\"U 49 0.1 C 110,53,128,124,50,52,98,51,97,107,120 a 0.5\",\"U 54 0.1 a 1\",\"U 128 0.2 bw 48 sx 0 i circle.png ay 0.5 sy 0 ax 0.5 x 1260 y 300 bh 48 t -2\",\"U 128 1 sx 1 ~ sy 1 ~\"]}\\n','KEY_FRAME 59\\n{\"entitymodule\":[\"C S\",\"U 49 0.1 a 1\",\"U 54 0.1 C 104,57,129,89,55,80,58,56,127\",\"U 24 0.1 a 1\",\"U 129 0.2 bw 48 sx 0 i cross.png ay 0.5 sy 0 ax 0.5 x 1260 y 600 bh 48 t -1\",\"U 129 1 sx 1 ~ sy 1 ~\"]}\\n','KEY_FRAME 60\\n{\"entitymodule\":[\"C S\",\"U 54 0.1 C 104,57,129,89,55,80,130,58,56,127\",\"U 130 0.2 bw 48 sx 0 i circle.png ay 0.5 sy 0 ax 0.5 x 1140 y 600 bh 48 t -2\",\"U 130 1 sx 1 ~ sy 1 ~\"]}\\n','KEY_FRAME 61\\n{\"entitymodule\":[\"C S\",\"C S\",\"U 49 0.1 v false C 110,53,128,124,50,52,98,51,97,107,120,131\",\"U 132 0.2 bw 192 sx 0 i cross.png ay 0.5 sy 0 ax 0.5 x 1200 y 300 bh 192 t -1\",\"U 131 0.2 bw 48 sx 0 i cross.png ay 0.5 sy 0 ax 0.5 x 1200 y 300 bh 48 t -1\",\"U 131 1 sx 1 ~ sy 1 ~\",\"U 14 1 C 117,17,109,18,15,102,122,132,16,92,119\",\"U 13 1 a 0.3\",\"U 132 1 sx 1 ~ sy 1 ~\"]}\\n']},_n=[\"#f2b213\",\"#22a1e4\"],Sn=[mn],Cn={views:['KEY_FRAME 0\\n{\"global\":{\"entitymodule\":{\"width\":1920,\"height\":1080}},\"frame\":{\"duration\":800,\"entitymodule\":\"CS;S;S;T;T;S;S;T;T;S;R;R;T;S;G;R;R;T;S;G\\\\nU6 1 bw 100 i go_stone_white.png ay 0.5 v 1 ax 0.5 x 175 y 600 bh 100;7 1 bw 100 i go_stone_black.png ay 0.5 v 1 ax 0.5 x 1745 y 600 bh 100;2 1 i logoCG.png ay 0.5 v 1 ax 0.5 x 1640 y 960;17 1 f 16777215 v 1 w 120 x 1660 y 100 W 0 h 120;4 1 f 0 ay 0.5 v 1 ff arial ax 0.5 x 250 y 500 s 50 T Captured: z 20;5 1 f 0 ay 0.5 v 1 ff arial ax 0.5 x 1670 y 500 s 50 T Captured: z 20;8 1 f 0 ay 0.5 v 1 ff arial ax 0.5 x 325 y 600 s 100 T 0;20 1 ch 18,19 v 1;14 1 bw 116 i $0 ay 0.5 v 1 ax 0.5 x 200 y 160 bh 116 z 20;1 1 bw 1920 i background.jpg ay 0 v 1 ax 0 bh 1080;3 1 bw 1920 i background_points.png ay 0 v 1 ax 0 bh 1080;16 1 f -2 v 1 w 140 x 1650 y 90 W 0 h 140;18 1 f 16777215 ay 0.5 v 1 ff arial ax 0.5 x 1720 y 280 s 40 T $1 z 20;11 1 f -1 v 1 w 140 x 130 y 90 W 0 h 140;13 1 f 16777215 ay 0.5 v 1 ff arial ax 0.5 x 200 y 280 s 40 T $0 z 20;15 1 ch 13,14 v 1;12 1 f 16777215 v 1 w 120 x 140 y 100 W 0 h 120;19 1 bw 116 i $1 ay 0.5 v 1 ax 0.5 x 1720 y 160 bh 116 z 20;10 1 bw 950 i go_board_9x9.png v 1 x 485 y 65 bh 950;9 1 f 0 ay 0.5 v 1 ff arial ax 0.5 x 1595 y 600 s 100 T 0\"}}\\n','KEY_FRAME 1\\n{\"entitymodule\":\"CS;T;T;S;S;T;T;S;S\\\\nU21 1 bw 1920 i background_points.png ay 0 v 1 ax 0 bh 1080;24 1 bw 100 i go_stone_white.png ay 0.5 v 1 ax 0.5 x 175 y 600 bh 100;28 1 bw 950 i go_board_9x9.png v 1 x 485 y 65 bh 950;26 1 f 0 ay 0.5 v 1 ff arial ax 0.5 x 325 y 600 s 100 T 0;25 1 bw 100 i go_stone_black.png ay 0.5 v 1 ax 0.5 x 1745 y 600 bh 100;22 1 f 0 ay 0.5 v 1 ff arial ax 0.5 x 250 y 500 s 50 T Captured: z 20;29 1 bw 105 i go_stone_black.png v 1 x 1010 y 170 bh 105;27 1 f 0 ay 0.5 v 1 ff arial ax 0.5 x 1595 y 600 s 100 T 0;23 1 f 0 ay 0.5 v 1 ff arial ax 0.5 x 1670 y 500 s 50 T Captured: z 20\"}\\n','KEY_FRAME 2\\n{\"entitymodule\":\"CS;T;T;S;S;T;T;S;S;S\\\\nU31 1 f 0 ay 0.5 v 1 ff arial ax 0.5 x 250 y 500 s 50 T Captured: z 20;37 1 bw 950 i go_board_9x9.png v 1 x 485 y 65 bh 950;34 1 bw 100 i go_stone_black.png ay 0.5 v 1 ax 0.5 x 1745 y 600 bh 100;36 1 f 0 ay 0.5 v 1 ff arial ax 0.5 x 1595 y 600 s 100 T 0;39 1 bw 105 i go_stone_black.png v 1 x 1010 y 170 bh 105;35 1 f 0 ay 0.5 v 1 ff arial ax 0.5 x 325 y 600 s 100 T 0;38 1 bw 105 i go_stone_white.png v 1 x 905 y 170 bh 105;32 1 f 0 ay 0.5 v 1 ff arial ax 0.5 x 1670 y 500 s 50 T Captured: z 20;33 1 bw 100 i go_stone_white.png ay 0.5 v 1 ax 0.5 x 175 y 600 bh 100;30 1 bw 1920 i background_points.png ay 0 v 1 ax 0 bh 1080\"}\\n','KEY_FRAME 3\\n{\"entitymodule\":\"CS;T;T;S;S;T;T;S;S;S;S\\\\nU46 1 f 0 ay 0.5 v 1 ff arial ax 0.5 x 1595 y 600 s 100 T 0;48 1 bw 105 i go_stone_black.png v 1 x 800 y 170 bh 105;50 1 bw 105 i go_stone_black.png v 1 x 1010 y 170 bh 105;43 1 bw 100 i go_stone_white.png ay 0.5 v 1 ax 0.5 x 175 y 600 bh 100;47 1 bw 950 i go_board_9x9.png v 1 x 485 y 65 bh 950;41 1 f 0 ay 0.5 v 1 ff arial ax 0.5 x 250 y 500 s 50 T Captured: z 20;40 1 bw 1920 i background_points.png ay 0 v 1 ax 0 bh 1080;42 1 f 0 ay 0.5 v 1 ff arial ax 0.5 x 1670 y 500 s 50 T Captured: z 20;44 1 bw 100 i go_stone_black.png ay 0.5 v 1 ax 0.5 x 1745 y 600 bh 100;45 1 f 0 ay 0.5 v 1 ff arial ax 0.5 x 325 y 600 s 100 T 0;49 1 bw 105 i go_stone_white.png v 1 x 905 y 170 bh 105\"}\\n','KEY_FRAME 4\\n{\"entitymodule\":\"CS;T;T;S;S;T;T;S;S;S;S;S\\\\nU54 1 bw 100 i go_stone_white.png ay 0.5 v 1 ax 0.5 x 175 y 600 bh 100;51 1 bw 1920 i background_points.png ay 0 v 1 ax 0 bh 1080;53 1 f 0 ay 0.5 v 1 ff arial ax 0.5 x 1670 y 500 s 50 T Captured: z 20;60 1 bw 105 i go_stone_black.png v 1 x 800 y 170 bh 105;56 1 f 0 ay 0.5 v 1 ff arial ax 0.5 x 325 y 600 s 100 T 0;59 1 bw 105 i go_stone_white.png v 1 x 1010 y 65 bh 105;62 1 bw 105 i go_stone_black.png v 1 x 1010 y 170 bh 105;57 1 f 0 ay 0.5 v 1 ff arial ax 0.5 x 1595 y 600 s 100 T 0;58 1 bw 950 i go_board_9x9.png v 1 x 485 y 65 bh 950;55 1 bw 100 i go_stone_black.png ay 0.5 v 1 ax 0.5 x 1745 y 600 bh 100;52 1 f 0 ay 0.5 v 1 ff arial ax 0.5 x 250 y 500 s 50 T Captured: z 20;61 1 bw 105 i go_stone_white.png v 1 x 905 y 170 bh 105\"}\\n','KEY_FRAME 5\\n{\"entitymodule\":\"CS;T;T;S;S;T;T;S;S;S;S;S;S\\\\nU69 1 f 0 ay 0.5 v 1 ff arial ax 0.5 x 1595 y 600 s 100 T 0;63 1 bw 1920 i background_points.png ay 0 v 1 ax 0 bh 1080;74 1 bw 105 i go_stone_black.png v 1 x 1010 y 170 bh 105;73 1 bw 105 i go_stone_white.png v 1 x 905 y 170 bh 105;72 1 bw 105 i go_stone_black.png v 1 x 800 y 170 bh 105;65 1 f 0 ay 0.5 v 1 ff arial ax 0.5 x 1670 y 500 s 50 T Captured: z 20;71 1 bw 105 i go_stone_white.png v 1 x 1010 y 65 bh 105;64 1 f 0 ay 0.5 v 1 ff arial ax 0.5 x 250 y 500 s 50 T Captured: z 20;70 1 bw 950 i go_board_9x9.png v 1 x 485 y 65 bh 950;68 1 f 0 ay 0.5 v 1 ff arial ax 0.5 x 325 y 600 s 100 T 0;66 1 bw 100 i go_stone_white.png ay 0.5 v 1 ax 0.5 x 175 y 600 bh 100;75 1 bw 105 i go_stone_black.png v 1 x 905 y 275 bh 105;67 1 bw 100 i go_stone_black.png ay 0.5 v 1 ax 0.5 x 1745 y 600 bh 100\"}\\n','KEY_FRAME 6\\n{\"entitymodule\":\"CS;T;T;S;S;T;T;S;S;S;S;S;S;S\\\\nU85 1 bw 105 i go_stone_black.png v 1 x 800 y 170 bh 105;86 1 bw 105 i go_stone_white.png v 1 x 905 y 170 bh 105;78 1 f 0 ay 0.5 v 1 ff arial ax 0.5 x 1670 y 500 s 50 T Captured: z 20;81 1 f 0 ay 0.5 v 1 ff arial ax 0.5 x 325 y 600 s 100 T 0;87 1 bw 105 i go_stone_black.png v 1 x 1010 y 170 bh 105;83 1 bw 950 i go_board_9x9.png v 1 x 485 y 65 bh 950;88 1 bw 105 i go_stone_black.png v 1 x 905 y 275 bh 105;82 1 f 0 ay 0.5 v 1 ff arial ax 0.5 x 1595 y 600 s 100 T 0;89 1 bw 105 i go_stone_white.png v 1 x 1010 y 275 bh 105;84 1 bw 105 i go_stone_white.png v 1 x 1010 y 65 bh 105;79 1 bw 100 i go_stone_white.png ay 0.5 v 1 ax 0.5 x 175 y 600 bh 100;77 1 f 0 ay 0.5 v 1 ff arial ax 0.5 x 250 y 500 s 50 T Captured: z 20;80 1 bw 100 i go_stone_black.png ay 0.5 v 1 ax 0.5 x 1745 y 600 bh 100;76 1 bw 1920 i background_points.png ay 0 v 1 ax 0 bh 1080\"}\\n','KEY_FRAME 7\\n{\"entitymodule\":\"CS;T;T;S;S;T;T;S;S;S;S;S;S;S;S\\\\nU92 1 f 0 ay 0.5 v 1 ff arial ax 0.5 x 1670 y 500 s 50 T Captured: z 20;102 1 bw 105 i go_stone_black.png v 1 x 905 y 275 bh 105;100 1 bw 105 i go_stone_white.png v 1 x 905 y 170 bh 105;90 1 bw 1920 i background_points.png ay 0 v 1 ax 0 bh 1080;98 1 bw 105 i go_stone_white.png v 1 x 1010 y 65 bh 105;96 1 f 0 ay 0.5 v 1 ff arial ax 0.5 x 1595 y 600 s 100 T 0;91 1 f 0 ay 0.5 v 1 ff arial ax 0.5 x 250 y 500 s 50 T Captured: z 20;97 1 bw 950 i go_board_9x9.png v 1 x 485 y 65 bh 950;101 1 bw 105 i go_stone_black.png v 1 x 1010 y 170 bh 105;95 1 f 0 ay 0.5 v 1 ff arial ax 0.5 x 325 y 600 s 100 T 0;99 1 bw 105 i go_stone_black.png v 1 x 800 y 170 bh 105;103 1 bw 105 i go_stone_white.png v 1 x 1010 y 275 bh 105;104 1 bw 105 i go_stone_black.png v 1 x 1115 y 275 bh 105;94 1 bw 100 i go_stone_black.png ay 0.5 v 1 ax 0.5 x 1745 y 600 bh 100;93 1 bw 100 i go_stone_white.png ay 0.5 v 1 ax 0.5 x 175 y 600 bh 100\"}\\n','KEY_FRAME 8\\n{\"entitymodule\":\"CS;T;T;S;S;T;T;S;S;S;S;S;S;S;S;S\\\\nU119 1 bw 105 i go_stone_white.png v 1 x 1010 y 275 bh 105;110 1 f 0 ay 0.5 v 1 ff arial ax 0.5 x 325 y 600 s 100 T 0;108 1 bw 100 i go_stone_white.png ay 0.5 v 1 ax 0.5 x 175 y 600 bh 100;115 1 bw 105 i go_stone_white.png v 1 x 905 y 170 bh 105;109 1 bw 100 i go_stone_black.png ay 0.5 v 1 ax 0.5 x 1745 y 600 bh 100;116 1 bw 105 i go_stone_black.png v 1 x 1010 y 170 bh 105;114 1 bw 105 i go_stone_black.png v 1 x 800 y 170 bh 105;118 1 bw 105 i go_stone_black.png v 1 x 905 y 275 bh 105;107 1 f 0 ay 0.5 v 1 ff arial ax 0.5 x 1670 y 500 s 50 T Captured: z 20;111 1 f 0 ay 0.5 v 1 ff arial ax 0.5 x 1595 y 600 s 100 T 0;106 1 f 0 ay 0.5 v 1 ff arial ax 0.5 x 250 y 500 s 50 T Captured: z 20;117 1 bw 105 i go_stone_white.png v 1 x 800 y 275 bh 105;112 1 bw 950 i go_board_9x9.png v 1 x 485 y 65 bh 950;105 1 bw 1920 i background_points.png ay 0 v 1 ax 0 bh 1080;120 1 bw 105 i go_stone_black.png v 1 x 1115 y 275 bh 105;113 1 bw 105 i go_stone_white.png v 1 x 1010 y 65 bh 105\"}\\n','KEY_FRAME 9\\n{\"entitymodule\":\"CS;T;T;S;S;T;T;S;S;S;S;S;S;S;S;S;S\\\\nU126 1 f 0 ay 0.5 v 1 ff arial ax 0.5 x 325 y 600 s 100 T 0;125 1 bw 100 i go_stone_black.png ay 0.5 v 1 ax 0.5 x 1745 y 600 bh 100;131 1 bw 105 i go_stone_white.png v 1 x 905 y 170 bh 105;128 1 bw 950 i go_board_9x9.png v 1 x 485 y 65 bh 950;121 1 bw 1920 i background_points.png ay 0 v 1 ax 0 bh 1080;134 1 bw 105 i go_stone_black.png v 1 x 905 y 275 bh 105;129 1 bw 105 i go_stone_white.png v 1 x 1010 y 65 bh 105;133 1 bw 105 i go_stone_white.png v 1 x 800 y 275 bh 105;127 1 f 0 ay 0.5 v 1 ff arial ax 0.5 x 1595 y 600 s 100 T 0;137 1 bw 105 i go_stone_black.png v 1 x 800 y 380 bh 105;123 1 f 0 ay 0.5 v 1 ff arial ax 0.5 x 1670 y 500 s 50 T Captured: z 20;132 1 bw 105 i go_stone_black.png v 1 x 1010 y 170 bh 105;136 1 bw 105 i go_stone_black.png v 1 x 1115 y 275 bh 105;124 1 bw 100 i go_stone_white.png ay 0.5 v 1 ax 0.5 x 175 y 600 bh 100;135 1 bw 105 i go_stone_white.png v 1 x 1010 y 275 bh 105;130 1 bw 105 i go_stone_black.png v 1 x 800 y 170 bh 105;122 1 f 0 ay 0.5 v 1 ff arial ax 0.5 x 250 y 500 s 50 T Captured: z 20\"}\\n','KEY_FRAME 10\\n{\"entitymodule\":\"CS;T;T;S;S;T;T;S;S;S;S;S;S;S;S;S;S\\\\nU145 1 bw 950 i go_board_9x9.png v 1 x 485 y 65 bh 950;139 1 f 0 ay 0.5 v 1 ff arial ax 0.5 x 250 y 500 s 50 T Captured: z 20;152 1 bw 105 i go_stone_white.png v 1 x 1010 y 275 bh 105;138 1 bw 1920 i background_points.png ay 0 v 1 ax 0 bh 1080;149 1 bw 105 i go_stone_white.png v 1 x 1115 y 170 bh 105;147 1 bw 105 i go_stone_black.png v 1 x 800 y 170 bh 105;151 1 bw 105 i go_stone_black.png v 1 x 905 y 275 bh 105;154 1 bw 105 i go_stone_black.png v 1 x 800 y 380 bh 105;148 1 bw 105 i go_stone_white.png v 1 x 905 y 170 bh 105;144 1 f 0 ay 0.5 v 1 ff arial ax 0.5 x 1595 y 600 s 100 T 1;150 1 bw 105 i go_stone_white.png v 1 x 800 y 275 bh 105;143 1 f 0 ay 0.5 v 1 ff arial ax 0.5 x 325 y 600 s 100 T 0;140 1 f 0 ay 0.5 v 1 ff arial ax 0.5 x 1670 y 500 s 50 T Captured: z 20;141 1 bw 100 i go_stone_white.png ay 0.5 v 1 ax 0.5 x 175 y 600 bh 100;146 1 bw 105 i go_stone_white.png v 1 x 1010 y 65 bh 105;153 1 bw 105 i go_stone_black.png v 1 x 1115 y 275 bh 105;142 1 bw 100 i go_stone_black.png ay 0.5 v 1 ax 0.5 x 1745 y 600 bh 100\"}\\n','KEY_FRAME 11\\n{\"entitymodule\":\"CS;T;T;S;S;T;T;S;S;S;S;S;S;S;S;S;S;S\\\\nU161 1 f 0 ay 0.5 v 1 ff arial ax 0.5 x 1595 y 600 s 100 T 1;158 1 bw 100 i go_stone_white.png ay 0.5 v 1 ax 0.5 x 175 y 600 bh 100;165 1 bw 105 i go_stone_white.png v 1 x 905 y 170 bh 105;171 1 bw 105 i go_stone_black.png v 1 x 800 y 380 bh 105;172 1 bw 105 i go_stone_black.png v 1 x 905 y 380 bh 105;156 1 f 0 ay 0.5 v 1 ff arial ax 0.5 x 250 y 500 s 50 T Captured: z 20;169 1 bw 105 i go_stone_white.png v 1 x 1010 y 275 bh 105;162 1 bw 950 i go_board_9x9.png v 1 x 485 y 65 bh 950;160 1 f 0 ay 0.5 v 1 ff arial ax 0.5 x 325 y 600 s 100 T 0;157 1 f 0 ay 0.5 v 1 ff arial ax 0.5 x 1670 y 500 s 50 T Captured: z 20;159 1 bw 100 i go_stone_black.png ay 0.5 v 1 ax 0.5 x 1745 y 600 bh 100;166 1 bw 105 i go_stone_white.png v 1 x 1115 y 170 bh 105;170 1 bw 105 i go_stone_black.png v 1 x 1115 y 275 bh 105;164 1 bw 105 i go_stone_black.png v 1 x 800 y 170 bh 105;163 1 bw 105 i go_stone_white.png v 1 x 1010 y 65 bh 105;168 1 bw 105 i go_stone_black.png v 1 x 905 y 275 bh 105;155 1 bw 1920 i background_points.png ay 0 v 1 ax 0 bh 1080;167 1 bw 105 i go_stone_white.png v 1 x 800 y 275 bh 105\"}\\n','KEY_FRAME 12\\n{\"entitymodule\":\"CS;T;T;S;S;T;T;S;S;S;S;S;S;S;S;S;S;S;S\\\\nU185 1 bw 105 i go_stone_white.png v 1 x 800 y 275 bh 105;182 1 bw 105 i go_stone_black.png v 1 x 800 y 170 bh 105;190 1 bw 105 i go_stone_black.png v 1 x 800 y 380 bh 105;174 1 f 0 ay 0.5 v 1 ff arial ax 0.5 x 250 y 500 s 50 T Captured: z 20;187 1 bw 105 i go_stone_white.png v 1 x 1010 y 275 bh 105;181 1 bw 105 i go_stone_white.png v 1 x 1010 y 65 bh 105;176 1 bw 100 i go_stone_white.png ay 0.5 v 1 ax 0.5 x 175 y 600 bh 100;183 1 bw 105 i go_stone_white.png v 1 x 905 y 170 bh 105;191 1 bw 105 i go_stone_black.png v 1 x 905 y 380 bh 105;177 1 bw 100 i go_stone_black.png ay 0.5 v 1 ax 0.5 x 1745 y 600 bh 100;179 1 f 0 ay 0.5 v 1 ff arial ax 0.5 x 1595 y 600 s 100 T 1;189 1 bw 105 i go_stone_white.png v 1 x 695 y 380 bh 105;175 1 f 0 ay 0.5 v 1 ff arial ax 0.5 x 1670 y 500 s 50 T Captured: z 20;188 1 bw 105 i go_stone_black.png v 1 x 1115 y 275 bh 105;178 1 f 0 ay 0.5 v 1 ff arial ax 0.5 x 325 y 600 s 100 T 0;186 1 bw 105 i go_stone_black.png v 1 x 905 y 275 bh 105;180 1 bw 950 i go_board_9x9.png v 1 x 485 y 65 bh 950;184 1 bw 105 i go_stone_white.png v 1 x 1115 y 170 bh 105;173 1 bw 1920 i background_points.png ay 0 v 1 ax 0 bh 1080\"}\\n','KEY_FRAME 13\\n{\"entitymodule\":\"CS;T;T;S;S;T;T;S;S;S;S;S;S;S;S;S;S;S;S;S\\\\nU208 1 bw 105 i go_stone_white.png v 1 x 695 y 380 bh 105;199 1 bw 950 i go_board_9x9.png v 1 x 485 y 65 bh 950;192 1 bw 1920 i background_points.png ay 0 v 1 ax 0 bh 1080;206 1 bw 105 i go_stone_white.png v 1 x 1010 y 275 bh 105;210 1 bw 105 i go_stone_black.png v 1 x 905 y 380 bh 105;194 1 f 0 ay 0.5 v 1 ff arial ax 0.5 x 1670 y 500 s 50 T Captured: z 20;211 1 bw 105 i go_stone_black.png v 1 x 485 y 590 bh 105;202 1 bw 105 i go_stone_white.png v 1 x 905 y 170 bh 105;193 1 f 0 ay 0.5 v 1 ff arial ax 0.5 x 250 y 500 s 50 T Captured: z 20;200 1 bw 105 i go_stone_white.png v 1 x 1010 y 65 bh 105;209 1 bw 105 i go_stone_black.png v 1 x 800 y 380 bh 105;207 1 bw 105 i go_stone_black.png v 1 x 1115 y 275 bh 105;204 1 bw 105 i go_stone_white.png v 1 x 800 y 275 bh 105;201 1 bw 105 i go_stone_black.png v 1 x 800 y 170 bh 105;196 1 bw 100 i go_stone_black.png ay 0.5 v 1 ax 0.5 x 1745 y 600 bh 100;203 1 bw 105 i go_stone_white.png v 1 x 1115 y 170 bh 105;198 1 f 0 ay 0.5 v 1 ff arial ax 0.5 x 1595 y 600 s 100 T 1;205 1 bw 105 i go_stone_black.png v 1 x 905 y 275 bh 105;195 1 bw 100 i go_stone_white.png ay 0.5 v 1 ax 0.5 x 175 y 600 bh 100;197 1 f 0 ay 0.5 v 1 ff arial ax 0.5 x 325 y 600 s 100 T 0\"}\\n','KEY_FRAME 14\\n{\"entitymodule\":\"CS;T;T;S;S;T;T;S;S;S;S;S;S;S;S;S;S;S;S;S;S\\\\nU226 1 bw 105 i go_stone_white.png v 1 x 1010 y 275 bh 105;216 1 bw 100 i go_stone_black.png ay 0.5 v 1 ax 0.5 x 1745 y 600 bh 100;225 1 bw 105 i go_stone_black.png v 1 x 905 y 275 bh 105;217 1 f 0 ay 0.5 v 1 ff arial ax 0.5 x 325 y 600 s 100 T 0;213 1 f 0 ay 0.5 v 1 ff arial ax 0.5 x 250 y 500 s 50 T Captured: z 20;223 1 bw 105 i go_stone_white.png v 1 x 1115 y 170 bh 105;231 1 bw 105 i go_stone_black.png v 1 x 485 y 590 bh 105;228 1 bw 105 i go_stone_white.png v 1 x 695 y 380 bh 105;227 1 bw 105 i go_stone_black.png v 1 x 1115 y 275 bh 105;215 1 bw 100 i go_stone_white.png ay 0.5 v 1 ax 0.5 x 175 y 600 bh 100;232 1 bw 105 i go_stone_white.png v 1 x 485 y 695 bh 105;224 1 bw 105 i go_stone_white.png v 1 x 800 y 275 bh 105;218 1 f 0 ay 0.5 v 1 ff arial ax 0.5 x 1595 y 600 s 100 T 1;219 1 bw 950 i go_board_9x9.png v 1 x 485 y 65 bh 950;212 1 bw 1920 i background_points.png ay 0 v 1 ax 0 bh 1080;229 1 bw 105 i go_stone_black.png v 1 x 800 y 380 bh 105;222 1 bw 105 i go_stone_white.png v 1 x 905 y 170 bh 105;214 1 f 0 ay 0.5 v 1 ff arial ax 0.5 x 1670 y 500 s 50 T Captured: z 20;230 1 bw 105 i go_stone_black.png v 1 x 905 y 380 bh 105;221 1 bw 105 i go_stone_black.png v 1 x 800 y 170 bh 105;220 1 bw 105 i go_stone_white.png v 1 x 1010 y 65 bh 105\"}\\n','KEY_FRAME 15\\n{\"entitymodule\":\"CS;T;T;S;S;T;T;S;S;S;S;S;S;S;S;S;S;S;S;S;S;S\\\\nU249 1 bw 105 i go_stone_white.png v 1 x 695 y 380 bh 105;240 1 bw 950 i go_board_9x9.png v 1 x 485 y 65 bh 950;251 1 bw 105 i go_stone_black.png v 1 x 905 y 380 bh 105;245 1 bw 105 i go_stone_white.png v 1 x 800 y 275 bh 105;246 1 bw 105 i go_stone_black.png v 1 x 905 y 275 bh 105;243 1 bw 105 i go_stone_white.png v 1 x 905 y 170 bh 105;253 1 bw 105 i go_stone_black.png v 1 x 590 y 590 bh 105;235 1 f 0 ay 0.5 v 1 ff arial ax 0.5 x 1670 y 500 s 50 T Captured: z 20;247 1 bw 105 i go_stone_white.png v 1 x 1010 y 275 bh 105;239 1 f 0 ay 0.5 v 1 ff arial ax 0.5 x 1595 y 600 s 100 T 1;237 1 bw 100 i go_stone_black.png ay 0.5 v 1 ax 0.5 x 1745 y 600 bh 100;248 1 bw 105 i go_stone_black.png v 1 x 1115 y 275 bh 105;252 1 bw 105 i go_stone_black.png v 1 x 485 y 590 bh 105;233 1 bw 1920 i background_points.png ay 0 v 1 ax 0 bh 1080;241 1 bw 105 i go_stone_white.png v 1 x 1010 y 65 bh 105;242 1 bw 105 i go_stone_black.png v 1 x 800 y 170 bh 105;250 1 bw 105 i go_stone_black.png v 1 x 800 y 380 bh 105;244 1 bw 105 i go_stone_white.png v 1 x 1115 y 170 bh 105;236 1 bw 100 i go_stone_white.png ay 0.5 v 1 ax 0.5 x 175 y 600 bh 100;254 1 bw 105 i go_stone_white.png v 1 x 485 y 695 bh 105;234 1 f 0 ay 0.5 v 1 ff arial ax 0.5 x 250 y 500 s 50 T Captured: z 20;238 1 f 0 ay 0.5 v 1 ff arial ax 0.5 x 325 y 600 s 100 T 0\"}\\n','KEY_FRAME 16\\n{\"entitymodule\":\"CS;T;T;S;S;T;T;S;S;S;S;S;S;S;S;S;S;S;S;S;S;S;S\\\\nU257 1 f 0 ay 0.5 v 1 ff arial ax 0.5 x 1670 y 500 s 50 T Captured: z 20;263 1 bw 105 i go_stone_white.png v 1 x 1010 y 65 bh 105;272 1 bw 105 i go_stone_black.png v 1 x 800 y 380 bh 105;276 1 bw 105 i go_stone_black.png v 1 x 590 y 590 bh 105;265 1 bw 105 i go_stone_white.png v 1 x 905 y 170 bh 105;260 1 f 0 ay 0.5 v 1 ff arial ax 0.5 x 325 y 600 s 100 T 0;274 1 bw 105 i go_stone_white.png v 1 x 1115 y 380 bh 105;269 1 bw 105 i go_stone_white.png v 1 x 1010 y 275 bh 105;273 1 bw 105 i go_stone_black.png v 1 x 905 y 380 bh 105;275 1 bw 105 i go_stone_black.png v 1 x 485 y 590 bh 105;256 1 f 0 ay 0.5 v 1 ff arial ax 0.5 x 250 y 500 s 50 T Captured: z 20;264 1 bw 105 i go_stone_black.png v 1 x 800 y 170 bh 105;262 1 bw 950 i go_board_9x9.png v 1 x 485 y 65 bh 950;266 1 bw 105 i go_stone_white.png v 1 x 1115 y 170 bh 105;270 1 bw 105 i go_stone_black.png v 1 x 1115 y 275 bh 105;259 1 bw 100 i go_stone_black.png ay 0.5 v 1 ax 0.5 x 1745 y 600 bh 100;268 1 bw 105 i go_stone_black.png v 1 x 905 y 275 bh 105;258 1 bw 100 i go_stone_white.png ay 0.5 v 1 ax 0.5 x 175 y 600 bh 100;267 1 bw 105 i go_stone_white.png v 1 x 800 y 275 bh 105;271 1 bw 105 i go_stone_white.png v 1 x 695 y 380 bh 105;261 1 f 0 ay 0.5 v 1 ff arial ax 0.5 x 1595 y 600 s 100 T 1;277 1 bw 105 i go_stone_white.png v 1 x 485 y 695 bh 105;255 1 bw 1920 i background_points.png ay 0 v 1 ax 0 bh 1080\"}\\n','KEY_FRAME 17\\n{\"entitymodule\":\"CS;T;T;S;S;T;T;S;S;S;S;S;S;S;S;S;S;S;S;S;S;S;S\\\\nU281 1 bw 100 i go_stone_white.png ay 0.5 v 1 ax 0.5 x 175 y 600 bh 100;286 1 bw 105 i go_stone_white.png v 1 x 1010 y 65 bh 105;278 1 bw 1920 i background_points.png ay 0 v 1 ax 0 bh 1080;299 1 bw 105 i go_stone_black.png v 1 x 590 y 590 bh 105;296 1 bw 105 i go_stone_black.png v 1 x 905 y 380 bh 105;294 1 bw 105 i go_stone_white.png v 1 x 695 y 380 bh 105;285 1 bw 950 i go_board_9x9.png v 1 x 485 y 65 bh 950;284 1 f 0 ay 0.5 v 1 ff arial ax 0.5 x 1595 y 600 s 100 T 1;297 1 bw 105 i go_stone_white.png v 1 x 1115 y 380 bh 105;289 1 bw 105 i go_stone_white.png v 1 x 1115 y 170 bh 105;292 1 bw 105 i go_stone_white.png v 1 x 1010 y 275 bh 105;293 1 bw 105 i go_stone_black.png v 1 x 1115 y 275 bh 105;291 1 bw 105 i go_stone_black.png v 1 x 905 y 275 bh 105;288 1 bw 105 i go_stone_white.png v 1 x 905 y 170 bh 105;298 1 bw 105 i go_stone_black.png v 1 x 485 y 590 bh 105;283 1 f 0 ay 0.5 v 1 ff arial ax 0.5 x 325 y 600 s 100 T 1;280 1 f 0 ay 0.5 v 1 ff arial ax 0.5 x 1670 y 500 s 50 T Captured: z 20;300 1 bw 105 i go_stone_white.png v 1 x 485 y 695 bh 105;295 1 bw 105 i go_stone_black.png v 1 x 800 y 380 bh 105;279 1 f 0 ay 0.5 v 1 ff arial ax 0.5 x 250 y 500 s 50 T Captured: z 20;282 1 bw 100 i go_stone_black.png ay 0.5 v 1 ax 0.5 x 1745 y 600 bh 100;287 1 bw 105 i go_stone_black.png v 1 x 800 y 170 bh 105;290 1 bw 105 i go_stone_black.png v 1 x 695 y 275 bh 105\"}\\n','KEY_FRAME 18\\n{\"entitymodule\":\"CS;T;T;S;S;T;T;S;S;S;S;S;S;S;S;S;S;S;S;S;S;S;S;S\\\\nU303 1 f 0 ay 0.5 v 1 ff arial ax 0.5 x 1670 y 500 s 50 T Captured: z 20;323 1 bw 105 i go_stone_black.png v 1 x 590 y 590 bh 105;319 1 bw 105 i go_stone_black.png v 1 x 905 y 380 bh 105;315 1 bw 105 i go_stone_white.png v 1 x 1010 y 275 bh 105;318 1 bw 105 i go_stone_black.png v 1 x 800 y 380 bh 105;304 1 bw 100 i go_stone_white.png ay 0.5 v 1 ax 0.5 x 175 y 600 bh 100;307 1 f 0 ay 0.5 v 1 ff arial ax 0.5 x 1595 y 600 s 100 T 1;321 1 bw 105 i go_stone_white.png v 1 x 485 y 485 bh 105;309 1 bw 105 i go_stone_white.png v 1 x 1010 y 65 bh 105;324 1 bw 105 i go_stone_white.png v 1 x 485 y 695 bh 105;317 1 bw 105 i go_stone_white.png v 1 x 695 y 380 bh 105;320 1 bw 105 i go_stone_white.png v 1 x 1115 y 380 bh 105;306 1 f 0 ay 0.5 v 1 ff arial ax 0.5 x 325 y 600 s 100 T 1;302 1 f 0 ay 0.5 v 1 ff arial ax 0.5 x 250 y 500 s 50 T Captured: z 20;322 1 bw 105 i go_stone_black.png v 1 x 485 y 590 bh 105;310 1 bw 105 i go_stone_black.png v 1 x 800 y 170 bh 105;313 1 bw 105 i go_stone_black.png v 1 x 695 y 275 bh 105;311 1 bw 105 i go_stone_white.png v 1 x 905 y 170 bh 105;314 1 bw 105 i go_stone_black.png v 1 x 905 y 275 bh 105;305 1 bw 100 i go_stone_black.png ay 0.5 v 1 ax 0.5 x 1745 y 600 bh 100;301 1 bw 1920 i background_points.png ay 0 v 1 ax 0 bh 1080;308 1 bw 950 i go_board_9x9.png v 1 x 485 y 65 bh 950;312 1 bw 105 i go_stone_white.png v 1 x 1115 y 170 bh 105;316 1 bw 105 i go_stone_black.png v 1 x 1115 y 275 bh 105\"}\\n','KEY_FRAME 19\\n{\"entitymodule\":\"CS;T;T;S;S;T;T;S;S;S;S;S;S;S;S;S;S;S;S;S;S;S;S;S;S\\\\nU339 1 bw 105 i go_stone_black.png v 1 x 905 y 275 bh 105;335 1 bw 105 i go_stone_white.png v 1 x 905 y 170 bh 105;343 1 bw 105 i go_stone_black.png v 1 x 800 y 380 bh 105;330 1 f 0 ay 0.5 v 1 ff arial ax 0.5 x 325 y 600 s 100 T 1;345 1 bw 105 i go_stone_white.png v 1 x 1115 y 380 bh 105;326 1 f 0 ay 0.5 v 1 ff arial ax 0.5 x 250 y 500 s 50 T Captured: z 20;329 1 bw 100 i go_stone_black.png ay 0.5 v 1 ax 0.5 x 1745 y 600 bh 100;334 1 bw 105 i go_stone_black.png v 1 x 800 y 170 bh 105;341 1 bw 105 i go_stone_black.png v 1 x 1115 y 275 bh 105;333 1 bw 105 i go_stone_white.png v 1 x 1010 y 65 bh 105;349 1 bw 105 i go_stone_white.png v 1 x 485 y 695 bh 105;347 1 bw 105 i go_stone_black.png v 1 x 485 y 590 bh 105;346 1 bw 105 i go_stone_white.png v 1 x 485 y 485 bh 105;340 1 bw 105 i go_stone_white.png v 1 x 1010 y 275 bh 105;344 1 bw 105 i go_stone_black.png v 1 x 905 y 380 bh 105;338 1 bw 105 i go_stone_black.png v 1 x 800 y 275 bh 105;342 1 bw 105 i go_stone_white.png v 1 x 695 y 380 bh 105;336 1 bw 105 i go_stone_white.png v 1 x 1115 y 170 bh 105;337 1 bw 105 i go_stone_black.png v 1 x 695 y 275 bh 105;327 1 f 0 ay 0.5 v 1 ff arial ax 0.5 x 1670 y 500 s 50 T Captured: z 20;348 1 bw 105 i go_stone_black.png v 1 x 590 y 590 bh 105;332 1 bw 950 i go_board_9x9.png v 1 x 485 y 65 bh 950;325 1 bw 1920 i background_points.png ay 0 v 1 ax 0 bh 1080;331 1 f 0 ay 0.5 v 1 ff arial ax 0.5 x 1595 y 600 s 100 T 1;328 1 bw 100 i go_stone_white.png ay 0.5 v 1 ax 0.5 x 175 y 600 bh 100\"}\\n','KEY_FRAME 20\\n{\"entitymodule\":\"CS;T;T;S;S;T;T;S;S;S;S;S;S;S;S;S;S;S;S;S;S;S;S;S;S;S\\\\nU368 1 bw 105 i go_stone_white.png v 1 x 695 y 380 bh 105;355 1 f 0 ay 0.5 v 1 ff arial ax 0.5 x 325 y 600 s 100 T 1;353 1 bw 100 i go_stone_white.png ay 0.5 v 1 ax 0.5 x 175 y 600 bh 100;375 1 bw 105 i go_stone_white.png v 1 x 485 y 695 bh 105;360 1 bw 105 i go_stone_black.png v 1 x 800 y 170 bh 105;372 1 bw 105 i go_stone_white.png v 1 x 485 y 485 bh 105;369 1 bw 105 i go_stone_black.png v 1 x 800 y 380 bh 105;374 1 bw 105 i go_stone_black.png v 1 x 590 y 590 bh 105;356 1 f 0 ay 0.5 v 1 ff arial ax 0.5 x 1595 y 600 s 100 T 1;361 1 bw 105 i go_stone_white.png v 1 x 905 y 170 bh 105;373 1 bw 105 i go_stone_black.png v 1 x 485 y 590 bh 105;350 1 bw 1920 i background_points.png ay 0 v 1 ax 0 bh 1080;371 1 bw 105 i go_stone_white.png v 1 x 1115 y 380 bh 105;364 1 bw 105 i go_stone_black.png v 1 x 800 y 275 bh 105;357 1 bw 950 i go_board_9x9.png v 1 x 485 y 65 bh 950;370 1 bw 105 i go_stone_black.png v 1 x 905 y 380 bh 105;366 1 bw 105 i go_stone_white.png v 1 x 1010 y 275 bh 105;354 1 bw 100 i go_stone_black.png ay 0.5 v 1 ax 0.5 x 1745 y 600 bh 100;358 1 bw 105 i go_stone_white.png v 1 x 800 y 65 bh 105;362 1 bw 105 i go_stone_white.png v 1 x 1115 y 170 bh 105;359 1 bw 105 i go_stone_white.png v 1 x 1010 y 65 bh 105;367 1 bw 105 i go_stone_black.png v 1 x 1115 y 275 bh 105;365 1 bw 105 i go_stone_black.png v 1 x 905 y 275 bh 105;363 1 bw 105 i go_stone_black.png v 1 x 695 y 275 bh 105;352 1 f 0 ay 0.5 v 1 ff arial ax 0.5 x 1670 y 500 s 50 T Captured: z 20;351 1 f 0 ay 0.5 v 1 ff arial ax 0.5 x 250 y 500 s 50 T Captured: z 20\",\"endScreen\":[null,\"logo.png\",null]}\\n'],agents:[{index:0,name:\"Player 0\",avatar:\"https://static.codingame.com/servlet/fileservlet?id=16085713250612&format=viewer_avatar\",agentId:0},{index:1,name:\"Player 1\",avatar:\"https://static.codingame.com/servlet/fileservlet?id=16085756802960&format=viewer_avatar\",agentId:1}]};function On(t){return(On=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&\"function\"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?\"symbol\":typeof t})(t)}function Un(t){var e=\"function\"==typeof Map?new Map:void 0;return(Un=function(t){if(null===t||(n=t,-1===Function.toString.call(n).indexOf(\"[native code]\")))return t;var n;if(\"function\"!=typeof t)throw new TypeError(\"Super expression must either be null or a function\");if(void 0!==e){if(e.has(t))return e.get(t);e.set(t,r)}function r(){return kn(t,arguments,Pn(this).constructor)}return r.prototype=Object.create(t.prototype,{constructor:{value:r,enumerable:!1,writable:!0,configurable:!0}}),Rn(r,t)})(t)}function kn(t,e,n){return(kn=Tn()?Reflect.construct:function(t,e,n){var r=[null];r.push.apply(r,e);var o=new(Function.bind.apply(t,r));return n&&Rn(o,n.prototype),o}).apply(null,arguments)}function Tn(){if(\"undefined\"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if(\"function\"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],(function(){}))),!0}catch(t){return!1}}function Rn(t,e){return(Rn=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t})(t,e)}function Pn(t){return(Pn=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}var En=function(){!function(t,e){if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function\");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&Rn(t,e)}(e,Un(Error));var t=function(t){var e=Tn();return function(){var n,r,o,i=Pn(t);return r=this,!(o=e?(n=Pn(this).constructor,Reflect.construct(i,arguments,n)):i.apply(this,arguments))||\"object\"!==On(o)&&\"function\"!=typeof o?function(t){if(void 0!==t)return t;throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\")}(r):o}}(e);function e(n,r){var o;return function(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}(this,e),(o=t.call(this,'<Error in module \"'+n+'\">')).cause=r,o.name=\"ModuleError\",o}return e}();function jn(t,e){var n,r=Object.keys(t);return Object.getOwnPropertySymbols&&(n=Object.getOwnPropertySymbols(t),e&&(n=n.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),r.push.apply(r,n)),r}function Dn(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?jn(Object(n),!0).forEach((function(e){var r,o,i;r=t,i=n[o=e],o in r?Object.defineProperty(r,o,{value:i,enumerable:!0,configurable:!0,writable:!0}):r[o]=i})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):jn(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}function An(t,e){(null==e||e>t.length)&&(e=t.length);for(var n=0,r=new Array(e);n<e;n++)r[n]=t[n];return r}function Fn(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}var Mn=function(){function t(e){!function(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}(this,t),this.toDestroy=[],this.stepByStepAnimateSpeed=null;var n,r,o=e||Cn;o?(n=o.views,r=o.agents,this.demo={playerCount:r.length,logo:\"logo.png\",overlayAlpha:.2,agents:r,frames:n},this.demo.agents.forEach((function(e){e.color=t.playerColors[e.index]}))):this.demo=wn}var e,n,o;return e=t,o=[{key:\"getGameRatio\",value:function(){return t.WIDTH/t.HEIGHT}},{key:\"requirements\",get:function(){return{PIXI:\"PIXI4\"}}},{key:\"VERSION\",get:function(){return 2}},{key:\"WIDTH\",get:function(){return 1920}},{key:\"HEIGHT\",get:function(){return 1080}},{key:\"playerColors\",get:function(){return _n}},{key:\"SDK_GAME\",get:function(){return!0}},{key:\"RenderTimeout\",get:function(){return\"localhost\"===window.location.hostname?1/0:2e4}}],(n=[{key:\"getDefaultOverSampling\",value:function(){return 2}},{key:\"handleModuleError\",value:function(t,e){l.push(new En(t,e)),console.error(e),l.push({message:'<Module \"'.concat(t,'\" disabled>\\n')}),delete this.modules[t]}},{key:\"instantiateModules\",value:function(){this.modules={};var t,e=function(t,e){var n;if(\"undefined\"==typeof Symbol||null==t[Symbol.iterator]){if(Array.isArray(t)||(n=function(t,e){if(t){if(\"string\"==typeof t)return An(t,e);var n=Object.prototype.toString.call(t).slice(8,-1);return\"Object\"===n&&t.constructor&&(n=t.constructor.name),\"Map\"===n||\"Set\"===n?Array.from(t):\"Arguments\"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)?An(t,e):void 0}}(t))||e&&t&&\"number\"==typeof t.length){n&&(t=n);var r=0,o=function(){};return{s:o,n:function(){return r>=t.length?{done:!0}:{done:!1,value:t[r++]}},e:function(t){throw t},f:o}}throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\")}var i,a=!0,s=!1;return{s:function(){n=t[Symbol.iterator]()},n:function(){var t=n.next();return a=t.done,t},e:function(t){s=!0,i=t},f:function(){try{a||null==n.return||n.return()}finally{if(s)throw i}}}}(Sn);try{for(e.s();!(t=e.n()).done;){var n=t.value;try{this.modules[n.name]=new n(r)}catch(t){this.handleModuleError(n.name,t)}}}catch(t){e.e(t)}finally{e.f()}}},{key:\"destroy\",value:function(){this.alreadyLoaded&&(this.renderer.destroy(),this.endCallback=null),this.destroyed=!0}},{key:\"destroyScene\",value:function(){!function(){for(var t=0,e=be.length;t<e;++t)be[t].destroy(!0);be=[]}()}},{key:\"getGameName\",value:function(){return\"Atari Go\"}},{key:\"canSwapPlayers\",value:function(){return!1}},{key:\"addErrorListener\",value:function(t){l.listen(t)}},{key:\"getResources\",value:function(){return Object.assign({baseUrl:\"\",images:{},spines:{},sprites:[],fonts:[],others:[]},r)}},{key:\"getOptions\",value:function(){return[]}},{key:\"setDebug\",value:function(){this.asyncRenderingTime=t.RenderTimeout}},{key:\"initPreload\",value:function(t,e,n,r,o){t.canvasWidth=r,t.canvasHeight=o,t.loaderProgress=new PIXI.Text(\"100\",{fontSize:.117*o||30,fontFamily:\"Lato\",fontWeight:\"900\",fill:\"white\",align:\"center\"}),t.loaderProgress.anchor.y=1,t.loaderProgress.anchor.x=1.3,t.progress=t.realProgress=n,t.loaderProgress.position.y=o,t.progressBar=new PIXI.Graphics,e.addChild(t.progressBar),e.addChild(t.loaderProgress)}},{key:\"preload\",value:function(t,e,n){t.progress=n}},{key:\"renderPreloadScene\",value:function(t,e){var n=Math.pow(.998,e);return t.realProgress=n*t.realProgress+(1-n)*t.progress,t.loaderProgress.text=(100*t.realProgress).toFixed(0),t.loaderProgress.position.x=t.realProgress*t.canvasWidth,t.progressBar.clear(),t.progressBar.beginFill(0,1),t.progressBar.drawRect(0,0,t.canvasWidth*t.realProgress+1,t.canvasHeight),t.progressBar.endFill(),t.progressBar.beginFill(4146246,1),t.progressBar.drawRect(t.canvasWidth*t.realProgress,0,t.canvasWidth,t.canvasHeight),t.progressBar.endFill(),!0}},{key:\"initDefaultScene\",value:function(e,n){var r=new PIXI.Container;if(e.drawer=this,e.time=0,this.demo){if(this.demo.logo)try{var o=PIXI.Sprite.fromFrame(this.demo.logo);o.position.set(t.WIDTH/2,t.HEIGHT/2),o.anchor.set(.5),o.baseScale=a(o.texture.width,o.texture.height,2*t.WIDTH/3,t.HEIGHT/2,0),r.addChild(o),e.logo=o}catch(n){l.push({cause:n,message:'Missing \"logo.png\" to complete replay.'}),e.logo=new PIXI.Container,e.logo.baseScale=1,r.addChild(e.logo),e.missingLogo=!0}var i=new PIXI.Graphics;e.missingLogo||(i.beginFill(0,this.demo.overlayAlpha||0),i.drawRect(0,0,t.WIDTH+20,t.HEIGHT+20),i.endFill(),i.x-=10,i.y-=10);var s=new PIXI.Container;try{this.initDefaultFrames(this.demo.playerCount,this.demo.frames,this.demo.agents),this.preconstructScene(this.scope,n,this.initWidth,this.initHeight),this.initScene(this.scope,s,this.frames,!0),this.updateScene(this.scope,this.question,this.frames,this.currentFrame,this.progress,1,this.reasons[this.currentFrame],!0)}catch(n){l.push({cause:n,message:\"Cannot load demo, you might want to reset the demo\"})}e.demo=s,e.demotime=0,this.currentFrame=-1,n.addChild(s),n.addChild(i),n.addChild(r)}e.updateTime=0,e.frameTime=0}},{key:\"initDefaultFrames\",value:function(e,n,r){var o=this;this.instantiateModules(),this.playerInfo=r.map((function(t,e){return{name:t.name||\"Anonymous\",color:t.color?o.parseColor(t.color):\"#ffffff\",number:e,index:t.index,type:t.type,isMe:\"CODINGAMER\"===t.type&&t.typeData.me,avatar:t.avatarTexture}})),this.instantiateModules(),this._frames=n.map((function(t){var e,n=t.split(\"\\n\"),r=n[0].split(\" \");try{e=JSON.parse(n.slice(1).join(\"\\n\"))}catch(t){e={}}return Dn(Dn({},e),{},{key:\"KEY_FRAME\"===r[0]})})).filter((function(t){return t.key})),this.parseGlobalData(this._frames[0].global),this.playerCount=e,this.reasons=[],this.frames=[],this.currentFrame=0,this.currentFrameDuration=1e3,this.progress=1;var i=this._frames[0].frame;i.key=this._frames[0].key,this.frames.push(this.parseFrame(i,this.frames));for(var a=1;a<this._frames.length;++a)this.frames.push(this.parseFrame(this._frames[a],this.frames));this.asyncRenderingTime=t.RenderTimeout}},{key:\"renderDefaultScene\",value:function(t,e){if(e=Math.min(80,e),void 0===this.demo)return!1;this.currentFrame=this.currentFrameTemp||0,t.frameTime+=e,t.updateTime+=e,t.demotime+=e/1e3;var n,r=Math.max(0,Math.min(1,(t.demotime-1)/.5));t.logo&&(t.logo.alpha=r,t.logo.scale.x=t.logo.scale.y=(3-2*r)*t.logo.baseScale),!t.missingLogo&&1.5<t.demotime&&t.demotime<=2.2?(n=15*Math.max(0,1-(t.demotime-1.5)/.7),t.demo.x=(2*Math.random()-1)*n,t.demo.y=(2*Math.random()-1)*n):t.demo.x=t.demo.y=0;var o=this.getFrameDuration(this.currentFrame);return 30<=t.updateTime&&(t.updateTime-=30,0===this.currentFrame?this.progress=1:this.progress=i(0,o,t.frameTime),this.updateScene(this.scope,this.question,this.frames,this.currentFrame,this.progress,1,this.reasons[this.currentFrame],!0)),t.frameTime>=o&&(t.frameTime-=o,this.currentFrame=(this.currentFrame+1)%this.frames.length),this.renderScene(this.scope,this.question,this.frames,this.currentFrame,this.progress,1,this.reasons[this.currentFrame],e,!0),this.currentFrameTemp=this.currentFrame,this.currentFrame=-1,!0}},{key:\"endDefaultScene\",value:function(){return!0}},{key:\"parseGlobalData\",value:function(t){for(var e in this.modules){var n=this.modules[e];\"function\"==typeof n.handleGlobalData&&n.handleGlobalData(this.playerInfo,t[e])}}},{key:\"parseFrame\",value:function(t,e){var n={data:{},frameInfo:{number:e.length}};if(n.previous=e[e.length-1]||n,n!==n.previous&&(n.previous.next=n),!t.key)return n.previous;for(var r in t.duration&&(this.currentFrameDuration=t.duration),n.frameInfo.frameDuration=this.currentFrameDuration,n===n.previous?(n.frameInfo.date=0,n.frameInfo.frameDuration=0):n.frameInfo.date=n.previous.frameInfo.date+n.previous.frameInfo.frameDuration,this.modules){var o=this.modules[r];\"function\"==typeof o.handleFrameData&&(n.data[r]=o.handleFrameData(n.frameInfo,t[r]))}return n}},{key:\"preconstructScene\",value:function(e,n,r,o){e.canvasHeight=o,e.canvasWidth=r,e.time=0,e.endTime=0,e.playerInfo=this.playerInfo,n.scale.x=r/t.WIDTH,n.scale.y=o/t.HEIGHT}},{key:\"initScene\",value:function(t,e){for(var n in this.modules){var r=this.modules[n],o=new PIXI.Container;try{r.reinitScene(o,{width:t.canvasWidth,height:t.canvasHeight,oversampling:this.oversampling})}catch(t){this.handleModuleError(n,t)}e.addChild(o)}}},{key:\"updateScene\",value:function(t,e,n,r,o,i,a,s,c){var u=n[r];if(!c&&this.stepByStepAnimateSpeed){if(this.checkSteppedToNextFrame(t,u,o))return void this.startAsynchronousAnimation(t,u);if(this.checkSteppedToPreviousFrame(t,u,o))return void this.startAsynchronousAnimation(t,t.currentFrame,!0);t.targetProgress=null}for(var l in t.currentFrame=u,t.currentProgress=o,t.reason=a,this.modules){var f=this.modules[l];if(u.data.hasOwnProperty(l))try{f.updateScene(u.previous.data[l],u.data[l],o,i)}catch(t){this.handleModuleError(l,t)}}}},{key:\"startAsynchronousAnimation\",value:function(t,e,n){var r=2<arguments.length&&void 0!==n&&n;t.targetProgress=r?0:1,r||1!==t.currentProgress||(t.currentProgress=0),t.currentFrame=e,t.reverseAsynchronousAnimation=r}},{key:\"checkStepped\",value:function(t,e,n){return t.currentFrame&&0===this.speed&&1===n}},{key:\"checkSteppedToNextFrame\",value:function(t,e,n){return this.checkStepped(t,e,n)&&(t.currentFrame===e.previous&&t.currentFrame!==e||t.currentFrame===e&&t.currentProgress!==n)}},{key:\"checkSteppedToPreviousFrame\",value:function(t,e,n){return this.checkStepped(t,e,n)&&t.currentFrame.previous===e&&t.currentFrame!==e}},{key:\"initEndScene\",value:function(t){t.endSceneViewed=!1}},{key:\"destroyEndScene\",value:function(){}},{key:\"renderEndScene\",value:function(t,e,n){0===t.endTime&&this.initEndScene(t,n),t.endTime+=e,void 0<=t.endTime&&!t.endSceneViewed&&(this.endCallback&&this.endCallback(),t.endSceneViewed=!0)}},{key:\"renderScene\",value:function(t,e,n,r,o,i,a,s){s=Math.min(80,s);var c,u,l,f=!this.debugMode&&r===n.length-1&&1===o;for(var y in f?this.renderEndScene(t,s,\"Win\"!==a):(0<t.endTime&&this.destroyEndScene(t),t.endTime=0),this.stepByStepAnimateSpeed&&this.isAsynchronousAnimationOngoing(t)&&(c=this.currentFrame,t.reverseAsynchronousAnimation&&c++,l=s/200*this.getFrameSpeed(c)*this.stepByStepAnimateSpeed,t.reverseAsynchronousAnimation?(u=t.currentProgress-l)<=0&&(c=this.currentFrame,u=1,t.targetProgress=1):(u=t.currentProgress+l,u=Math.min(t.targetProgress,u)),this.updateScene(this.scope,this.question,this.frames,c,u,this.speed,this.reasons[c],!1,!0)),this.modules){var p=this.modules[y];if(\"function\"==typeof p.animateScene)try{p.animateScene(s)}catch(t){this.handleModuleError(y,t)}}return!0}},{key:\"isAsynchronousAnimationOngoing\",value:function(t){return null!=t.targetProgress&&t.currentProgress!==t.targetProgress}},{key:\"getFrameSpeed\",value:function(t){return 500/this.getFrameDuration(t)}},{key:\"getFrameDuration\",value:function(t){return this.frames&&this.frames[t]&&this.frames[t].frameInfo.frameDuration||1e3}},{key:\"enableAsyncRendering\",value:function(e){this.asyncRendering=e,this.asyncRenderingTime=t.RenderTimeout}},{key:\"purge\",value:function(){this.scope={},this.changed=!0,this.container.interactiveChildren=!1,this.container.destroy({texture:!1,children:!0}),delete this.container,this.container=new PIXI.Container}},{key:\"reinitScene\",value:function(){1<=this.loaded&&(this.destroyScene(this.scope),this.purge(),this.asyncRenderingTime=t.RenderTimeout,this.preconstructScene(this.scope,this.container,this.initWidth,this.initHeight),this.initScene(this.scope,this.container,this.frames),this.updateScene(this.scope,this.question,this.frames,this.currentFrame,this.progress,this.speed,this.reasons[this.currentFrame]),this.changed=!0)}},{key:\"reinitDefaultScene\",value:function(){1<=this.loaded&&(this.intro=!0,this.destroyScene(this.scope),this.purge(),this.asyncRenderingTime=t.RenderTimeout,this.initDefaultScene(this.scope,this.container,this.initWidth,this.initHeight),this.changed=!0)}},{key:\"reinitLoadingScene\",value:function(){this.loaded<1&&(this.purge(),this.asyncRenderingTime=t.RenderTimeout,this.initPreload(this.scope,this.container,this.loaded,this.initWidth,this.initHeight))}},{key:\"reinit\",value:function(t){1<=this.loaded?0<=this.currentFrame&&!this.intro?this.reinitScene():this.intro&&!t||this.reinitDefaultScene():this.reinitLoadingScene()}},{key:\"animate\",value:function(t){var e;this.destroyed||(this.lastRenderTime||(this.lastRenderTime=t),e=t-this.lastRenderTime,this.asynchronousStep&&(e=this.asynchronousStep),this.onBeforeRender&&this.onBeforeRender(),this.loading||(this.loaded<1?this.changed|=this.renderPreloadScene(this.scope,e):(this.changed||this.asyncRendering&&0<this.asyncRenderingTime||this.isAsynchronousAnimationOngoing(this.scope))&&(this.currentFrame<0?this.changed|=this.renderDefaultScene(this.scope,e):this.intro?(this.changed=!0,this.endDefaultScene(this.scope,e)&&(this.intro=!1,this.reinit(!0))):this.changed|=this.renderScene(this.scope,this.question,this.frames,this.currentFrame,this.progress,this.speed,this.reasons[this.currentFrame],e)),this.changed&&(this.renderer.render(this.container),this.changed=!1)),this.onAfterRender&&this.onAfterRender(),this.lastRenderTime=t,this.destroyed||requestAnimationFrame(this.animate.bind(this)),this.asyncRenderingTime-=e)}},{key:\"_initFrames\",value:function(t,e){this.instantiateModules(),this._frames=e.map((function(t){var e,n=t[0].split(\" \");try{e=JSON.parse(t.slice(1).join(\"\\n\"))}catch(t){e={}}return Dn(Dn({},e),{},{key:\"KEY_FRAME\"===n[0]})})),this.parseGlobalData(this._frames[0].global),this.playerCount=t,this.reasons=[],this.frames=[],this.currentFrame=0,this.currentFrameDuration=1e3,this.progress=1;var n=this._frames[0].frame;n.key=this._frames[0].key,this.frames.push(this.parseFrame(n,this.frames));for(var r=1;r<this._frames.length;++r)this.frames.push(this.parseFrame(this._frames[r],this.frames))}},{key:\"isTurnBasedGame\",value:function(){return!1}},{key:\"initFrames\",value:function(t,e){this.playerInfo&&this.playerInfo.forEach((function(t){t.avatar&&t.avatar.destroy(!0)}));var n=this,r=new PIXI.loaders.Loader(window.location.origin);function o(){n._initFrames(e.length,t),n.loading=!1,n.reinit(!1),i=!0}this.playerInfo=e.map((function(t,e){var o={name:t.name||\"Anonymous\",color:t.color?n.parseColor(t.color):\"#ffffff\",number:e,index:t.index,type:t.type,isMe:\"CODINGAMER\"===t.type&&t.typeData.me,avatar:null};return null!=t.avatar&&r.add(\"avatar\"+e,t.avatar,{loadType:2,crossOrigin:!0},(function(t){o.avatar=t.texture,PIXI.Texture.addToCache(t.texture,\"$\"+o.index)})),o}));var i=!(this.loading=!0);r.on(\"complete\",o),r.on(\"error\",(function(t){console.warn(t),i||o()})),r.load()}},{key:\"update\",value:function(e,n,r){0<=this.currentFrame&&(this.asyncRenderingTime=t.RenderTimeout,this.changed=!0,this.speed=r,this.currentFrame=e,this.progress=n,1<=this.loaded&&!this.intro&&this.updateScene(this.scope,this.question,this.frames,e,n,this.speed,this.reasons[this.currentFrame]))}},{key:\"parseColor\",value:function(t){if(Array.isArray(t)){for(var e=[],n=0;n<t.length;++n)e.push(this.parseColor(t[n]));return e}return parseInt(t.substring(1),16)}},{key:\"init\",value:function(e,n,r,o,i,a,s){var c,u=this;function f(){0<=u.currentFrame&&(u.changed=!0)}window.PIXI=t.PIXI||window.PIXI,this.oversampling=i||1,this.canvas=$(e),this.canvas.off(\"mousemove\"),this.canvas.off(\"wheel\"),this.canvas.bind(\"wheel\",f),this.canvas.mousemove(f),o&&(this.colors=this.parseColor(o)),\"ide\"===s&&(this.debugModeSetByUser||(this.debugMode=!0),l.listen((function(t){return console.error(t.cause?t.cause:t)}))),this.asyncRendering=!0,this.asyncRenderingTime=0,this.destroyed=!1,this.asynchronousStep=null;var y,p=this;if(this.initWidth=0|n,this.initHeight=0|r,this.endCallback=a||this.endCallback,this.alreadyLoaded)this.changed=!0,this.renderer.resize(this.initWidth,this.initHeight),this.reinit(!0);else{this.alreadyLoaded=!0,this.question=null,this.scope=null,this.currentFrame=-1,this.loaded=0,this.container=new PIXI.Container;var h=this.getResources();this.renderer=this.createRenderer(this.initWidth,this.initHeight,e),y=this.renderer,he=y;var b,g=new PIXI.loaders.Loader(h.baseUrl);for(c in h.images)g.add(c,h.images[c],{crossOrigin:!0});for(b=0;b<h.sprites.length;++b)g.add(h.sprites[b],{crossOrigin:!0});for(b=0;b<h.fonts.length;++b)g.add(h.fonts[b],{crossOrigin:!0});for(c in h.spines)g.add(c,h.spines[c],{crossOrigin:!0});for(b=0;b<h.others.length;++b)g.add(h.others[b],{crossOrigin:!0});this.demo&&this.demo.agents.forEach((function(t){g.add(\"avatar\"+t.index,t.avatar,{loadType:2,crossOrigin:!0},(function(e){t.avatarTexture=e.texture,PIXI.Texture.addToCache(e.texture,\"$\"+t.index)}))})),p.scope={};var d=function(){requestAnimationFrame(p.animate.bind(p)),p.initPreload(p.scope,p.container,p.loaded=0,p.initWidth,p.initHeight)};g.on(\"start\",d),g.on(\"progress\",(function(t,e){t.progress<100&&p.preload(p.scope,p.container,p.loaded=t.progress/100,p.initWidth,p.initHeight,e)}));var v=function(){var t;for(t in h.images)h.images.hasOwnProperty(t)&&g.resources[t].texture&&PIXI.Texture.addToCache(g.resources[t].texture,t);for(t in h.spines)h.spines.hasOwnProperty(t)&&(PIXI.AnimCache[t]=PIXI.AnimCache[h.baseUrl+h.spines[t]]);p.loaded=1,p.reinit(!0),p.changed=!0};g.on(\"complete\",v),g.on(\"error\",(function(t){console.warn(t)})),Object.keys(g.resources).length?g.load():(d(),v())}}},{key:\"createRenderer\",value:function(t,e,n){return PIXI.autoDetectRenderer(t,e,{view:n,clearBeforeRender:!0,preserveDrawingBuffer:!1})}},{key:\"isReady\",value:function(){return 1<=this.loaded}}])&&Fn(e.prototype,n),o&&Fn(e,o),t}()}]).Drawer;",
      "levelParams": {
        "0": {
          "aiCode": "import java.util.Scanner;\r\nimport java.util.Collection;\r\nimport java.util.List;\r\nimport java.util.ArrayList;\r\nimport java.util.HashSet;\r\nimport java.util.Set;\r\nimport java.util.HashMap;\r\nimport java.util.Map;\r\nimport java.util.TreeMap;\r\nimport java.util.Collections;\r\n\r\nclass Player {\r\n\r\n  public static final boolean LOCAL = false;\r\n\r\n  public Scanner in = new Scanner(System.in);\r\n\r\n  public static int turnCount;\r\n\r\n  public static PlayerColor MY_COLOR;\r\n  public static PlayerColor OPPONENT_COLOR;\r\n  public static Move OPPONENTS_LAST_MOVE = new Move(-1, -1, PlayerColor.WHITE);\r\n  public static int MY_SCORE;\r\n  public static int OPPONENT_SCORE;\r\n  public static int BOARD_SIZE;\r\n  public static int FIELDS_ON_BOARD;\r\n  public static PlayerColor[][] BOARD;\r\n\r\n  public MoveCalculator calculator;\r\n  public Move chosenMove;\r\n\r\n  static {\r\n    MoveCalculatorFactory.usedCalculatorImplementation =\r\n        MoveCalculatorImplementation.MOVE_CALCULATOR_LEVEL_1;\r\n    // MoveCalculatorFactory.usedCalculatorImplementation =\r\n    // MoveCalculatorImplementation.MOVE_CALCULATOR_LEVEL_2;\r\n    // MoveCalculatorFactory.usedCalculatorImplementation =\r\n    // MoveCalculatorImplementation.MOVE_CALCULATOR_LEVEL_3;\r\n  }\r\n\r\n  /** Entry point at Codingame, which calls then the play() method. */\r\n  public static void main(String[] args) {\r\n    Player p = new Player();\r\n    p.play();\r\n  }\r\n\r\n  /**\r\n   * This method is called, by the main Method, which is added by the Converter. This way, the game\r\n   * should be played at Codingame.\r\n   */\r\n  public void play() {\r\n    readInitialInput(in);\r\n    while (true) {\r\n      turnCount++;\r\n      readFromScanner(in);\r\n      calculateMove();\r\n      sendMove();\r\n    }\r\n  }\r\n\r\n  private void readInitialInput(Scanner in) {\r\n    String myColor = in.nextLine();\r\n    BOARD_SIZE = in.nextInt(); // the size of the board (width and height)\r\n    MY_COLOR = PlayerColor.fromCharCode(myColor);\r\n    OPPONENT_COLOR = PlayerColor.getOpposizeColor(MY_COLOR);\r\n  }\r\n\r\n  /**\r\n   * Default read in logic comes here.\r\n   *\r\n   * @param in Scanner, which provides the defined input lines.\r\n   */\r\n  public void readFromScanner(Scanner in) {\r\n    int opponentX =\r\n        in\r\n            .nextInt(); // The x coordinate of your opponent's last move (or -1 if the opponent\r\n                        // passed)\r\n    int opponentY =\r\n        in\r\n            .nextInt(); // The y coordinate of your opponent's last move (or -1 if the opponent\r\n                        // passed)\r\n    OPPONENTS_LAST_MOVE = new Move(opponentY, opponentX, PlayerColor.getOpposizeColor(MY_COLOR));\r\n    MY_SCORE = in.nextInt(); // Your current score (the number of captured stones)\r\n    OPPONENT_SCORE = in.nextInt(); // the opponents current score (the number of captured stones)\r\n\r\n    FIELDS_ON_BOARD = BOARD_SIZE * BOARD_SIZE;\r\n    if (in.hasNextLine()) {\r\n      in.nextLine();\r\n    }\r\n    String[] lines = new String[BOARD_SIZE];\r\n    for (int i = 0; i < BOARD_SIZE; i++) {\r\n      String line =\r\n          in\r\n              .nextLine(); // A row of the current board where 'B' marks a black stone, 'W' marks a\r\n                           // white stone and '.' marks an empty field\r\n      lines[i] = line;\r\n    }\r\n\r\n    BOARD = Referee.getBoard(lines);\r\n\r\n    chosenMove = null;\r\n  }\r\n\r\n  public void sendMove() {\r\n    if (chosenMove == null) {\r\n      System.err.println(\"ERROR: NO MOVE CHOSEN - USING DEFAULT: PASS\");\r\n      System.out.println(\"PASS\");\r\n    } else if (chosenMove.isPass()) {\r\n      System.out.println(\"PASS\");\r\n    } else {\r\n      System.out.println(chosenMove.getCol() + \" \" + chosenMove.getRow());\r\n    }\r\n  }\r\n\r\n  public void calculateMove() {\r\n    if (calculator == null) {\r\n      calculator = MoveCalculatorFactory.createCalculator();\r\n    }\r\n    calculator.calculateMove(this);\r\n  }\r\n\r\n  public void setChosenMove(Move chosenMove) {\r\n    this.chosenMove = chosenMove;\r\n  }\r\n\r\n  public abstract static class AbstractMoveCalculator implements MoveCalculator {\r\n\r\n    public Referee referee;\r\n\r\n    public AbstractMoveCalculator() {\r\n      referee = new Referee();\r\n    }\r\n\r\n    public abstract void calculateMove(Player player);\r\n\r\n    public List<Group> findGroups(Referee ref, PlayerColor color) {\r\n      List<Group> groups = new ArrayList<Group>(Player.FIELDS_ON_BOARD / 2);\r\n      Set<FieldPosition> known = new HashSet<>();\r\n      for (int row = 0; row < Player.BOARD_SIZE; row++) {\r\n        for (int col = 0; col < Player.BOARD_SIZE; col++) {\r\n          FieldPosition pos = new FieldPosition(row, col);\r\n          if (!known.contains(pos) && ref.getStoneColor(pos) == color) {\r\n            Group group = Group.findGroup(ref, pos);\r\n            groups.add(group);\r\n            known.addAll(group.getStones());\r\n          }\r\n        }\r\n      }\r\n\r\n      return groups;\r\n    }\r\n\r\n    protected void update() {\r\n      // update current scores\r\n      referee.getGame().setStonesCaptured(Player.MY_COLOR, Player.MY_SCORE);\r\n      referee\r\n          .getGame()\r\n          .setStonesCaptured(PlayerColor.getOpposizeColor(Player.MY_COLOR), Player.OPPONENT_SCORE);\r\n      // update the board\r\n      referee.addMove(Player.OPPONENTS_LAST_MOVE);\r\n      referee.setBoard(Player.BOARD);\r\n      referee.setBoard(referee.getBoardCopy());\r\n    }\r\n\r\n    protected Move getRandomMove() {\r\n      Move random;\r\n      do {\r\n        random =\r\n            new Move(\r\n                (int) (Math.random() * Player.BOARD_SIZE - 6 + 3),\r\n                (int) (Math.random() * Player.BOARD_SIZE - 6 + 3),\r\n                Player.MY_COLOR);\r\n      } while (!referee.isValidMove(random));\r\n      return random;\r\n    }\r\n\r\n    protected List<FieldPosition> getStonesOnBoard() {\r\n      List<FieldPosition> stones = new ArrayList<FieldPosition>(Player.FIELDS_ON_BOARD);\r\n      PlayerColor[][] board = referee.getBoard();\r\n      for (int i = 0; i < Player.BOARD_SIZE; i++) {\r\n        for (int j = 0; j < Player.BOARD_SIZE; j++) {\r\n          if (board[i][j] != null) {\r\n            stones.add(new FieldPosition(i, j));\r\n          }\r\n        }\r\n      }\r\n      return stones;\r\n    }\r\n\r\n    protected List<FieldPosition> getFreeFieldsNear(List<FieldPosition> placedStones) {\r\n      List<FieldPosition> freeFieldsNear = new ArrayList<>(Player.FIELDS_ON_BOARD);\r\n      for (FieldPosition stone : placedStones) {\r\n        for (FieldPosition pos : stone.getFieldsNear()) {\r\n          if (referee.isFieldEmpty(pos)) {\r\n            freeFieldsNear.add(pos);\r\n          }\r\n        }\r\n      }\r\n      return freeFieldsNear;\r\n    }\r\n  }\r\n\r\n  public static class Vector2D implements Cloneable {\r\n\r\n    public double x;\r\n    public double y;\r\n\r\n    public static final Vector2D NAN_VEC = new Vector2D(Double.NaN, Double.NaN);\r\n    public static final Vector2D NULL_VEC = new Vector2D(0, 0);\r\n\r\n    /*public enum Axis {\r\n    \tX,\r\n    \tY;\r\n    }*/\r\n\r\n    public Vector2D() {}\r\n\r\n    /** Crate a new Vector2D with x and y components. */\r\n    public Vector2D(double x, double y) {\r\n      this.x = x;\r\n      this.y = y;\r\n    }\r\n\r\n    public Vector2D(double... val) {\r\n      if (val.length != 2) {\r\n        // throw new LinearAlgebraException(\"A 2D Vector has 2 entries.\");\r\n      }\r\n      x = val[0];\r\n      y = val[1];\r\n    }\r\n    /**\r\n     * Create a Vector2D by an angle (in degree). An angle of 0 results in (x, y) = (1, 0); 90 in\r\n     * (x, y) = (0, 1); ... The resulting vector has a length of 1.\r\n     *\r\n     * @param angleDegree The angle of the new vector in degree.\r\n     */\r\n    public Vector2D(double angleDegree) {\r\n      this(Math.cos(angleDegree * Math.PI / 180), Math.sin(angleDegree * Math.PI / 180));\r\n    }\r\n\r\n    private Vector2D(Vector2D clone) {\r\n      this.x = clone.x;\r\n      this.y = clone.y;\r\n    }\r\n\r\n    /** Clone this Vector2D object. */\r\n    public Vector2D clone() {\r\n      return new Vector2D(this);\r\n    }\r\n\r\n    public String toString() {\r\n      return \"Vector2D[x: \" + x + \" y: \" + y + \"]\";\r\n    }\r\n\r\n    public String toString(String format) {\r\n      return String.format(format, x, y);\r\n    }\r\n\r\n    public boolean equals(Object obj) {\r\n      if (obj instanceof Vector2D) {\r\n        Vector2D v = (Vector2D) obj;\r\n        return Math.abs(x - v.x) < 1e-8 && Math.abs(y - v.y) < 1e-8;\r\n      }\r\n      return false;\r\n    }\r\n\r\n    /** Get this vector as 2D-Array. */\r\n    public double[] asArray() {\r\n      return new double[] {x, y};\r\n    }\r\n\r\n    /** The (euclidean) length of the Vector. */\r\n    public double length() {\r\n      return Math.hypot(x, y);\r\n    }\r\n    /**\r\n     * The length of this vector in a given norm.\r\n     *\r\n     * @param norm The norm of the vector length.\r\n     * @return The length of this vector in the given norm.\r\n     */\r\n    public double length(int norm) {\r\n      if (norm == Integer.MAX_VALUE) {\r\n        return Math.max(x, y);\r\n      }\r\n      return Math.pow(Math.pow(x, norm) + Math.pow(y, norm), 1.0 / norm);\r\n    }\r\n\r\n    /**\r\n     * Rotate the Vector an angle (in degrees) resulting in a new Vector that is returned.\r\n     *\r\n     * @param degrees The angle to return the vector.\r\n     * @return The new created vector.\r\n     */\r\n    public Vector2D rotate(double degrees) {\r\n      return new Vector2D(getAngle() + degrees).setLength(length());\r\n    }\r\n\r\n    /**\r\n     * Project the vector given as parameter on this vector.\r\n     *\r\n     * @param vec The vector that is to be projected on this vector.\r\n     * @return The projected vector.\r\n     */\r\n    public Vector2D project(Vector2D vec) {\r\n      return mult(scalar(vec) / Math.pow(length(), 2));\r\n    }\r\n\r\n    /**\r\n     * Add another Vector2D to this vector resulting in a new Vector that is returned.\r\n     *\r\n     * @param vec The vector added to this vector.\r\n     * @return The new created vector.\r\n     */\r\n    public Vector2D add(Vector2D vec) {\r\n      return new Vector2D(x + vec.x, y + vec.y);\r\n    }\r\n    /**\r\n     * Subtract another Vector3D from this vector resulting in a new Vector that is returned.\r\n     *\r\n     * @param vec The vector subtracted from this vector.\r\n     * @return The new created vector.\r\n     */\r\n    public Vector2D sub(Vector2D vec) {\r\n      return new Vector2D(x - vec.x, y - vec.y);\r\n    }\r\n    /**\r\n     * Multiply this vector with a scalar resulting in a new Vector that is returned.\r\n     *\r\n     * @param scalar The scalar to multiply this vector with.\r\n     * @return The new created vector.\r\n     */\r\n    public Vector2D mult(double scalar) {\r\n      return new Vector2D(x * scalar, y * scalar);\r\n    }\r\n\r\n    /**\r\n     * Check whether this vector is linearly dependent to the parameter vector.\r\n     *\r\n     * @param vec The checked vector.\r\n     * @return True if the vectors are linearly dependent. False otherwise.\r\n     */\r\n    public boolean isLinearlyDependent(Vector2D vec) {\r\n      double t1 = (x == 0 ? 0 : vec.x / x);\r\n      double t2 = (y == 0 ? 0 : vec.y / y);\r\n      return Math.abs(t1 - t2) < 1e-5 && t1 != 0; // all parameters t are equal and != 0\r\n    }\r\n\r\n    /**\r\n     * Check whether the parameter vectors are linearly dependent.\r\n     *\r\n     * @param vectors The vectors that are checked.\r\n     * @return True if the vectors are linearly dependent. False otherwise.\r\n     */\r\n    public boolean isLinearlyDependentVectors(Vector2D... vectors) {\r\n      if (vectors.length < 2) {\r\n        return false;\r\n      } else if (vectors.length > 2) {\r\n        // 3 or more vectors in the R^2 are always linearly dependent\r\n        return true;\r\n      } else {\r\n        return vectors[0].isLinearlyDependent(vectors[1]);\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Calculate the scalar product of this vector and the parameter vector.\r\n     *\r\n     * @param vec The vector to calculate the scalar with this vector.\r\n     * @return The scalar of the vectors.\r\n     */\r\n    public double scalar(Vector2D vec) {\r\n      return this.x * vec.x + this.y * vec.y;\r\n    }\r\n\r\n    /**\r\n     * Create a new vector with the same direction but a different length as this vector.\r\n     *\r\n     * @param length The length of the new vector.\r\n     * @return The new vector with a new length.\r\n     */\r\n    public Vector2D setLength(double length) {\r\n      double len = length();\r\n      return new Vector2D(x * length / len, y * length / len);\r\n    }\r\n\r\n    /**\r\n     * Get the distance of this point's position vector to another point's position vector.\r\n     *\r\n     * @param p The second point's position vector.\r\n     * @return The distance between the points.\r\n     */\r\n    public double distance(Vector2D p) {\r\n      return Math.sqrt((this.x - p.x) * (this.x - p.x) + (this.y - p.y) * (this.y - p.y));\r\n    }\r\n\r\n    /** Change this vector to the new coordinates. */\r\n    public void move(double x, double y) {\r\n      this.x = x;\r\n      this.y = y;\r\n    }\r\n\r\n    /**\r\n     * Move a point's position vector in a direction (by a vector) and a distance.\r\n     *\r\n     * @param p The direction vector.\r\n     * @param distance The distance to move the new vector\r\n     * @return The new created vector.\r\n     */\r\n    public Vector2D moveTo(Vector2D p, double distance) {\r\n      double d = distance(p);\r\n      double dx = p.x - x;\r\n      double dy = p.y - y;\r\n      double coef = distance / d;\r\n      return new Vector2D(x + dx * coef, y + dy * coef);\r\n    }\r\n\r\n    /** Get the angle of this vector. Angle: 0 is right ((x, y) = (1, 0)); on clockwise (degree) */\r\n    public double getAngle() {\r\n      return ((Math.atan2(y, x) * 180 / Math.PI) + 720) % 360;\r\n    }\r\n\r\n    /** Get the angle of this vector as radiant. */\r\n    public double getAngleRad() {\r\n      return (Math.atan2(y, x) + 4 * Math.PI) % (2 * Math.PI);\r\n    }\r\n\r\n    /**\r\n     * Get the angle difference of this vector to another vector.\r\n     *\r\n     * @param vec The other vector.\r\n     * @return The angle difference of the two vectors (from 0 to 180).\r\n     */\r\n    public double getAngleDeltaTo(Vector2D vec) {\r\n      double delta = Math.abs(getAngle() - vec.getAngle());\r\n      if (delta > 180) {\r\n        delta = 360 - delta;\r\n      }\r\n      return delta;\r\n    }\r\n\r\n    /**\r\n     * Get the vector from this point to another.\r\n     *\r\n     * @param vec The point to which the vector is calculated.\r\n     * @return The vector from this points position vector to the other point.\r\n     */\r\n    public Vector2D vectorTo(Vector2D vec) {\r\n      return new Vector2D(vec.x - x, vec.y - y);\r\n    }\r\n\r\n    /**\r\n     * Checks whether a point (by its position vector) is in a given range of this point.\r\n     *\r\n     * @param p The point that is checked.\r\n     * @param range The range used for the check.\r\n     * @return True if the point is in the range of this point (distance <= range).\r\n     */\r\n    public boolean isInRange(Vector2D p, double range) {\r\n      return p != this && distance(p) <= range;\r\n    }\r\n\r\n    public double getX() {\r\n      return x;\r\n    }\r\n\r\n    public double getY() {\r\n      return y;\r\n    }\r\n  }\r\n\r\n  /** The stronges AI for the third and last league */\r\n  public static class MoveCalculatorLevel3 extends AbstractMoveCalculator\r\n      implements MoveCalculator {\r\n\r\n    /** The total number of moves that can be simulated in time */\r\n    public final int CALCULATED_MOVES = 100;\r\n\r\n    private int numScoreCalculations;\r\n    private long start;\r\n\r\n    public void calculateMove(Player player) {\r\n      update();\r\n      numScoreCalculations = 0;\r\n      start = System.currentTimeMillis();\r\n      DebugUtils.pause();\r\n\r\n      // first move is random\r\n      if (Player.turnCount == 1) {\r\n        player.setChosenMove(getRandomMove());\r\n        return;\r\n      }\r\n\r\n      Map<Move, Referee> possibleMoves = new HashMap<Move, Referee>();\r\n\r\n      // add passing as possible move\r\n      possibleMoves.put(new Move(-1, -1, Player.MY_COLOR), referee.clone());\r\n\r\n      // stones beneath other placed stones\r\n      List<FieldPosition> placedStones = getStonesOnBoard();\r\n      List<FieldPosition> nearPlacedStones = getFreeFieldsNear(placedStones);\r\n\r\n      DebugUtils.print(\"TIMING after nearPlacedStones: \" + (System.currentTimeMillis() - start));\r\n\r\n      if (nearPlacedStones.size() > CALCULATED_MOVES) {\r\n        Collections.shuffle(nearPlacedStones);\r\n        nearPlacedStones = nearPlacedStones.subList(0, CALCULATED_MOVES);\r\n      }\r\n\r\n      DebugUtils.print(\"TIMING: after shuffle \" + (System.currentTimeMillis() - start));\r\n\r\n      for (FieldPosition pos : nearPlacedStones) {\r\n        Move move = new Move(pos.getRow(), pos.getCol(), Player.MY_COLOR);\r\n        if (referee.isValidMove(move)) {\r\n          Referee ref = referee.clone();\r\n          ref.addMove(move);\r\n          possibleMoves.put(move, ref);\r\n        }\r\n      }\r\n\r\n      DebugUtils.print(\r\n          \"TIMING after adding near placed stones: \" + (System.currentTimeMillis() - start));\r\n\r\n      // all other positions (if spaces left)\r\n      int calculationsLeft = CALCULATED_MOVES - possibleMoves.size();\r\n      for (int i = 0; i < calculationsLeft; i++) {\r\n        Move random =\r\n            new Move(\r\n                (int) (Math.random() * Player.BOARD_SIZE),\r\n                (int) (Math.random() * Player.BOARD_SIZE),\r\n                Player.MY_COLOR);\r\n        if (referee.isValidMove(random)) {\r\n          Referee ref = referee.clone();\r\n          ref.addMove(random);\r\n          possibleMoves.put(random, ref);\r\n        }\r\n      }\r\n\r\n      DebugUtils.print(\r\n          \"TIMING after adding left calculations: \" + (System.currentTimeMillis() - start));\r\n\r\n      TreeMap<Double, Move> scores = new TreeMap<>();\r\n      for (Map.Entry<Move, Referee> move : possibleMoves.entrySet()) {\r\n        double score = calculateRefereeScore(move.getValue());\r\n        scores.put(score, move.getKey());\r\n      }\r\n\r\n      Move bestMove;\r\n      if (scores.isEmpty()) {\r\n        bestMove = new Move(-1, -1, Player.MY_COLOR);\r\n      } else {\r\n        bestMove = scores.lastEntry().getValue();\r\n      }\r\n      player.setChosenMove(bestMove);\r\n\r\n      referee.addMove(bestMove);\r\n    }\r\n\r\n    public double calculateRefereeScore(Referee ref) {\r\n      DebugUtils.pause();\r\n      DebugUtils.print(numScoreCalculations + \": \" + (System.currentTimeMillis() - start));\r\n      numScoreCalculations++;\r\n      DebugUtils.start();\r\n\r\n      double score = 0;\r\n\r\n      int myScore = ref.getGame().getStonesCaptured(Player.OPPONENT_COLOR);\r\n      int opponentScore = ref.getGame().getStonesCaptured(Player.MY_COLOR);\r\n\r\n      score += myScore * 1000;\r\n      score -= opponentScore * 1000;\r\n\r\n      List<Group> myGroups = findGroups(ref, Player.MY_COLOR);\r\n      List<Group> opponentGroups = findGroups(ref, Player.OPPONENT_COLOR);\r\n\r\n      int libertiesMe = 0;\r\n      int minLibertiesOpponent = Integer.MAX_VALUE;\r\n      int minLibertiesMe = Integer.MAX_VALUE;\r\n\r\n      for (Group group : myGroups) {\r\n        int liberties = group.getLiberties(ref).size();\r\n        libertiesMe += liberties;\r\n        minLibertiesMe = Math.min(liberties, minLibertiesMe);\r\n      }\r\n      for (Group group : opponentGroups) {\r\n        int liberties = group.getLiberties(ref).size();\r\n        minLibertiesOpponent = Math.min(liberties, minLibertiesOpponent);\r\n      }\r\n\r\n      score += libertiesMe;\r\n      score += minLibertiesMe * 10;\r\n      score -= minLibertiesOpponent * 100;\r\n\r\n      if (minLibertiesMe == 1) {\r\n        score -= 1000;\r\n      }\r\n\r\n      return score;\r\n    }\r\n  }\r\n\r\n  /** A slightly better AI for the second league: */\r\n  public static class MoveCalculatorLevel2 extends AbstractMoveCalculator\r\n      implements MoveCalculator {\r\n\r\n    public void calculateMove(Player player) {\r\n      update();\r\n\r\n      // first move is random\r\n      if (Player.turnCount == 1) {\r\n        player.setChosenMove(getRandomMove());\r\n        return;\r\n      }\r\n\r\n      Map<Move, Referee> possibleMoves = new HashMap<Move, Referee>();\r\n      for (int row = 0; row < Player.BOARD_SIZE; row++) {\r\n        for (int col = 0; col < Player.BOARD_SIZE; col++) {\r\n          Move move = new Move(row, col, Player.MY_COLOR);\r\n          Referee ref = referee.clone();\r\n          if (ref.isValidMove(move)) {\r\n            ref.addMove(move);\r\n            possibleMoves.put(move, ref);\r\n          }\r\n        }\r\n      }\r\n      // add passing as possible move\r\n      possibleMoves.put(new Move(-1, -1, Player.MY_COLOR), referee.clone());\r\n\r\n      TreeMap<Double, Move> scores = new TreeMap<>();\r\n      for (Map.Entry<Move, Referee> move : possibleMoves.entrySet()) {\r\n        double score = calculateRefereeScore(move.getValue());\r\n        scores.put(score, move.getKey());\r\n      }\r\n\r\n      Move bestMove;\r\n      if (scores.isEmpty()) {\r\n        bestMove = new Move(-1, -1, Player.MY_COLOR);\r\n      } else {\r\n        bestMove = scores.lastEntry().getValue();\r\n      }\r\n      player.setChosenMove(bestMove);\r\n\r\n      referee.addMove(bestMove);\r\n    }\r\n\r\n    public double calculateRefereeScore(Referee ref) {\r\n      double score = 0;\r\n\r\n      int myScore = ref.getGame().getStonesCaptured(Player.OPPONENT_COLOR);\r\n      int opponentScore = ref.getGame().getStonesCaptured(Player.MY_COLOR);\r\n\r\n      score += myScore * 1000;\r\n      score -= opponentScore * 1000;\r\n\r\n      List<Group> myGroups = findGroups(ref, Player.MY_COLOR);\r\n      List<Group> opponentGroups = findGroups(ref, Player.OPPONENT_COLOR);\r\n\r\n      int libertiesMe = 0;\r\n      int minLibertiesOpponent = Integer.MAX_VALUE;\r\n      int minLibertiesMe = Integer.MAX_VALUE;\r\n\r\n      for (Group group : myGroups) {\r\n        int liberties = group.getLiberties(ref).size();\r\n        libertiesMe += liberties;\r\n        minLibertiesMe = Math.min(liberties, minLibertiesMe);\r\n      }\r\n      for (Group group : opponentGroups) {\r\n        int liberties = group.getLiberties(ref).size();\r\n        minLibertiesOpponent = Math.min(liberties, minLibertiesOpponent);\r\n      }\r\n\r\n      score += libertiesMe;\r\n      score += minLibertiesMe * 10;\r\n      score -= minLibertiesOpponent * 100;\r\n\r\n      return score;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Simple AI for first league:\r\n   *\r\n   * <p>if (can kill enemy stones) kill them else choose a random legal move\r\n   */\r\n  public static class MoveCalculatorLevel1 extends AbstractMoveCalculator\r\n      implements MoveCalculator {\r\n\r\n    public void calculateMove(Player player) {\r\n      DebugUtils.print(\"start\");\r\n      update();\r\n      DebugUtils.print(\"after update\");\r\n\r\n      // first move is random\r\n      if (Player.turnCount == 1) {\r\n        player.setChosenMove(getRandomMove());\r\n        return;\r\n      }\r\n      DebugUtils.print(\"after random first turn\");\r\n\r\n      Map<Move, Referee> possibleMoves = new HashMap<Move, Referee>();\r\n      for (int row = 0; row < Player.BOARD_SIZE; row++) {\r\n        for (int col = 0; col < Player.BOARD_SIZE; col++) {\r\n          Move move = new Move(row, col, Player.MY_COLOR);\r\n          Referee ref = referee.clone();\r\n          if (ref.isValidMove(move)) {\r\n            ref.addMove(move);\r\n            possibleMoves.put(move, ref);\r\n          }\r\n        }\r\n      }\r\n      DebugUtils.print(\"after possible moves\");\r\n      // add passing as possible move\r\n      possibleMoves.put(new Move(-1, -1, Player.MY_COLOR), referee.clone());\r\n      DebugUtils.print(\"after pass as possible move\");\r\n\r\n      TreeMap<Double, Move> scores = new TreeMap<>();\r\n      for (Map.Entry<Move, Referee> move : possibleMoves.entrySet()) {\r\n        double score = calculateRefereeScore(move.getValue());\r\n        scores.put(score, move.getKey());\r\n      }\r\n      DebugUtils.print(\"after scores\");\r\n\r\n      Move bestMove;\r\n      if (scores.isEmpty()) {\r\n        bestMove = new Move(-1, -1, Player.MY_COLOR);\r\n      } else {\r\n        bestMove = scores.lastEntry().getValue();\r\n      }\r\n      player.setChosenMove(bestMove);\r\n\r\n      DebugUtils.print(\"after setChosenMove\");\r\n\r\n      referee.addMove(bestMove);\r\n\r\n      DebugUtils.print(\"end\");\r\n    }\r\n\r\n    public double calculateRefereeScore(Referee ref) {\r\n      double score = 0;\r\n\r\n      int myScore = ref.getGame().getStonesCaptured(Player.OPPONENT_COLOR);\r\n      int opponentScore = ref.getGame().getStonesCaptured(Player.MY_COLOR);\r\n\r\n      score += myScore * 1000;\r\n      score -= opponentScore * 1000;\r\n\r\n      score += Math.random();\r\n\r\n      return score;\r\n    }\r\n  }\r\n\r\n  public static class Group {\r\n\r\n    private Set<FieldPosition> stones;\r\n    private PlayerColor color;\r\n\r\n    public Group(Set<FieldPosition> stones, PlayerColor color) {\r\n      this.stones = stones;\r\n      this.color = color;\r\n    }\r\n\r\n    public Group(PlayerColor color) {\r\n      this.color = color;\r\n      this.stones = new HashSet<FieldPosition>();\r\n    }\r\n\r\n    public static Group findGroup(Referee ref, FieldPosition startingPosition) {\r\n      PlayerColor groupColor = ref.getStoneColor(startingPosition);\r\n      final int boardSize = Player.BOARD_SIZE;\r\n      if (groupColor == null) {\r\n        throw new IllegalArgumentException(\r\n            \"The field of the starting position is empty (position was: \" + startingPosition + \")\");\r\n      }\r\n\r\n      // complete the group by adding stones using a flood fill\r\n      Set<FieldPosition> allStones = new HashSet<FieldPosition>();\r\n\r\n      // initialize the current queue and the next step queue\r\n      Set<FieldPosition> currentStones = new HashSet<FieldPosition>();\r\n      Set<FieldPosition> nextStones = new HashSet<FieldPosition>();\r\n\r\n      // add the starting position\r\n      currentStones.add(startingPosition);\r\n\r\n      // add the fields with the iterative flood fill till the queues are empty\r\n      while (!currentStones.isEmpty()) {\r\n        for (FieldPosition currentField : currentStones) {\r\n          for (FieldPosition near : currentField.getFieldsNear(boardSize)) {\r\n            if (near.exists(boardSize)\r\n                && // the field exists on the board\r\n                ref.getStoneColor(near) != null\r\n                && // prevent NPE\r\n                ref.getStoneColor(near).equals(groupColor)\r\n                && // the field contains a stone of the group color\r\n                !allStones.contains(near)\r\n                && !currentStones.contains(near)) { // the field is not already added\r\n              nextStones.add(near);\r\n            }\r\n          }\r\n        }\r\n        // add the current stones to the group, copy the next steps to the queue and clear next\r\n        // steps\r\n        allStones.addAll(currentStones);\r\n        currentStones = nextStones;\r\n        nextStones = new HashSet<FieldPosition>();\r\n      }\r\n\r\n      return new Group(allStones, groupColor);\r\n    }\r\n\r\n    public boolean isBeaten(Referee ref) {\r\n      Set<FieldPosition> nearFreeFields = getLiberties(ref);\r\n\r\n      return nearFreeFields.isEmpty();\r\n    }\r\n\r\n    public Set<FieldPosition> getLiberties(Referee ref) {\r\n      Set<FieldPosition> liberties = new HashSet<>();\r\n      for (FieldPosition stone : stones) {\r\n        for (FieldPosition pos : stone.getFieldsNear()) {\r\n          if (pos.exists() && ref.isFieldEmpty(pos)) {\r\n            liberties.add(pos);\r\n          }\r\n        }\r\n      }\r\n      return liberties;\r\n\r\n      //\t\treturn stones.stream().flatMap(s -> s.getFieldsNear(Player.BOARD_SIZE).stream()) //all\r\n      // fields near\r\n      //\t\t\t\t.filter(field -> field.exists(Player.BOARD_SIZE) && ref.isFieldEmpty(field)) //existing\r\n      // and empty\r\n      //\t\t\t\t.collect(Collectors.toSet());\r\n    }\r\n\r\n    public void addStone(FieldPosition pos) {\r\n      stones.add(pos);\r\n    }\r\n\r\n    public void addStones(List<FieldPosition> positions) {\r\n      stones.addAll(positions);\r\n    }\r\n\r\n    public void remove(FieldPosition pos) {\r\n      stones.remove(pos);\r\n    }\r\n\r\n    public void clear() {\r\n      stones.clear();\r\n    }\r\n\r\n    public Set<FieldPosition> getStones() {\r\n      return stones;\r\n    }\r\n\r\n    public void setStones(Set<FieldPosition> stones) {\r\n      this.stones = stones;\r\n    }\r\n\r\n    public PlayerColor getColor() {\r\n      return color;\r\n    }\r\n\r\n    public void setColor(PlayerColor color) {\r\n      this.color = color;\r\n    }\r\n  }\r\n\r\n  public static class DebugUtils {\r\n\r\n    public static final boolean DEBUG = true;\r\n    public static boolean PAUSE_DEBUG = false;\r\n\r\n    public static final String DEFAULT_VECTOR_FORMAT = \"(%4.0f|%4.0f)\";\r\n\r\n    public static void pause() {\r\n      PAUSE_DEBUG = true;\r\n    }\r\n\r\n    public static void start() {\r\n      PAUSE_DEBUG = false;\r\n    }\r\n\r\n    public static void printVector2D(Vector2D vec, String prefix) {\r\n      print(prefix + vec.toString(\"(%4.0f|%4.0f)\"));\r\n    }\r\n\r\n    public static void printVector2D(Vector2D vec, String prefix, String format) {\r\n      print(prefix + vec.toString(format));\r\n    }\r\n\r\n    public static void printBoard(PlayerColor[][] board) {\r\n      StringBuilder sb = new StringBuilder();\r\n      for (PlayerColor[] line : board) {\r\n        for (PlayerColor field : line) {\r\n          sb.append(PlayerColor.toCharCode(field));\r\n        }\r\n        sb.append('\\n');\r\n      }\r\n      print(sb.toString());\r\n    }\r\n\r\n    public static void print(Object obj) {\r\n      print(obj.toString());\r\n    }\r\n\r\n    public static void print(String s) {\r\n      if (DEBUG) {\r\n        if (!PAUSE_DEBUG) {\r\n          System.err.println(s);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  public static class Game {\r\n\r\n    private int blackStonesCaptured;\r\n    private int whiteStonesCaptured;\r\n\r\n    public Game clone() {\r\n      Game clone = new Game();\r\n      clone.setBlackStonesCaptured(blackStonesCaptured);\r\n      clone.setWhiteStonesCaptured(whiteStonesCaptured);\r\n      return clone;\r\n    }\r\n\r\n    public int getStonesCaptured(PlayerColor color) {\r\n      if (color == PlayerColor.BLACK) {\r\n        return getBlackStonesCaptured();\r\n      } else if (color == PlayerColor.WHITE) {\r\n        return whiteStonesCaptured;\r\n      }\r\n      throw new IllegalStateException(\"Unknown PlayerColor: \" + color);\r\n    }\r\n\r\n    public void setStonesCaptured(PlayerColor color, int captured) {\r\n      if (color == PlayerColor.BLACK) {\r\n        blackStonesCaptured = captured;\r\n      } else if (color == PlayerColor.WHITE) {\r\n        whiteStonesCaptured = captured;\r\n      } else {\r\n        throw new IllegalStateException(\"Unknown PlayerColor: \" + color);\r\n      }\r\n    }\r\n\r\n    public int getBlackStonesCaptured() {\r\n      return blackStonesCaptured;\r\n    }\r\n\r\n    public void setBlackStonesCaptured(int blackStonesCaptured) {\r\n      this.blackStonesCaptured = blackStonesCaptured;\r\n    }\r\n\r\n    public int getWhiteStonesCaptured() {\r\n      return whiteStonesCaptured;\r\n    }\r\n\r\n    public void setWhiteStonesCaptured(int whiteStonesCaptured) {\r\n      this.whiteStonesCaptured = whiteStonesCaptured;\r\n    }\r\n  }\r\n\r\n  public static class FieldPosition {\r\n\r\n    private int row;\r\n    private int col;\r\n\r\n    public FieldPosition(int row, int col) {\r\n      super();\r\n      this.row = row;\r\n      this.col = col;\r\n    }\r\n\r\n    public int hashCode() {\r\n      final int prime = 31;\r\n      int result = 1;\r\n      result = prime * result + col;\r\n      result = prime * result + row;\r\n      return result;\r\n    }\r\n\r\n    public boolean equals(Object obj) {\r\n      if (this == obj) return true;\r\n      if (obj == null) return false;\r\n      if (getClass() != obj.getClass()) return false;\r\n      FieldPosition other = (FieldPosition) obj;\r\n      if (col != other.col) return false;\r\n      if (row != other.row) return false;\r\n      return true;\r\n    }\r\n\r\n    public List<FieldPosition> getFieldsNear() {\r\n      return getFieldsNear(Player.BOARD_SIZE);\r\n    }\r\n\r\n    public List<FieldPosition> getFieldsNear(int boardSize) {\r\n      int[][] near = new int[][] {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\r\n      List<FieldPosition> nearFields = new ArrayList<FieldPosition>();\r\n      for (int[] nearDiff : near) {\r\n        FieldPosition position = new FieldPosition(row + nearDiff[0], col + nearDiff[1]);\r\n        if (position.exists(boardSize)) {\r\n          nearFields.add(position);\r\n        }\r\n      }\r\n      return nearFields;\r\n    }\r\n\r\n    public boolean exists() {\r\n      return exists(Player.BOARD_SIZE);\r\n    }\r\n\r\n    public boolean exists(int boardSize) {\r\n      return row >= 0 && col >= 0 && row < boardSize && col < boardSize;\r\n    }\r\n\r\n    public int getRow() {\r\n      return row;\r\n    }\r\n\r\n    public void setRow(int row) {\r\n      this.row = row;\r\n    }\r\n\r\n    public int getCol() {\r\n      return col;\r\n    }\r\n\r\n    public void setCol(int col) {\r\n      this.col = col;\r\n    }\r\n  }\r\n\r\n  public interface MoveCalculator {\r\n\r\n    public void calculateMove(Player player);\r\n  }\r\n\r\n  public static class MoveCalculatorFactory {\r\n\r\n    public static MoveCalculatorImplementation usedCalculatorImplementation;\r\n\r\n    public static MoveCalculator createCalculator() {\r\n      switch (usedCalculatorImplementation) {\r\n        case MOVE_CALCULATOR_LEVEL_1:\r\n          return new MoveCalculatorLevel1();\r\n        case MOVE_CALCULATOR_LEVEL_2:\r\n          return new MoveCalculatorLevel2();\r\n        case MOVE_CALCULATOR_LEVEL_3:\r\n          return new MoveCalculatorLevel3();\r\n        default:\r\n          throw new IllegalStateException(\r\n              \"Unknown implementation type: \"\r\n                  + usedCalculatorImplementation\r\n                  + \"; choose a type in MoveCalculatorFactory or declare the unknown type\");\r\n      }\r\n    }\r\n  }\r\n\r\n  public enum MoveCalculatorImplementation {\r\n    MOVE_CALCULATOR_LEVEL_1, //\r\n    MOVE_CALCULATOR_LEVEL_2, //\r\n    MOVE_CALCULATOR_LEVEL_3, //\r\n  }\r\n\r\n  public enum PlayerColor {\r\n    BLACK,\r\n    WHITE;\r\n\r\n    public static PlayerColor getOpposizeColor(PlayerColor lastMove) {\r\n      switch (lastMove) {\r\n        case BLACK:\r\n          return WHITE;\r\n        case WHITE:\r\n          return BLACK;\r\n        default:\r\n          return null;\r\n      }\r\n    }\r\n\r\n    public static String toCharCode(PlayerColor color) {\r\n      if (color == BLACK) {\r\n        return \"B\";\r\n      }\r\n      if (color == WHITE) {\r\n        return \"W\";\r\n      }\r\n      return \".\";\r\n    }\r\n\r\n    public String toCharCode() {\r\n      return toCharCode(this);\r\n    }\r\n\r\n    public static PlayerColor fromCharCode(String charCode) {\r\n      if (charCode.equals(\"B\")) {\r\n        return BLACK;\r\n      } else if (charCode.equals(\"W\")) {\r\n        return WHITE;\r\n      }\r\n      throw new IllegalStateException(\"unknown charCode: \" + charCode);\r\n    }\r\n  }\r\n\r\n  public static class Referee {\r\n\r\n    public static final int FRAME_DURATION = 800;\r\n    public static final int FRAME_WIDTH = 1920;\r\n    public static final int FRAME_HEIGHT = 1080;\r\n    public static final int BOARD_WIDTH = 950;\r\n\r\n    private Game game;\r\n\r\n    private PlayerColor[][] board;\r\n    private PlayerColor[][] previousBoard;\r\n\r\n    public Referee() {\r\n      this(new Game());\r\n    }\r\n\r\n    public Referee(Game game) {\r\n      this.game = game;\r\n      board = new PlayerColor[Player.BOARD_SIZE][Player.BOARD_SIZE];\r\n    }\r\n\r\n    // ***************************************************************************************************************\r\n    // *** CG stuff\r\n    // ***************************************************************************************************************\r\n\r\n    // ***************************************************************************************************************\r\n    // *** simulation\r\n    // ***************************************************************************************************************\r\n\r\n    public Referee clone() {\r\n      Referee clone = new Referee(game.clone());\r\n      clone.board = new PlayerColor[Player.BOARD_SIZE][Player.BOARD_SIZE];\r\n      clone.previousBoard = new PlayerColor[Player.BOARD_SIZE][Player.BOARD_SIZE];\r\n\r\n      for (int i = 0; i < Player.BOARD_SIZE; i++) {\r\n        clone.board = getBoardCopy(board);\r\n        clone.previousBoard = getBoardCopy(previousBoard);\r\n      }\r\n\r\n      return clone;\r\n    }\r\n\r\n    // ***************************************************************************************************************\r\n    // *** game methods\r\n    // ***************************************************************************************************************\r\n\r\n    public static PlayerColor[][] getBoard(String[] lines) {\r\n      int size = lines.length;\r\n      PlayerColor[][] board = new PlayerColor[size][size];\r\n      for (int i = 0; i < size; i++) {\r\n        for (int j = 0; j < size; j++) {\r\n          if (lines[i].charAt(j) == 'B') {\r\n            board[i][j] = PlayerColor.BLACK;\r\n          } else if (lines[i].charAt(j) == 'W') {\r\n            board[i][j] = PlayerColor.WHITE;\r\n          }\r\n        }\r\n      }\r\n      return board;\r\n    }\r\n\r\n    /** Execute all moves in the list to create the current board */\r\n\r\n    /*private*/ void fillBoard(List<Move> moves) throws IllegalArgumentException {\r\n      if (moves != null) {\r\n        for (Move move : moves) {\r\n          if (isValidMove(move)) {\r\n            addMove(move);\r\n          } else {\r\n            throw new IllegalArgumentException(\r\n                \"Invalid move. The given list of moves contains a move that is not valid: \" + move);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    public PlayerColor[][] getBoard() {\r\n      return board;\r\n    }\r\n\r\n    /** A deep copy of the current board */\r\n    public PlayerColor[][] getBoardCopy() {\r\n      return getBoardCopy(board);\r\n    }\r\n\r\n    public PlayerColor[][] getBoardCopy(PlayerColor[][] board) {\r\n      PlayerColor[][] newBoard = new PlayerColor[Player.BOARD_SIZE][Player.BOARD_SIZE];\r\n      if (board != null) {\r\n        for (int i = 0; i < Player.BOARD_SIZE; i++) {\r\n          for (int j = 0; j < Player.BOARD_SIZE; j++) {\r\n            newBoard[i][j] = board[i][j];\r\n          }\r\n        }\r\n      }\r\n      return newBoard;\r\n    }\r\n    /**\r\n     * Check whether the move is valid\r\n     *\r\n     * <p>Checked are:\r\n     *\r\n     * <ul>\r\n     *   <li>color (players turn)\r\n     *   <li>position (on field and empty)\r\n     *   <li>no suicidal move (placed stone is not directly beaten)\r\n     *   <li>ko rule (move doesn't create the same board that was there in the last move)\r\n     * </ul>\r\n     */\r\n    public boolean isValidMove(Move move) {\r\n      if (move.isPass()) {\r\n        // passing is always a valid move\r\n        return true;\r\n      }\r\n      if (!move.getPos().exists(Player.BOARD_SIZE)) {\r\n        // position doesn't exist\r\n        return false;\r\n      }\r\n      if (getStoneColor(move.getPos()) != null) {\r\n        // field not empty\r\n        return false;\r\n      }\r\n\r\n      // execute the move and check whether the state is valid\r\n      PlayerColor[][] tmpBoard = getBoardCopy(); // keep a copy of the board for a rollback\r\n      // make the move\r\n      board[move.getRow()][move.getCol()] = move.getColor();\r\n      removeBeaten(move);\r\n\r\n      // check the group of the new stone\r\n      Group group = Group.findGroup(this, move.getPos());\r\n      if (group.isBeaten(this)) {\r\n        // added stone is directly beaten\r\n        board = tmpBoard;\r\n        return false;\r\n      }\r\n\r\n      if (!Player.OPPONENTS_LAST_MOVE.isPass() && boardsEqual(board, previousBoard)) {\r\n        // restores the board from the last move (ko rule violated)\r\n        board = tmpBoard;\r\n        return false;\r\n      }\r\n\r\n      board = tmpBoard;\r\n      return true;\r\n    }\r\n\r\n    /*private*/ static boolean boardsEqual(PlayerColor[][] board, PlayerColor[][] previousBoard) {\r\n      if (previousBoard == null) {\r\n        // previousBoard can be null if there was no previous move\r\n        // in this case the ko-rule can't be violated and the boards are treated as not equal (so\r\n        // false is returned)\r\n        return false;\r\n      }\r\n      boolean equal = true;\r\n      for (int i = 0; i < board.length; i++) {\r\n        for (int j = 0; j < board[0].length; j++) {\r\n          equal &= board[i][j] == previousBoard[i][j];\r\n        }\r\n      }\r\n      return equal;\r\n    }\r\n\r\n    /**\r\n     * Execute a move without checking whether it's valid. The new stone is added and beaten ones\r\n     * are removed\r\n     */\r\n    public void addMove(Move move) {\r\n      if (!move.isPass()) {\r\n        // copy the board to the previous board field\r\n        previousBoard = getBoardCopy();\r\n\r\n        // set the new stone\r\n        board[move.getRow()][move.getCol()] = move.getColor();\r\n        // remove beaten stones (if any)\r\n        removeBeaten(move, true);\r\n      }\r\n    }\r\n\r\n    /** Remove all stones that were beaten by the move */\r\n\r\n    /*private*/ void removeBeaten(Move move) {\r\n      removeBeaten(move, false);\r\n    }\r\n\r\n    private void removeBeaten(Move move, boolean countBeaten) {\r\n      // find the fields near to the move field\r\n      List<FieldPosition> near = move.getPos().getFieldsNear(Player.BOARD_SIZE);\r\n      for (FieldPosition pos : near) {\r\n        // check whether the field has a stone of the different color on it\r\n        if (getStoneColor(pos) == PlayerColor.getOpposizeColor(move.getColor())) {\r\n          Group group = Group.findGroup(this, pos);\r\n          if (group.isBeaten(this)) {\r\n            removeStones(group.getStones(), countBeaten);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    /** Remove all stones in the collection from the field */\r\n\r\n    /*private*/ void removeStones(Collection<FieldPosition> stones) {\r\n      removeStones(stones, false);\r\n    }\r\n\r\n    private void removeStones(Collection<FieldPosition> stones, boolean countBeaten) {\r\n      int stonesBeaten = stones.size();\r\n      PlayerColor beatenStonesColor = null;\r\n      for (FieldPosition pos : stones) {\r\n        beatenStonesColor = board[pos.getRow()][pos.getCol()];\r\n        board[pos.getRow()][pos.getCol()] = null;\r\n      }\r\n\r\n      if (countBeaten) {\r\n        if (beatenStonesColor == PlayerColor.BLACK) {\r\n          game.setBlackStonesCaptured(game.getBlackStonesCaptured() + stonesBeaten);\r\n        } else if (beatenStonesColor == PlayerColor.WHITE) {\r\n          game.setWhiteStonesCaptured(game.getWhiteStonesCaptured() + stonesBeaten);\r\n        }\r\n      }\r\n    }\r\n\r\n    public boolean isFieldEmpty(FieldPosition pos) {\r\n      return board[pos.getRow()][pos.getCol()] == null;\r\n    }\r\n\r\n    public PlayerColor getStoneColor(FieldPosition pos) {\r\n      return board[pos.getRow()][pos.getCol()];\r\n    }\r\n\r\n    public Game getGame() {\r\n      return game;\r\n    }\r\n\r\n    public void setBoard(PlayerColor[][] board) {\r\n      this.board = board;\r\n    }\r\n\r\n    public void setPreviousBoard(PlayerColor[][] board) {\r\n      this.previousBoard = board;\r\n    }\r\n\r\n    public PlayerColor[][] getPreviousBoard() {\r\n      return previousBoard;\r\n    }\r\n\r\n    public void printBoards() {\r\n      DebugUtils.print(\"Board\");\r\n      DebugUtils.printBoard(board);\r\n      DebugUtils.print(\"Previous Board\");\r\n      DebugUtils.printBoard(previousBoard);\r\n    }\r\n  }\r\n\r\n  /** @author Tobias */\r\n  public static class Move {\r\n\r\n    private int row;\r\n    private int col;\r\n    private Type type;\r\n    private PlayerColor color;\r\n\r\n    public enum Type {\r\n      STONE,\r\n      PASS;\r\n    }\r\n\r\n    public Move(int row, int col, PlayerColor color) {\r\n      this.row = row;\r\n      this.col = col;\r\n      this.color = color;\r\n      this.type = Type.STONE;\r\n      if (row == -1 && col == -1) {\r\n        this.type = Type.PASS;\r\n      }\r\n    }\r\n\r\n    public static Move getPassMove(PlayerColor color) {\r\n      Move pass = new Move(-1, -1, color);\r\n      pass.setType(Type.PASS);\r\n      return pass;\r\n    }\r\n\r\n    public FieldPosition getPos() {\r\n      return new FieldPosition(row, col);\r\n    }\r\n\r\n    public int hashCode() {\r\n      final int prime = 31;\r\n      int result = 1;\r\n      result = prime * result + col;\r\n      result = prime * result + ((color == null) ? 0 : color.hashCode());\r\n      result = prime * result + row;\r\n      return result;\r\n    }\r\n\r\n    public boolean equals(Object obj) {\r\n      if (this == obj) return true;\r\n      if (obj == null) return false;\r\n      if (getClass() != obj.getClass()) return false;\r\n      Move other = (Move) obj;\r\n      if (col != other.col) return false;\r\n      if (color != other.color) return false;\r\n      if (row != other.row) return false;\r\n      return true;\r\n    }\r\n\r\n    public int getRow() {\r\n      return row;\r\n    }\r\n\r\n    public void setRow(int row) {\r\n      this.row = row;\r\n    }\r\n\r\n    public int getCol() {\r\n      return col;\r\n    }\r\n\r\n    public void setCol(int col) {\r\n      this.col = col;\r\n    }\r\n\r\n    public PlayerColor getColor() {\r\n      return color;\r\n    }\r\n\r\n    public void setColor(PlayerColor color) {\r\n      this.color = color;\r\n    }\r\n\r\n    public Type getType() {\r\n      return type;\r\n    }\r\n\r\n    public void setType(Type type) {\r\n      this.type = type;\r\n    }\r\n\r\n    public boolean isPass() {\r\n      return type == Type.PASS;\r\n    }\r\n  }\r\n}\r\n",
          "testCases": [],
          "maxPlayers": 2,
          "minPlayers": 2,
          "statements": {
            "1": "<div style=\"color:#cccccc;padding:20px;margin-right:15px;margin-left:15px;margin-bottom:10px;text-align:left\">This is a slight modification of the board game <a href=\"https://en.wikipedia.org/wiki/Go_(game)\">Go</a>\r\n<br>Click <a href=\"https://senseis.xmp.net/?BasicRulesOfGo\">here</a> for an introduction into the rules of Go.\r\n<br>Click <a href=\"https://github.com/tfassbender/codingame_atari_go\">here</a> for the Referee code<br>\r\n</div>\r\n<div class=\"statement-body\">\r\n    <!-- RULES -->\r\n    <div class=\"statement-section statement-rules\">\r\n        <h1>\r\n            <span class=\"icon icon-rules\">&nbsp;</span>\r\n            <span>Rules</span>\r\n        </h1>\r\n        <div class=\"statement-rules-content\">\r\n            Atari Go is a modification of the classical board game <a href=\"https://en.wikipedia.org/wiki/Go_(game)\">Go</a>, that is often used to teach new players the rules of Go.<br />\r\n            The rules are basically the same as the Go rules with some modifications to make the game a bit easier:\r\n            <ul>\r\n            \t<li>You don't gain points by occupying fields</li>\r\n            \t<li>The only way to gain points is to capture the stones of your opponent</li>\r\n            \t<li>The game does not end after both players have passed (the game ends after <const>80</const> turns)</li>\r\n            \t<li>All other rules stay the same as in the game of Go</li>\r\n            </ul>\r\n            \r\n            <h3>Go Rules</h3>\r\n            A game of Go is usually played on a board of 19x19 fields. In the first leagues a board of 9x9 or 13x13 fields is used, but in the later leagues a 19x19 board is used.\r\n            <br>\r\n            While playing, both players place one of their stones (per turn) on a free position on the field. The stones are not moved after they are placed. You can only add new stones.\r\n            <br>\r\n            The goal of the game is to capture the stones of your opponent. This can be done by surrounding the stones (or groups) of your opponent with your stones. If a stone or group has no free fields beneath it, it is captured and removed from the board (see example 2).\r\n            <br>\r\n            If a stone is surrounded by other stones of the same color this stone is not captured, but all stones that are directly touching each other form a group. This group shares it's free fields. So a group of stones is often stronger and more difficult to capture than a single stone (see example 1).\r\n            <br>\r\n            <br>\r\n            Beside these simple rules there are a view more rules, on where stones can be placed and where not.\r\n            <ul>\r\n            \t<li>You can only place a stone on a field where no stone is placed yet</li>\r\n            \t<li>You can not play a stone that would directly be removed (no suicidal moves). An exception to this rule is that the opponent stones are removed before this rule is applied. So if your stone seems to be directly surrounded by other stones, but it captures and removes at least one of the surrounding stones it can be played (see example 3)</li>\r\n            \t<li>You can not play a stone that would lead to the same board, like in the last turn when you played a stone. This is called the Ko-Rule (see example 4)</li>\r\n            </ul>\r\n        </div>\r\n    </div>\r\n\r\n    <!-- EXAMPLES -->\r\n    <div class=\"statement-section statement-examples\">\r\n        <h1>\r\n            <span class=\"icon icon-example\">&nbsp;</span>\r\n            <span>Examples</span>\r\n        </h1>\r\n\r\n        <div class=\"statement-examples-text\">\r\n            <div class=\"first-example\">\r\n            \t<h3>Example 1 - Groups</h3>\r\n            \tIn the image below the three white stones form a group. Therefore the two upper stones (that are completely surrounded) are not captured as long as one stone of the group is not completely captured.\r\n            \t<p><img src=\"https://senseis.xmp.net/diagrams/41/49d804c30e36bd3cf3666a6d76f39644.png\" style=\"height: 150px; width: auto;\"></img></p>\r\n            \t<br>\r\n            \t<br>\r\n            </div>\r\n            \r\n            <div class=\"second-example\">\r\n            \t<h3>Example 2 - Capturing stones</h3>\r\n            \tIn the image below the white stone is almost captured. The last free field it has is marked with a red square. The other fields (marked with red crosses) are not directly adjacent to the white stone and are therefore no free fields for the white stone.\r\n            \t<p><img src=\"https://senseis.xmp.net/diagrams/0/7cac8afadce46df1d520ee56b4eece8b.png\" style=\"height: 150px; width: auto;\"></img></p>\r\n            \tNow if the back stone is placed like in the image below...\r\n            \t<p><img src=\"https://senseis.xmp.net/diagrams/48/ceb2245b3fbf4c62872f4bdf2796ac95.png\" style=\"height: 150px; width: auto;\"></img></p>\r\n            \t...the white stone has no free fields around it and therefore it is captured. So it will be removed and after the turn of the black stone the field will look like in the image below.\r\n            \t<p><img src=\"https://senseis.xmp.net/diagrams/13/6e7dc384eb2e8b494e097f38d4259bcb.png\" style=\"height: 150px; width: auto;\"></img></p>\r\n            \t<br>\r\n            \t<br>\r\n            </div>\r\n            \r\n            <div class=\"third-example\">\r\n            \t<h3>Example 3 - Suicidal moves</h3>\r\n            \tIn the image below, a white stone that is placed in the middle of the four black stones would have no free fields beneath it and would be directly removed. Therefore a white stone can't be placed in the middle of the black stones in this case.\r\n            \t<p><img src=\"https://senseis.xmp.net/diagrams/13/6e7dc384eb2e8b494e097f38d4259bcb.png\" style=\"height: 150px; width: auto;\"></img></p>\r\n            \tAn exception to this rule is shown in the following image: In this image it seems to be the same case. A white stone that is placed in the middle of the black stones would have no free fields adjacent to it and would be removed. But in this case the white stone can be placed in the middle of the black stones as shown in the next image.\r\n            \t<p><img src=\"https://senseis.xmp.net/diagrams/37/0708d56ffed33ef1058f0185803a7f46.png\" style=\"height: 150px; width: auto;\"></img></p>\r\n            \tBefore the free fields of the white stone are counted, first the black stones are to be removed. This leads to the following field after the white stone is placed:\r\n            \t<p><img src=\"https://senseis.xmp.net/diagrams/47/00bb7694a7980ec3018ee6a2e721f212.png\" style=\"height: 150px; width: auto;\"></img></p>\r\n            \tSince the white stone now has a free field adjacent to it (where the black stone was removed) it can be played.\r\n            \t<br>\r\n            \t<br>\r\n            </div>\r\n            \r\n            <div class=\"fourth-example\">\r\n            \t<h3>Example 4 - Ko-Rule</h3>\r\n            \tIn the third example it was shown that in a field, like the one in the image below, a white stone can be placed in the middle of the four black stones...\r\n            \t<p><img src=\"https://senseis.xmp.net/diagrams/37/0708d56ffed33ef1058f0185803a7f46.png\" style=\"height: 150px; width: auto;\"></img></p>\r\n            \t... which would lead to a board that looks like this:\r\n            \t<p><img src=\"https://senseis.xmp.net/diagrams/47/00bb7694a7980ec3018ee6a2e721f212.png\" style=\"height: 150px; width: auto;\"></img></p>\r\n            \tNow it seems that a black stone could do a similar move by placing it in the middle of the four white stones like this:\r\n            \t<p><img src=\"https://senseis.xmp.net/diagrams/28/8da1b11165650ffa0964df5ff2debbe1.png\" style=\"height: 150px; width: auto;\"></img></p>\r\n            \tThis would normally be a valid move (just like in the third example), but to prevent the game to get stuck on this (both players just capturing the same stones again and again), the above move is not possible for the black stone, because it would lead to the same board like one turn before (the first image of this example).<br>\r\n            \tBut it would be possible to place a black stone on any other field, let white place a stone too, and then come back to this formation of stones and place the black stone in between the white stones (like in the image above) because now it would no longer lead to the same board like in the first image of this example (there are now two more stones placed somewhere on the board).\r\n            \t<br>\r\n            \t<br>\r\n            </div>\r\n        </div>\r\n    </div><br>\r\n\r\n    <!-- Victory conditions -->\r\n    <div class=\"statement-victory-conditions\">\r\n        <div class=\"icon victory\"></div>\r\n        <div class=\"blk\">\r\n            <div class=\"title\">Victory Conditions</div>\r\n            <div class=\"text\">\r\n                <ul style=\"padding-bottom: 0;\">\r\n                    <li>Capture more stones than your opponent</li>\r\n                    <li>If no player has captured any stones after the maximum number of turns is reached, the player that has played more stones wins (to prevent a draw if a player passes in every move)</li>\r\n                </ul>\r\n            </div>\r\n        </div>\r\n    </div>\r\n\r\n    <!-- Lose conditions -->\r\n    <div class=\"statement-lose-conditions\">\r\n        <div class=\"icon lose\"></div>\r\n        <div class=\"blk\">\r\n            <div class=\"title\">Loss Conditions</div>\r\n            <div class=\"text\">\r\n                <ul style=\"padding-bottom: 0;\">\r\n                    <li>You send an illegal move</li>\r\n                    <li>You don't respond in time or output an unrecognized command</li>\r\n                </ul>\r\n            </div>\r\n        </div>\r\n    </div>\r\n\r\n    <!-- PROTOCOL -->\r\n    <div class=\"statement-section statement-protocol\">\r\n        <h1>\r\n        <span class=\"icon icon-protocol\">&nbsp;</span>\r\n        <span>Game Input</span>\r\n    </h1>\r\n\r\n    <!-- Protocol block -->\r\n    <div class=\"blk\">\r\n        <div class=\"title\">Initial input</div>\r\n        <div class=\"text\">\r\n            <span class=\"statement-lineno\">First line</span>: <var>myColor</var>: <action>B</action> if you are playing the black stones or <action>W</action> if you're playing the white stones.\r\n            <br>\r\n            <span class=\"statement-lineno\">Next line</span>: <var>boardSize</var>: an integer representing the size of the board\r\n            <br>\r\n            <br>\r\n        </div>\r\n        <div class=\"title\">Input for one game turn</div>\r\n        <div class=\"text\">\r\n            <span class=\"statement-lineno\">First line</span>: <var>x</var> <var>y</var>: two integers representing the position of the last stone, that your opponent played (\"-1 -1\" in the first turn)\r\n            <br>\r\n            <span class=\"statement-lineno\">Next line</span>: <var>myScore</var> <var>opponentScore</var>: two integers representing your current score and your opponent's current score (the number of captured stones)\r\n            <br>\r\n            <span class=\"statement-lineno\">Next <var>boardSize</var> lines</span>: <var>line</var>: one line of the current board, where <action>B</action> marks a black stone, <action>W</action> marks a white stone and <action>.</action> marks an empty field\r\n            <br>\r\n        </div>\r\n    </div>\r\n\r\n    <!-- Protocol block -->\r\n    <div class=\"blk\">\r\n        <div class=\"title\">Output</div>\r\n        <div class=\"text\">\r\n            <span class=\"statement-lineno\">A single line containing</span>: either the <var>x</var> and <var>y</var> coordinates of the next stone you want to play or <var>PASS</var> if you don't want to play a stone (<var>PASS</var> is always a valid move)<br>\r\n        <br>\r\n        </div>\r\n    </div>\r\n\r\n    <!-- Protocol block -->\r\n    <div class=\"blk\">\r\n        <div class=\"title\">Constraints</div>\r\n        Response time first turn is \r\n        <const>1000</const> ms.\r\n        <br>Response time per turn is \r\n        <const>100</const> ms.\r\n        <br><br>The game ends after <const>80</const> turns (40 stones for each player)\r\n        </div>\r\n    </div>\r\n</div>",
            "2": "<div style=\"color:#cccccc;padding:20px;margin-right:15px;margin-left:15px;margin-bottom:10px;text-align:left\">This is a slight modification of the board game <a href=\"https://en.wikipedia.org/wiki/Go_(game)\">Go</a>\r\n<br>Click <a href=\"https://senseis.xmp.net/?BasicRulesOfGo\">here</a> for an introduction into the rules of Go.\r\n<br>Click <a href=\"https://github.com/tfassbender/codingame_atari_go\">here</a> for the Referee code<br>\r\n</div>\r\n<div class=\"statement-body\">\r\n    <!-- RULES -->\r\n    <div class=\"statement-section statement-rules\">\r\n        <h1>\r\n            <span class=\"icon icon-rules\">&nbsp;</span>\r\n            <span>Rules</span>\r\n        </h1>\r\n        <div class=\"statement-rules-content\">\r\n            Atari Go is a modification of the classical board game <a href=\"https://en.wikipedia.org/wiki/Go_(game)\">Go</a>, that is often used to teach new players the rules of Go.<br />\r\n            The rules are basically the same as the Go rules with some modifications to make the game a bit easier:\r\n            <ul>\r\n            \t<li>You don't gain points by occupying fields</li>\r\n            \t<li>The only way to gain points is to capture the stones of your opponent</li>\r\n            \t<li>The game does not end after both players have passed (the game ends after <const>80</const> turns)</li>\r\n            \t<li>All other rules stay the same as in the game of Go</li>\r\n            </ul>\r\n            \r\n            <h3>Go Rules</h3>\r\n            A game of Go is usually played on a board of 19x19 fields. In the first leagues a board of 9x9 or 13x13 fields is used, but in the later leagues a 19x19 board is used.\r\n            <br>\r\n            While playing, both players place one of their stones (per turn) on a free position on the field. The stones are not moved after they are placed. You can only add new stones.\r\n            <br>\r\n            The goal of the game is to capture the stones of your opponent. This can be done by surrounding the stones (or groups) of your opponent with your stones. If a stone or group has no free fields beneath it, it is captured and removed from the board (see example 2).\r\n            <br>\r\n            If a stone is surrounded by other stones of the same color this stone is not captured, but all stones that are directly touching each other form a group. This group shares it's free fields. So a group of stones is often stronger and more difficult to capture than a single stone (see example 1).\r\n            <br>\r\n            <br>\r\n            Beside these simple rules there are a view more rules, on where stones can be placed and where not.\r\n            <ul>\r\n            \t<li>You can only place a stone on a field where no stone is placed yet</li>\r\n            \t<li>You can not play a stone that would directly be removed (no suicidal moves). An exception to this rule is that the opponent stones are removed before this rule is applied. So if your stone seems to be directly surrounded by other stones, but it captures and removes at least one of the surrounding stones it can be played (see example 3)</li>\r\n            \t<li>You can not play a stone that would lead to the same board, like in the last turn when you played a stone. This is called the Ko-Rule (see example 4)</li>\r\n            </ul>\r\n        </div>\r\n    </div>\r\n\r\n    <!-- EXAMPLES -->\r\n    <div class=\"statement-section statement-examples\">\r\n        <h1>\r\n            <span class=\"icon icon-example\">&nbsp;</span>\r\n            <span>Examples</span>\r\n        </h1>\r\n\r\n        <div class=\"statement-examples-text\">\r\n            <div class=\"first-example\">\r\n            \t<h3>Example 1 - Groups</h3>\r\n            \tIn the image below the three white stones form a group. Therefore the two upper stones (that are completely surrounded) are not captured as long as one stone of the group is not completely captured.\r\n            \t<p><img src=\"https://senseis.xmp.net/diagrams/41/49d804c30e36bd3cf3666a6d76f39644.png\" style=\"height: 150px; width: auto;\"></img></p>\r\n            \t<br>\r\n            \t<br>\r\n            </div>\r\n            \r\n            <div class=\"second-example\">\r\n            \t<h3>Example 2 - Capturing stones</h3>\r\n            \tIn the image below the white stone is almost captured. The last free field it has is marked with a red square. The other fields (marked with red crosses) are not directly adjacent to the white stone and are therefore no free fields for the white stone.\r\n            \t<p><img src=\"https://senseis.xmp.net/diagrams/0/7cac8afadce46df1d520ee56b4eece8b.png\" style=\"height: 150px; width: auto;\"></img></p>\r\n            \tNow if the back stone is placed like in the image below...\r\n            \t<p><img src=\"https://senseis.xmp.net/diagrams/48/ceb2245b3fbf4c62872f4bdf2796ac95.png\" style=\"height: 150px; width: auto;\"></img></p>\r\n            \t...the white stone has no free fields around it and therefore it is captured. So it will be removed and after the turn of the black stone the field will look like in the image below.\r\n            \t<p><img src=\"https://senseis.xmp.net/diagrams/13/6e7dc384eb2e8b494e097f38d4259bcb.png\" style=\"height: 150px; width: auto;\"></img></p>\r\n            \t<br>\r\n            \t<br>\r\n            </div>\r\n            \r\n            <div class=\"third-example\">\r\n            \t<h3>Example 3 - Suicidal moves</h3>\r\n            \tIn the image below, a white stone that is placed in the middle of the four black stones would have no free fields beneath it and would be directly removed. Therefore a white stone can't be placed in the middle of the black stones in this case.\r\n            \t<p><img src=\"https://senseis.xmp.net/diagrams/13/6e7dc384eb2e8b494e097f38d4259bcb.png\" style=\"height: 150px; width: auto;\"></img></p>\r\n            \tAn exception to this rule is shown in the following image: In this image it seems to be the same case. A white stone that is placed in the middle of the black stones would have no free fields adjacent to it and would be removed. But in this case the white stone can be placed in the middle of the black stones as shown in the next image.\r\n            \t<p><img src=\"https://senseis.xmp.net/diagrams/37/0708d56ffed33ef1058f0185803a7f46.png\" style=\"height: 150px; width: auto;\"></img></p>\r\n            \tBefore the free fields of the white stone are counted, first the black stones are to be removed. This leads to the following field after the white stone is placed:\r\n            \t<p><img src=\"https://senseis.xmp.net/diagrams/47/00bb7694a7980ec3018ee6a2e721f212.png\" style=\"height: 150px; width: auto;\"></img></p>\r\n            \tSince the white stone now has a free field adjacent to it (where the black stone was removed) it can be played.\r\n            \t<br>\r\n            \t<br>\r\n            </div>\r\n            \r\n            <div class=\"fourth-example\">\r\n            \t<h3>Example 4 - Ko-Rule</h3>\r\n            \tIn the third example it was shown that in a field, like the one in the image below, a white stone can be placed in the middle of the four black stones...\r\n            \t<p><img src=\"https://senseis.xmp.net/diagrams/37/0708d56ffed33ef1058f0185803a7f46.png\" style=\"height: 150px; width: auto;\"></img></p>\r\n            \t... which would lead to a board that looks like this:\r\n            \t<p><img src=\"https://senseis.xmp.net/diagrams/47/00bb7694a7980ec3018ee6a2e721f212.png\" style=\"height: 150px; width: auto;\"></img></p>\r\n            \tNow it seems that a black stone could do a similar move by placing it in the middle of the four white stones like this:\r\n            \t<p><img src=\"https://senseis.xmp.net/diagrams/28/8da1b11165650ffa0964df5ff2debbe1.png\" style=\"height: 150px; width: auto;\"></img></p>\r\n            \tThis would normally be a valid move (just like in the third example), but to prevent the game to get stuck on this (both players just capturing the same stones again and again), the above move is not possible for the black stone, because it would lead to the same board like one turn before (the first image of this example).<br>\r\n            \tBut it would be possible to place a black stone on any other field, let white place a stone too, and then come back to this formation of stones and place the black stone in between the white stones (like in the image above) because now it would no longer lead to the same board like in the first image of this example (there are now two more stones placed somewhere on the board).\r\n            \t<br>\r\n            \t<br>\r\n            </div>\r\n        </div>\r\n    </div><br>\r\n\r\n    <!-- Victory conditions -->\r\n    <div class=\"statement-victory-conditions\">\r\n        <div class=\"icon victory\"></div>\r\n        <div class=\"blk\">\r\n            <div class=\"title\">Victory Conditions</div>\r\n            <div class=\"text\">\r\n                <ul style=\"padding-bottom: 0;\">\r\n                    <li>Capture more stones than your opponent</li>\r\n                    <li>If no player has captured any stones after the maximum number of turns is reached, the player that has played more stones wins (to prevent a draw if a player passes in every move)</li>\r\n                </ul>\r\n            </div>\r\n        </div>\r\n    </div>\r\n\r\n    <!-- Lose conditions -->\r\n    <div class=\"statement-lose-conditions\">\r\n        <div class=\"icon lose\"></div>\r\n        <div class=\"blk\">\r\n            <div class=\"title\">Loss Conditions</div>\r\n            <div class=\"text\">\r\n                <ul style=\"padding-bottom: 0;\">\r\n                    <li>You send an illegal move</li>\r\n                    <li>You don't respond in time or output an unrecognized command</li>\r\n                </ul>\r\n            </div>\r\n        </div>\r\n    </div>\r\n\r\n    <!-- PROTOCOL -->\r\n    <div class=\"statement-section statement-protocol\">\r\n        <h1>\r\n        <span class=\"icon icon-protocol\">&nbsp;</span>\r\n        <span>Game Input</span>\r\n    </h1>\r\n\r\n    <!-- Protocol block -->\r\n    <div class=\"blk\">\r\n        <div class=\"title\">Initial input</div>\r\n        <div class=\"text\">\r\n            <span class=\"statement-lineno\">First line</span>: <var>myColor</var>: <action>B</action> if you are playing the black stones or <action>W</action> if you're playing the white stones.\r\n            <br>\r\n            <span class=\"statement-lineno\">Next line</span>: <var>boardSize</var>: an integer representing the size of the board\r\n            <br>\r\n            <br>\r\n        </div>\r\n        <div class=\"title\">Input for one game turn</div>\r\n        <div class=\"text\">\r\n            <span class=\"statement-lineno\">First line</span>: <var>x</var> <var>y</var>: two integers representing the position of the last stone, that your opponent played (\"-1 -1\" in the first turn)\r\n            <br>\r\n            <span class=\"statement-lineno\">Next line</span>: <var>myScore</var> <var>opponentScore</var>: two integers representing your current score and your opponent's current score (the number of captured stones)\r\n            <br>\r\n            <span class=\"statement-lineno\">Next <var>boardSize</var> lines</span>: <var>line</var>: one line of the current board, where <action>B</action> marks a black stone, <action>W</action> marks a white stone and <action>.</action> marks an empty field\r\n            <br>\r\n        </div>\r\n    </div>\r\n\r\n    <!-- Protocol block -->\r\n    <div class=\"blk\">\r\n        <div class=\"title\">Output</div>\r\n        <div class=\"text\">\r\n            <span class=\"statement-lineno\">A single line containing</span>: either the <var>x</var> and <var>y</var> coordinates of the next stone you want to play or <var>PASS</var> if you don't want to play a stone (<var>PASS</var> is always a valid move)<br>\r\n        <br>\r\n        </div>\r\n    </div>\r\n\r\n    <!-- Protocol block -->\r\n    <div class=\"blk\">\r\n        <div class=\"title\">Constraints</div>\r\n        Response time first turn is \r\n        <const>1000</const> ms.\r\n        <br>Response time per turn is \r\n        <const>100</const> ms.\r\n        <br><br>The game ends after <const>80</const> turns (40 stones for each player)\r\n        </div>\r\n    </div>\r\n</div>"
          },
          "questionType": "multi",
          "stubGenerator": "read myColor:string(1)\r\nread boardSize:int\r\ngameloop\r\nread opponentX:int opponentY:int\r\nread myScore:int opponentScore:int\r\nloop boardSize read line:string(boardSize)\r\nwrite PASS\r\n\r\nSTATEMENT\r\nCapture more stones than your opponent.\r\n\r\nINPUT\r\nopponentX: The x coordinate of your opponent's last move (or -1 if the opponent passed)\r\nopponentY: The y coordinate of your opponent's last move (or -1 if the opponent passed)\r\nmyScore: Your current score (the number of captured stones)\r\nopponentScore: the opponents current score (the number of captured stones)\r\nboardSize: the size of the board (width and height)\r\nline: A row of the current board where 'B' marks a black stone, 'W' marks a white stone and '.' marks an empty field\r\n\r\nOUTPUT\r\nx and y coordinates of the stone you want to place or PASS if you don't want to place a stone",
          "welcomePopups": {},
          "aiCodeExtension": "java",
          "criteriaLanguageMap": {}
        },
        "1": {
          "aiCode": "import java.util.Scanner;\r\nimport java.util.Collection;\r\nimport java.util.List;\r\nimport java.util.ArrayList;\r\nimport java.util.HashSet;\r\nimport java.util.Set;\r\nimport java.util.HashMap;\r\nimport java.util.Map;\r\nimport java.util.TreeMap;\r\nimport java.util.Collections;\r\n\r\nclass Player {\r\n\r\n  public static final boolean LOCAL = false;\r\n\r\n  public Scanner in = new Scanner(System.in);\r\n\r\n  public static int turnCount;\r\n\r\n  public static PlayerColor MY_COLOR;\r\n  public static PlayerColor OPPONENT_COLOR;\r\n  public static Move OPPONENTS_LAST_MOVE = new Move(-1, -1, PlayerColor.WHITE);\r\n  public static int MY_SCORE;\r\n  public static int OPPONENT_SCORE;\r\n  public static int BOARD_SIZE;\r\n  public static int FIELDS_ON_BOARD;\r\n  public static PlayerColor[][] BOARD;\r\n\r\n  public MoveCalculator calculator;\r\n  public Move chosenMove;\r\n\r\n  static {\r\n    // MoveCalculatorFactory.usedCalculatorImplementation =\r\n    // MoveCalculatorImplementation.MOVE_CALCULATOR_LEVEL_1;\r\n    MoveCalculatorFactory.usedCalculatorImplementation =\r\n        MoveCalculatorImplementation.MOVE_CALCULATOR_LEVEL_2;\r\n    // MoveCalculatorFactory.usedCalculatorImplementation =\r\n    // MoveCalculatorImplementation.MOVE_CALCULATOR_LEVEL_3;\r\n  }\r\n\r\n  /** Entry point at Codingame, which calls then the play() method. */\r\n  public static void main(String[] args) {\r\n    Player p = new Player();\r\n    p.play();\r\n  }\r\n\r\n  /**\r\n   * This method is called, by the main Method, which is added by the Converter. This way, the game\r\n   * should be played at Codingame.\r\n   */\r\n  public void play() {\r\n    readInitialInput(in);\r\n    while (true) {\r\n      turnCount++;\r\n      readFromScanner(in);\r\n      calculateMove();\r\n      sendMove();\r\n    }\r\n  }\r\n\r\n  private void readInitialInput(Scanner in) {\r\n    String myColor = in.nextLine();\r\n    BOARD_SIZE = in.nextInt(); // the size of the board (width and height)\r\n    MY_COLOR = PlayerColor.fromCharCode(myColor);\r\n    OPPONENT_COLOR = PlayerColor.getOpposizeColor(MY_COLOR);\r\n  }\r\n\r\n  /**\r\n   * Default read in logic comes here.\r\n   *\r\n   * @param in Scanner, which provides the defined input lines.\r\n   */\r\n  public void readFromScanner(Scanner in) {\r\n    int opponentX =\r\n        in\r\n            .nextInt(); // The x coordinate of your opponent's last move (or -1 if the opponent\r\n                        // passed)\r\n    int opponentY =\r\n        in\r\n            .nextInt(); // The y coordinate of your opponent's last move (or -1 if the opponent\r\n                        // passed)\r\n    OPPONENTS_LAST_MOVE = new Move(opponentY, opponentX, PlayerColor.getOpposizeColor(MY_COLOR));\r\n    MY_SCORE = in.nextInt(); // Your current score (the number of captured stones)\r\n    OPPONENT_SCORE = in.nextInt(); // the opponents current score (the number of captured stones)\r\n\r\n    FIELDS_ON_BOARD = BOARD_SIZE * BOARD_SIZE;\r\n    if (in.hasNextLine()) {\r\n      in.nextLine();\r\n    }\r\n    String[] lines = new String[BOARD_SIZE];\r\n    for (int i = 0; i < BOARD_SIZE; i++) {\r\n      String line =\r\n          in\r\n              .nextLine(); // A row of the current board where 'B' marks a black stone, 'W' marks a\r\n                           // white stone and '.' marks an empty field\r\n      lines[i] = line;\r\n    }\r\n\r\n    BOARD = Referee.getBoard(lines);\r\n\r\n    chosenMove = null;\r\n  }\r\n\r\n  public void sendMove() {\r\n    if (chosenMove == null) {\r\n      System.err.println(\"ERROR: NO MOVE CHOSEN - USING DEFAULT: PASS\");\r\n      System.out.println(\"PASS\");\r\n    } else if (chosenMove.isPass()) {\r\n      System.out.println(\"PASS\");\r\n    } else {\r\n      System.out.println(chosenMove.getCol() + \" \" + chosenMove.getRow());\r\n    }\r\n  }\r\n\r\n  public void calculateMove() {\r\n    if (calculator == null) {\r\n      calculator = MoveCalculatorFactory.createCalculator();\r\n    }\r\n    calculator.calculateMove(this);\r\n  }\r\n\r\n  public void setChosenMove(Move chosenMove) {\r\n    this.chosenMove = chosenMove;\r\n  }\r\n\r\n  public abstract static class AbstractMoveCalculator implements MoveCalculator {\r\n\r\n    public Referee referee;\r\n\r\n    public AbstractMoveCalculator() {\r\n      referee = new Referee();\r\n    }\r\n\r\n    public abstract void calculateMove(Player player);\r\n\r\n    public List<Group> findGroups(Referee ref, PlayerColor color) {\r\n      List<Group> groups = new ArrayList<Group>(Player.FIELDS_ON_BOARD / 2);\r\n      Set<FieldPosition> known = new HashSet<>();\r\n      for (int row = 0; row < Player.BOARD_SIZE; row++) {\r\n        for (int col = 0; col < Player.BOARD_SIZE; col++) {\r\n          FieldPosition pos = new FieldPosition(row, col);\r\n          if (!known.contains(pos) && ref.getStoneColor(pos) == color) {\r\n            Group group = Group.findGroup(ref, pos);\r\n            groups.add(group);\r\n            known.addAll(group.getStones());\r\n          }\r\n        }\r\n      }\r\n\r\n      return groups;\r\n    }\r\n\r\n    protected void update() {\r\n      // update current scores\r\n      referee.getGame().setStonesCaptured(Player.MY_COLOR, Player.MY_SCORE);\r\n      referee\r\n          .getGame()\r\n          .setStonesCaptured(PlayerColor.getOpposizeColor(Player.MY_COLOR), Player.OPPONENT_SCORE);\r\n      // update the board\r\n      referee.addMove(Player.OPPONENTS_LAST_MOVE);\r\n      referee.setBoard(Player.BOARD);\r\n      referee.setBoard(referee.getBoardCopy());\r\n    }\r\n\r\n    protected Move getRandomMove() {\r\n      Move random;\r\n      do {\r\n        random =\r\n            new Move(\r\n                (int) (Math.random() * Player.BOARD_SIZE - 6 + 3),\r\n                (int) (Math.random() * Player.BOARD_SIZE - 6 + 3),\r\n                Player.MY_COLOR);\r\n      } while (!referee.isValidMove(random));\r\n      return random;\r\n    }\r\n\r\n    protected List<FieldPosition> getStonesOnBoard() {\r\n      List<FieldPosition> stones = new ArrayList<FieldPosition>(Player.FIELDS_ON_BOARD);\r\n      PlayerColor[][] board = referee.getBoard();\r\n      for (int i = 0; i < Player.BOARD_SIZE; i++) {\r\n        for (int j = 0; j < Player.BOARD_SIZE; j++) {\r\n          if (board[i][j] != null) {\r\n            stones.add(new FieldPosition(i, j));\r\n          }\r\n        }\r\n      }\r\n      return stones;\r\n    }\r\n\r\n    protected List<FieldPosition> getFreeFieldsNear(List<FieldPosition> placedStones) {\r\n      List<FieldPosition> freeFieldsNear = new ArrayList<>(Player.FIELDS_ON_BOARD);\r\n      for (FieldPosition stone : placedStones) {\r\n        for (FieldPosition pos : stone.getFieldsNear()) {\r\n          if (referee.isFieldEmpty(pos)) {\r\n            freeFieldsNear.add(pos);\r\n          }\r\n        }\r\n      }\r\n      return freeFieldsNear;\r\n    }\r\n  }\r\n\r\n  public static class Vector2D implements Cloneable {\r\n\r\n    public double x;\r\n    public double y;\r\n\r\n    public static final Vector2D NAN_VEC = new Vector2D(Double.NaN, Double.NaN);\r\n    public static final Vector2D NULL_VEC = new Vector2D(0, 0);\r\n\r\n    /*public enum Axis {\r\n    \tX,\r\n    \tY;\r\n    }*/\r\n\r\n    public Vector2D() {}\r\n\r\n    /** Crate a new Vector2D with x and y components. */\r\n    public Vector2D(double x, double y) {\r\n      this.x = x;\r\n      this.y = y;\r\n    }\r\n\r\n    public Vector2D(double... val) {\r\n      if (val.length != 2) {\r\n        // throw new LinearAlgebraException(\"A 2D Vector has 2 entries.\");\r\n      }\r\n      x = val[0];\r\n      y = val[1];\r\n    }\r\n    /**\r\n     * Create a Vector2D by an angle (in degree). An angle of 0 results in (x, y) = (1, 0); 90 in\r\n     * (x, y) = (0, 1); ... The resulting vector has a length of 1.\r\n     *\r\n     * @param angleDegree The angle of the new vector in degree.\r\n     */\r\n    public Vector2D(double angleDegree) {\r\n      this(Math.cos(angleDegree * Math.PI / 180), Math.sin(angleDegree * Math.PI / 180));\r\n    }\r\n\r\n    private Vector2D(Vector2D clone) {\r\n      this.x = clone.x;\r\n      this.y = clone.y;\r\n    }\r\n\r\n    /** Clone this Vector2D object. */\r\n    public Vector2D clone() {\r\n      return new Vector2D(this);\r\n    }\r\n\r\n    public String toString() {\r\n      return \"Vector2D[x: \" + x + \" y: \" + y + \"]\";\r\n    }\r\n\r\n    public String toString(String format) {\r\n      return String.format(format, x, y);\r\n    }\r\n\r\n    public boolean equals(Object obj) {\r\n      if (obj instanceof Vector2D) {\r\n        Vector2D v = (Vector2D) obj;\r\n        return Math.abs(x - v.x) < 1e-8 && Math.abs(y - v.y) < 1e-8;\r\n      }\r\n      return false;\r\n    }\r\n\r\n    /** Get this vector as 2D-Array. */\r\n    public double[] asArray() {\r\n      return new double[] {x, y};\r\n    }\r\n\r\n    /** The (euclidean) length of the Vector. */\r\n    public double length() {\r\n      return Math.hypot(x, y);\r\n    }\r\n    /**\r\n     * The length of this vector in a given norm.\r\n     *\r\n     * @param norm The norm of the vector length.\r\n     * @return The length of this vector in the given norm.\r\n     */\r\n    public double length(int norm) {\r\n      if (norm == Integer.MAX_VALUE) {\r\n        return Math.max(x, y);\r\n      }\r\n      return Math.pow(Math.pow(x, norm) + Math.pow(y, norm), 1.0 / norm);\r\n    }\r\n\r\n    /**\r\n     * Rotate the Vector an angle (in degrees) resulting in a new Vector that is returned.\r\n     *\r\n     * @param degrees The angle to return the vector.\r\n     * @return The new created vector.\r\n     */\r\n    public Vector2D rotate(double degrees) {\r\n      return new Vector2D(getAngle() + degrees).setLength(length());\r\n    }\r\n\r\n    /**\r\n     * Project the vector given as parameter on this vector.\r\n     *\r\n     * @param vec The vector that is to be projected on this vector.\r\n     * @return The projected vector.\r\n     */\r\n    public Vector2D project(Vector2D vec) {\r\n      return mult(scalar(vec) / Math.pow(length(), 2));\r\n    }\r\n\r\n    /**\r\n     * Add another Vector2D to this vector resulting in a new Vector that is returned.\r\n     *\r\n     * @param vec The vector added to this vector.\r\n     * @return The new created vector.\r\n     */\r\n    public Vector2D add(Vector2D vec) {\r\n      return new Vector2D(x + vec.x, y + vec.y);\r\n    }\r\n    /**\r\n     * Subtract another Vector3D from this vector resulting in a new Vector that is returned.\r\n     *\r\n     * @param vec The vector subtracted from this vector.\r\n     * @return The new created vector.\r\n     */\r\n    public Vector2D sub(Vector2D vec) {\r\n      return new Vector2D(x - vec.x, y - vec.y);\r\n    }\r\n    /**\r\n     * Multiply this vector with a scalar resulting in a new Vector that is returned.\r\n     *\r\n     * @param scalar The scalar to multiply this vector with.\r\n     * @return The new created vector.\r\n     */\r\n    public Vector2D mult(double scalar) {\r\n      return new Vector2D(x * scalar, y * scalar);\r\n    }\r\n\r\n    /**\r\n     * Check whether this vector is linearly dependent to the parameter vector.\r\n     *\r\n     * @param vec The checked vector.\r\n     * @return True if the vectors are linearly dependent. False otherwise.\r\n     */\r\n    public boolean isLinearlyDependent(Vector2D vec) {\r\n      double t1 = (x == 0 ? 0 : vec.x / x);\r\n      double t2 = (y == 0 ? 0 : vec.y / y);\r\n      return Math.abs(t1 - t2) < 1e-5 && t1 != 0; // all parameters t are equal and != 0\r\n    }\r\n\r\n    /**\r\n     * Check whether the parameter vectors are linearly dependent.\r\n     *\r\n     * @param vectors The vectors that are checked.\r\n     * @return True if the vectors are linearly dependent. False otherwise.\r\n     */\r\n    public boolean isLinearlyDependentVectors(Vector2D... vectors) {\r\n      if (vectors.length < 2) {\r\n        return false;\r\n      } else if (vectors.length > 2) {\r\n        // 3 or more vectors in the R^2 are always linearly dependent\r\n        return true;\r\n      } else {\r\n        return vectors[0].isLinearlyDependent(vectors[1]);\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Calculate the scalar product of this vector and the parameter vector.\r\n     *\r\n     * @param vec The vector to calculate the scalar with this vector.\r\n     * @return The scalar of the vectors.\r\n     */\r\n    public double scalar(Vector2D vec) {\r\n      return this.x * vec.x + this.y * vec.y;\r\n    }\r\n\r\n    /**\r\n     * Create a new vector with the same direction but a different length as this vector.\r\n     *\r\n     * @param length The length of the new vector.\r\n     * @return The new vector with a new length.\r\n     */\r\n    public Vector2D setLength(double length) {\r\n      double len = length();\r\n      return new Vector2D(x * length / len, y * length / len);\r\n    }\r\n\r\n    /**\r\n     * Get the distance of this point's position vector to another point's position vector.\r\n     *\r\n     * @param p The second point's position vector.\r\n     * @return The distance between the points.\r\n     */\r\n    public double distance(Vector2D p) {\r\n      return Math.sqrt((this.x - p.x) * (this.x - p.x) + (this.y - p.y) * (this.y - p.y));\r\n    }\r\n\r\n    /** Change this vector to the new coordinates. */\r\n    public void move(double x, double y) {\r\n      this.x = x;\r\n      this.y = y;\r\n    }\r\n\r\n    /**\r\n     * Move a point's position vector in a direction (by a vector) and a distance.\r\n     *\r\n     * @param p The direction vector.\r\n     * @param distance The distance to move the new vector\r\n     * @return The new created vector.\r\n     */\r\n    public Vector2D moveTo(Vector2D p, double distance) {\r\n      double d = distance(p);\r\n      double dx = p.x - x;\r\n      double dy = p.y - y;\r\n      double coef = distance / d;\r\n      return new Vector2D(x + dx * coef, y + dy * coef);\r\n    }\r\n\r\n    /** Get the angle of this vector. Angle: 0 is right ((x, y) = (1, 0)); on clockwise (degree) */\r\n    public double getAngle() {\r\n      return ((Math.atan2(y, x) * 180 / Math.PI) + 720) % 360;\r\n    }\r\n\r\n    /** Get the angle of this vector as radiant. */\r\n    public double getAngleRad() {\r\n      return (Math.atan2(y, x) + 4 * Math.PI) % (2 * Math.PI);\r\n    }\r\n\r\n    /**\r\n     * Get the angle difference of this vector to another vector.\r\n     *\r\n     * @param vec The other vector.\r\n     * @return The angle difference of the two vectors (from 0 to 180).\r\n     */\r\n    public double getAngleDeltaTo(Vector2D vec) {\r\n      double delta = Math.abs(getAngle() - vec.getAngle());\r\n      if (delta > 180) {\r\n        delta = 360 - delta;\r\n      }\r\n      return delta;\r\n    }\r\n\r\n    /**\r\n     * Get the vector from this point to another.\r\n     *\r\n     * @param vec The point to which the vector is calculated.\r\n     * @return The vector from this points position vector to the other point.\r\n     */\r\n    public Vector2D vectorTo(Vector2D vec) {\r\n      return new Vector2D(vec.x - x, vec.y - y);\r\n    }\r\n\r\n    /**\r\n     * Checks whether a point (by its position vector) is in a given range of this point.\r\n     *\r\n     * @param p The point that is checked.\r\n     * @param range The range used for the check.\r\n     * @return True if the point is in the range of this point (distance <= range).\r\n     */\r\n    public boolean isInRange(Vector2D p, double range) {\r\n      return p != this && distance(p) <= range;\r\n    }\r\n\r\n    public double getX() {\r\n      return x;\r\n    }\r\n\r\n    public double getY() {\r\n      return y;\r\n    }\r\n  }\r\n\r\n  /** The stronges AI for the third and last league */\r\n  public static class MoveCalculatorLevel3 extends AbstractMoveCalculator\r\n      implements MoveCalculator {\r\n\r\n    /** The total number of moves that can be simulated in time */\r\n    public final int CALCULATED_MOVES = 100;\r\n\r\n    private int numScoreCalculations;\r\n    private long start;\r\n\r\n    public void calculateMove(Player player) {\r\n      update();\r\n      numScoreCalculations = 0;\r\n      start = System.currentTimeMillis();\r\n      DebugUtils.pause();\r\n\r\n      // first move is random\r\n      if (Player.turnCount == 1) {\r\n        player.setChosenMove(getRandomMove());\r\n        return;\r\n      }\r\n\r\n      Map<Move, Referee> possibleMoves = new HashMap<Move, Referee>();\r\n\r\n      // add passing as possible move\r\n      possibleMoves.put(new Move(-1, -1, Player.MY_COLOR), referee.clone());\r\n\r\n      // stones beneath other placed stones\r\n      List<FieldPosition> placedStones = getStonesOnBoard();\r\n      List<FieldPosition> nearPlacedStones = getFreeFieldsNear(placedStones);\r\n\r\n      DebugUtils.print(\"TIMING after nearPlacedStones: \" + (System.currentTimeMillis() - start));\r\n\r\n      if (nearPlacedStones.size() > CALCULATED_MOVES) {\r\n        Collections.shuffle(nearPlacedStones);\r\n        nearPlacedStones = nearPlacedStones.subList(0, CALCULATED_MOVES);\r\n      }\r\n\r\n      DebugUtils.print(\"TIMING: after shuffle \" + (System.currentTimeMillis() - start));\r\n\r\n      for (FieldPosition pos : nearPlacedStones) {\r\n        Move move = new Move(pos.getRow(), pos.getCol(), Player.MY_COLOR);\r\n        if (referee.isValidMove(move)) {\r\n          Referee ref = referee.clone();\r\n          ref.addMove(move);\r\n          possibleMoves.put(move, ref);\r\n        }\r\n      }\r\n\r\n      DebugUtils.print(\r\n          \"TIMING after adding near placed stones: \" + (System.currentTimeMillis() - start));\r\n\r\n      // all other positions (if spaces left)\r\n      int calculationsLeft = CALCULATED_MOVES - possibleMoves.size();\r\n      for (int i = 0; i < calculationsLeft; i++) {\r\n        Move random =\r\n            new Move(\r\n                (int) (Math.random() * Player.BOARD_SIZE),\r\n                (int) (Math.random() * Player.BOARD_SIZE),\r\n                Player.MY_COLOR);\r\n        if (referee.isValidMove(random)) {\r\n          Referee ref = referee.clone();\r\n          ref.addMove(random);\r\n          possibleMoves.put(random, ref);\r\n        }\r\n      }\r\n\r\n      DebugUtils.print(\r\n          \"TIMING after adding left calculations: \" + (System.currentTimeMillis() - start));\r\n\r\n      TreeMap<Double, Move> scores = new TreeMap<>();\r\n      for (Map.Entry<Move, Referee> move : possibleMoves.entrySet()) {\r\n        double score = calculateRefereeScore(move.getValue());\r\n        scores.put(score, move.getKey());\r\n      }\r\n\r\n      Move bestMove;\r\n      if (scores.isEmpty()) {\r\n        bestMove = new Move(-1, -1, Player.MY_COLOR);\r\n      } else {\r\n        bestMove = scores.lastEntry().getValue();\r\n      }\r\n      player.setChosenMove(bestMove);\r\n\r\n      referee.addMove(bestMove);\r\n    }\r\n\r\n    public double calculateRefereeScore(Referee ref) {\r\n      DebugUtils.pause();\r\n      DebugUtils.print(numScoreCalculations + \": \" + (System.currentTimeMillis() - start));\r\n      numScoreCalculations++;\r\n      DebugUtils.start();\r\n\r\n      double score = 0;\r\n\r\n      int myScore = ref.getGame().getStonesCaptured(Player.OPPONENT_COLOR);\r\n      int opponentScore = ref.getGame().getStonesCaptured(Player.MY_COLOR);\r\n\r\n      score += myScore * 1000;\r\n      score -= opponentScore * 1000;\r\n\r\n      List<Group> myGroups = findGroups(ref, Player.MY_COLOR);\r\n      List<Group> opponentGroups = findGroups(ref, Player.OPPONENT_COLOR);\r\n\r\n      int libertiesMe = 0;\r\n      int minLibertiesOpponent = Integer.MAX_VALUE;\r\n      int minLibertiesMe = Integer.MAX_VALUE;\r\n\r\n      for (Group group : myGroups) {\r\n        int liberties = group.getLiberties(ref).size();\r\n        libertiesMe += liberties;\r\n        minLibertiesMe = Math.min(liberties, minLibertiesMe);\r\n      }\r\n      for (Group group : opponentGroups) {\r\n        int liberties = group.getLiberties(ref).size();\r\n        minLibertiesOpponent = Math.min(liberties, minLibertiesOpponent);\r\n      }\r\n\r\n      score += libertiesMe;\r\n      score += minLibertiesMe * 10;\r\n      score -= minLibertiesOpponent * 100;\r\n\r\n      if (minLibertiesMe == 1) {\r\n        score -= 1000;\r\n      }\r\n\r\n      return score;\r\n    }\r\n  }\r\n\r\n  /** A slightly better AI for the second league: */\r\n  public static class MoveCalculatorLevel2 extends AbstractMoveCalculator\r\n      implements MoveCalculator {\r\n\r\n    public void calculateMove(Player player) {\r\n      update();\r\n\r\n      // first move is random\r\n      if (Player.turnCount == 1) {\r\n        player.setChosenMove(getRandomMove());\r\n        return;\r\n      }\r\n\r\n      Map<Move, Referee> possibleMoves = new HashMap<Move, Referee>();\r\n      for (int row = 0; row < Player.BOARD_SIZE; row++) {\r\n        for (int col = 0; col < Player.BOARD_SIZE; col++) {\r\n          Move move = new Move(row, col, Player.MY_COLOR);\r\n          Referee ref = referee.clone();\r\n          if (ref.isValidMove(move)) {\r\n            ref.addMove(move);\r\n            possibleMoves.put(move, ref);\r\n          }\r\n        }\r\n      }\r\n      // add passing as possible move\r\n      possibleMoves.put(new Move(-1, -1, Player.MY_COLOR), referee.clone());\r\n\r\n      TreeMap<Double, Move> scores = new TreeMap<>();\r\n      for (Map.Entry<Move, Referee> move : possibleMoves.entrySet()) {\r\n        double score = calculateRefereeScore(move.getValue());\r\n        scores.put(score, move.getKey());\r\n      }\r\n\r\n      Move bestMove;\r\n      if (scores.isEmpty()) {\r\n        bestMove = new Move(-1, -1, Player.MY_COLOR);\r\n      } else {\r\n        bestMove = scores.lastEntry().getValue();\r\n      }\r\n      player.setChosenMove(bestMove);\r\n\r\n      referee.addMove(bestMove);\r\n    }\r\n\r\n    public double calculateRefereeScore(Referee ref) {\r\n      double score = 0;\r\n\r\n      int myScore = ref.getGame().getStonesCaptured(Player.OPPONENT_COLOR);\r\n      int opponentScore = ref.getGame().getStonesCaptured(Player.MY_COLOR);\r\n\r\n      score += myScore * 1000;\r\n      score -= opponentScore * 1000;\r\n\r\n      List<Group> myGroups = findGroups(ref, Player.MY_COLOR);\r\n      List<Group> opponentGroups = findGroups(ref, Player.OPPONENT_COLOR);\r\n\r\n      int libertiesMe = 0;\r\n      int minLibertiesOpponent = Integer.MAX_VALUE;\r\n      int minLibertiesMe = Integer.MAX_VALUE;\r\n\r\n      for (Group group : myGroups) {\r\n        int liberties = group.getLiberties(ref).size();\r\n        libertiesMe += liberties;\r\n        minLibertiesMe = Math.min(liberties, minLibertiesMe);\r\n      }\r\n      for (Group group : opponentGroups) {\r\n        int liberties = group.getLiberties(ref).size();\r\n        minLibertiesOpponent = Math.min(liberties, minLibertiesOpponent);\r\n      }\r\n\r\n      score += libertiesMe;\r\n      score += minLibertiesMe * 10;\r\n      score -= minLibertiesOpponent * 100;\r\n\r\n      return score;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Simple AI for first league:\r\n   *\r\n   * <p>if (can kill enemy stones) kill them else choose a random legal move\r\n   */\r\n  public static class MoveCalculatorLevel1 extends AbstractMoveCalculator\r\n      implements MoveCalculator {\r\n\r\n    public void calculateMove(Player player) {\r\n      DebugUtils.print(\"start\");\r\n      update();\r\n      DebugUtils.print(\"after update\");\r\n\r\n      // first move is random\r\n      if (Player.turnCount == 1) {\r\n        player.setChosenMove(getRandomMove());\r\n        return;\r\n      }\r\n      DebugUtils.print(\"after random first turn\");\r\n\r\n      Map<Move, Referee> possibleMoves = new HashMap<Move, Referee>();\r\n      for (int row = 0; row < Player.BOARD_SIZE; row++) {\r\n        for (int col = 0; col < Player.BOARD_SIZE; col++) {\r\n          Move move = new Move(row, col, Player.MY_COLOR);\r\n          Referee ref = referee.clone();\r\n          if (ref.isValidMove(move)) {\r\n            ref.addMove(move);\r\n            possibleMoves.put(move, ref);\r\n          }\r\n        }\r\n      }\r\n      DebugUtils.print(\"after possible moves\");\r\n      // add passing as possible move\r\n      possibleMoves.put(new Move(-1, -1, Player.MY_COLOR), referee.clone());\r\n      DebugUtils.print(\"after pass as possible move\");\r\n\r\n      TreeMap<Double, Move> scores = new TreeMap<>();\r\n      for (Map.Entry<Move, Referee> move : possibleMoves.entrySet()) {\r\n        double score = calculateRefereeScore(move.getValue());\r\n        scores.put(score, move.getKey());\r\n      }\r\n      DebugUtils.print(\"after scores\");\r\n\r\n      Move bestMove;\r\n      if (scores.isEmpty()) {\r\n        bestMove = new Move(-1, -1, Player.MY_COLOR);\r\n      } else {\r\n        bestMove = scores.lastEntry().getValue();\r\n      }\r\n      player.setChosenMove(bestMove);\r\n\r\n      DebugUtils.print(\"after setChosenMove\");\r\n\r\n      referee.addMove(bestMove);\r\n\r\n      DebugUtils.print(\"end\");\r\n    }\r\n\r\n    public double calculateRefereeScore(Referee ref) {\r\n      double score = 0;\r\n\r\n      int myScore = ref.getGame().getStonesCaptured(Player.OPPONENT_COLOR);\r\n      int opponentScore = ref.getGame().getStonesCaptured(Player.MY_COLOR);\r\n\r\n      score += myScore * 1000;\r\n      score -= opponentScore * 1000;\r\n\r\n      score += Math.random();\r\n\r\n      return score;\r\n    }\r\n  }\r\n\r\n  public static class Group {\r\n\r\n    private Set<FieldPosition> stones;\r\n    private PlayerColor color;\r\n\r\n    public Group(Set<FieldPosition> stones, PlayerColor color) {\r\n      this.stones = stones;\r\n      this.color = color;\r\n    }\r\n\r\n    public Group(PlayerColor color) {\r\n      this.color = color;\r\n      this.stones = new HashSet<FieldPosition>();\r\n    }\r\n\r\n    public static Group findGroup(Referee ref, FieldPosition startingPosition) {\r\n      PlayerColor groupColor = ref.getStoneColor(startingPosition);\r\n      final int boardSize = Player.BOARD_SIZE;\r\n      if (groupColor == null) {\r\n        throw new IllegalArgumentException(\r\n            \"The field of the starting position is empty (position was: \" + startingPosition + \")\");\r\n      }\r\n\r\n      // complete the group by adding stones using a flood fill\r\n      Set<FieldPosition> allStones = new HashSet<FieldPosition>();\r\n\r\n      // initialize the current queue and the next step queue\r\n      Set<FieldPosition> currentStones = new HashSet<FieldPosition>();\r\n      Set<FieldPosition> nextStones = new HashSet<FieldPosition>();\r\n\r\n      // add the starting position\r\n      currentStones.add(startingPosition);\r\n\r\n      // add the fields with the iterative flood fill till the queues are empty\r\n      while (!currentStones.isEmpty()) {\r\n        for (FieldPosition currentField : currentStones) {\r\n          for (FieldPosition near : currentField.getFieldsNear(boardSize)) {\r\n            if (near.exists(boardSize)\r\n                && // the field exists on the board\r\n                ref.getStoneColor(near) != null\r\n                && // prevent NPE\r\n                ref.getStoneColor(near).equals(groupColor)\r\n                && // the field contains a stone of the group color\r\n                !allStones.contains(near)\r\n                && !currentStones.contains(near)) { // the field is not already added\r\n              nextStones.add(near);\r\n            }\r\n          }\r\n        }\r\n        // add the current stones to the group, copy the next steps to the queue and clear next\r\n        // steps\r\n        allStones.addAll(currentStones);\r\n        currentStones = nextStones;\r\n        nextStones = new HashSet<FieldPosition>();\r\n      }\r\n\r\n      return new Group(allStones, groupColor);\r\n    }\r\n\r\n    public boolean isBeaten(Referee ref) {\r\n      Set<FieldPosition> nearFreeFields = getLiberties(ref);\r\n\r\n      return nearFreeFields.isEmpty();\r\n    }\r\n\r\n    public Set<FieldPosition> getLiberties(Referee ref) {\r\n      Set<FieldPosition> liberties = new HashSet<>();\r\n      for (FieldPosition stone : stones) {\r\n        for (FieldPosition pos : stone.getFieldsNear()) {\r\n          if (pos.exists() && ref.isFieldEmpty(pos)) {\r\n            liberties.add(pos);\r\n          }\r\n        }\r\n      }\r\n      return liberties;\r\n\r\n      //\t\treturn stones.stream().flatMap(s -> s.getFieldsNear(Player.BOARD_SIZE).stream()) //all\r\n      // fields near\r\n      //\t\t\t\t.filter(field -> field.exists(Player.BOARD_SIZE) && ref.isFieldEmpty(field)) //existing\r\n      // and empty\r\n      //\t\t\t\t.collect(Collectors.toSet());\r\n    }\r\n\r\n    public void addStone(FieldPosition pos) {\r\n      stones.add(pos);\r\n    }\r\n\r\n    public void addStones(List<FieldPosition> positions) {\r\n      stones.addAll(positions);\r\n    }\r\n\r\n    public void remove(FieldPosition pos) {\r\n      stones.remove(pos);\r\n    }\r\n\r\n    public void clear() {\r\n      stones.clear();\r\n    }\r\n\r\n    public Set<FieldPosition> getStones() {\r\n      return stones;\r\n    }\r\n\r\n    public void setStones(Set<FieldPosition> stones) {\r\n      this.stones = stones;\r\n    }\r\n\r\n    public PlayerColor getColor() {\r\n      return color;\r\n    }\r\n\r\n    public void setColor(PlayerColor color) {\r\n      this.color = color;\r\n    }\r\n  }\r\n\r\n  public static class DebugUtils {\r\n\r\n    public static final boolean DEBUG = true;\r\n    public static boolean PAUSE_DEBUG = false;\r\n\r\n    public static final String DEFAULT_VECTOR_FORMAT = \"(%4.0f|%4.0f)\";\r\n\r\n    public static void pause() {\r\n      PAUSE_DEBUG = true;\r\n    }\r\n\r\n    public static void start() {\r\n      PAUSE_DEBUG = false;\r\n    }\r\n\r\n    public static void printVector2D(Vector2D vec, String prefix) {\r\n      print(prefix + vec.toString(\"(%4.0f|%4.0f)\"));\r\n    }\r\n\r\n    public static void printVector2D(Vector2D vec, String prefix, String format) {\r\n      print(prefix + vec.toString(format));\r\n    }\r\n\r\n    public static void printBoard(PlayerColor[][] board) {\r\n      StringBuilder sb = new StringBuilder();\r\n      for (PlayerColor[] line : board) {\r\n        for (PlayerColor field : line) {\r\n          sb.append(PlayerColor.toCharCode(field));\r\n        }\r\n        sb.append('\\n');\r\n      }\r\n      print(sb.toString());\r\n    }\r\n\r\n    public static void print(Object obj) {\r\n      print(obj.toString());\r\n    }\r\n\r\n    public static void print(String s) {\r\n      if (DEBUG) {\r\n        if (!PAUSE_DEBUG) {\r\n          System.err.println(s);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  public static class Game {\r\n\r\n    private int blackStonesCaptured;\r\n    private int whiteStonesCaptured;\r\n\r\n    public Game clone() {\r\n      Game clone = new Game();\r\n      clone.setBlackStonesCaptured(blackStonesCaptured);\r\n      clone.setWhiteStonesCaptured(whiteStonesCaptured);\r\n      return clone;\r\n    }\r\n\r\n    public int getStonesCaptured(PlayerColor color) {\r\n      if (color == PlayerColor.BLACK) {\r\n        return getBlackStonesCaptured();\r\n      } else if (color == PlayerColor.WHITE) {\r\n        return whiteStonesCaptured;\r\n      }\r\n      throw new IllegalStateException(\"Unknown PlayerColor: \" + color);\r\n    }\r\n\r\n    public void setStonesCaptured(PlayerColor color, int captured) {\r\n      if (color == PlayerColor.BLACK) {\r\n        blackStonesCaptured = captured;\r\n      } else if (color == PlayerColor.WHITE) {\r\n        whiteStonesCaptured = captured;\r\n      } else {\r\n        throw new IllegalStateException(\"Unknown PlayerColor: \" + color);\r\n      }\r\n    }\r\n\r\n    public int getBlackStonesCaptured() {\r\n      return blackStonesCaptured;\r\n    }\r\n\r\n    public void setBlackStonesCaptured(int blackStonesCaptured) {\r\n      this.blackStonesCaptured = blackStonesCaptured;\r\n    }\r\n\r\n    public int getWhiteStonesCaptured() {\r\n      return whiteStonesCaptured;\r\n    }\r\n\r\n    public void setWhiteStonesCaptured(int whiteStonesCaptured) {\r\n      this.whiteStonesCaptured = whiteStonesCaptured;\r\n    }\r\n  }\r\n\r\n  public static class FieldPosition {\r\n\r\n    private int row;\r\n    private int col;\r\n\r\n    public FieldPosition(int row, int col) {\r\n      super();\r\n      this.row = row;\r\n      this.col = col;\r\n    }\r\n\r\n    public int hashCode() {\r\n      final int prime = 31;\r\n      int result = 1;\r\n      result = prime * result + col;\r\n      result = prime * result + row;\r\n      return result;\r\n    }\r\n\r\n    public boolean equals(Object obj) {\r\n      if (this == obj) return true;\r\n      if (obj == null) return false;\r\n      if (getClass() != obj.getClass()) return false;\r\n      FieldPosition other = (FieldPosition) obj;\r\n      if (col != other.col) return false;\r\n      if (row != other.row) return false;\r\n      return true;\r\n    }\r\n\r\n    public List<FieldPosition> getFieldsNear() {\r\n      return getFieldsNear(Player.BOARD_SIZE);\r\n    }\r\n\r\n    public List<FieldPosition> getFieldsNear(int boardSize) {\r\n      int[][] near = new int[][] {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\r\n      List<FieldPosition> nearFields = new ArrayList<FieldPosition>();\r\n      for (int[] nearDiff : near) {\r\n        FieldPosition position = new FieldPosition(row + nearDiff[0], col + nearDiff[1]);\r\n        if (position.exists(boardSize)) {\r\n          nearFields.add(position);\r\n        }\r\n      }\r\n      return nearFields;\r\n    }\r\n\r\n    public boolean exists() {\r\n      return exists(Player.BOARD_SIZE);\r\n    }\r\n\r\n    public boolean exists(int boardSize) {\r\n      return row >= 0 && col >= 0 && row < boardSize && col < boardSize;\r\n    }\r\n\r\n    public int getRow() {\r\n      return row;\r\n    }\r\n\r\n    public void setRow(int row) {\r\n      this.row = row;\r\n    }\r\n\r\n    public int getCol() {\r\n      return col;\r\n    }\r\n\r\n    public void setCol(int col) {\r\n      this.col = col;\r\n    }\r\n  }\r\n\r\n  public interface MoveCalculator {\r\n\r\n    public void calculateMove(Player player);\r\n  }\r\n\r\n  public static class MoveCalculatorFactory {\r\n\r\n    public static MoveCalculatorImplementation usedCalculatorImplementation;\r\n\r\n    public static MoveCalculator createCalculator() {\r\n      switch (usedCalculatorImplementation) {\r\n        case MOVE_CALCULATOR_LEVEL_1:\r\n          return new MoveCalculatorLevel1();\r\n        case MOVE_CALCULATOR_LEVEL_2:\r\n          return new MoveCalculatorLevel2();\r\n        case MOVE_CALCULATOR_LEVEL_3:\r\n          return new MoveCalculatorLevel3();\r\n        default:\r\n          throw new IllegalStateException(\r\n              \"Unknown implementation type: \"\r\n                  + usedCalculatorImplementation\r\n                  + \"; choose a type in MoveCalculatorFactory or declare the unknown type\");\r\n      }\r\n    }\r\n  }\r\n\r\n  public enum MoveCalculatorImplementation {\r\n    MOVE_CALCULATOR_LEVEL_1, //\r\n    MOVE_CALCULATOR_LEVEL_2, //\r\n    MOVE_CALCULATOR_LEVEL_3, //\r\n  }\r\n\r\n  public enum PlayerColor {\r\n    BLACK,\r\n    WHITE;\r\n\r\n    public static PlayerColor getOpposizeColor(PlayerColor lastMove) {\r\n      switch (lastMove) {\r\n        case BLACK:\r\n          return WHITE;\r\n        case WHITE:\r\n          return BLACK;\r\n        default:\r\n          return null;\r\n      }\r\n    }\r\n\r\n    public static String toCharCode(PlayerColor color) {\r\n      if (color == BLACK) {\r\n        return \"B\";\r\n      }\r\n      if (color == WHITE) {\r\n        return \"W\";\r\n      }\r\n      return \".\";\r\n    }\r\n\r\n    public String toCharCode() {\r\n      return toCharCode(this);\r\n    }\r\n\r\n    public static PlayerColor fromCharCode(String charCode) {\r\n      if (charCode.equals(\"B\")) {\r\n        return BLACK;\r\n      } else if (charCode.equals(\"W\")) {\r\n        return WHITE;\r\n      }\r\n      throw new IllegalStateException(\"unknown charCode: \" + charCode);\r\n    }\r\n  }\r\n\r\n  public static class Referee {\r\n\r\n    public static final int FRAME_DURATION = 800;\r\n    public static final int FRAME_WIDTH = 1920;\r\n    public static final int FRAME_HEIGHT = 1080;\r\n    public static final int BOARD_WIDTH = 950;\r\n\r\n    private Game game;\r\n\r\n    private PlayerColor[][] board;\r\n    private PlayerColor[][] previousBoard;\r\n\r\n    public Referee() {\r\n      this(new Game());\r\n    }\r\n\r\n    public Referee(Game game) {\r\n      this.game = game;\r\n      board = new PlayerColor[Player.BOARD_SIZE][Player.BOARD_SIZE];\r\n    }\r\n\r\n    // ***************************************************************************************************************\r\n    // *** CG stuff\r\n    // ***************************************************************************************************************\r\n\r\n    // ***************************************************************************************************************\r\n    // *** simulation\r\n    // ***************************************************************************************************************\r\n\r\n    public Referee clone() {\r\n      Referee clone = new Referee(game.clone());\r\n      clone.board = new PlayerColor[Player.BOARD_SIZE][Player.BOARD_SIZE];\r\n      clone.previousBoard = new PlayerColor[Player.BOARD_SIZE][Player.BOARD_SIZE];\r\n\r\n      for (int i = 0; i < Player.BOARD_SIZE; i++) {\r\n        clone.board = getBoardCopy(board);\r\n        clone.previousBoard = getBoardCopy(previousBoard);\r\n      }\r\n\r\n      return clone;\r\n    }\r\n\r\n    // ***************************************************************************************************************\r\n    // *** game methods\r\n    // ***************************************************************************************************************\r\n\r\n    public static PlayerColor[][] getBoard(String[] lines) {\r\n      int size = lines.length;\r\n      PlayerColor[][] board = new PlayerColor[size][size];\r\n      for (int i = 0; i < size; i++) {\r\n        for (int j = 0; j < size; j++) {\r\n          if (lines[i].charAt(j) == 'B') {\r\n            board[i][j] = PlayerColor.BLACK;\r\n          } else if (lines[i].charAt(j) == 'W') {\r\n            board[i][j] = PlayerColor.WHITE;\r\n          }\r\n        }\r\n      }\r\n      return board;\r\n    }\r\n\r\n    /** Execute all moves in the list to create the current board */\r\n\r\n    /*private*/ void fillBoard(List<Move> moves) throws IllegalArgumentException {\r\n      if (moves != null) {\r\n        for (Move move : moves) {\r\n          if (isValidMove(move)) {\r\n            addMove(move);\r\n          } else {\r\n            throw new IllegalArgumentException(\r\n                \"Invalid move. The given list of moves contains a move that is not valid: \" + move);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    public PlayerColor[][] getBoard() {\r\n      return board;\r\n    }\r\n\r\n    /** A deep copy of the current board */\r\n    public PlayerColor[][] getBoardCopy() {\r\n      return getBoardCopy(board);\r\n    }\r\n\r\n    public PlayerColor[][] getBoardCopy(PlayerColor[][] board) {\r\n      PlayerColor[][] newBoard = new PlayerColor[Player.BOARD_SIZE][Player.BOARD_SIZE];\r\n      if (board != null) {\r\n        for (int i = 0; i < Player.BOARD_SIZE; i++) {\r\n          for (int j = 0; j < Player.BOARD_SIZE; j++) {\r\n            newBoard[i][j] = board[i][j];\r\n          }\r\n        }\r\n      }\r\n      return newBoard;\r\n    }\r\n    /**\r\n     * Check whether the move is valid\r\n     *\r\n     * <p>Checked are:\r\n     *\r\n     * <ul>\r\n     *   <li>color (players turn)\r\n     *   <li>position (on field and empty)\r\n     *   <li>no suicidal move (placed stone is not directly beaten)\r\n     *   <li>ko rule (move doesn't create the same board that was there in the last move)\r\n     * </ul>\r\n     */\r\n    public boolean isValidMove(Move move) {\r\n      if (move.isPass()) {\r\n        // passing is always a valid move\r\n        return true;\r\n      }\r\n      if (!move.getPos().exists(Player.BOARD_SIZE)) {\r\n        // position doesn't exist\r\n        return false;\r\n      }\r\n      if (getStoneColor(move.getPos()) != null) {\r\n        // field not empty\r\n        return false;\r\n      }\r\n\r\n      // execute the move and check whether the state is valid\r\n      PlayerColor[][] tmpBoard = getBoardCopy(); // keep a copy of the board for a rollback\r\n      // make the move\r\n      board[move.getRow()][move.getCol()] = move.getColor();\r\n      removeBeaten(move);\r\n\r\n      // check the group of the new stone\r\n      Group group = Group.findGroup(this, move.getPos());\r\n      if (group.isBeaten(this)) {\r\n        // added stone is directly beaten\r\n        board = tmpBoard;\r\n        return false;\r\n      }\r\n\r\n      if (!Player.OPPONENTS_LAST_MOVE.isPass() && boardsEqual(board, previousBoard)) {\r\n        // restores the board from the last move (ko rule violated)\r\n        board = tmpBoard;\r\n        return false;\r\n      }\r\n\r\n      board = tmpBoard;\r\n      return true;\r\n    }\r\n\r\n    /*private*/ static boolean boardsEqual(PlayerColor[][] board, PlayerColor[][] previousBoard) {\r\n      if (previousBoard == null) {\r\n        // previousBoard can be null if there was no previous move\r\n        // in this case the ko-rule can't be violated and the boards are treated as not equal (so\r\n        // false is returned)\r\n        return false;\r\n      }\r\n      boolean equal = true;\r\n      for (int i = 0; i < board.length; i++) {\r\n        for (int j = 0; j < board[0].length; j++) {\r\n          equal &= board[i][j] == previousBoard[i][j];\r\n        }\r\n      }\r\n      return equal;\r\n    }\r\n\r\n    /**\r\n     * Execute a move without checking whether it's valid. The new stone is added and beaten ones\r\n     * are removed\r\n     */\r\n    public void addMove(Move move) {\r\n      if (!move.isPass()) {\r\n        // copy the board to the previous board field\r\n        previousBoard = getBoardCopy();\r\n\r\n        // set the new stone\r\n        board[move.getRow()][move.getCol()] = move.getColor();\r\n        // remove beaten stones (if any)\r\n        removeBeaten(move, true);\r\n      }\r\n    }\r\n\r\n    /** Remove all stones that were beaten by the move */\r\n\r\n    /*private*/ void removeBeaten(Move move) {\r\n      removeBeaten(move, false);\r\n    }\r\n\r\n    private void removeBeaten(Move move, boolean countBeaten) {\r\n      // find the fields near to the move field\r\n      List<FieldPosition> near = move.getPos().getFieldsNear(Player.BOARD_SIZE);\r\n      for (FieldPosition pos : near) {\r\n        // check whether the field has a stone of the different color on it\r\n        if (getStoneColor(pos) == PlayerColor.getOpposizeColor(move.getColor())) {\r\n          Group group = Group.findGroup(this, pos);\r\n          if (group.isBeaten(this)) {\r\n            removeStones(group.getStones(), countBeaten);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    /** Remove all stones in the collection from the field */\r\n\r\n    /*private*/ void removeStones(Collection<FieldPosition> stones) {\r\n      removeStones(stones, false);\r\n    }\r\n\r\n    private void removeStones(Collection<FieldPosition> stones, boolean countBeaten) {\r\n      int stonesBeaten = stones.size();\r\n      PlayerColor beatenStonesColor = null;\r\n      for (FieldPosition pos : stones) {\r\n        beatenStonesColor = board[pos.getRow()][pos.getCol()];\r\n        board[pos.getRow()][pos.getCol()] = null;\r\n      }\r\n\r\n      if (countBeaten) {\r\n        if (beatenStonesColor == PlayerColor.BLACK) {\r\n          game.setBlackStonesCaptured(game.getBlackStonesCaptured() + stonesBeaten);\r\n        } else if (beatenStonesColor == PlayerColor.WHITE) {\r\n          game.setWhiteStonesCaptured(game.getWhiteStonesCaptured() + stonesBeaten);\r\n        }\r\n      }\r\n    }\r\n\r\n    public boolean isFieldEmpty(FieldPosition pos) {\r\n      return board[pos.getRow()][pos.getCol()] == null;\r\n    }\r\n\r\n    public PlayerColor getStoneColor(FieldPosition pos) {\r\n      return board[pos.getRow()][pos.getCol()];\r\n    }\r\n\r\n    public Game getGame() {\r\n      return game;\r\n    }\r\n\r\n    public void setBoard(PlayerColor[][] board) {\r\n      this.board = board;\r\n    }\r\n\r\n    public void setPreviousBoard(PlayerColor[][] board) {\r\n      this.previousBoard = board;\r\n    }\r\n\r\n    public PlayerColor[][] getPreviousBoard() {\r\n      return previousBoard;\r\n    }\r\n\r\n    public void printBoards() {\r\n      DebugUtils.print(\"Board\");\r\n      DebugUtils.printBoard(board);\r\n      DebugUtils.print(\"Previous Board\");\r\n      DebugUtils.printBoard(previousBoard);\r\n    }\r\n  }\r\n\r\n  /** @author Tobias */\r\n  public static class Move {\r\n\r\n    private int row;\r\n    private int col;\r\n    private Type type;\r\n    private PlayerColor color;\r\n\r\n    public enum Type {\r\n      STONE,\r\n      PASS;\r\n    }\r\n\r\n    public Move(int row, int col, PlayerColor color) {\r\n      this.row = row;\r\n      this.col = col;\r\n      this.color = color;\r\n      this.type = Type.STONE;\r\n      if (row == -1 && col == -1) {\r\n        this.type = Type.PASS;\r\n      }\r\n    }\r\n\r\n    public static Move getPassMove(PlayerColor color) {\r\n      Move pass = new Move(-1, -1, color);\r\n      pass.setType(Type.PASS);\r\n      return pass;\r\n    }\r\n\r\n    public FieldPosition getPos() {\r\n      return new FieldPosition(row, col);\r\n    }\r\n\r\n    public int hashCode() {\r\n      final int prime = 31;\r\n      int result = 1;\r\n      result = prime * result + col;\r\n      result = prime * result + ((color == null) ? 0 : color.hashCode());\r\n      result = prime * result + row;\r\n      return result;\r\n    }\r\n\r\n    public boolean equals(Object obj) {\r\n      if (this == obj) return true;\r\n      if (obj == null) return false;\r\n      if (getClass() != obj.getClass()) return false;\r\n      Move other = (Move) obj;\r\n      if (col != other.col) return false;\r\n      if (color != other.color) return false;\r\n      if (row != other.row) return false;\r\n      return true;\r\n    }\r\n\r\n    public int getRow() {\r\n      return row;\r\n    }\r\n\r\n    public void setRow(int row) {\r\n      this.row = row;\r\n    }\r\n\r\n    public int getCol() {\r\n      return col;\r\n    }\r\n\r\n    public void setCol(int col) {\r\n      this.col = col;\r\n    }\r\n\r\n    public PlayerColor getColor() {\r\n      return color;\r\n    }\r\n\r\n    public void setColor(PlayerColor color) {\r\n      this.color = color;\r\n    }\r\n\r\n    public Type getType() {\r\n      return type;\r\n    }\r\n\r\n    public void setType(Type type) {\r\n      this.type = type;\r\n    }\r\n\r\n    public boolean isPass() {\r\n      return type == Type.PASS;\r\n    }\r\n  }\r\n}\r\n",
          "testCases": [],
          "maxPlayers": 2,
          "minPlayers": 2,
          "statements": {
            "1": "<div style=\"color:#cccccc;padding:20px;margin-right:15px;margin-left:15px;margin-bottom:10px;text-align:left\">This is a slight modification of the board game <a href=\"https://en.wikipedia.org/wiki/Go_(game)\">Go</a>\r\n<br>Click <a href=\"https://senseis.xmp.net/?BasicRulesOfGo\">here</a> for an introduction into the rules of Go.\r\n<br>Click <a href=\"https://github.com/tfassbender/codingame_atari_go\">here</a> for the Referee code<br>\r\n</div>\r\n<div class=\"statement-body\">\r\n<!-- GOAL --> \r\n    <div class=\"statement-section statement-goal\"> \r\n      <h2> \r\n        <span class=\"icon icon-goal\">&nbsp;</span> \r\n        <span>The Goal</span> \r\n      </h2> \r\n      <div class=\"statement-goal-content\"> \r\n        The game is now played over 200 turns. \r\n      </div> \r\n    </div> \r\n    <!-- RULES -->\r\n    <div class=\"statement-section statement-rules\">\r\n        <h1>\r\n            <span class=\"icon icon-rules\">&nbsp;</span>\r\n            <span>Rules</span>\r\n        </h1>\r\n        <div class=\"statement-rules-content\">\r\n            Atari Go is a modification of the classical board game <a href=\"https://en.wikipedia.org/wiki/Go_(game)\">Go</a>, that is often used to teach new players the rules of Go.<br />\r\n            The rules are basically the same as the Go rules with some modifications to make the game a bit easier:\r\n            <ul>\r\n            \t<li>You don't gain points by occupying fields</li>\r\n            \t<li>The only way to gain points is to capture the stones of your opponent</li>\r\n            \t<li>The game does not end after both players have passed (the game ends after <const>200</const> turns)</li>\r\n            \t<li>All other rules stay the same as in the game of Go</li>\r\n            </ul>\r\n            \r\n            <h3>Go Rules</h3>\r\n            A game of Go is usually played on a board of 19x19 fields. In the first leagues a board of 9x9 or 13x13 fields is used, but in the later leagues a 19x19 board is used.\r\n            <br>\r\n            While playing, both players place one of their stones (per turn) on a free position on the field. The stones are not moved after they are placed. You can only add new stones.\r\n            <br>\r\n            The goal of the game is to capture the stones of your opponent. This can be done by surrounding the stones (or groups) of your opponent with your stones. If a stone or group has no free fields beneath it, it is captured and removed from the board (see example 2).\r\n            <br>\r\n            If a stone is surrounded by other stones of the same color this stone is not captured, but all stones that are directly touching each other form a group. This group shares it's free fields. So a group of stones is often stronger and more difficult to capture than a single stone (see example 1).\r\n            <br>\r\n            <br>\r\n            Beside these simple rules there are a view more rules, on where stones can be placed and where not.\r\n            <ul>\r\n            \t<li>You can only place a stone on a field where no stone is placed yet</li>\r\n            \t<li>You can not play a stone that would directly be removed (no suicidal moves). An exception to this rule is that the opponent stones are removed before this rule is applied. So if your stone seems to be directly surrounded by other stones, but it captures and removes at least one of the surrounding stones it can be played (see example 3)</li>\r\n            \t<li>You can not play a stone that would lead to the same board, like in the last turn when you played a stone. This is called the Ko-Rule (see example 4)</li>\r\n            </ul>\r\n        </div>\r\n    </div>\r\n\r\n    <!-- EXAMPLES -->\r\n    <div class=\"statement-section statement-examples\">\r\n        <h1>\r\n            <span class=\"icon icon-example\">&nbsp;</span>\r\n            <span>Examples</span>\r\n        </h1>\r\n\r\n        <div class=\"statement-examples-text\">\r\n            <div class=\"first-example\">\r\n            \t<h3>Example 1 - Groups</h3>\r\n            \tIn the image below the three white stones form a group. Therefore the two upper stones (that are completely surrounded) are not captured as long as one stone of the group is not completely captured.\r\n            \t<p><img src=\"https://senseis.xmp.net/diagrams/41/49d804c30e36bd3cf3666a6d76f39644.png\" style=\"height: 150px; width: auto;\"></img></p>\r\n            \t<br>\r\n            \t<br>\r\n            </div>\r\n            \r\n            <div class=\"second-example\">\r\n            \t<h3>Example 2 - Capturing stones</h3>\r\n            \tIn the image below the white stone is almost captured. The last free field it has is marked with a red square. The other fields (marked with red crosses) are not directly adjacent to the white stone and are therefore no free fields for the white stone.\r\n            \t<p><img src=\"https://senseis.xmp.net/diagrams/0/7cac8afadce46df1d520ee56b4eece8b.png\" style=\"height: 150px; width: auto;\"></img></p>\r\n            \tNow if the back stone is placed like in the image below...\r\n            \t<p><img src=\"https://senseis.xmp.net/diagrams/48/ceb2245b3fbf4c62872f4bdf2796ac95.png\" style=\"height: 150px; width: auto;\"></img></p>\r\n            \t...the white stone has no free fields around it and therefore it is captured. So it will be removed and after the turn of the black stone the field will look like in the image below.\r\n            \t<p><img src=\"https://senseis.xmp.net/diagrams/13/6e7dc384eb2e8b494e097f38d4259bcb.png\" style=\"height: 150px; width: auto;\"></img></p>\r\n            \t<br>\r\n            \t<br>\r\n            </div>\r\n            \r\n            <div class=\"third-example\">\r\n            \t<h3>Example 3 - Suicidal moves</h3>\r\n            \tIn the image below, a white stone that is placed in the middle of the four black stones would have no free fields beneath it and would be directly removed. Therefore a white stone can't be placed in the middle of the black stones in this case.\r\n            \t<p><img src=\"https://senseis.xmp.net/diagrams/13/6e7dc384eb2e8b494e097f38d4259bcb.png\" style=\"height: 150px; width: auto;\"></img></p>\r\n            \tAn exception to this rule is shown in the following image: In this image it seems to be the same case. A white stone that is placed in the middle of the black stones would have no free fields adjacent to it and would be removed. But in this case the white stone can be placed in the middle of the black stones as shown in the next image.\r\n            \t<p><img src=\"https://senseis.xmp.net/diagrams/37/0708d56ffed33ef1058f0185803a7f46.png\" style=\"height: 150px; width: auto;\"></img></p>\r\n            \tBefore the free fields of the white stone are counted, first the black stones are to be removed. This leads to the following field after the white stone is placed:\r\n            \t<p><img src=\"https://senseis.xmp.net/diagrams/47/00bb7694a7980ec3018ee6a2e721f212.png\" style=\"height: 150px; width: auto;\"></img></p>\r\n            \tSince the white stone now has a free field adjacent to it (where the black stone was removed) it can be played.\r\n            \t<br>\r\n            \t<br>\r\n            </div>\r\n            \r\n            <div class=\"fourth-example\">\r\n            \t<h3>Example 4 - Ko-Rule</h3>\r\n            \tIn the third example it was shown that in a field, like the one in the image below, a white stone can be placed in the middle of the four black stones...\r\n            \t<p><img src=\"https://senseis.xmp.net/diagrams/37/0708d56ffed33ef1058f0185803a7f46.png\" style=\"height: 150px; width: auto;\"></img></p>\r\n            \t... which would lead to a board that looks like this:\r\n            \t<p><img src=\"https://senseis.xmp.net/diagrams/47/00bb7694a7980ec3018ee6a2e721f212.png\" style=\"height: 150px; width: auto;\"></img></p>\r\n            \tNow it seems that a black stone could do a similar move by placing it in the middle of the four white stones like this:\r\n            \t<p><img src=\"https://senseis.xmp.net/diagrams/28/8da1b11165650ffa0964df5ff2debbe1.png\" style=\"height: 150px; width: auto;\"></img></p>\r\n            \tThis would normally be a valid move (just like in the third example), but to prevent the game to get stuck on this (both players just capturing the same stones again and again), the above move is not possible for the black stone, because it would lead to the same board like one turn before (the first image of this example).<br>\r\n            \tBut it would be possible to place a black stone on any other field, let white place a stone too, and then come back to this formation of stones and place the black stone in between the white stones (like in the image above) because now it would no longer lead to the same board like in the first image of this example (there are now two more stones placed somewhere on the board).\r\n            \t<br>\r\n            \t<br>\r\n            </div>\r\n        </div>\r\n    </div><br>\r\n\r\n    <!-- Victory conditions -->\r\n    <div class=\"statement-victory-conditions\">\r\n        <div class=\"icon victory\"></div>\r\n        <div class=\"blk\">\r\n            <div class=\"title\">Victory Conditions</div>\r\n            <div class=\"text\">\r\n                <ul style=\"padding-bottom: 0;\">\r\n                    <li>Capture more stones than your opponent</li>\r\n                    <li>If no player has captured any stones after the maximum number of turns is reached, the player that has played more stones wins (to prevent a draw if a player passes in every move)</li>\r\n                </ul>\r\n            </div>\r\n        </div>\r\n    </div>\r\n\r\n    <!-- Lose conditions -->\r\n    <div class=\"statement-lose-conditions\">\r\n        <div class=\"icon lose\"></div>\r\n        <div class=\"blk\">\r\n            <div class=\"title\">Loss Conditions</div>\r\n            <div class=\"text\">\r\n                <ul style=\"padding-bottom: 0;\">\r\n                    <li>You send an illegal move</li>\r\n                    <li>You don't respond in time or output an unrecognized command</li>\r\n                </ul>\r\n            </div>\r\n        </div>\r\n    </div>\r\n\r\n    <!-- PROTOCOL -->\r\n    <div class=\"statement-section statement-protocol\">\r\n        <h1>\r\n        <span class=\"icon icon-protocol\">&nbsp;</span>\r\n        <span>Game Input</span>\r\n    </h1>\r\n\r\n    <!-- Protocol block -->\r\n    <div class=\"blk\">\r\n        <div class=\"title\">Initial input</div>\r\n        <div class=\"text\">\r\n            <span class=\"statement-lineno\">First line</span>: <var>myColor</var>: <action>B</action> if you are playing the black stones or <action>W</action> if you're playing the white stones.\r\n            <br>\r\n            <span class=\"statement-lineno\">Next line</span>: <var>boardSize</var>: an integer representing the size of the board\r\n            <br>\r\n            <br>\r\n        </div>\r\n        <div class=\"title\">Input for one game turn</div>\r\n        <div class=\"text\">\r\n            <span class=\"statement-lineno\">First line</span>: <var>x</var> <var>y</var>: two integers representing the position of the last stone, that your opponent played (\"-1 -1\" in the first turn)\r\n            <br>\r\n            <span class=\"statement-lineno\">Next line</span>: <var>myScore</var> <var>opponentScore</var>: two integers representing your current score and your opponent's current score (the number of captured stones)\r\n            <br>\r\n            <span class=\"statement-lineno\">Next <var>boardSize</var> lines</span>: <var>line</var>: one line of the current board, where <action>B</action> marks a black stone, <action>W</action> marks a white stone and <action>.</action> marks an empty field\r\n            <br>\r\n        </div>\r\n    </div>\r\n\r\n    <!-- Protocol block -->\r\n    <div class=\"blk\">\r\n        <div class=\"title\">Output</div>\r\n        <div class=\"text\">\r\n            <span class=\"statement-lineno\">A single line containing</span>: either the <var>x</var> and <var>y</var> coordinates of the next stone you want to play or <var>PASS</var> if you don't want to play a stone (<var>PASS</var> is always a valid move)<br>\r\n        <br>\r\n        </div>\r\n    </div>\r\n\r\n    <!-- Protocol block -->\r\n    <div class=\"blk\">\r\n        <div class=\"title\">Constraints</div>\r\n        Response time first turn is \r\n        <const>1000</const> ms.\r\n        <br>Response time per turn is \r\n        <const>100</const> ms.\r\n        <br><br>The game ends after <const>200</const> turns (200 stones for each player)\r\n        </div>\r\n    </div>\r\n</div>",
            "2": "<div style=\"color:#cccccc;padding:20px;margin-right:15px;margin-left:15px;margin-bottom:10px;text-align:left\">This is a slight modification of the board game <a href=\"https://en.wikipedia.org/wiki/Go_(game)\">Go</a>\r\n<br>Click <a href=\"https://senseis.xmp.net/?BasicRulesOfGo\">here</a> for an introduction into the rules of Go.\r\n<br>Click <a href=\"https://github.com/tfassbender/codingame_atari_go\">here</a> for the Referee code<br>\r\n</div>\r\n<div class=\"statement-body\">\r\n<!-- GOAL --> \r\n    <div class=\"statement-section statement-goal\"> \r\n      <h2> \r\n        <span class=\"icon icon-goal\">&nbsp;</span> \r\n        <span>The Goal</span> \r\n      </h2> \r\n      <div class=\"statement-goal-content\"> \r\n        The game is now played over 200 turns. \r\n      </div> \r\n    </div> \r\n    <!-- RULES -->\r\n    <div class=\"statement-section statement-rules\">\r\n        <h1>\r\n            <span class=\"icon icon-rules\">&nbsp;</span>\r\n            <span>Rules</span>\r\n        </h1>\r\n        <div class=\"statement-rules-content\">\r\n            Atari Go is a modification of the classical board game <a href=\"https://en.wikipedia.org/wiki/Go_(game)\">Go</a>, that is often used to teach new players the rules of Go.<br />\r\n            The rules are basically the same as the Go rules with some modifications to make the game a bit easier:\r\n            <ul>\r\n            \t<li>You don't gain points by occupying fields</li>\r\n            \t<li>The only way to gain points is to capture the stones of your opponent</li>\r\n            \t<li>The game does not end after both players have passed (the game ends after <const>200</const> turns)</li>\r\n            \t<li>All other rules stay the same as in the game of Go</li>\r\n            </ul>\r\n            \r\n            <h3>Go Rules</h3>\r\n            A game of Go is usually played on a board of 19x19 fields. In the first leagues a board of 9x9 or 13x13 fields is used, but in the later leagues a 19x19 board is used.\r\n            <br>\r\n            While playing, both players place one of their stones (per turn) on a free position on the field. The stones are not moved after they are placed. You can only add new stones.\r\n            <br>\r\n            The goal of the game is to capture the stones of your opponent. This can be done by surrounding the stones (or groups) of your opponent with your stones. If a stone or group has no free fields beneath it, it is captured and removed from the board (see example 2).\r\n            <br>\r\n            If a stone is surrounded by other stones of the same color this stone is not captured, but all stones that are directly touching each other form a group. This group shares it's free fields. So a group of stones is often stronger and more difficult to capture than a single stone (see example 1).\r\n            <br>\r\n            <br>\r\n            Beside these simple rules there are a view more rules, on where stones can be placed and where not.\r\n            <ul>\r\n            \t<li>You can only place a stone on a field where no stone is placed yet</li>\r\n            \t<li>You can not play a stone that would directly be removed (no suicidal moves). An exception to this rule is that the opponent stones are removed before this rule is applied. So if your stone seems to be directly surrounded by other stones, but it captures and removes at least one of the surrounding stones it can be played (see example 3)</li>\r\n            \t<li>You can not play a stone that would lead to the same board, like in the last turn when you played a stone. This is called the Ko-Rule (see example 4)</li>\r\n            </ul>\r\n        </div>\r\n    </div>\r\n\r\n    <!-- EXAMPLES -->\r\n    <div class=\"statement-section statement-examples\">\r\n        <h1>\r\n            <span class=\"icon icon-example\">&nbsp;</span>\r\n            <span>Examples</span>\r\n        </h1>\r\n\r\n        <div class=\"statement-examples-text\">\r\n            <div class=\"first-example\">\r\n            \t<h3>Example 1 - Groups</h3>\r\n            \tIn the image below the three white stones form a group. Therefore the two upper stones (that are completely surrounded) are not captured as long as one stone of the group is not completely captured.\r\n            \t<p><img src=\"https://senseis.xmp.net/diagrams/41/49d804c30e36bd3cf3666a6d76f39644.png\" style=\"height: 150px; width: auto;\"></img></p>\r\n            \t<br>\r\n            \t<br>\r\n            </div>\r\n            \r\n            <div class=\"second-example\">\r\n            \t<h3>Example 2 - Capturing stones</h3>\r\n            \tIn the image below the white stone is almost captured. The last free field it has is marked with a red square. The other fields (marked with red crosses) are not directly adjacent to the white stone and are therefore no free fields for the white stone.\r\n            \t<p><img src=\"https://senseis.xmp.net/diagrams/0/7cac8afadce46df1d520ee56b4eece8b.png\" style=\"height: 150px; width: auto;\"></img></p>\r\n            \tNow if the back stone is placed like in the image below...\r\n            \t<p><img src=\"https://senseis.xmp.net/diagrams/48/ceb2245b3fbf4c62872f4bdf2796ac95.png\" style=\"height: 150px; width: auto;\"></img></p>\r\n            \t...the white stone has no free fields around it and therefore it is captured. So it will be removed and after the turn of the black stone the field will look like in the image below.\r\n            \t<p><img src=\"https://senseis.xmp.net/diagrams/13/6e7dc384eb2e8b494e097f38d4259bcb.png\" style=\"height: 150px; width: auto;\"></img></p>\r\n            \t<br>\r\n            \t<br>\r\n            </div>\r\n            \r\n            <div class=\"third-example\">\r\n            \t<h3>Example 3 - Suicidal moves</h3>\r\n            \tIn the image below, a white stone that is placed in the middle of the four black stones would have no free fields beneath it and would be directly removed. Therefore a white stone can't be placed in the middle of the black stones in this case.\r\n            \t<p><img src=\"https://senseis.xmp.net/diagrams/13/6e7dc384eb2e8b494e097f38d4259bcb.png\" style=\"height: 150px; width: auto;\"></img></p>\r\n            \tAn exception to this rule is shown in the following image: In this image it seems to be the same case. A white stone that is placed in the middle of the black stones would have no free fields adjacent to it and would be removed. But in this case the white stone can be placed in the middle of the black stones as shown in the next image.\r\n            \t<p><img src=\"https://senseis.xmp.net/diagrams/37/0708d56ffed33ef1058f0185803a7f46.png\" style=\"height: 150px; width: auto;\"></img></p>\r\n            \tBefore the free fields of the white stone are counted, first the black stones are to be removed. This leads to the following field after the white stone is placed:\r\n            \t<p><img src=\"https://senseis.xmp.net/diagrams/47/00bb7694a7980ec3018ee6a2e721f212.png\" style=\"height: 150px; width: auto;\"></img></p>\r\n            \tSince the white stone now has a free field adjacent to it (where the black stone was removed) it can be played.\r\n            \t<br>\r\n            \t<br>\r\n            </div>\r\n            \r\n            <div class=\"fourth-example\">\r\n            \t<h3>Example 4 - Ko-Rule</h3>\r\n            \tIn the third example it was shown that in a field, like the one in the image below, a white stone can be placed in the middle of the four black stones...\r\n            \t<p><img src=\"https://senseis.xmp.net/diagrams/37/0708d56ffed33ef1058f0185803a7f46.png\" style=\"height: 150px; width: auto;\"></img></p>\r\n            \t... which would lead to a board that looks like this:\r\n            \t<p><img src=\"https://senseis.xmp.net/diagrams/47/00bb7694a7980ec3018ee6a2e721f212.png\" style=\"height: 150px; width: auto;\"></img></p>\r\n            \tNow it seems that a black stone could do a similar move by placing it in the middle of the four white stones like this:\r\n            \t<p><img src=\"https://senseis.xmp.net/diagrams/28/8da1b11165650ffa0964df5ff2debbe1.png\" style=\"height: 150px; width: auto;\"></img></p>\r\n            \tThis would normally be a valid move (just like in the third example), but to prevent the game to get stuck on this (both players just capturing the same stones again and again), the above move is not possible for the black stone, because it would lead to the same board like one turn before (the first image of this example).<br>\r\n            \tBut it would be possible to place a black stone on any other field, let white place a stone too, and then come back to this formation of stones and place the black stone in between the white stones (like in the image above) because now it would no longer lead to the same board like in the first image of this example (there are now two more stones placed somewhere on the board).\r\n            \t<br>\r\n            \t<br>\r\n            </div>\r\n        </div>\r\n    </div><br>\r\n\r\n    <!-- Victory conditions -->\r\n    <div class=\"statement-victory-conditions\">\r\n        <div class=\"icon victory\"></div>\r\n        <div class=\"blk\">\r\n            <div class=\"title\">Victory Conditions</div>\r\n            <div class=\"text\">\r\n                <ul style=\"padding-bottom: 0;\">\r\n                    <li>Capture more stones than your opponent</li>\r\n                    <li>If no player has captured any stones after the maximum number of turns is reached, the player that has played more stones wins (to prevent a draw if a player passes in every move)</li>\r\n                </ul>\r\n            </div>\r\n        </div>\r\n    </div>\r\n\r\n    <!-- Lose conditions -->\r\n    <div class=\"statement-lose-conditions\">\r\n        <div class=\"icon lose\"></div>\r\n        <div class=\"blk\">\r\n            <div class=\"title\">Loss Conditions</div>\r\n            <div class=\"text\">\r\n                <ul style=\"padding-bottom: 0;\">\r\n                    <li>You send an illegal move</li>\r\n                    <li>You don't respond in time or output an unrecognized command</li>\r\n                </ul>\r\n            </div>\r\n        </div>\r\n    </div>\r\n\r\n    <!-- PROTOCOL -->\r\n    <div class=\"statement-section statement-protocol\">\r\n        <h1>\r\n        <span class=\"icon icon-protocol\">&nbsp;</span>\r\n        <span>Game Input</span>\r\n    </h1>\r\n\r\n    <!-- Protocol block -->\r\n    <div class=\"blk\">\r\n        <div class=\"title\">Initial input</div>\r\n        <div class=\"text\">\r\n            <span class=\"statement-lineno\">First line</span>: <var>myColor</var>: <action>B</action> if you are playing the black stones or <action>W</action> if you're playing the white stones.\r\n            <br>\r\n            <span class=\"statement-lineno\">Next line</span>: <var>boardSize</var>: an integer representing the size of the board\r\n            <br>\r\n            <br>\r\n        </div>\r\n        <div class=\"title\">Input for one game turn</div>\r\n        <div class=\"text\">\r\n            <span class=\"statement-lineno\">First line</span>: <var>x</var> <var>y</var>: two integers representing the position of the last stone, that your opponent played (\"-1 -1\" in the first turn)\r\n            <br>\r\n            <span class=\"statement-lineno\">Next line</span>: <var>myScore</var> <var>opponentScore</var>: two integers representing your current score and your opponent's current score (the number of captured stones)\r\n            <br>\r\n            <span class=\"statement-lineno\">Next <var>boardSize</var> lines</span>: <var>line</var>: one line of the current board, where <action>B</action> marks a black stone, <action>W</action> marks a white stone and <action>.</action> marks an empty field\r\n            <br>\r\n        </div>\r\n    </div>\r\n\r\n    <!-- Protocol block -->\r\n    <div class=\"blk\">\r\n        <div class=\"title\">Output</div>\r\n        <div class=\"text\">\r\n            <span class=\"statement-lineno\">A single line containing</span>: either the <var>x</var> and <var>y</var> coordinates of the next stone you want to play or <var>PASS</var> if you don't want to play a stone (<var>PASS</var> is always a valid move)<br>\r\n        <br>\r\n        </div>\r\n    </div>\r\n\r\n    <!-- Protocol block -->\r\n    <div class=\"blk\">\r\n        <div class=\"title\">Constraints</div>\r\n        Response time first turn is \r\n        <const>1000</const> ms.\r\n        <br>Response time per turn is \r\n        <const>100</const> ms.\r\n        <br><br>The game ends after <const>200</const> turns (200 stones for each player)\r\n        </div>\r\n    </div>\r\n</div>"
          },
          "questionType": "multi",
          "stubGenerator": "read myColor:string(1)\r\nread boardSize:int\r\ngameloop\r\nread opponentX:int opponentY:int\r\nread myScore:int opponentScore:int\r\nloop boardSize read line:string(boardSize)\r\nwrite PASS\r\n\r\nSTATEMENT\r\nCapture more stones than your opponent.\r\n\r\nINPUT\r\nopponentX: The x coordinate of your opponent's last move (or -1 if the opponent passed)\r\nopponentY: The y coordinate of your opponent's last move (or -1 if the opponent passed)\r\nmyScore: Your current score (the number of captured stones)\r\nopponentScore: the opponents current score (the number of captured stones)\r\nboardSize: the size of the board (width and height)\r\nline: A row of the current board where 'B' marks a black stone, 'W' marks a white stone and '.' marks an empty field\r\n\r\nOUTPUT\r\nx and y coordinates of the stone you want to place or PASS if you don't want to place a stone",
          "welcomePopups": {
            "1": "<div style=\"text-align:center\">\r\n        <h2>You&#39;ve made it to the next league.</h2>\r\n        The game now lasts 200 turns.\r\n        <div class=\"small\"><img src=\"https://cdn-games.codingame.com/community/1443538-1590321517105/67db39d8eea83cf1ae98792b8fd1e377cf3d2cdcd6d173e33bbaf1b890c08502.png\" style=\"width:500px;max-width:100%\" /></div>\r\n        <div class=\"small\">See the updated statement for details.</div>\r\n</div>",
            "2": "<div style=\"text-align:center\">\r\n        <h2>You&#39;ve made it to the next league.</h2>\r\n        The game now lasts 200 turns.\r\n        <div class=\"small\"><img src=\"https://cdn-games.codingame.com/community/1443538-1590321517105/67db39d8eea83cf1ae98792b8fd1e377cf3d2cdcd6d173e33bbaf1b890c08502.png\" style=\"width:500px;max-width:100%\" /></div>\r\n        <div class=\"small\">See the updated statement for details.</div>\r\n</div>"
          },
          "aiCodeExtension": "java",
          "criteriaLanguageMap": {}
        },
        "2": {
          "aiCode": "import java.util.Scanner;\r\nimport java.util.Collection;\r\nimport java.util.List;\r\nimport java.util.ArrayList;\r\nimport java.util.HashSet;\r\nimport java.util.Set;\r\nimport java.util.HashMap;\r\nimport java.util.Map;\r\nimport java.util.TreeMap;\r\nimport java.util.Collections;\r\n\r\nclass Player {\r\n\r\n  public static final boolean LOCAL = false;\r\n\r\n  public Scanner in = new Scanner(System.in);\r\n\r\n  public static int turnCount;\r\n\r\n  public static PlayerColor MY_COLOR;\r\n  public static PlayerColor OPPONENT_COLOR;\r\n  public static Move OPPONENTS_LAST_MOVE = new Move(-1, -1, PlayerColor.WHITE);\r\n  public static int MY_SCORE;\r\n  public static int OPPONENT_SCORE;\r\n  public static int BOARD_SIZE;\r\n  public static int FIELDS_ON_BOARD;\r\n  public static PlayerColor[][] BOARD;\r\n\r\n  public MoveCalculator calculator;\r\n  public Move chosenMove;\r\n\r\n  static {\r\n    // MoveCalculatorFactory.usedCalculatorImplementation =\r\n    // MoveCalculatorImplementation.MOVE_CALCULATOR_LEVEL_1;\r\n    // MoveCalculatorFactory.usedCalculatorImplementation =\r\n    // MoveCalculatorImplementation.MOVE_CALCULATOR_LEVEL_2;\r\n    MoveCalculatorFactory.usedCalculatorImplementation =\r\n        MoveCalculatorImplementation.MOVE_CALCULATOR_LEVEL_3;\r\n  }\r\n\r\n  /** Entry point at Codingame, which calls then the play() method. */\r\n  public static void main(String[] args) {\r\n    Player p = new Player();\r\n    p.play();\r\n  }\r\n\r\n  /**\r\n   * This method is called, by the main Method, which is added by the Converter. This way, the game\r\n   * should be played at Codingame.\r\n   */\r\n  public void play() {\r\n    readInitialInput(in);\r\n    while (true) {\r\n      turnCount++;\r\n      readFromScanner(in);\r\n      calculateMove();\r\n      sendMove();\r\n    }\r\n  }\r\n\r\n  private void readInitialInput(Scanner in) {\r\n    String myColor = in.nextLine();\r\n    BOARD_SIZE = in.nextInt(); // the size of the board (width and height)\r\n    MY_COLOR = PlayerColor.fromCharCode(myColor);\r\n    OPPONENT_COLOR = PlayerColor.getOpposizeColor(MY_COLOR);\r\n  }\r\n\r\n  /**\r\n   * Default read in logic comes here.\r\n   *\r\n   * @param in Scanner, which provides the defined input lines.\r\n   */\r\n  public void readFromScanner(Scanner in) {\r\n    int opponentX =\r\n        in\r\n            .nextInt(); // The x coordinate of your opponent's last move (or -1 if the opponent\r\n                        // passed)\r\n    int opponentY =\r\n        in\r\n            .nextInt(); // The y coordinate of your opponent's last move (or -1 if the opponent\r\n                        // passed)\r\n    OPPONENTS_LAST_MOVE = new Move(opponentY, opponentX, PlayerColor.getOpposizeColor(MY_COLOR));\r\n    MY_SCORE = in.nextInt(); // Your current score (the number of captured stones)\r\n    OPPONENT_SCORE = in.nextInt(); // the opponents current score (the number of captured stones)\r\n\r\n    FIELDS_ON_BOARD = BOARD_SIZE * BOARD_SIZE;\r\n    if (in.hasNextLine()) {\r\n      in.nextLine();\r\n    }\r\n    String[] lines = new String[BOARD_SIZE];\r\n    for (int i = 0; i < BOARD_SIZE; i++) {\r\n      String line =\r\n          in\r\n              .nextLine(); // A row of the current board where 'B' marks a black stone, 'W' marks a\r\n                           // white stone and '.' marks an empty field\r\n      lines[i] = line;\r\n    }\r\n\r\n    BOARD = Referee.getBoard(lines);\r\n\r\n    chosenMove = null;\r\n  }\r\n\r\n  public void sendMove() {\r\n    if (chosenMove == null) {\r\n      System.err.println(\"ERROR: NO MOVE CHOSEN - USING DEFAULT: PASS\");\r\n      System.out.println(\"PASS\");\r\n    } else if (chosenMove.isPass()) {\r\n      System.out.println(\"PASS\");\r\n    } else {\r\n      System.out.println(chosenMove.getCol() + \" \" + chosenMove.getRow());\r\n    }\r\n  }\r\n\r\n  public void calculateMove() {\r\n    if (calculator == null) {\r\n      calculator = MoveCalculatorFactory.createCalculator();\r\n    }\r\n    calculator.calculateMove(this);\r\n  }\r\n\r\n  public void setChosenMove(Move chosenMove) {\r\n    this.chosenMove = chosenMove;\r\n  }\r\n\r\n  public abstract static class AbstractMoveCalculator implements MoveCalculator {\r\n\r\n    public Referee referee;\r\n\r\n    public AbstractMoveCalculator() {\r\n      referee = new Referee();\r\n    }\r\n\r\n    public abstract void calculateMove(Player player);\r\n\r\n    public List<Group> findGroups(Referee ref, PlayerColor color) {\r\n      List<Group> groups = new ArrayList<Group>(Player.FIELDS_ON_BOARD / 2);\r\n      Set<FieldPosition> known = new HashSet<>();\r\n      for (int row = 0; row < Player.BOARD_SIZE; row++) {\r\n        for (int col = 0; col < Player.BOARD_SIZE; col++) {\r\n          FieldPosition pos = new FieldPosition(row, col);\r\n          if (!known.contains(pos) && ref.getStoneColor(pos) == color) {\r\n            Group group = Group.findGroup(ref, pos);\r\n            groups.add(group);\r\n            known.addAll(group.getStones());\r\n          }\r\n        }\r\n      }\r\n\r\n      return groups;\r\n    }\r\n\r\n    protected void update() {\r\n      // update current scores\r\n      referee.getGame().setStonesCaptured(Player.MY_COLOR, Player.MY_SCORE);\r\n      referee\r\n          .getGame()\r\n          .setStonesCaptured(PlayerColor.getOpposizeColor(Player.MY_COLOR), Player.OPPONENT_SCORE);\r\n      // update the board\r\n      referee.addMove(Player.OPPONENTS_LAST_MOVE);\r\n      referee.setBoard(Player.BOARD);\r\n      referee.setBoard(referee.getBoardCopy());\r\n    }\r\n\r\n    protected Move getRandomMove() {\r\n      Move random;\r\n      do {\r\n        random =\r\n            new Move(\r\n                (int) (Math.random() * Player.BOARD_SIZE - 6 + 3),\r\n                (int) (Math.random() * Player.BOARD_SIZE - 6 + 3),\r\n                Player.MY_COLOR);\r\n      } while (!referee.isValidMove(random));\r\n      return random;\r\n    }\r\n\r\n    protected List<FieldPosition> getStonesOnBoard() {\r\n      List<FieldPosition> stones = new ArrayList<FieldPosition>(Player.FIELDS_ON_BOARD);\r\n      PlayerColor[][] board = referee.getBoard();\r\n      for (int i = 0; i < Player.BOARD_SIZE; i++) {\r\n        for (int j = 0; j < Player.BOARD_SIZE; j++) {\r\n          if (board[i][j] != null) {\r\n            stones.add(new FieldPosition(i, j));\r\n          }\r\n        }\r\n      }\r\n      return stones;\r\n    }\r\n\r\n    protected List<FieldPosition> getFreeFieldsNear(List<FieldPosition> placedStones) {\r\n      List<FieldPosition> freeFieldsNear = new ArrayList<>(Player.FIELDS_ON_BOARD);\r\n      for (FieldPosition stone : placedStones) {\r\n        for (FieldPosition pos : stone.getFieldsNear()) {\r\n          if (referee.isFieldEmpty(pos)) {\r\n            freeFieldsNear.add(pos);\r\n          }\r\n        }\r\n      }\r\n      return freeFieldsNear;\r\n    }\r\n  }\r\n\r\n  public static class Vector2D implements Cloneable {\r\n\r\n    public double x;\r\n    public double y;\r\n\r\n    public static final Vector2D NAN_VEC = new Vector2D(Double.NaN, Double.NaN);\r\n    public static final Vector2D NULL_VEC = new Vector2D(0, 0);\r\n\r\n    /*public enum Axis {\r\n    \tX,\r\n    \tY;\r\n    }*/\r\n\r\n    public Vector2D() {}\r\n\r\n    /** Crate a new Vector2D with x and y components. */\r\n    public Vector2D(double x, double y) {\r\n      this.x = x;\r\n      this.y = y;\r\n    }\r\n\r\n    public Vector2D(double... val) {\r\n      if (val.length != 2) {\r\n        // throw new LinearAlgebraException(\"A 2D Vector has 2 entries.\");\r\n      }\r\n      x = val[0];\r\n      y = val[1];\r\n    }\r\n    /**\r\n     * Create a Vector2D by an angle (in degree). An angle of 0 results in (x, y) = (1, 0); 90 in\r\n     * (x, y) = (0, 1); ... The resulting vector has a length of 1.\r\n     *\r\n     * @param angleDegree The angle of the new vector in degree.\r\n     */\r\n    public Vector2D(double angleDegree) {\r\n      this(Math.cos(angleDegree * Math.PI / 180), Math.sin(angleDegree * Math.PI / 180));\r\n    }\r\n\r\n    private Vector2D(Vector2D clone) {\r\n      this.x = clone.x;\r\n      this.y = clone.y;\r\n    }\r\n\r\n    /** Clone this Vector2D object. */\r\n    public Vector2D clone() {\r\n      return new Vector2D(this);\r\n    }\r\n\r\n    public String toString() {\r\n      return \"Vector2D[x: \" + x + \" y: \" + y + \"]\";\r\n    }\r\n\r\n    public String toString(String format) {\r\n      return String.format(format, x, y);\r\n    }\r\n\r\n    public boolean equals(Object obj) {\r\n      if (obj instanceof Vector2D) {\r\n        Vector2D v = (Vector2D) obj;\r\n        return Math.abs(x - v.x) < 1e-8 && Math.abs(y - v.y) < 1e-8;\r\n      }\r\n      return false;\r\n    }\r\n\r\n    /** Get this vector as 2D-Array. */\r\n    public double[] asArray() {\r\n      return new double[] {x, y};\r\n    }\r\n\r\n    /** The (euclidean) length of the Vector. */\r\n    public double length() {\r\n      return Math.hypot(x, y);\r\n    }\r\n    /**\r\n     * The length of this vector in a given norm.\r\n     *\r\n     * @param norm The norm of the vector length.\r\n     * @return The length of this vector in the given norm.\r\n     */\r\n    public double length(int norm) {\r\n      if (norm == Integer.MAX_VALUE) {\r\n        return Math.max(x, y);\r\n      }\r\n      return Math.pow(Math.pow(x, norm) + Math.pow(y, norm), 1.0 / norm);\r\n    }\r\n\r\n    /**\r\n     * Rotate the Vector an angle (in degrees) resulting in a new Vector that is returned.\r\n     *\r\n     * @param degrees The angle to return the vector.\r\n     * @return The new created vector.\r\n     */\r\n    public Vector2D rotate(double degrees) {\r\n      return new Vector2D(getAngle() + degrees).setLength(length());\r\n    }\r\n\r\n    /**\r\n     * Project the vector given as parameter on this vector.\r\n     *\r\n     * @param vec The vector that is to be projected on this vector.\r\n     * @return The projected vector.\r\n     */\r\n    public Vector2D project(Vector2D vec) {\r\n      return mult(scalar(vec) / Math.pow(length(), 2));\r\n    }\r\n\r\n    /**\r\n     * Add another Vector2D to this vector resulting in a new Vector that is returned.\r\n     *\r\n     * @param vec The vector added to this vector.\r\n     * @return The new created vector.\r\n     */\r\n    public Vector2D add(Vector2D vec) {\r\n      return new Vector2D(x + vec.x, y + vec.y);\r\n    }\r\n    /**\r\n     * Subtract another Vector3D from this vector resulting in a new Vector that is returned.\r\n     *\r\n     * @param vec The vector subtracted from this vector.\r\n     * @return The new created vector.\r\n     */\r\n    public Vector2D sub(Vector2D vec) {\r\n      return new Vector2D(x - vec.x, y - vec.y);\r\n    }\r\n    /**\r\n     * Multiply this vector with a scalar resulting in a new Vector that is returned.\r\n     *\r\n     * @param scalar The scalar to multiply this vector with.\r\n     * @return The new created vector.\r\n     */\r\n    public Vector2D mult(double scalar) {\r\n      return new Vector2D(x * scalar, y * scalar);\r\n    }\r\n\r\n    /**\r\n     * Check whether this vector is linearly dependent to the parameter vector.\r\n     *\r\n     * @param vec The checked vector.\r\n     * @return True if the vectors are linearly dependent. False otherwise.\r\n     */\r\n    public boolean isLinearlyDependent(Vector2D vec) {\r\n      double t1 = (x == 0 ? 0 : vec.x / x);\r\n      double t2 = (y == 0 ? 0 : vec.y / y);\r\n      return Math.abs(t1 - t2) < 1e-5 && t1 != 0; // all parameters t are equal and != 0\r\n    }\r\n\r\n    /**\r\n     * Check whether the parameter vectors are linearly dependent.\r\n     *\r\n     * @param vectors The vectors that are checked.\r\n     * @return True if the vectors are linearly dependent. False otherwise.\r\n     */\r\n    public boolean isLinearlyDependentVectors(Vector2D... vectors) {\r\n      if (vectors.length < 2) {\r\n        return false;\r\n      } else if (vectors.length > 2) {\r\n        // 3 or more vectors in the R^2 are always linearly dependent\r\n        return true;\r\n      } else {\r\n        return vectors[0].isLinearlyDependent(vectors[1]);\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Calculate the scalar product of this vector and the parameter vector.\r\n     *\r\n     * @param vec The vector to calculate the scalar with this vector.\r\n     * @return The scalar of the vectors.\r\n     */\r\n    public double scalar(Vector2D vec) {\r\n      return this.x * vec.x + this.y * vec.y;\r\n    }\r\n\r\n    /**\r\n     * Create a new vector with the same direction but a different length as this vector.\r\n     *\r\n     * @param length The length of the new vector.\r\n     * @return The new vector with a new length.\r\n     */\r\n    public Vector2D setLength(double length) {\r\n      double len = length();\r\n      return new Vector2D(x * length / len, y * length / len);\r\n    }\r\n\r\n    /**\r\n     * Get the distance of this point's position vector to another point's position vector.\r\n     *\r\n     * @param p The second point's position vector.\r\n     * @return The distance between the points.\r\n     */\r\n    public double distance(Vector2D p) {\r\n      return Math.sqrt((this.x - p.x) * (this.x - p.x) + (this.y - p.y) * (this.y - p.y));\r\n    }\r\n\r\n    /** Change this vector to the new coordinates. */\r\n    public void move(double x, double y) {\r\n      this.x = x;\r\n      this.y = y;\r\n    }\r\n\r\n    /**\r\n     * Move a point's position vector in a direction (by a vector) and a distance.\r\n     *\r\n     * @param p The direction vector.\r\n     * @param distance The distance to move the new vector\r\n     * @return The new created vector.\r\n     */\r\n    public Vector2D moveTo(Vector2D p, double distance) {\r\n      double d = distance(p);\r\n      double dx = p.x - x;\r\n      double dy = p.y - y;\r\n      double coef = distance / d;\r\n      return new Vector2D(x + dx * coef, y + dy * coef);\r\n    }\r\n\r\n    /** Get the angle of this vector. Angle: 0 is right ((x, y) = (1, 0)); on clockwise (degree) */\r\n    public double getAngle() {\r\n      return ((Math.atan2(y, x) * 180 / Math.PI) + 720) % 360;\r\n    }\r\n\r\n    /** Get the angle of this vector as radiant. */\r\n    public double getAngleRad() {\r\n      return (Math.atan2(y, x) + 4 * Math.PI) % (2 * Math.PI);\r\n    }\r\n\r\n    /**\r\n     * Get the angle difference of this vector to another vector.\r\n     *\r\n     * @param vec The other vector.\r\n     * @return The angle difference of the two vectors (from 0 to 180).\r\n     */\r\n    public double getAngleDeltaTo(Vector2D vec) {\r\n      double delta = Math.abs(getAngle() - vec.getAngle());\r\n      if (delta > 180) {\r\n        delta = 360 - delta;\r\n      }\r\n      return delta;\r\n    }\r\n\r\n    /**\r\n     * Get the vector from this point to another.\r\n     *\r\n     * @param vec The point to which the vector is calculated.\r\n     * @return The vector from this points position vector to the other point.\r\n     */\r\n    public Vector2D vectorTo(Vector2D vec) {\r\n      return new Vector2D(vec.x - x, vec.y - y);\r\n    }\r\n\r\n    /**\r\n     * Checks whether a point (by its position vector) is in a given range of this point.\r\n     *\r\n     * @param p The point that is checked.\r\n     * @param range The range used for the check.\r\n     * @return True if the point is in the range of this point (distance <= range).\r\n     */\r\n    public boolean isInRange(Vector2D p, double range) {\r\n      return p != this && distance(p) <= range;\r\n    }\r\n\r\n    public double getX() {\r\n      return x;\r\n    }\r\n\r\n    public double getY() {\r\n      return y;\r\n    }\r\n  }\r\n\r\n  /** The stronges AI for the third and last league */\r\n  public static class MoveCalculatorLevel3 extends AbstractMoveCalculator\r\n      implements MoveCalculator {\r\n\r\n    /** The total number of moves that can be simulated in time */\r\n    public final int CALCULATED_MOVES = 100;\r\n\r\n    private int numScoreCalculations;\r\n    private long start;\r\n\r\n    public void calculateMove(Player player) {\r\n      update();\r\n      numScoreCalculations = 0;\r\n      start = System.currentTimeMillis();\r\n      DebugUtils.pause();\r\n\r\n      // first move is random\r\n      if (Player.turnCount == 1) {\r\n        player.setChosenMove(getRandomMove());\r\n        return;\r\n      }\r\n\r\n      Map<Move, Referee> possibleMoves = new HashMap<Move, Referee>();\r\n\r\n      // add passing as possible move\r\n      possibleMoves.put(new Move(-1, -1, Player.MY_COLOR), referee.clone());\r\n\r\n      // stones beneath other placed stones\r\n      List<FieldPosition> placedStones = getStonesOnBoard();\r\n      List<FieldPosition> nearPlacedStones = getFreeFieldsNear(placedStones);\r\n\r\n      DebugUtils.print(\"TIMING after nearPlacedStones: \" + (System.currentTimeMillis() - start));\r\n\r\n      if (nearPlacedStones.size() > CALCULATED_MOVES) {\r\n        Collections.shuffle(nearPlacedStones);\r\n        nearPlacedStones = nearPlacedStones.subList(0, CALCULATED_MOVES);\r\n      }\r\n\r\n      DebugUtils.print(\"TIMING: after shuffle \" + (System.currentTimeMillis() - start));\r\n\r\n      for (FieldPosition pos : nearPlacedStones) {\r\n        Move move = new Move(pos.getRow(), pos.getCol(), Player.MY_COLOR);\r\n        if (referee.isValidMove(move)) {\r\n          Referee ref = referee.clone();\r\n          ref.addMove(move);\r\n          possibleMoves.put(move, ref);\r\n        }\r\n      }\r\n\r\n      DebugUtils.print(\r\n          \"TIMING after adding near placed stones: \" + (System.currentTimeMillis() - start));\r\n\r\n      // all other positions (if spaces left)\r\n      int calculationsLeft = CALCULATED_MOVES - possibleMoves.size();\r\n      for (int i = 0; i < calculationsLeft; i++) {\r\n        Move random =\r\n            new Move(\r\n                (int) (Math.random() * Player.BOARD_SIZE),\r\n                (int) (Math.random() * Player.BOARD_SIZE),\r\n                Player.MY_COLOR);\r\n        if (referee.isValidMove(random)) {\r\n          Referee ref = referee.clone();\r\n          ref.addMove(random);\r\n          possibleMoves.put(random, ref);\r\n        }\r\n      }\r\n\r\n      DebugUtils.print(\r\n          \"TIMING after adding left calculations: \" + (System.currentTimeMillis() - start));\r\n\r\n      TreeMap<Double, Move> scores = new TreeMap<>();\r\n      for (Map.Entry<Move, Referee> move : possibleMoves.entrySet()) {\r\n        double score = calculateRefereeScore(move.getValue());\r\n        scores.put(score, move.getKey());\r\n      }\r\n\r\n      Move bestMove;\r\n      if (scores.isEmpty()) {\r\n        bestMove = new Move(-1, -1, Player.MY_COLOR);\r\n      } else {\r\n        bestMove = scores.lastEntry().getValue();\r\n      }\r\n      player.setChosenMove(bestMove);\r\n\r\n      referee.addMove(bestMove);\r\n    }\r\n\r\n    public double calculateRefereeScore(Referee ref) {\r\n      DebugUtils.pause();\r\n      DebugUtils.print(numScoreCalculations + \": \" + (System.currentTimeMillis() - start));\r\n      numScoreCalculations++;\r\n      DebugUtils.start();\r\n\r\n      double score = 0;\r\n\r\n      int myScore = ref.getGame().getStonesCaptured(Player.OPPONENT_COLOR);\r\n      int opponentScore = ref.getGame().getStonesCaptured(Player.MY_COLOR);\r\n\r\n      score += myScore * 1000;\r\n      score -= opponentScore * 1000;\r\n\r\n      List<Group> myGroups = findGroups(ref, Player.MY_COLOR);\r\n      List<Group> opponentGroups = findGroups(ref, Player.OPPONENT_COLOR);\r\n\r\n      int libertiesMe = 0;\r\n      int minLibertiesOpponent = Integer.MAX_VALUE;\r\n      int minLibertiesMe = Integer.MAX_VALUE;\r\n\r\n      for (Group group : myGroups) {\r\n        int liberties = group.getLiberties(ref).size();\r\n        libertiesMe += liberties;\r\n        minLibertiesMe = Math.min(liberties, minLibertiesMe);\r\n      }\r\n      for (Group group : opponentGroups) {\r\n        int liberties = group.getLiberties(ref).size();\r\n        minLibertiesOpponent = Math.min(liberties, minLibertiesOpponent);\r\n      }\r\n\r\n      score += libertiesMe;\r\n      score += minLibertiesMe * 10;\r\n      score -= minLibertiesOpponent * 100;\r\n\r\n      if (minLibertiesMe == 1) {\r\n        score -= 1000;\r\n      }\r\n\r\n      return score;\r\n    }\r\n  }\r\n\r\n  /** A slightly better AI for the second league: */\r\n  public static class MoveCalculatorLevel2 extends AbstractMoveCalculator\r\n      implements MoveCalculator {\r\n\r\n    public void calculateMove(Player player) {\r\n      update();\r\n\r\n      // first move is random\r\n      if (Player.turnCount == 1) {\r\n        player.setChosenMove(getRandomMove());\r\n        return;\r\n      }\r\n\r\n      Map<Move, Referee> possibleMoves = new HashMap<Move, Referee>();\r\n      for (int row = 0; row < Player.BOARD_SIZE; row++) {\r\n        for (int col = 0; col < Player.BOARD_SIZE; col++) {\r\n          Move move = new Move(row, col, Player.MY_COLOR);\r\n          Referee ref = referee.clone();\r\n          if (ref.isValidMove(move)) {\r\n            ref.addMove(move);\r\n            possibleMoves.put(move, ref);\r\n          }\r\n        }\r\n      }\r\n      // add passing as possible move\r\n      possibleMoves.put(new Move(-1, -1, Player.MY_COLOR), referee.clone());\r\n\r\n      TreeMap<Double, Move> scores = new TreeMap<>();\r\n      for (Map.Entry<Move, Referee> move : possibleMoves.entrySet()) {\r\n        double score = calculateRefereeScore(move.getValue());\r\n        scores.put(score, move.getKey());\r\n      }\r\n\r\n      Move bestMove;\r\n      if (scores.isEmpty()) {\r\n        bestMove = new Move(-1, -1, Player.MY_COLOR);\r\n      } else {\r\n        bestMove = scores.lastEntry().getValue();\r\n      }\r\n      player.setChosenMove(bestMove);\r\n\r\n      referee.addMove(bestMove);\r\n    }\r\n\r\n    public double calculateRefereeScore(Referee ref) {\r\n      double score = 0;\r\n\r\n      int myScore = ref.getGame().getStonesCaptured(Player.OPPONENT_COLOR);\r\n      int opponentScore = ref.getGame().getStonesCaptured(Player.MY_COLOR);\r\n\r\n      score += myScore * 1000;\r\n      score -= opponentScore * 1000;\r\n\r\n      List<Group> myGroups = findGroups(ref, Player.MY_COLOR);\r\n      List<Group> opponentGroups = findGroups(ref, Player.OPPONENT_COLOR);\r\n\r\n      int libertiesMe = 0;\r\n      int minLibertiesOpponent = Integer.MAX_VALUE;\r\n      int minLibertiesMe = Integer.MAX_VALUE;\r\n\r\n      for (Group group : myGroups) {\r\n        int liberties = group.getLiberties(ref).size();\r\n        libertiesMe += liberties;\r\n        minLibertiesMe = Math.min(liberties, minLibertiesMe);\r\n      }\r\n      for (Group group : opponentGroups) {\r\n        int liberties = group.getLiberties(ref).size();\r\n        minLibertiesOpponent = Math.min(liberties, minLibertiesOpponent);\r\n      }\r\n\r\n      score += libertiesMe;\r\n      score += minLibertiesMe * 10;\r\n      score -= minLibertiesOpponent * 100;\r\n\r\n      return score;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Simple AI for first league:\r\n   *\r\n   * <p>if (can kill enemy stones) kill them else choose a random legal move\r\n   */\r\n  public static class MoveCalculatorLevel1 extends AbstractMoveCalculator\r\n      implements MoveCalculator {\r\n\r\n    public void calculateMove(Player player) {\r\n      DebugUtils.print(\"start\");\r\n      update();\r\n      DebugUtils.print(\"after update\");\r\n\r\n      // first move is random\r\n      if (Player.turnCount == 1) {\r\n        player.setChosenMove(getRandomMove());\r\n        return;\r\n      }\r\n      DebugUtils.print(\"after random first turn\");\r\n\r\n      Map<Move, Referee> possibleMoves = new HashMap<Move, Referee>();\r\n      for (int row = 0; row < Player.BOARD_SIZE; row++) {\r\n        for (int col = 0; col < Player.BOARD_SIZE; col++) {\r\n          Move move = new Move(row, col, Player.MY_COLOR);\r\n          Referee ref = referee.clone();\r\n          if (ref.isValidMove(move)) {\r\n            ref.addMove(move);\r\n            possibleMoves.put(move, ref);\r\n          }\r\n        }\r\n      }\r\n      DebugUtils.print(\"after possible moves\");\r\n      // add passing as possible move\r\n      possibleMoves.put(new Move(-1, -1, Player.MY_COLOR), referee.clone());\r\n      DebugUtils.print(\"after pass as possible move\");\r\n\r\n      TreeMap<Double, Move> scores = new TreeMap<>();\r\n      for (Map.Entry<Move, Referee> move : possibleMoves.entrySet()) {\r\n        double score = calculateRefereeScore(move.getValue());\r\n        scores.put(score, move.getKey());\r\n      }\r\n      DebugUtils.print(\"after scores\");\r\n\r\n      Move bestMove;\r\n      if (scores.isEmpty()) {\r\n        bestMove = new Move(-1, -1, Player.MY_COLOR);\r\n      } else {\r\n        bestMove = scores.lastEntry().getValue();\r\n      }\r\n      player.setChosenMove(bestMove);\r\n\r\n      DebugUtils.print(\"after setChosenMove\");\r\n\r\n      referee.addMove(bestMove);\r\n\r\n      DebugUtils.print(\"end\");\r\n    }\r\n\r\n    public double calculateRefereeScore(Referee ref) {\r\n      double score = 0;\r\n\r\n      int myScore = ref.getGame().getStonesCaptured(Player.OPPONENT_COLOR);\r\n      int opponentScore = ref.getGame().getStonesCaptured(Player.MY_COLOR);\r\n\r\n      score += myScore * 1000;\r\n      score -= opponentScore * 1000;\r\n\r\n      score += Math.random();\r\n\r\n      return score;\r\n    }\r\n  }\r\n\r\n  public static class Group {\r\n\r\n    private Set<FieldPosition> stones;\r\n    private PlayerColor color;\r\n\r\n    public Group(Set<FieldPosition> stones, PlayerColor color) {\r\n      this.stones = stones;\r\n      this.color = color;\r\n    }\r\n\r\n    public Group(PlayerColor color) {\r\n      this.color = color;\r\n      this.stones = new HashSet<FieldPosition>();\r\n    }\r\n\r\n    public static Group findGroup(Referee ref, FieldPosition startingPosition) {\r\n      PlayerColor groupColor = ref.getStoneColor(startingPosition);\r\n      final int boardSize = Player.BOARD_SIZE;\r\n      if (groupColor == null) {\r\n        throw new IllegalArgumentException(\r\n            \"The field of the starting position is empty (position was: \" + startingPosition + \")\");\r\n      }\r\n\r\n      // complete the group by adding stones using a flood fill\r\n      Set<FieldPosition> allStones = new HashSet<FieldPosition>();\r\n\r\n      // initialize the current queue and the next step queue\r\n      Set<FieldPosition> currentStones = new HashSet<FieldPosition>();\r\n      Set<FieldPosition> nextStones = new HashSet<FieldPosition>();\r\n\r\n      // add the starting position\r\n      currentStones.add(startingPosition);\r\n\r\n      // add the fields with the iterative flood fill till the queues are empty\r\n      while (!currentStones.isEmpty()) {\r\n        for (FieldPosition currentField : currentStones) {\r\n          for (FieldPosition near : currentField.getFieldsNear(boardSize)) {\r\n            if (near.exists(boardSize)\r\n                && // the field exists on the board\r\n                ref.getStoneColor(near) != null\r\n                && // prevent NPE\r\n                ref.getStoneColor(near).equals(groupColor)\r\n                && // the field contains a stone of the group color\r\n                !allStones.contains(near)\r\n                && !currentStones.contains(near)) { // the field is not already added\r\n              nextStones.add(near);\r\n            }\r\n          }\r\n        }\r\n        // add the current stones to the group, copy the next steps to the queue and clear next\r\n        // steps\r\n        allStones.addAll(currentStones);\r\n        currentStones = nextStones;\r\n        nextStones = new HashSet<FieldPosition>();\r\n      }\r\n\r\n      return new Group(allStones, groupColor);\r\n    }\r\n\r\n    public boolean isBeaten(Referee ref) {\r\n      Set<FieldPosition> nearFreeFields = getLiberties(ref);\r\n\r\n      return nearFreeFields.isEmpty();\r\n    }\r\n\r\n    public Set<FieldPosition> getLiberties(Referee ref) {\r\n      Set<FieldPosition> liberties = new HashSet<>();\r\n      for (FieldPosition stone : stones) {\r\n        for (FieldPosition pos : stone.getFieldsNear()) {\r\n          if (pos.exists() && ref.isFieldEmpty(pos)) {\r\n            liberties.add(pos);\r\n          }\r\n        }\r\n      }\r\n      return liberties;\r\n\r\n      //\t\treturn stones.stream().flatMap(s -> s.getFieldsNear(Player.BOARD_SIZE).stream()) //all\r\n      // fields near\r\n      //\t\t\t\t.filter(field -> field.exists(Player.BOARD_SIZE) && ref.isFieldEmpty(field)) //existing\r\n      // and empty\r\n      //\t\t\t\t.collect(Collectors.toSet());\r\n    }\r\n\r\n    public void addStone(FieldPosition pos) {\r\n      stones.add(pos);\r\n    }\r\n\r\n    public void addStones(List<FieldPosition> positions) {\r\n      stones.addAll(positions);\r\n    }\r\n\r\n    public void remove(FieldPosition pos) {\r\n      stones.remove(pos);\r\n    }\r\n\r\n    public void clear() {\r\n      stones.clear();\r\n    }\r\n\r\n    public Set<FieldPosition> getStones() {\r\n      return stones;\r\n    }\r\n\r\n    public void setStones(Set<FieldPosition> stones) {\r\n      this.stones = stones;\r\n    }\r\n\r\n    public PlayerColor getColor() {\r\n      return color;\r\n    }\r\n\r\n    public void setColor(PlayerColor color) {\r\n      this.color = color;\r\n    }\r\n  }\r\n\r\n  public static class DebugUtils {\r\n\r\n    public static final boolean DEBUG = true;\r\n    public static boolean PAUSE_DEBUG = false;\r\n\r\n    public static final String DEFAULT_VECTOR_FORMAT = \"(%4.0f|%4.0f)\";\r\n\r\n    public static void pause() {\r\n      PAUSE_DEBUG = true;\r\n    }\r\n\r\n    public static void start() {\r\n      PAUSE_DEBUG = false;\r\n    }\r\n\r\n    public static void printVector2D(Vector2D vec, String prefix) {\r\n      print(prefix + vec.toString(\"(%4.0f|%4.0f)\"));\r\n    }\r\n\r\n    public static void printVector2D(Vector2D vec, String prefix, String format) {\r\n      print(prefix + vec.toString(format));\r\n    }\r\n\r\n    public static void printBoard(PlayerColor[][] board) {\r\n      StringBuilder sb = new StringBuilder();\r\n      for (PlayerColor[] line : board) {\r\n        for (PlayerColor field : line) {\r\n          sb.append(PlayerColor.toCharCode(field));\r\n        }\r\n        sb.append('\\n');\r\n      }\r\n      print(sb.toString());\r\n    }\r\n\r\n    public static void print(Object obj) {\r\n      print(obj.toString());\r\n    }\r\n\r\n    public static void print(String s) {\r\n      if (DEBUG) {\r\n        if (!PAUSE_DEBUG) {\r\n          System.err.println(s);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  public static class Game {\r\n\r\n    private int blackStonesCaptured;\r\n    private int whiteStonesCaptured;\r\n\r\n    public Game clone() {\r\n      Game clone = new Game();\r\n      clone.setBlackStonesCaptured(blackStonesCaptured);\r\n      clone.setWhiteStonesCaptured(whiteStonesCaptured);\r\n      return clone;\r\n    }\r\n\r\n    public int getStonesCaptured(PlayerColor color) {\r\n      if (color == PlayerColor.BLACK) {\r\n        return getBlackStonesCaptured();\r\n      } else if (color == PlayerColor.WHITE) {\r\n        return whiteStonesCaptured;\r\n      }\r\n      throw new IllegalStateException(\"Unknown PlayerColor: \" + color);\r\n    }\r\n\r\n    public void setStonesCaptured(PlayerColor color, int captured) {\r\n      if (color == PlayerColor.BLACK) {\r\n        blackStonesCaptured = captured;\r\n      } else if (color == PlayerColor.WHITE) {\r\n        whiteStonesCaptured = captured;\r\n      } else {\r\n        throw new IllegalStateException(\"Unknown PlayerColor: \" + color);\r\n      }\r\n    }\r\n\r\n    public int getBlackStonesCaptured() {\r\n      return blackStonesCaptured;\r\n    }\r\n\r\n    public void setBlackStonesCaptured(int blackStonesCaptured) {\r\n      this.blackStonesCaptured = blackStonesCaptured;\r\n    }\r\n\r\n    public int getWhiteStonesCaptured() {\r\n      return whiteStonesCaptured;\r\n    }\r\n\r\n    public void setWhiteStonesCaptured(int whiteStonesCaptured) {\r\n      this.whiteStonesCaptured = whiteStonesCaptured;\r\n    }\r\n  }\r\n\r\n  public static class FieldPosition {\r\n\r\n    private int row;\r\n    private int col;\r\n\r\n    public FieldPosition(int row, int col) {\r\n      super();\r\n      this.row = row;\r\n      this.col = col;\r\n    }\r\n\r\n    public int hashCode() {\r\n      final int prime = 31;\r\n      int result = 1;\r\n      result = prime * result + col;\r\n      result = prime * result + row;\r\n      return result;\r\n    }\r\n\r\n    public boolean equals(Object obj) {\r\n      if (this == obj) return true;\r\n      if (obj == null) return false;\r\n      if (getClass() != obj.getClass()) return false;\r\n      FieldPosition other = (FieldPosition) obj;\r\n      if (col != other.col) return false;\r\n      if (row != other.row) return false;\r\n      return true;\r\n    }\r\n\r\n    public List<FieldPosition> getFieldsNear() {\r\n      return getFieldsNear(Player.BOARD_SIZE);\r\n    }\r\n\r\n    public List<FieldPosition> getFieldsNear(int boardSize) {\r\n      int[][] near = new int[][] {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\r\n      List<FieldPosition> nearFields = new ArrayList<FieldPosition>();\r\n      for (int[] nearDiff : near) {\r\n        FieldPosition position = new FieldPosition(row + nearDiff[0], col + nearDiff[1]);\r\n        if (position.exists(boardSize)) {\r\n          nearFields.add(position);\r\n        }\r\n      }\r\n      return nearFields;\r\n    }\r\n\r\n    public boolean exists() {\r\n      return exists(Player.BOARD_SIZE);\r\n    }\r\n\r\n    public boolean exists(int boardSize) {\r\n      return row >= 0 && col >= 0 && row < boardSize && col < boardSize;\r\n    }\r\n\r\n    public int getRow() {\r\n      return row;\r\n    }\r\n\r\n    public void setRow(int row) {\r\n      this.row = row;\r\n    }\r\n\r\n    public int getCol() {\r\n      return col;\r\n    }\r\n\r\n    public void setCol(int col) {\r\n      this.col = col;\r\n    }\r\n  }\r\n\r\n  public interface MoveCalculator {\r\n\r\n    public void calculateMove(Player player);\r\n  }\r\n\r\n  public static class MoveCalculatorFactory {\r\n\r\n    public static MoveCalculatorImplementation usedCalculatorImplementation;\r\n\r\n    public static MoveCalculator createCalculator() {\r\n      switch (usedCalculatorImplementation) {\r\n        case MOVE_CALCULATOR_LEVEL_1:\r\n          return new MoveCalculatorLevel1();\r\n        case MOVE_CALCULATOR_LEVEL_2:\r\n          return new MoveCalculatorLevel2();\r\n        case MOVE_CALCULATOR_LEVEL_3:\r\n          return new MoveCalculatorLevel3();\r\n        default:\r\n          throw new IllegalStateException(\r\n              \"Unknown implementation type: \"\r\n                  + usedCalculatorImplementation\r\n                  + \"; choose a type in MoveCalculatorFactory or declare the unknown type\");\r\n      }\r\n    }\r\n  }\r\n\r\n  public enum MoveCalculatorImplementation {\r\n    MOVE_CALCULATOR_LEVEL_1, //\r\n    MOVE_CALCULATOR_LEVEL_2, //\r\n    MOVE_CALCULATOR_LEVEL_3, //\r\n  }\r\n\r\n  public enum PlayerColor {\r\n    BLACK,\r\n    WHITE;\r\n\r\n    public static PlayerColor getOpposizeColor(PlayerColor lastMove) {\r\n      switch (lastMove) {\r\n        case BLACK:\r\n          return WHITE;\r\n        case WHITE:\r\n          return BLACK;\r\n        default:\r\n          return null;\r\n      }\r\n    }\r\n\r\n    public static String toCharCode(PlayerColor color) {\r\n      if (color == BLACK) {\r\n        return \"B\";\r\n      }\r\n      if (color == WHITE) {\r\n        return \"W\";\r\n      }\r\n      return \".\";\r\n    }\r\n\r\n    public String toCharCode() {\r\n      return toCharCode(this);\r\n    }\r\n\r\n    public static PlayerColor fromCharCode(String charCode) {\r\n      if (charCode.equals(\"B\")) {\r\n        return BLACK;\r\n      } else if (charCode.equals(\"W\")) {\r\n        return WHITE;\r\n      }\r\n      throw new IllegalStateException(\"unknown charCode: \" + charCode);\r\n    }\r\n  }\r\n\r\n  public static class Referee {\r\n\r\n    public static final int FRAME_DURATION = 800;\r\n    public static final int FRAME_WIDTH = 1920;\r\n    public static final int FRAME_HEIGHT = 1080;\r\n    public static final int BOARD_WIDTH = 950;\r\n\r\n    private Game game;\r\n\r\n    private PlayerColor[][] board;\r\n    private PlayerColor[][] previousBoard;\r\n\r\n    public Referee() {\r\n      this(new Game());\r\n    }\r\n\r\n    public Referee(Game game) {\r\n      this.game = game;\r\n      board = new PlayerColor[Player.BOARD_SIZE][Player.BOARD_SIZE];\r\n    }\r\n\r\n    // ***************************************************************************************************************\r\n    // *** CG stuff\r\n    // ***************************************************************************************************************\r\n\r\n    // ***************************************************************************************************************\r\n    // *** simulation\r\n    // ***************************************************************************************************************\r\n\r\n    public Referee clone() {\r\n      Referee clone = new Referee(game.clone());\r\n      clone.board = new PlayerColor[Player.BOARD_SIZE][Player.BOARD_SIZE];\r\n      clone.previousBoard = new PlayerColor[Player.BOARD_SIZE][Player.BOARD_SIZE];\r\n\r\n      for (int i = 0; i < Player.BOARD_SIZE; i++) {\r\n        clone.board = getBoardCopy(board);\r\n        clone.previousBoard = getBoardCopy(previousBoard);\r\n      }\r\n\r\n      return clone;\r\n    }\r\n\r\n    // ***************************************************************************************************************\r\n    // *** game methods\r\n    // ***************************************************************************************************************\r\n\r\n    public static PlayerColor[][] getBoard(String[] lines) {\r\n      int size = lines.length;\r\n      PlayerColor[][] board = new PlayerColor[size][size];\r\n      for (int i = 0; i < size; i++) {\r\n        for (int j = 0; j < size; j++) {\r\n          if (lines[i].charAt(j) == 'B') {\r\n            board[i][j] = PlayerColor.BLACK;\r\n          } else if (lines[i].charAt(j) == 'W') {\r\n            board[i][j] = PlayerColor.WHITE;\r\n          }\r\n        }\r\n      }\r\n      return board;\r\n    }\r\n\r\n    /** Execute all moves in the list to create the current board */\r\n\r\n    /*private*/ void fillBoard(List<Move> moves) throws IllegalArgumentException {\r\n      if (moves != null) {\r\n        for (Move move : moves) {\r\n          if (isValidMove(move)) {\r\n            addMove(move);\r\n          } else {\r\n            throw new IllegalArgumentException(\r\n                \"Invalid move. The given list of moves contains a move that is not valid: \" + move);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    public PlayerColor[][] getBoard() {\r\n      return board;\r\n    }\r\n\r\n    /** A deep copy of the current board */\r\n    public PlayerColor[][] getBoardCopy() {\r\n      return getBoardCopy(board);\r\n    }\r\n\r\n    public PlayerColor[][] getBoardCopy(PlayerColor[][] board) {\r\n      PlayerColor[][] newBoard = new PlayerColor[Player.BOARD_SIZE][Player.BOARD_SIZE];\r\n      if (board != null) {\r\n        for (int i = 0; i < Player.BOARD_SIZE; i++) {\r\n          for (int j = 0; j < Player.BOARD_SIZE; j++) {\r\n            newBoard[i][j] = board[i][j];\r\n          }\r\n        }\r\n      }\r\n      return newBoard;\r\n    }\r\n    /**\r\n     * Check whether the move is valid\r\n     *\r\n     * <p>Checked are:\r\n     *\r\n     * <ul>\r\n     *   <li>color (players turn)\r\n     *   <li>position (on field and empty)\r\n     *   <li>no suicidal move (placed stone is not directly beaten)\r\n     *   <li>ko rule (move doesn't create the same board that was there in the last move)\r\n     * </ul>\r\n     */\r\n    public boolean isValidMove(Move move) {\r\n      if (move.isPass()) {\r\n        // passing is always a valid move\r\n        return true;\r\n      }\r\n      if (!move.getPos().exists(Player.BOARD_SIZE)) {\r\n        // position doesn't exist\r\n        return false;\r\n      }\r\n      if (getStoneColor(move.getPos()) != null) {\r\n        // field not empty\r\n        return false;\r\n      }\r\n\r\n      // execute the move and check whether the state is valid\r\n      PlayerColor[][] tmpBoard = getBoardCopy(); // keep a copy of the board for a rollback\r\n      // make the move\r\n      board[move.getRow()][move.getCol()] = move.getColor();\r\n      removeBeaten(move);\r\n\r\n      // check the group of the new stone\r\n      Group group = Group.findGroup(this, move.getPos());\r\n      if (group.isBeaten(this)) {\r\n        // added stone is directly beaten\r\n        board = tmpBoard;\r\n        return false;\r\n      }\r\n\r\n      if (!Player.OPPONENTS_LAST_MOVE.isPass() && boardsEqual(board, previousBoard)) {\r\n        // restores the board from the last move (ko rule violated)\r\n        board = tmpBoard;\r\n        return false;\r\n      }\r\n\r\n      board = tmpBoard;\r\n      return true;\r\n    }\r\n\r\n    /*private*/ static boolean boardsEqual(PlayerColor[][] board, PlayerColor[][] previousBoard) {\r\n      if (previousBoard == null) {\r\n        // previousBoard can be null if there was no previous move\r\n        // in this case the ko-rule can't be violated and the boards are treated as not equal (so\r\n        // false is returned)\r\n        return false;\r\n      }\r\n      boolean equal = true;\r\n      for (int i = 0; i < board.length; i++) {\r\n        for (int j = 0; j < board[0].length; j++) {\r\n          equal &= board[i][j] == previousBoard[i][j];\r\n        }\r\n      }\r\n      return equal;\r\n    }\r\n\r\n    /**\r\n     * Execute a move without checking whether it's valid. The new stone is added and beaten ones\r\n     * are removed\r\n     */\r\n    public void addMove(Move move) {\r\n      if (!move.isPass()) {\r\n        // copy the board to the previous board field\r\n        previousBoard = getBoardCopy();\r\n\r\n        // set the new stone\r\n        board[move.getRow()][move.getCol()] = move.getColor();\r\n        // remove beaten stones (if any)\r\n        removeBeaten(move, true);\r\n      }\r\n    }\r\n\r\n    /** Remove all stones that were beaten by the move */\r\n\r\n    /*private*/ void removeBeaten(Move move) {\r\n      removeBeaten(move, false);\r\n    }\r\n\r\n    private void removeBeaten(Move move, boolean countBeaten) {\r\n      // find the fields near to the move field\r\n      List<FieldPosition> near = move.getPos().getFieldsNear(Player.BOARD_SIZE);\r\n      for (FieldPosition pos : near) {\r\n        // check whether the field has a stone of the different color on it\r\n        if (getStoneColor(pos) == PlayerColor.getOpposizeColor(move.getColor())) {\r\n          Group group = Group.findGroup(this, pos);\r\n          if (group.isBeaten(this)) {\r\n            removeStones(group.getStones(), countBeaten);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    /** Remove all stones in the collection from the field */\r\n\r\n    /*private*/ void removeStones(Collection<FieldPosition> stones) {\r\n      removeStones(stones, false);\r\n    }\r\n\r\n    private void removeStones(Collection<FieldPosition> stones, boolean countBeaten) {\r\n      int stonesBeaten = stones.size();\r\n      PlayerColor beatenStonesColor = null;\r\n      for (FieldPosition pos : stones) {\r\n        beatenStonesColor = board[pos.getRow()][pos.getCol()];\r\n        board[pos.getRow()][pos.getCol()] = null;\r\n      }\r\n\r\n      if (countBeaten) {\r\n        if (beatenStonesColor == PlayerColor.BLACK) {\r\n          game.setBlackStonesCaptured(game.getBlackStonesCaptured() + stonesBeaten);\r\n        } else if (beatenStonesColor == PlayerColor.WHITE) {\r\n          game.setWhiteStonesCaptured(game.getWhiteStonesCaptured() + stonesBeaten);\r\n        }\r\n      }\r\n    }\r\n\r\n    public boolean isFieldEmpty(FieldPosition pos) {\r\n      return board[pos.getRow()][pos.getCol()] == null;\r\n    }\r\n\r\n    public PlayerColor getStoneColor(FieldPosition pos) {\r\n      return board[pos.getRow()][pos.getCol()];\r\n    }\r\n\r\n    public Game getGame() {\r\n      return game;\r\n    }\r\n\r\n    public void setBoard(PlayerColor[][] board) {\r\n      this.board = board;\r\n    }\r\n\r\n    public void setPreviousBoard(PlayerColor[][] board) {\r\n      this.previousBoard = board;\r\n    }\r\n\r\n    public PlayerColor[][] getPreviousBoard() {\r\n      return previousBoard;\r\n    }\r\n\r\n    public void printBoards() {\r\n      DebugUtils.print(\"Board\");\r\n      DebugUtils.printBoard(board);\r\n      DebugUtils.print(\"Previous Board\");\r\n      DebugUtils.printBoard(previousBoard);\r\n    }\r\n  }\r\n\r\n  /** @author Tobias */\r\n  public static class Move {\r\n\r\n    private int row;\r\n    private int col;\r\n    private Type type;\r\n    private PlayerColor color;\r\n\r\n    public enum Type {\r\n      STONE,\r\n      PASS;\r\n    }\r\n\r\n    public Move(int row, int col, PlayerColor color) {\r\n      this.row = row;\r\n      this.col = col;\r\n      this.color = color;\r\n      this.type = Type.STONE;\r\n      if (row == -1 && col == -1) {\r\n        this.type = Type.PASS;\r\n      }\r\n    }\r\n\r\n    public static Move getPassMove(PlayerColor color) {\r\n      Move pass = new Move(-1, -1, color);\r\n      pass.setType(Type.PASS);\r\n      return pass;\r\n    }\r\n\r\n    public FieldPosition getPos() {\r\n      return new FieldPosition(row, col);\r\n    }\r\n\r\n    public int hashCode() {\r\n      final int prime = 31;\r\n      int result = 1;\r\n      result = prime * result + col;\r\n      result = prime * result + ((color == null) ? 0 : color.hashCode());\r\n      result = prime * result + row;\r\n      return result;\r\n    }\r\n\r\n    public boolean equals(Object obj) {\r\n      if (this == obj) return true;\r\n      if (obj == null) return false;\r\n      if (getClass() != obj.getClass()) return false;\r\n      Move other = (Move) obj;\r\n      if (col != other.col) return false;\r\n      if (color != other.color) return false;\r\n      if (row != other.row) return false;\r\n      return true;\r\n    }\r\n\r\n    public int getRow() {\r\n      return row;\r\n    }\r\n\r\n    public void setRow(int row) {\r\n      this.row = row;\r\n    }\r\n\r\n    public int getCol() {\r\n      return col;\r\n    }\r\n\r\n    public void setCol(int col) {\r\n      this.col = col;\r\n    }\r\n\r\n    public PlayerColor getColor() {\r\n      return color;\r\n    }\r\n\r\n    public void setColor(PlayerColor color) {\r\n      this.color = color;\r\n    }\r\n\r\n    public Type getType() {\r\n      return type;\r\n    }\r\n\r\n    public void setType(Type type) {\r\n      this.type = type;\r\n    }\r\n\r\n    public boolean isPass() {\r\n      return type == Type.PASS;\r\n    }\r\n  }\r\n}\r\n",
          "testCases": [],
          "maxPlayers": 2,
          "minPlayers": 2,
          "statements": {
            "1": "<div style=\"color:#cccccc;padding:20px;margin-right:15px;margin-left:15px;margin-bottom:10px;text-align:left\">This is a slight modification of the board game <a href=\"https://en.wikipedia.org/wiki/Go_(game)\">Go</a>\r\n<br>Click <a href=\"https://senseis.xmp.net/?BasicRulesOfGo\">here</a> for an introduction into the rules of Go.\r\n<br>Click <a href=\"https://github.com/tfassbender/codingame_atari_go\">here</a> for the Referee code<br>\r\n</div>\r\n<div class=\"statement-body\">\r\n<!-- GOAL --> \r\n    <div class=\"statement-section statement-goal\"> \r\n      <h2> \r\n        <span class=\"icon icon-goal\">&nbsp;</span> \r\n        <span>The Goal</span> \r\n      </h2> \r\n      <div class=\"statement-goal-content\"> \r\n        The game is now played on a 13x13 board and lasts 200 turns.\r\n      </div> \r\n    </div> \r\n    <!-- RULES -->\r\n    <div class=\"statement-section statement-rules\">\r\n        <h1>\r\n            <span class=\"icon icon-rules\">&nbsp;</span>\r\n            <span>Rules</span>\r\n        </h1>\r\n        <div class=\"statement-rules-content\">\r\n            Atari Go is a modification of the classical board game <a href=\"https://en.wikipedia.org/wiki/Go_(game)\">Go</a>, that is often used to teach new players the rules of Go.<br />\r\n            The rules are basically the same as the Go rules with some modifications to make the game a bit easier:\r\n            <ul>\r\n            \t<li>You don't gain points by occupying fields</li>\r\n            \t<li>The only way to gain points is to capture the stones of your opponent</li>\r\n            \t<li>The game does not end after both players have passed (the game ends after <const>200</const> turns)</li>\r\n            \t<li>All other rules stay the same as in the game of Go</li>\r\n            </ul>\r\n            \r\n            <h3>Go Rules</h3>\r\n            A game of Go is usually played on a board of 19x19 fields. In the first leagues a board of 9x9 or 13x13 fields is used, but in the later leagues a 19x19 board is used.\r\n            <br>\r\n            While playing, both players place one of their stones (per turn) on a free position on the field. The stones are not moved after they are placed. You can only add new stones.\r\n            <br>\r\n            The goal of the game is to capture the stones of your opponent. This can be done by surrounding the stones (or groups) of your opponent with your stones. If a stone or group has no free fields beneath it, it is captured and removed from the board (see example 2).\r\n            <br>\r\n            If a stone is surrounded by other stones of the same color this stone is not captured, but all stones that are directly touching each other form a group. This group shares it's free fields. So a group of stones is often stronger and more difficult to capture than a single stone (see example 1).\r\n            <br>\r\n            <br>\r\n            Beside these simple rules there are a view more rules, on where stones can be placed and where not.\r\n            <ul>\r\n            \t<li>You can only place a stone on a field where no stone is placed yet</li>\r\n            \t<li>You can not play a stone that would directly be removed (no suicidal moves). An exception to this rule is that the opponent stones are removed before this rule is applied. So if your stone seems to be directly surrounded by other stones, but it captures and removes at least one of the surrounding stones it can be played (see example 3)</li>\r\n            \t<li>You can not play a stone that would lead to the same board, like in the last turn when you played a stone. This is called the Ko-Rule (see example 4)</li>\r\n            </ul>\r\n        </div>\r\n    </div>\r\n\r\n    <!-- EXAMPLES -->\r\n    <div class=\"statement-section statement-examples\">\r\n        <h1>\r\n            <span class=\"icon icon-example\">&nbsp;</span>\r\n            <span>Examples</span>\r\n        </h1>\r\n\r\n        <div class=\"statement-examples-text\">\r\n            <div class=\"first-example\">\r\n            \t<h3>Example 1 - Groups</h3>\r\n            \tIn the image below the three white stones form a group. Therefore the two upper stones (that are completely surrounded) are not captured as long as one stone of the group is not completely captured.\r\n            \t<p><img src=\"https://senseis.xmp.net/diagrams/41/49d804c30e36bd3cf3666a6d76f39644.png\" style=\"height: 150px; width: auto;\"></img></p>\r\n            \t<br>\r\n            \t<br>\r\n            </div>\r\n            \r\n            <div class=\"second-example\">\r\n            \t<h3>Example 2 - Capturing stones</h3>\r\n            \tIn the image below the white stone is almost captured. The last free field it has is marked with a red square. The other fields (marked with red crosses) are not directly adjacent to the white stone and are therefore no free fields for the white stone.\r\n            \t<p><img src=\"https://senseis.xmp.net/diagrams/0/7cac8afadce46df1d520ee56b4eece8b.png\" style=\"height: 150px; width: auto;\"></img></p>\r\n            \tNow if the back stone is placed like in the image below...\r\n            \t<p><img src=\"https://senseis.xmp.net/diagrams/48/ceb2245b3fbf4c62872f4bdf2796ac95.png\" style=\"height: 150px; width: auto;\"></img></p>\r\n            \t...the white stone has no free fields around it and therefore it is captured. So it will be removed and after the turn of the black stone the field will look like in the image below.\r\n            \t<p><img src=\"https://senseis.xmp.net/diagrams/13/6e7dc384eb2e8b494e097f38d4259bcb.png\" style=\"height: 150px; width: auto;\"></img></p>\r\n            \t<br>\r\n            \t<br>\r\n            </div>\r\n            \r\n            <div class=\"third-example\">\r\n            \t<h3>Example 3 - Suicidal moves</h3>\r\n            \tIn the image below, a white stone that is placed in the middle of the four black stones would have no free fields beneath it and would be directly removed. Therefore a white stone can't be placed in the middle of the black stones in this case.\r\n            \t<p><img src=\"https://senseis.xmp.net/diagrams/13/6e7dc384eb2e8b494e097f38d4259bcb.png\" style=\"height: 150px; width: auto;\"></img></p>\r\n            \tAn exception to this rule is shown in the following image: In this image it seems to be the same case. A white stone that is placed in the middle of the black stones would have no free fields adjacent to it and would be removed. But in this case the white stone can be placed in the middle of the black stones as shown in the next image.\r\n            \t<p><img src=\"https://senseis.xmp.net/diagrams/37/0708d56ffed33ef1058f0185803a7f46.png\" style=\"height: 150px; width: auto;\"></img></p>\r\n            \tBefore the free fields of the white stone are counted, first the black stones are to be removed. This leads to the following field after the white stone is placed:\r\n            \t<p><img src=\"https://senseis.xmp.net/diagrams/47/00bb7694a7980ec3018ee6a2e721f212.png\" style=\"height: 150px; width: auto;\"></img></p>\r\n            \tSince the white stone now has a free field adjacent to it (where the black stone was removed) it can be played.\r\n            \t<br>\r\n            \t<br>\r\n            </div>\r\n            \r\n            <div class=\"fourth-example\">\r\n            \t<h3>Example 4 - Ko-Rule</h3>\r\n            \tIn the third example it was shown that in a field, like the one in the image below, a white stone can be placed in the middle of the four black stones...\r\n            \t<p><img src=\"https://senseis.xmp.net/diagrams/37/0708d56ffed33ef1058f0185803a7f46.png\" style=\"height: 150px; width: auto;\"></img></p>\r\n            \t... which would lead to a board that looks like this:\r\n            \t<p><img src=\"https://senseis.xmp.net/diagrams/47/00bb7694a7980ec3018ee6a2e721f212.png\" style=\"height: 150px; width: auto;\"></img></p>\r\n            \tNow it seems that a black stone could do a similar move by placing it in the middle of the four white stones like this:\r\n            \t<p><img src=\"https://senseis.xmp.net/diagrams/28/8da1b11165650ffa0964df5ff2debbe1.png\" style=\"height: 150px; width: auto;\"></img></p>\r\n            \tThis would normally be a valid move (just like in the third example), but to prevent the game to get stuck on this (both players just capturing the same stones again and again), the above move is not possible for the black stone, because it would lead to the same board like one turn before (the first image of this example).<br>\r\n            \tBut it would be possible to place a black stone on any other field, let white place a stone too, and then come back to this formation of stones and place the black stone in between the white stones (like in the image above) because now it would no longer lead to the same board like in the first image of this example (there are now two more stones placed somewhere on the board).\r\n            \t<br>\r\n            \t<br>\r\n            </div>\r\n        </div>\r\n    </div><br>\r\n\r\n    <!-- Victory conditions -->\r\n    <div class=\"statement-victory-conditions\">\r\n        <div class=\"icon victory\"></div>\r\n        <div class=\"blk\">\r\n            <div class=\"title\">Victory Conditions</div>\r\n            <div class=\"text\">\r\n                <ul style=\"padding-bottom: 0;\">\r\n                    <li>Capture more stones than your opponent</li>\r\n                    <li>If no player has captured any stones after the maximum number of turns is reached, the player that has played more stones wins (to prevent a draw if a player passes in every move)</li>\r\n                </ul>\r\n            </div>\r\n        </div>\r\n    </div>\r\n\r\n    <!-- Lose conditions -->\r\n    <div class=\"statement-lose-conditions\">\r\n        <div class=\"icon lose\"></div>\r\n        <div class=\"blk\">\r\n            <div class=\"title\">Loss Conditions</div>\r\n            <div class=\"text\">\r\n                <ul style=\"padding-bottom: 0;\">\r\n                    <li>You send an illegal move</li>\r\n                    <li>You don't respond in time or output an unrecognized command</li>\r\n                </ul>\r\n            </div>\r\n        </div>\r\n    </div>\r\n\r\n    <!-- PROTOCOL -->\r\n    <div class=\"statement-section statement-protocol\">\r\n        <h1>\r\n        <span class=\"icon icon-protocol\">&nbsp;</span>\r\n        <span>Game Input</span>\r\n    </h1>\r\n\r\n    <!-- Protocol block -->\r\n    <div class=\"blk\">\r\n        <div class=\"title\">Initial input</div>\r\n        <div class=\"text\">\r\n            <span class=\"statement-lineno\">First line</span>: <var>myColor</var>: <action>B</action> if you are playing the black stones or <action>W</action> if you're playing the white stones.\r\n            <br>\r\n            <span class=\"statement-lineno\">Next line</span>: <var>boardSize</var>: an integer representing the size of the board\r\n            <br>\r\n            <br>\r\n        </div>\r\n        <div class=\"title\">Input for one game turn</div>\r\n        <div class=\"text\">\r\n            <span class=\"statement-lineno\">First line</span>: <var>x</var> <var>y</var>: two integers representing the position of the last stone, that your opponent played (\"-1 -1\" in the first turn)\r\n            <br>\r\n            <span class=\"statement-lineno\">Next line</span>: <var>myScore</var> <var>opponentScore</var>: two integers representing your current score and your opponent's current score (the number of captured stones)\r\n            <br>\r\n            <span class=\"statement-lineno\">Next <var>boardSize</var> lines</span>: <var>line</var>: one line of the current board, where <action>B</action> marks a black stone, <action>W</action> marks a white stone and <action>.</action> marks an empty field\r\n            <br>\r\n        </div>\r\n    </div>\r\n\r\n    <!-- Protocol block -->\r\n    <div class=\"blk\">\r\n        <div class=\"title\">Output</div>\r\n        <div class=\"text\">\r\n            <span class=\"statement-lineno\">A single line containing</span>: either the <var>x</var> and <var>y</var> coordinates of the next stone you want to play or <var>PASS</var> if you don't want to play a stone (<var>PASS</var> is always a valid move)<br>\r\n        <br>\r\n        </div>\r\n    </div>\r\n\r\n    <!-- Protocol block -->\r\n    <div class=\"blk\">\r\n        <div class=\"title\">Constraints</div>\r\n        Response time first turn is \r\n        <const>1000</const> ms.\r\n        <br>Response time per turn is \r\n        <const>100</const> ms.\r\n        <br><br>The game ends after <const>200</const> turns (200 stones for each player)\r\n        </div>\r\n    </div>\r\n</div>",
            "2": "<div style=\"color:#cccccc;padding:20px;margin-right:15px;margin-left:15px;margin-bottom:10px;text-align:left\">This is a slight modification of the board game <a href=\"https://en.wikipedia.org/wiki/Go_(game)\">Go</a>\r\n<br>Click <a href=\"https://senseis.xmp.net/?BasicRulesOfGo\">here</a> for an introduction into the rules of Go.\r\n<br>Click <a href=\"https://github.com/tfassbender/codingame_atari_go\">here</a> for the Referee code<br>\r\n</div>\r\n<div class=\"statement-body\">\r\n<!-- GOAL --> \r\n    <div class=\"statement-section statement-goal\"> \r\n      <h2> \r\n        <span class=\"icon icon-goal\">&nbsp;</span> \r\n        <span>The Goal</span> \r\n      </h2> \r\n      <div class=\"statement-goal-content\"> \r\n        The game is now played on a 13x13 board and lasts 200 turns.\r\n      </div> \r\n    </div> \r\n    <!-- RULES -->\r\n    <div class=\"statement-section statement-rules\">\r\n        <h1>\r\n            <span class=\"icon icon-rules\">&nbsp;</span>\r\n            <span>Rules</span>\r\n        </h1>\r\n        <div class=\"statement-rules-content\">\r\n            Atari Go is a modification of the classical board game <a href=\"https://en.wikipedia.org/wiki/Go_(game)\">Go</a>, that is often used to teach new players the rules of Go.<br />\r\n            The rules are basically the same as the Go rules with some modifications to make the game a bit easier:\r\n            <ul>\r\n            \t<li>You don't gain points by occupying fields</li>\r\n            \t<li>The only way to gain points is to capture the stones of your opponent</li>\r\n            \t<li>The game does not end after both players have passed (the game ends after <const>200</const> turns)</li>\r\n            \t<li>All other rules stay the same as in the game of Go</li>\r\n            </ul>\r\n            \r\n            <h3>Go Rules</h3>\r\n            A game of Go is usually played on a board of 19x19 fields. In the first leagues a board of 9x9 or 13x13 fields is used, but in the later leagues a 19x19 board is used.\r\n            <br>\r\n            While playing, both players place one of their stones (per turn) on a free position on the field. The stones are not moved after they are placed. You can only add new stones.\r\n            <br>\r\n            The goal of the game is to capture the stones of your opponent. This can be done by surrounding the stones (or groups) of your opponent with your stones. If a stone or group has no free fields beneath it, it is captured and removed from the board (see example 2).\r\n            <br>\r\n            If a stone is surrounded by other stones of the same color this stone is not captured, but all stones that are directly touching each other form a group. This group shares it's free fields. So a group of stones is often stronger and more difficult to capture than a single stone (see example 1).\r\n            <br>\r\n            <br>\r\n            Beside these simple rules there are a view more rules, on where stones can be placed and where not.\r\n            <ul>\r\n            \t<li>You can only place a stone on a field where no stone is placed yet</li>\r\n            \t<li>You can not play a stone that would directly be removed (no suicidal moves). An exception to this rule is that the opponent stones are removed before this rule is applied. So if your stone seems to be directly surrounded by other stones, but it captures and removes at least one of the surrounding stones it can be played (see example 3)</li>\r\n            \t<li>You can not play a stone that would lead to the same board, like in the last turn when you played a stone. This is called the Ko-Rule (see example 4)</li>\r\n            </ul>\r\n        </div>\r\n    </div>\r\n\r\n    <!-- EXAMPLES -->\r\n    <div class=\"statement-section statement-examples\">\r\n        <h1>\r\n            <span class=\"icon icon-example\">&nbsp;</span>\r\n            <span>Examples</span>\r\n        </h1>\r\n\r\n        <div class=\"statement-examples-text\">\r\n            <div class=\"first-example\">\r\n            \t<h3>Example 1 - Groups</h3>\r\n            \tIn the image below the three white stones form a group. Therefore the two upper stones (that are completely surrounded) are not captured as long as one stone of the group is not completely captured.\r\n            \t<p><img src=\"https://senseis.xmp.net/diagrams/41/49d804c30e36bd3cf3666a6d76f39644.png\" style=\"height: 150px; width: auto;\"></img></p>\r\n            \t<br>\r\n            \t<br>\r\n            </div>\r\n            \r\n            <div class=\"second-example\">\r\n            \t<h3>Example 2 - Capturing stones</h3>\r\n            \tIn the image below the white stone is almost captured. The last free field it has is marked with a red square. The other fields (marked with red crosses) are not directly adjacent to the white stone and are therefore no free fields for the white stone.\r\n            \t<p><img src=\"https://senseis.xmp.net/diagrams/0/7cac8afadce46df1d520ee56b4eece8b.png\" style=\"height: 150px; width: auto;\"></img></p>\r\n            \tNow if the back stone is placed like in the image below...\r\n            \t<p><img src=\"https://senseis.xmp.net/diagrams/48/ceb2245b3fbf4c62872f4bdf2796ac95.png\" style=\"height: 150px; width: auto;\"></img></p>\r\n            \t...the white stone has no free fields around it and therefore it is captured. So it will be removed and after the turn of the black stone the field will look like in the image below.\r\n            \t<p><img src=\"https://senseis.xmp.net/diagrams/13/6e7dc384eb2e8b494e097f38d4259bcb.png\" style=\"height: 150px; width: auto;\"></img></p>\r\n            \t<br>\r\n            \t<br>\r\n            </div>\r\n            \r\n            <div class=\"third-example\">\r\n            \t<h3>Example 3 - Suicidal moves</h3>\r\n            \tIn the image below, a white stone that is placed in the middle of the four black stones would have no free fields beneath it and would be directly removed. Therefore a white stone can't be placed in the middle of the black stones in this case.\r\n            \t<p><img src=\"https://senseis.xmp.net/diagrams/13/6e7dc384eb2e8b494e097f38d4259bcb.png\" style=\"height: 150px; width: auto;\"></img></p>\r\n            \tAn exception to this rule is shown in the following image: In this image it seems to be the same case. A white stone that is placed in the middle of the black stones would have no free fields adjacent to it and would be removed. But in this case the white stone can be placed in the middle of the black stones as shown in the next image.\r\n            \t<p><img src=\"https://senseis.xmp.net/diagrams/37/0708d56ffed33ef1058f0185803a7f46.png\" style=\"height: 150px; width: auto;\"></img></p>\r\n            \tBefore the free fields of the white stone are counted, first the black stones are to be removed. This leads to the following field after the white stone is placed:\r\n            \t<p><img src=\"https://senseis.xmp.net/diagrams/47/00bb7694a7980ec3018ee6a2e721f212.png\" style=\"height: 150px; width: auto;\"></img></p>\r\n            \tSince the white stone now has a free field adjacent to it (where the black stone was removed) it can be played.\r\n            \t<br>\r\n            \t<br>\r\n            </div>\r\n            \r\n            <div class=\"fourth-example\">\r\n            \t<h3>Example 4 - Ko-Rule</h3>\r\n            \tIn the third example it was shown that in a field, like the one in the image below, a white stone can be placed in the middle of the four black stones...\r\n            \t<p><img src=\"https://senseis.xmp.net/diagrams/37/0708d56ffed33ef1058f0185803a7f46.png\" style=\"height: 150px; width: auto;\"></img></p>\r\n            \t... which would lead to a board that looks like this:\r\n            \t<p><img src=\"https://senseis.xmp.net/diagrams/47/00bb7694a7980ec3018ee6a2e721f212.png\" style=\"height: 150px; width: auto;\"></img></p>\r\n            \tNow it seems that a black stone could do a similar move by placing it in the middle of the four white stones like this:\r\n            \t<p><img src=\"https://senseis.xmp.net/diagrams/28/8da1b11165650ffa0964df5ff2debbe1.png\" style=\"height: 150px; width: auto;\"></img></p>\r\n            \tThis would normally be a valid move (just like in the third example), but to prevent the game to get stuck on this (both players just capturing the same stones again and again), the above move is not possible for the black stone, because it would lead to the same board like one turn before (the first image of this example).<br>\r\n            \tBut it would be possible to place a black stone on any other field, let white place a stone too, and then come back to this formation of stones and place the black stone in between the white stones (like in the image above) because now it would no longer lead to the same board like in the first image of this example (there are now two more stones placed somewhere on the board).\r\n            \t<br>\r\n            \t<br>\r\n            </div>\r\n        </div>\r\n    </div><br>\r\n\r\n    <!-- Victory conditions -->\r\n    <div class=\"statement-victory-conditions\">\r\n        <div class=\"icon victory\"></div>\r\n        <div class=\"blk\">\r\n            <div class=\"title\">Victory Conditions</div>\r\n            <div class=\"text\">\r\n                <ul style=\"padding-bottom: 0;\">\r\n                    <li>Capture more stones than your opponent</li>\r\n                    <li>If no player has captured any stones after the maximum number of turns is reached, the player that has played more stones wins (to prevent a draw if a player passes in every move)</li>\r\n                </ul>\r\n            </div>\r\n        </div>\r\n    </div>\r\n\r\n    <!-- Lose conditions -->\r\n    <div class=\"statement-lose-conditions\">\r\n        <div class=\"icon lose\"></div>\r\n        <div class=\"blk\">\r\n            <div class=\"title\">Loss Conditions</div>\r\n            <div class=\"text\">\r\n                <ul style=\"padding-bottom: 0;\">\r\n                    <li>You send an illegal move</li>\r\n                    <li>You don't respond in time or output an unrecognized command</li>\r\n                </ul>\r\n            </div>\r\n        </div>\r\n    </div>\r\n\r\n    <!-- PROTOCOL -->\r\n    <div class=\"statement-section statement-protocol\">\r\n        <h1>\r\n        <span class=\"icon icon-protocol\">&nbsp;</span>\r\n        <span>Game Input</span>\r\n    </h1>\r\n\r\n    <!-- Protocol block -->\r\n    <div class=\"blk\">\r\n        <div class=\"title\">Initial input</div>\r\n        <div class=\"text\">\r\n            <span class=\"statement-lineno\">First line</span>: <var>myColor</var>: <action>B</action> if you are playing the black stones or <action>W</action> if you're playing the white stones.\r\n            <br>\r\n            <span class=\"statement-lineno\">Next line</span>: <var>boardSize</var>: an integer representing the size of the board\r\n            <br>\r\n            <br>\r\n        </div>\r\n        <div class=\"title\">Input for one game turn</div>\r\n        <div class=\"text\">\r\n            <span class=\"statement-lineno\">First line</span>: <var>x</var> <var>y</var>: two integers representing the position of the last stone, that your opponent played (\"-1 -1\" in the first turn)\r\n            <br>\r\n            <span class=\"statement-lineno\">Next line</span>: <var>myScore</var> <var>opponentScore</var>: two integers representing your current score and your opponent's current score (the number of captured stones)\r\n            <br>\r\n            <span class=\"statement-lineno\">Next <var>boardSize</var> lines</span>: <var>line</var>: one line of the current board, where <action>B</action> marks a black stone, <action>W</action> marks a white stone and <action>.</action> marks an empty field\r\n            <br>\r\n        </div>\r\n    </div>\r\n\r\n    <!-- Protocol block -->\r\n    <div class=\"blk\">\r\n        <div class=\"title\">Output</div>\r\n        <div class=\"text\">\r\n            <span class=\"statement-lineno\">A single line containing</span>: either the <var>x</var> and <var>y</var> coordinates of the next stone you want to play or <var>PASS</var> if you don't want to play a stone (<var>PASS</var> is always a valid move)<br>\r\n        <br>\r\n        </div>\r\n    </div>\r\n\r\n    <!-- Protocol block -->\r\n    <div class=\"blk\">\r\n        <div class=\"title\">Constraints</div>\r\n        Response time first turn is \r\n        <const>1000</const> ms.\r\n        <br>Response time per turn is \r\n        <const>100</const> ms.\r\n        <br><br>The game ends after <const>200</const> turns (200 stones for each player)\r\n        </div>\r\n    </div>\r\n</div>"
          },
          "questionType": "multi",
          "stubGenerator": "read myColor:string(1)\r\nread boardSize:int\r\ngameloop\r\nread opponentX:int opponentY:int\r\nread myScore:int opponentScore:int\r\nloop boardSize read line:string(boardSize)\r\nwrite PASS\r\n\r\nSTATEMENT\r\nCapture more stones than your opponent.\r\n\r\nINPUT\r\nopponentX: The x coordinate of your opponent's last move (or -1 if the opponent passed)\r\nopponentY: The y coordinate of your opponent's last move (or -1 if the opponent passed)\r\nmyScore: Your current score (the number of captured stones)\r\nopponentScore: the opponents current score (the number of captured stones)\r\nboardSize: the size of the board (width and height)\r\nline: A row of the current board where 'B' marks a black stone, 'W' marks a white stone and '.' marks an empty field\r\n\r\nOUTPUT\r\nx and y coordinates of the stone you want to place or PASS if you don't want to place a stone",
          "welcomePopups": {
            "1": "<div style=\"text-align:center\">\r\n        <h2>You&#39;ve made it to the next league.</h2>\r\n        The game is now played on a 13x13 board.\r\n        <div class=\"small\"><img src=\"https://cdn-games.codingame.com/community/1443538-1590321517105/67db39d8eea83cf1ae98792b8fd1e377cf3d2cdcd6d173e33bbaf1b890c08502.png\" style=\"width:500px;max-width:100%\" /></div>\r\n        <div class=\"small\">See the updated statement for details.</div>\r\n</div>",
            "2": "<div style=\"text-align:center\">\r\n        <h2>You&#39;ve made it to the next league.</h2>\r\n        The game is now played on a 13x13 board.\r\n        <div class=\"small\"><img src=\"https://cdn-games.codingame.com/community/1443538-1590321517105/67db39d8eea83cf1ae98792b8fd1e377cf3d2cdcd6d173e33bbaf1b890c08502.png\" style=\"width:500px;max-width:100%\" /></div>\r\n        <div class=\"small\">See the updated statement for details.</div>\r\n</div>"
          },
          "aiCodeExtension": "java",
          "criteriaLanguageMap": {}
        },
        "3": {
          "aiCode": "import java.util.Scanner;\r\nimport java.util.Collection;\r\nimport java.util.List;\r\nimport java.util.ArrayList;\r\nimport java.util.HashSet;\r\nimport java.util.Set;\r\nimport java.util.HashMap;\r\nimport java.util.Map;\r\nimport java.util.TreeMap;\r\nimport java.util.Collections;\r\n\r\nclass Player {\r\n\r\n  public static final boolean LOCAL = false;\r\n\r\n  public Scanner in = new Scanner(System.in);\r\n\r\n  public static int turnCount;\r\n\r\n  public static PlayerColor MY_COLOR;\r\n  public static PlayerColor OPPONENT_COLOR;\r\n  public static Move OPPONENTS_LAST_MOVE = new Move(-1, -1, PlayerColor.WHITE);\r\n  public static int MY_SCORE;\r\n  public static int OPPONENT_SCORE;\r\n  public static int BOARD_SIZE;\r\n  public static int FIELDS_ON_BOARD;\r\n  public static PlayerColor[][] BOARD;\r\n\r\n  public MoveCalculator calculator;\r\n  public Move chosenMove;\r\n\r\n  static {\r\n    // MoveCalculatorFactory.usedCalculatorImplementation =\r\n    // MoveCalculatorImplementation.MOVE_CALCULATOR_LEVEL_1;\r\n    // MoveCalculatorFactory.usedCalculatorImplementation =\r\n    // MoveCalculatorImplementation.MOVE_CALCULATOR_LEVEL_2;\r\n    MoveCalculatorFactory.usedCalculatorImplementation =\r\n        MoveCalculatorImplementation.MOVE_CALCULATOR_LEVEL_3;\r\n  }\r\n\r\n  /** Entry point at Codingame, which calls then the play() method. */\r\n  public static void main(String[] args) {\r\n    Player p = new Player();\r\n    p.play();\r\n  }\r\n\r\n  /**\r\n   * This method is called, by the main Method, which is added by the Converter. This way, the game\r\n   * should be played at Codingame.\r\n   */\r\n  public void play() {\r\n    readInitialInput(in);\r\n    while (true) {\r\n      turnCount++;\r\n      readFromScanner(in);\r\n      calculateMove();\r\n      sendMove();\r\n    }\r\n  }\r\n\r\n  private void readInitialInput(Scanner in) {\r\n    String myColor = in.nextLine();\r\n    BOARD_SIZE = in.nextInt(); // the size of the board (width and height)\r\n    MY_COLOR = PlayerColor.fromCharCode(myColor);\r\n    OPPONENT_COLOR = PlayerColor.getOpposizeColor(MY_COLOR);\r\n  }\r\n\r\n  /**\r\n   * Default read in logic comes here.\r\n   *\r\n   * @param in Scanner, which provides the defined input lines.\r\n   */\r\n  public void readFromScanner(Scanner in) {\r\n    int opponentX =\r\n        in\r\n            .nextInt(); // The x coordinate of your opponent's last move (or -1 if the opponent\r\n                        // passed)\r\n    int opponentY =\r\n        in\r\n            .nextInt(); // The y coordinate of your opponent's last move (or -1 if the opponent\r\n                        // passed)\r\n    OPPONENTS_LAST_MOVE = new Move(opponentY, opponentX, PlayerColor.getOpposizeColor(MY_COLOR));\r\n    MY_SCORE = in.nextInt(); // Your current score (the number of captured stones)\r\n    OPPONENT_SCORE = in.nextInt(); // the opponents current score (the number of captured stones)\r\n\r\n    FIELDS_ON_BOARD = BOARD_SIZE * BOARD_SIZE;\r\n    if (in.hasNextLine()) {\r\n      in.nextLine();\r\n    }\r\n    String[] lines = new String[BOARD_SIZE];\r\n    for (int i = 0; i < BOARD_SIZE; i++) {\r\n      String line =\r\n          in\r\n              .nextLine(); // A row of the current board where 'B' marks a black stone, 'W' marks a\r\n                           // white stone and '.' marks an empty field\r\n      lines[i] = line;\r\n    }\r\n\r\n    BOARD = Referee.getBoard(lines);\r\n\r\n    chosenMove = null;\r\n  }\r\n\r\n  public void sendMove() {\r\n    if (chosenMove == null) {\r\n      System.err.println(\"ERROR: NO MOVE CHOSEN - USING DEFAULT: PASS\");\r\n      System.out.println(\"PASS\");\r\n    } else if (chosenMove.isPass()) {\r\n      System.out.println(\"PASS\");\r\n    } else {\r\n      System.out.println(chosenMove.getCol() + \" \" + chosenMove.getRow());\r\n    }\r\n  }\r\n\r\n  public void calculateMove() {\r\n    if (calculator == null) {\r\n      calculator = MoveCalculatorFactory.createCalculator();\r\n    }\r\n    calculator.calculateMove(this);\r\n  }\r\n\r\n  public void setChosenMove(Move chosenMove) {\r\n    this.chosenMove = chosenMove;\r\n  }\r\n\r\n  public abstract static class AbstractMoveCalculator implements MoveCalculator {\r\n\r\n    public Referee referee;\r\n\r\n    public AbstractMoveCalculator() {\r\n      referee = new Referee();\r\n    }\r\n\r\n    public abstract void calculateMove(Player player);\r\n\r\n    public List<Group> findGroups(Referee ref, PlayerColor color) {\r\n      List<Group> groups = new ArrayList<Group>(Player.FIELDS_ON_BOARD / 2);\r\n      Set<FieldPosition> known = new HashSet<>();\r\n      for (int row = 0; row < Player.BOARD_SIZE; row++) {\r\n        for (int col = 0; col < Player.BOARD_SIZE; col++) {\r\n          FieldPosition pos = new FieldPosition(row, col);\r\n          if (!known.contains(pos) && ref.getStoneColor(pos) == color) {\r\n            Group group = Group.findGroup(ref, pos);\r\n            groups.add(group);\r\n            known.addAll(group.getStones());\r\n          }\r\n        }\r\n      }\r\n\r\n      return groups;\r\n    }\r\n\r\n    protected void update() {\r\n      // update current scores\r\n      referee.getGame().setStonesCaptured(Player.MY_COLOR, Player.MY_SCORE);\r\n      referee\r\n          .getGame()\r\n          .setStonesCaptured(PlayerColor.getOpposizeColor(Player.MY_COLOR), Player.OPPONENT_SCORE);\r\n      // update the board\r\n      referee.addMove(Player.OPPONENTS_LAST_MOVE);\r\n      referee.setBoard(Player.BOARD);\r\n      referee.setBoard(referee.getBoardCopy());\r\n    }\r\n\r\n    protected Move getRandomMove() {\r\n      Move random;\r\n      do {\r\n        random =\r\n            new Move(\r\n                (int) (Math.random() * Player.BOARD_SIZE - 6 + 3),\r\n                (int) (Math.random() * Player.BOARD_SIZE - 6 + 3),\r\n                Player.MY_COLOR);\r\n      } while (!referee.isValidMove(random));\r\n      return random;\r\n    }\r\n\r\n    protected List<FieldPosition> getStonesOnBoard() {\r\n      List<FieldPosition> stones = new ArrayList<FieldPosition>(Player.FIELDS_ON_BOARD);\r\n      PlayerColor[][] board = referee.getBoard();\r\n      for (int i = 0; i < Player.BOARD_SIZE; i++) {\r\n        for (int j = 0; j < Player.BOARD_SIZE; j++) {\r\n          if (board[i][j] != null) {\r\n            stones.add(new FieldPosition(i, j));\r\n          }\r\n        }\r\n      }\r\n      return stones;\r\n    }\r\n\r\n    protected List<FieldPosition> getFreeFieldsNear(List<FieldPosition> placedStones) {\r\n      List<FieldPosition> freeFieldsNear = new ArrayList<>(Player.FIELDS_ON_BOARD);\r\n      for (FieldPosition stone : placedStones) {\r\n        for (FieldPosition pos : stone.getFieldsNear()) {\r\n          if (referee.isFieldEmpty(pos)) {\r\n            freeFieldsNear.add(pos);\r\n          }\r\n        }\r\n      }\r\n      return freeFieldsNear;\r\n    }\r\n  }\r\n\r\n  public static class Vector2D implements Cloneable {\r\n\r\n    public double x;\r\n    public double y;\r\n\r\n    public static final Vector2D NAN_VEC = new Vector2D(Double.NaN, Double.NaN);\r\n    public static final Vector2D NULL_VEC = new Vector2D(0, 0);\r\n\r\n    /*public enum Axis {\r\n    \tX,\r\n    \tY;\r\n    }*/\r\n\r\n    public Vector2D() {}\r\n\r\n    /** Crate a new Vector2D with x and y components. */\r\n    public Vector2D(double x, double y) {\r\n      this.x = x;\r\n      this.y = y;\r\n    }\r\n\r\n    public Vector2D(double... val) {\r\n      if (val.length != 2) {\r\n        // throw new LinearAlgebraException(\"A 2D Vector has 2 entries.\");\r\n      }\r\n      x = val[0];\r\n      y = val[1];\r\n    }\r\n    /**\r\n     * Create a Vector2D by an angle (in degree). An angle of 0 results in (x, y) = (1, 0); 90 in\r\n     * (x, y) = (0, 1); ... The resulting vector has a length of 1.\r\n     *\r\n     * @param angleDegree The angle of the new vector in degree.\r\n     */\r\n    public Vector2D(double angleDegree) {\r\n      this(Math.cos(angleDegree * Math.PI / 180), Math.sin(angleDegree * Math.PI / 180));\r\n    }\r\n\r\n    private Vector2D(Vector2D clone) {\r\n      this.x = clone.x;\r\n      this.y = clone.y;\r\n    }\r\n\r\n    /** Clone this Vector2D object. */\r\n    public Vector2D clone() {\r\n      return new Vector2D(this);\r\n    }\r\n\r\n    public String toString() {\r\n      return \"Vector2D[x: \" + x + \" y: \" + y + \"]\";\r\n    }\r\n\r\n    public String toString(String format) {\r\n      return String.format(format, x, y);\r\n    }\r\n\r\n    public boolean equals(Object obj) {\r\n      if (obj instanceof Vector2D) {\r\n        Vector2D v = (Vector2D) obj;\r\n        return Math.abs(x - v.x) < 1e-8 && Math.abs(y - v.y) < 1e-8;\r\n      }\r\n      return false;\r\n    }\r\n\r\n    /** Get this vector as 2D-Array. */\r\n    public double[] asArray() {\r\n      return new double[] {x, y};\r\n    }\r\n\r\n    /** The (euclidean) length of the Vector. */\r\n    public double length() {\r\n      return Math.hypot(x, y);\r\n    }\r\n    /**\r\n     * The length of this vector in a given norm.\r\n     *\r\n     * @param norm The norm of the vector length.\r\n     * @return The length of this vector in the given norm.\r\n     */\r\n    public double length(int norm) {\r\n      if (norm == Integer.MAX_VALUE) {\r\n        return Math.max(x, y);\r\n      }\r\n      return Math.pow(Math.pow(x, norm) + Math.pow(y, norm), 1.0 / norm);\r\n    }\r\n\r\n    /**\r\n     * Rotate the Vector an angle (in degrees) resulting in a new Vector that is returned.\r\n     *\r\n     * @param degrees The angle to return the vector.\r\n     * @return The new created vector.\r\n     */\r\n    public Vector2D rotate(double degrees) {\r\n      return new Vector2D(getAngle() + degrees).setLength(length());\r\n    }\r\n\r\n    /**\r\n     * Project the vector given as parameter on this vector.\r\n     *\r\n     * @param vec The vector that is to be projected on this vector.\r\n     * @return The projected vector.\r\n     */\r\n    public Vector2D project(Vector2D vec) {\r\n      return mult(scalar(vec) / Math.pow(length(), 2));\r\n    }\r\n\r\n    /**\r\n     * Add another Vector2D to this vector resulting in a new Vector that is returned.\r\n     *\r\n     * @param vec The vector added to this vector.\r\n     * @return The new created vector.\r\n     */\r\n    public Vector2D add(Vector2D vec) {\r\n      return new Vector2D(x + vec.x, y + vec.y);\r\n    }\r\n    /**\r\n     * Subtract another Vector3D from this vector resulting in a new Vector that is returned.\r\n     *\r\n     * @param vec The vector subtracted from this vector.\r\n     * @return The new created vector.\r\n     */\r\n    public Vector2D sub(Vector2D vec) {\r\n      return new Vector2D(x - vec.x, y - vec.y);\r\n    }\r\n    /**\r\n     * Multiply this vector with a scalar resulting in a new Vector that is returned.\r\n     *\r\n     * @param scalar The scalar to multiply this vector with.\r\n     * @return The new created vector.\r\n     */\r\n    public Vector2D mult(double scalar) {\r\n      return new Vector2D(x * scalar, y * scalar);\r\n    }\r\n\r\n    /**\r\n     * Check whether this vector is linearly dependent to the parameter vector.\r\n     *\r\n     * @param vec The checked vector.\r\n     * @return True if the vectors are linearly dependent. False otherwise.\r\n     */\r\n    public boolean isLinearlyDependent(Vector2D vec) {\r\n      double t1 = (x == 0 ? 0 : vec.x / x);\r\n      double t2 = (y == 0 ? 0 : vec.y / y);\r\n      return Math.abs(t1 - t2) < 1e-5 && t1 != 0; // all parameters t are equal and != 0\r\n    }\r\n\r\n    /**\r\n     * Check whether the parameter vectors are linearly dependent.\r\n     *\r\n     * @param vectors The vectors that are checked.\r\n     * @return True if the vectors are linearly dependent. False otherwise.\r\n     */\r\n    public boolean isLinearlyDependentVectors(Vector2D... vectors) {\r\n      if (vectors.length < 2) {\r\n        return false;\r\n      } else if (vectors.length > 2) {\r\n        // 3 or more vectors in the R^2 are always linearly dependent\r\n        return true;\r\n      } else {\r\n        return vectors[0].isLinearlyDependent(vectors[1]);\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Calculate the scalar product of this vector and the parameter vector.\r\n     *\r\n     * @param vec The vector to calculate the scalar with this vector.\r\n     * @return The scalar of the vectors.\r\n     */\r\n    public double scalar(Vector2D vec) {\r\n      return this.x * vec.x + this.y * vec.y;\r\n    }\r\n\r\n    /**\r\n     * Create a new vector with the same direction but a different length as this vector.\r\n     *\r\n     * @param length The length of the new vector.\r\n     * @return The new vector with a new length.\r\n     */\r\n    public Vector2D setLength(double length) {\r\n      double len = length();\r\n      return new Vector2D(x * length / len, y * length / len);\r\n    }\r\n\r\n    /**\r\n     * Get the distance of this point's position vector to another point's position vector.\r\n     *\r\n     * @param p The second point's position vector.\r\n     * @return The distance between the points.\r\n     */\r\n    public double distance(Vector2D p) {\r\n      return Math.sqrt((this.x - p.x) * (this.x - p.x) + (this.y - p.y) * (this.y - p.y));\r\n    }\r\n\r\n    /** Change this vector to the new coordinates. */\r\n    public void move(double x, double y) {\r\n      this.x = x;\r\n      this.y = y;\r\n    }\r\n\r\n    /**\r\n     * Move a point's position vector in a direction (by a vector) and a distance.\r\n     *\r\n     * @param p The direction vector.\r\n     * @param distance The distance to move the new vector\r\n     * @return The new created vector.\r\n     */\r\n    public Vector2D moveTo(Vector2D p, double distance) {\r\n      double d = distance(p);\r\n      double dx = p.x - x;\r\n      double dy = p.y - y;\r\n      double coef = distance / d;\r\n      return new Vector2D(x + dx * coef, y + dy * coef);\r\n    }\r\n\r\n    /** Get the angle of this vector. Angle: 0 is right ((x, y) = (1, 0)); on clockwise (degree) */\r\n    public double getAngle() {\r\n      return ((Math.atan2(y, x) * 180 / Math.PI) + 720) % 360;\r\n    }\r\n\r\n    /** Get the angle of this vector as radiant. */\r\n    public double getAngleRad() {\r\n      return (Math.atan2(y, x) + 4 * Math.PI) % (2 * Math.PI);\r\n    }\r\n\r\n    /**\r\n     * Get the angle difference of this vector to another vector.\r\n     *\r\n     * @param vec The other vector.\r\n     * @return The angle difference of the two vectors (from 0 to 180).\r\n     */\r\n    public double getAngleDeltaTo(Vector2D vec) {\r\n      double delta = Math.abs(getAngle() - vec.getAngle());\r\n      if (delta > 180) {\r\n        delta = 360 - delta;\r\n      }\r\n      return delta;\r\n    }\r\n\r\n    /**\r\n     * Get the vector from this point to another.\r\n     *\r\n     * @param vec The point to which the vector is calculated.\r\n     * @return The vector from this points position vector to the other point.\r\n     */\r\n    public Vector2D vectorTo(Vector2D vec) {\r\n      return new Vector2D(vec.x - x, vec.y - y);\r\n    }\r\n\r\n    /**\r\n     * Checks whether a point (by its position vector) is in a given range of this point.\r\n     *\r\n     * @param p The point that is checked.\r\n     * @param range The range used for the check.\r\n     * @return True if the point is in the range of this point (distance <= range).\r\n     */\r\n    public boolean isInRange(Vector2D p, double range) {\r\n      return p != this && distance(p) <= range;\r\n    }\r\n\r\n    public double getX() {\r\n      return x;\r\n    }\r\n\r\n    public double getY() {\r\n      return y;\r\n    }\r\n  }\r\n\r\n  /** The stronges AI for the third and last league */\r\n  public static class MoveCalculatorLevel3 extends AbstractMoveCalculator\r\n      implements MoveCalculator {\r\n\r\n    /** The total number of moves that can be simulated in time */\r\n    public final int CALCULATED_MOVES = 100;\r\n\r\n    private int numScoreCalculations;\r\n    private long start;\r\n\r\n    public void calculateMove(Player player) {\r\n      update();\r\n      numScoreCalculations = 0;\r\n      start = System.currentTimeMillis();\r\n      DebugUtils.pause();\r\n\r\n      // first move is random\r\n      if (Player.turnCount == 1) {\r\n        player.setChosenMove(getRandomMove());\r\n        return;\r\n      }\r\n\r\n      Map<Move, Referee> possibleMoves = new HashMap<Move, Referee>();\r\n\r\n      // add passing as possible move\r\n      possibleMoves.put(new Move(-1, -1, Player.MY_COLOR), referee.clone());\r\n\r\n      // stones beneath other placed stones\r\n      List<FieldPosition> placedStones = getStonesOnBoard();\r\n      List<FieldPosition> nearPlacedStones = getFreeFieldsNear(placedStones);\r\n\r\n      DebugUtils.print(\"TIMING after nearPlacedStones: \" + (System.currentTimeMillis() - start));\r\n\r\n      if (nearPlacedStones.size() > CALCULATED_MOVES) {\r\n        Collections.shuffle(nearPlacedStones);\r\n        nearPlacedStones = nearPlacedStones.subList(0, CALCULATED_MOVES);\r\n      }\r\n\r\n      DebugUtils.print(\"TIMING: after shuffle \" + (System.currentTimeMillis() - start));\r\n\r\n      for (FieldPosition pos : nearPlacedStones) {\r\n        Move move = new Move(pos.getRow(), pos.getCol(), Player.MY_COLOR);\r\n        if (referee.isValidMove(move)) {\r\n          Referee ref = referee.clone();\r\n          ref.addMove(move);\r\n          possibleMoves.put(move, ref);\r\n        }\r\n      }\r\n\r\n      DebugUtils.print(\r\n          \"TIMING after adding near placed stones: \" + (System.currentTimeMillis() - start));\r\n\r\n      // all other positions (if spaces left)\r\n      int calculationsLeft = CALCULATED_MOVES - possibleMoves.size();\r\n      for (int i = 0; i < calculationsLeft; i++) {\r\n        Move random =\r\n            new Move(\r\n                (int) (Math.random() * Player.BOARD_SIZE),\r\n                (int) (Math.random() * Player.BOARD_SIZE),\r\n                Player.MY_COLOR);\r\n        if (referee.isValidMove(random)) {\r\n          Referee ref = referee.clone();\r\n          ref.addMove(random);\r\n          possibleMoves.put(random, ref);\r\n        }\r\n      }\r\n\r\n      DebugUtils.print(\r\n          \"TIMING after adding left calculations: \" + (System.currentTimeMillis() - start));\r\n\r\n      TreeMap<Double, Move> scores = new TreeMap<>();\r\n      for (Map.Entry<Move, Referee> move : possibleMoves.entrySet()) {\r\n        double score = calculateRefereeScore(move.getValue());\r\n        scores.put(score, move.getKey());\r\n      }\r\n\r\n      Move bestMove;\r\n      if (scores.isEmpty()) {\r\n        bestMove = new Move(-1, -1, Player.MY_COLOR);\r\n      } else {\r\n        bestMove = scores.lastEntry().getValue();\r\n      }\r\n      player.setChosenMove(bestMove);\r\n\r\n      referee.addMove(bestMove);\r\n    }\r\n\r\n    public double calculateRefereeScore(Referee ref) {\r\n      DebugUtils.pause();\r\n      DebugUtils.print(numScoreCalculations + \": \" + (System.currentTimeMillis() - start));\r\n      numScoreCalculations++;\r\n      DebugUtils.start();\r\n\r\n      double score = 0;\r\n\r\n      int myScore = ref.getGame().getStonesCaptured(Player.OPPONENT_COLOR);\r\n      int opponentScore = ref.getGame().getStonesCaptured(Player.MY_COLOR);\r\n\r\n      score += myScore * 1000;\r\n      score -= opponentScore * 1000;\r\n\r\n      List<Group> myGroups = findGroups(ref, Player.MY_COLOR);\r\n      List<Group> opponentGroups = findGroups(ref, Player.OPPONENT_COLOR);\r\n\r\n      int libertiesMe = 0;\r\n      int minLibertiesOpponent = Integer.MAX_VALUE;\r\n      int minLibertiesMe = Integer.MAX_VALUE;\r\n\r\n      for (Group group : myGroups) {\r\n        int liberties = group.getLiberties(ref).size();\r\n        libertiesMe += liberties;\r\n        minLibertiesMe = Math.min(liberties, minLibertiesMe);\r\n      }\r\n      for (Group group : opponentGroups) {\r\n        int liberties = group.getLiberties(ref).size();\r\n        minLibertiesOpponent = Math.min(liberties, minLibertiesOpponent);\r\n      }\r\n\r\n      score += libertiesMe;\r\n      score += minLibertiesMe * 10;\r\n      score -= minLibertiesOpponent * 100;\r\n\r\n      if (minLibertiesMe == 1) {\r\n        score -= 1000;\r\n      }\r\n\r\n      return score;\r\n    }\r\n  }\r\n\r\n  /** A slightly better AI for the second league: */\r\n  public static class MoveCalculatorLevel2 extends AbstractMoveCalculator\r\n      implements MoveCalculator {\r\n\r\n    public void calculateMove(Player player) {\r\n      update();\r\n\r\n      // first move is random\r\n      if (Player.turnCount == 1) {\r\n        player.setChosenMove(getRandomMove());\r\n        return;\r\n      }\r\n\r\n      Map<Move, Referee> possibleMoves = new HashMap<Move, Referee>();\r\n      for (int row = 0; row < Player.BOARD_SIZE; row++) {\r\n        for (int col = 0; col < Player.BOARD_SIZE; col++) {\r\n          Move move = new Move(row, col, Player.MY_COLOR);\r\n          Referee ref = referee.clone();\r\n          if (ref.isValidMove(move)) {\r\n            ref.addMove(move);\r\n            possibleMoves.put(move, ref);\r\n          }\r\n        }\r\n      }\r\n      // add passing as possible move\r\n      possibleMoves.put(new Move(-1, -1, Player.MY_COLOR), referee.clone());\r\n\r\n      TreeMap<Double, Move> scores = new TreeMap<>();\r\n      for (Map.Entry<Move, Referee> move : possibleMoves.entrySet()) {\r\n        double score = calculateRefereeScore(move.getValue());\r\n        scores.put(score, move.getKey());\r\n      }\r\n\r\n      Move bestMove;\r\n      if (scores.isEmpty()) {\r\n        bestMove = new Move(-1, -1, Player.MY_COLOR);\r\n      } else {\r\n        bestMove = scores.lastEntry().getValue();\r\n      }\r\n      player.setChosenMove(bestMove);\r\n\r\n      referee.addMove(bestMove);\r\n    }\r\n\r\n    public double calculateRefereeScore(Referee ref) {\r\n      double score = 0;\r\n\r\n      int myScore = ref.getGame().getStonesCaptured(Player.OPPONENT_COLOR);\r\n      int opponentScore = ref.getGame().getStonesCaptured(Player.MY_COLOR);\r\n\r\n      score += myScore * 1000;\r\n      score -= opponentScore * 1000;\r\n\r\n      List<Group> myGroups = findGroups(ref, Player.MY_COLOR);\r\n      List<Group> opponentGroups = findGroups(ref, Player.OPPONENT_COLOR);\r\n\r\n      int libertiesMe = 0;\r\n      int minLibertiesOpponent = Integer.MAX_VALUE;\r\n      int minLibertiesMe = Integer.MAX_VALUE;\r\n\r\n      for (Group group : myGroups) {\r\n        int liberties = group.getLiberties(ref).size();\r\n        libertiesMe += liberties;\r\n        minLibertiesMe = Math.min(liberties, minLibertiesMe);\r\n      }\r\n      for (Group group : opponentGroups) {\r\n        int liberties = group.getLiberties(ref).size();\r\n        minLibertiesOpponent = Math.min(liberties, minLibertiesOpponent);\r\n      }\r\n\r\n      score += libertiesMe;\r\n      score += minLibertiesMe * 10;\r\n      score -= minLibertiesOpponent * 100;\r\n\r\n      return score;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Simple AI for first league:\r\n   *\r\n   * <p>if (can kill enemy stones) kill them else choose a random legal move\r\n   */\r\n  public static class MoveCalculatorLevel1 extends AbstractMoveCalculator\r\n      implements MoveCalculator {\r\n\r\n    public void calculateMove(Player player) {\r\n      DebugUtils.print(\"start\");\r\n      update();\r\n      DebugUtils.print(\"after update\");\r\n\r\n      // first move is random\r\n      if (Player.turnCount == 1) {\r\n        player.setChosenMove(getRandomMove());\r\n        return;\r\n      }\r\n      DebugUtils.print(\"after random first turn\");\r\n\r\n      Map<Move, Referee> possibleMoves = new HashMap<Move, Referee>();\r\n      for (int row = 0; row < Player.BOARD_SIZE; row++) {\r\n        for (int col = 0; col < Player.BOARD_SIZE; col++) {\r\n          Move move = new Move(row, col, Player.MY_COLOR);\r\n          Referee ref = referee.clone();\r\n          if (ref.isValidMove(move)) {\r\n            ref.addMove(move);\r\n            possibleMoves.put(move, ref);\r\n          }\r\n        }\r\n      }\r\n      DebugUtils.print(\"after possible moves\");\r\n      // add passing as possible move\r\n      possibleMoves.put(new Move(-1, -1, Player.MY_COLOR), referee.clone());\r\n      DebugUtils.print(\"after pass as possible move\");\r\n\r\n      TreeMap<Double, Move> scores = new TreeMap<>();\r\n      for (Map.Entry<Move, Referee> move : possibleMoves.entrySet()) {\r\n        double score = calculateRefereeScore(move.getValue());\r\n        scores.put(score, move.getKey());\r\n      }\r\n      DebugUtils.print(\"after scores\");\r\n\r\n      Move bestMove;\r\n      if (scores.isEmpty()) {\r\n        bestMove = new Move(-1, -1, Player.MY_COLOR);\r\n      } else {\r\n        bestMove = scores.lastEntry().getValue();\r\n      }\r\n      player.setChosenMove(bestMove);\r\n\r\n      DebugUtils.print(\"after setChosenMove\");\r\n\r\n      referee.addMove(bestMove);\r\n\r\n      DebugUtils.print(\"end\");\r\n    }\r\n\r\n    public double calculateRefereeScore(Referee ref) {\r\n      double score = 0;\r\n\r\n      int myScore = ref.getGame().getStonesCaptured(Player.OPPONENT_COLOR);\r\n      int opponentScore = ref.getGame().getStonesCaptured(Player.MY_COLOR);\r\n\r\n      score += myScore * 1000;\r\n      score -= opponentScore * 1000;\r\n\r\n      score += Math.random();\r\n\r\n      return score;\r\n    }\r\n  }\r\n\r\n  public static class Group {\r\n\r\n    private Set<FieldPosition> stones;\r\n    private PlayerColor color;\r\n\r\n    public Group(Set<FieldPosition> stones, PlayerColor color) {\r\n      this.stones = stones;\r\n      this.color = color;\r\n    }\r\n\r\n    public Group(PlayerColor color) {\r\n      this.color = color;\r\n      this.stones = new HashSet<FieldPosition>();\r\n    }\r\n\r\n    public static Group findGroup(Referee ref, FieldPosition startingPosition) {\r\n      PlayerColor groupColor = ref.getStoneColor(startingPosition);\r\n      final int boardSize = Player.BOARD_SIZE;\r\n      if (groupColor == null) {\r\n        throw new IllegalArgumentException(\r\n            \"The field of the starting position is empty (position was: \" + startingPosition + \")\");\r\n      }\r\n\r\n      // complete the group by adding stones using a flood fill\r\n      Set<FieldPosition> allStones = new HashSet<FieldPosition>();\r\n\r\n      // initialize the current queue and the next step queue\r\n      Set<FieldPosition> currentStones = new HashSet<FieldPosition>();\r\n      Set<FieldPosition> nextStones = new HashSet<FieldPosition>();\r\n\r\n      // add the starting position\r\n      currentStones.add(startingPosition);\r\n\r\n      // add the fields with the iterative flood fill till the queues are empty\r\n      while (!currentStones.isEmpty()) {\r\n        for (FieldPosition currentField : currentStones) {\r\n          for (FieldPosition near : currentField.getFieldsNear(boardSize)) {\r\n            if (near.exists(boardSize)\r\n                && // the field exists on the board\r\n                ref.getStoneColor(near) != null\r\n                && // prevent NPE\r\n                ref.getStoneColor(near).equals(groupColor)\r\n                && // the field contains a stone of the group color\r\n                !allStones.contains(near)\r\n                && !currentStones.contains(near)) { // the field is not already added\r\n              nextStones.add(near);\r\n            }\r\n          }\r\n        }\r\n        // add the current stones to the group, copy the next steps to the queue and clear next\r\n        // steps\r\n        allStones.addAll(currentStones);\r\n        currentStones = nextStones;\r\n        nextStones = new HashSet<FieldPosition>();\r\n      }\r\n\r\n      return new Group(allStones, groupColor);\r\n    }\r\n\r\n    public boolean isBeaten(Referee ref) {\r\n      Set<FieldPosition> nearFreeFields = getLiberties(ref);\r\n\r\n      return nearFreeFields.isEmpty();\r\n    }\r\n\r\n    public Set<FieldPosition> getLiberties(Referee ref) {\r\n      Set<FieldPosition> liberties = new HashSet<>();\r\n      for (FieldPosition stone : stones) {\r\n        for (FieldPosition pos : stone.getFieldsNear()) {\r\n          if (pos.exists() && ref.isFieldEmpty(pos)) {\r\n            liberties.add(pos);\r\n          }\r\n        }\r\n      }\r\n      return liberties;\r\n\r\n      //\t\treturn stones.stream().flatMap(s -> s.getFieldsNear(Player.BOARD_SIZE).stream()) //all\r\n      // fields near\r\n      //\t\t\t\t.filter(field -> field.exists(Player.BOARD_SIZE) && ref.isFieldEmpty(field)) //existing\r\n      // and empty\r\n      //\t\t\t\t.collect(Collectors.toSet());\r\n    }\r\n\r\n    public void addStone(FieldPosition pos) {\r\n      stones.add(pos);\r\n    }\r\n\r\n    public void addStones(List<FieldPosition> positions) {\r\n      stones.addAll(positions);\r\n    }\r\n\r\n    public void remove(FieldPosition pos) {\r\n      stones.remove(pos);\r\n    }\r\n\r\n    public void clear() {\r\n      stones.clear();\r\n    }\r\n\r\n    public Set<FieldPosition> getStones() {\r\n      return stones;\r\n    }\r\n\r\n    public void setStones(Set<FieldPosition> stones) {\r\n      this.stones = stones;\r\n    }\r\n\r\n    public PlayerColor getColor() {\r\n      return color;\r\n    }\r\n\r\n    public void setColor(PlayerColor color) {\r\n      this.color = color;\r\n    }\r\n  }\r\n\r\n  public static class DebugUtils {\r\n\r\n    public static final boolean DEBUG = true;\r\n    public static boolean PAUSE_DEBUG = false;\r\n\r\n    public static final String DEFAULT_VECTOR_FORMAT = \"(%4.0f|%4.0f)\";\r\n\r\n    public static void pause() {\r\n      PAUSE_DEBUG = true;\r\n    }\r\n\r\n    public static void start() {\r\n      PAUSE_DEBUG = false;\r\n    }\r\n\r\n    public static void printVector2D(Vector2D vec, String prefix) {\r\n      print(prefix + vec.toString(\"(%4.0f|%4.0f)\"));\r\n    }\r\n\r\n    public static void printVector2D(Vector2D vec, String prefix, String format) {\r\n      print(prefix + vec.toString(format));\r\n    }\r\n\r\n    public static void printBoard(PlayerColor[][] board) {\r\n      StringBuilder sb = new StringBuilder();\r\n      for (PlayerColor[] line : board) {\r\n        for (PlayerColor field : line) {\r\n          sb.append(PlayerColor.toCharCode(field));\r\n        }\r\n        sb.append('\\n');\r\n      }\r\n      print(sb.toString());\r\n    }\r\n\r\n    public static void print(Object obj) {\r\n      print(obj.toString());\r\n    }\r\n\r\n    public static void print(String s) {\r\n      if (DEBUG) {\r\n        if (!PAUSE_DEBUG) {\r\n          System.err.println(s);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  public static class Game {\r\n\r\n    private int blackStonesCaptured;\r\n    private int whiteStonesCaptured;\r\n\r\n    public Game clone() {\r\n      Game clone = new Game();\r\n      clone.setBlackStonesCaptured(blackStonesCaptured);\r\n      clone.setWhiteStonesCaptured(whiteStonesCaptured);\r\n      return clone;\r\n    }\r\n\r\n    public int getStonesCaptured(PlayerColor color) {\r\n      if (color == PlayerColor.BLACK) {\r\n        return getBlackStonesCaptured();\r\n      } else if (color == PlayerColor.WHITE) {\r\n        return whiteStonesCaptured;\r\n      }\r\n      throw new IllegalStateException(\"Unknown PlayerColor: \" + color);\r\n    }\r\n\r\n    public void setStonesCaptured(PlayerColor color, int captured) {\r\n      if (color == PlayerColor.BLACK) {\r\n        blackStonesCaptured = captured;\r\n      } else if (color == PlayerColor.WHITE) {\r\n        whiteStonesCaptured = captured;\r\n      } else {\r\n        throw new IllegalStateException(\"Unknown PlayerColor: \" + color);\r\n      }\r\n    }\r\n\r\n    public int getBlackStonesCaptured() {\r\n      return blackStonesCaptured;\r\n    }\r\n\r\n    public void setBlackStonesCaptured(int blackStonesCaptured) {\r\n      this.blackStonesCaptured = blackStonesCaptured;\r\n    }\r\n\r\n    public int getWhiteStonesCaptured() {\r\n      return whiteStonesCaptured;\r\n    }\r\n\r\n    public void setWhiteStonesCaptured(int whiteStonesCaptured) {\r\n      this.whiteStonesCaptured = whiteStonesCaptured;\r\n    }\r\n  }\r\n\r\n  public static class FieldPosition {\r\n\r\n    private int row;\r\n    private int col;\r\n\r\n    public FieldPosition(int row, int col) {\r\n      super();\r\n      this.row = row;\r\n      this.col = col;\r\n    }\r\n\r\n    public int hashCode() {\r\n      final int prime = 31;\r\n      int result = 1;\r\n      result = prime * result + col;\r\n      result = prime * result + row;\r\n      return result;\r\n    }\r\n\r\n    public boolean equals(Object obj) {\r\n      if (this == obj) return true;\r\n      if (obj == null) return false;\r\n      if (getClass() != obj.getClass()) return false;\r\n      FieldPosition other = (FieldPosition) obj;\r\n      if (col != other.col) return false;\r\n      if (row != other.row) return false;\r\n      return true;\r\n    }\r\n\r\n    public List<FieldPosition> getFieldsNear() {\r\n      return getFieldsNear(Player.BOARD_SIZE);\r\n    }\r\n\r\n    public List<FieldPosition> getFieldsNear(int boardSize) {\r\n      int[][] near = new int[][] {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\r\n      List<FieldPosition> nearFields = new ArrayList<FieldPosition>();\r\n      for (int[] nearDiff : near) {\r\n        FieldPosition position = new FieldPosition(row + nearDiff[0], col + nearDiff[1]);\r\n        if (position.exists(boardSize)) {\r\n          nearFields.add(position);\r\n        }\r\n      }\r\n      return nearFields;\r\n    }\r\n\r\n    public boolean exists() {\r\n      return exists(Player.BOARD_SIZE);\r\n    }\r\n\r\n    public boolean exists(int boardSize) {\r\n      return row >= 0 && col >= 0 && row < boardSize && col < boardSize;\r\n    }\r\n\r\n    public int getRow() {\r\n      return row;\r\n    }\r\n\r\n    public void setRow(int row) {\r\n      this.row = row;\r\n    }\r\n\r\n    public int getCol() {\r\n      return col;\r\n    }\r\n\r\n    public void setCol(int col) {\r\n      this.col = col;\r\n    }\r\n  }\r\n\r\n  public interface MoveCalculator {\r\n\r\n    public void calculateMove(Player player);\r\n  }\r\n\r\n  public static class MoveCalculatorFactory {\r\n\r\n    public static MoveCalculatorImplementation usedCalculatorImplementation;\r\n\r\n    public static MoveCalculator createCalculator() {\r\n      switch (usedCalculatorImplementation) {\r\n        case MOVE_CALCULATOR_LEVEL_1:\r\n          return new MoveCalculatorLevel1();\r\n        case MOVE_CALCULATOR_LEVEL_2:\r\n          return new MoveCalculatorLevel2();\r\n        case MOVE_CALCULATOR_LEVEL_3:\r\n          return new MoveCalculatorLevel3();\r\n        default:\r\n          throw new IllegalStateException(\r\n              \"Unknown implementation type: \"\r\n                  + usedCalculatorImplementation\r\n                  + \"; choose a type in MoveCalculatorFactory or declare the unknown type\");\r\n      }\r\n    }\r\n  }\r\n\r\n  public enum MoveCalculatorImplementation {\r\n    MOVE_CALCULATOR_LEVEL_1, //\r\n    MOVE_CALCULATOR_LEVEL_2, //\r\n    MOVE_CALCULATOR_LEVEL_3, //\r\n  }\r\n\r\n  public enum PlayerColor {\r\n    BLACK,\r\n    WHITE;\r\n\r\n    public static PlayerColor getOpposizeColor(PlayerColor lastMove) {\r\n      switch (lastMove) {\r\n        case BLACK:\r\n          return WHITE;\r\n        case WHITE:\r\n          return BLACK;\r\n        default:\r\n          return null;\r\n      }\r\n    }\r\n\r\n    public static String toCharCode(PlayerColor color) {\r\n      if (color == BLACK) {\r\n        return \"B\";\r\n      }\r\n      if (color == WHITE) {\r\n        return \"W\";\r\n      }\r\n      return \".\";\r\n    }\r\n\r\n    public String toCharCode() {\r\n      return toCharCode(this);\r\n    }\r\n\r\n    public static PlayerColor fromCharCode(String charCode) {\r\n      if (charCode.equals(\"B\")) {\r\n        return BLACK;\r\n      } else if (charCode.equals(\"W\")) {\r\n        return WHITE;\r\n      }\r\n      throw new IllegalStateException(\"unknown charCode: \" + charCode);\r\n    }\r\n  }\r\n\r\n  public static class Referee {\r\n\r\n    public static final int FRAME_DURATION = 800;\r\n    public static final int FRAME_WIDTH = 1920;\r\n    public static final int FRAME_HEIGHT = 1080;\r\n    public static final int BOARD_WIDTH = 950;\r\n\r\n    private Game game;\r\n\r\n    private PlayerColor[][] board;\r\n    private PlayerColor[][] previousBoard;\r\n\r\n    public Referee() {\r\n      this(new Game());\r\n    }\r\n\r\n    public Referee(Game game) {\r\n      this.game = game;\r\n      board = new PlayerColor[Player.BOARD_SIZE][Player.BOARD_SIZE];\r\n    }\r\n\r\n    // ***************************************************************************************************************\r\n    // *** CG stuff\r\n    // ***************************************************************************************************************\r\n\r\n    // ***************************************************************************************************************\r\n    // *** simulation\r\n    // ***************************************************************************************************************\r\n\r\n    public Referee clone() {\r\n      Referee clone = new Referee(game.clone());\r\n      clone.board = new PlayerColor[Player.BOARD_SIZE][Player.BOARD_SIZE];\r\n      clone.previousBoard = new PlayerColor[Player.BOARD_SIZE][Player.BOARD_SIZE];\r\n\r\n      for (int i = 0; i < Player.BOARD_SIZE; i++) {\r\n        clone.board = getBoardCopy(board);\r\n        clone.previousBoard = getBoardCopy(previousBoard);\r\n      }\r\n\r\n      return clone;\r\n    }\r\n\r\n    // ***************************************************************************************************************\r\n    // *** game methods\r\n    // ***************************************************************************************************************\r\n\r\n    public static PlayerColor[][] getBoard(String[] lines) {\r\n      int size = lines.length;\r\n      PlayerColor[][] board = new PlayerColor[size][size];\r\n      for (int i = 0; i < size; i++) {\r\n        for (int j = 0; j < size; j++) {\r\n          if (lines[i].charAt(j) == 'B') {\r\n            board[i][j] = PlayerColor.BLACK;\r\n          } else if (lines[i].charAt(j) == 'W') {\r\n            board[i][j] = PlayerColor.WHITE;\r\n          }\r\n        }\r\n      }\r\n      return board;\r\n    }\r\n\r\n    /** Execute all moves in the list to create the current board */\r\n\r\n    /*private*/ void fillBoard(List<Move> moves) throws IllegalArgumentException {\r\n      if (moves != null) {\r\n        for (Move move : moves) {\r\n          if (isValidMove(move)) {\r\n            addMove(move);\r\n          } else {\r\n            throw new IllegalArgumentException(\r\n                \"Invalid move. The given list of moves contains a move that is not valid: \" + move);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    public PlayerColor[][] getBoard() {\r\n      return board;\r\n    }\r\n\r\n    /** A deep copy of the current board */\r\n    public PlayerColor[][] getBoardCopy() {\r\n      return getBoardCopy(board);\r\n    }\r\n\r\n    public PlayerColor[][] getBoardCopy(PlayerColor[][] board) {\r\n      PlayerColor[][] newBoard = new PlayerColor[Player.BOARD_SIZE][Player.BOARD_SIZE];\r\n      if (board != null) {\r\n        for (int i = 0; i < Player.BOARD_SIZE; i++) {\r\n          for (int j = 0; j < Player.BOARD_SIZE; j++) {\r\n            newBoard[i][j] = board[i][j];\r\n          }\r\n        }\r\n      }\r\n      return newBoard;\r\n    }\r\n    /**\r\n     * Check whether the move is valid\r\n     *\r\n     * <p>Checked are:\r\n     *\r\n     * <ul>\r\n     *   <li>color (players turn)\r\n     *   <li>position (on field and empty)\r\n     *   <li>no suicidal move (placed stone is not directly beaten)\r\n     *   <li>ko rule (move doesn't create the same board that was there in the last move)\r\n     * </ul>\r\n     */\r\n    public boolean isValidMove(Move move) {\r\n      if (move.isPass()) {\r\n        // passing is always a valid move\r\n        return true;\r\n      }\r\n      if (!move.getPos().exists(Player.BOARD_SIZE)) {\r\n        // position doesn't exist\r\n        return false;\r\n      }\r\n      if (getStoneColor(move.getPos()) != null) {\r\n        // field not empty\r\n        return false;\r\n      }\r\n\r\n      // execute the move and check whether the state is valid\r\n      PlayerColor[][] tmpBoard = getBoardCopy(); // keep a copy of the board for a rollback\r\n      // make the move\r\n      board[move.getRow()][move.getCol()] = move.getColor();\r\n      removeBeaten(move);\r\n\r\n      // check the group of the new stone\r\n      Group group = Group.findGroup(this, move.getPos());\r\n      if (group.isBeaten(this)) {\r\n        // added stone is directly beaten\r\n        board = tmpBoard;\r\n        return false;\r\n      }\r\n\r\n      if (!Player.OPPONENTS_LAST_MOVE.isPass() && boardsEqual(board, previousBoard)) {\r\n        // restores the board from the last move (ko rule violated)\r\n        board = tmpBoard;\r\n        return false;\r\n      }\r\n\r\n      board = tmpBoard;\r\n      return true;\r\n    }\r\n\r\n    /*private*/ static boolean boardsEqual(PlayerColor[][] board, PlayerColor[][] previousBoard) {\r\n      if (previousBoard == null) {\r\n        // previousBoard can be null if there was no previous move\r\n        // in this case the ko-rule can't be violated and the boards are treated as not equal (so\r\n        // false is returned)\r\n        return false;\r\n      }\r\n      boolean equal = true;\r\n      for (int i = 0; i < board.length; i++) {\r\n        for (int j = 0; j < board[0].length; j++) {\r\n          equal &= board[i][j] == previousBoard[i][j];\r\n        }\r\n      }\r\n      return equal;\r\n    }\r\n\r\n    /**\r\n     * Execute a move without checking whether it's valid. The new stone is added and beaten ones\r\n     * are removed\r\n     */\r\n    public void addMove(Move move) {\r\n      if (!move.isPass()) {\r\n        // copy the board to the previous board field\r\n        previousBoard = getBoardCopy();\r\n\r\n        // set the new stone\r\n        board[move.getRow()][move.getCol()] = move.getColor();\r\n        // remove beaten stones (if any)\r\n        removeBeaten(move, true);\r\n      }\r\n    }\r\n\r\n    /** Remove all stones that were beaten by the move */\r\n\r\n    /*private*/ void removeBeaten(Move move) {\r\n      removeBeaten(move, false);\r\n    }\r\n\r\n    private void removeBeaten(Move move, boolean countBeaten) {\r\n      // find the fields near to the move field\r\n      List<FieldPosition> near = move.getPos().getFieldsNear(Player.BOARD_SIZE);\r\n      for (FieldPosition pos : near) {\r\n        // check whether the field has a stone of the different color on it\r\n        if (getStoneColor(pos) == PlayerColor.getOpposizeColor(move.getColor())) {\r\n          Group group = Group.findGroup(this, pos);\r\n          if (group.isBeaten(this)) {\r\n            removeStones(group.getStones(), countBeaten);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    /** Remove all stones in the collection from the field */\r\n\r\n    /*private*/ void removeStones(Collection<FieldPosition> stones) {\r\n      removeStones(stones, false);\r\n    }\r\n\r\n    private void removeStones(Collection<FieldPosition> stones, boolean countBeaten) {\r\n      int stonesBeaten = stones.size();\r\n      PlayerColor beatenStonesColor = null;\r\n      for (FieldPosition pos : stones) {\r\n        beatenStonesColor = board[pos.getRow()][pos.getCol()];\r\n        board[pos.getRow()][pos.getCol()] = null;\r\n      }\r\n\r\n      if (countBeaten) {\r\n        if (beatenStonesColor == PlayerColor.BLACK) {\r\n          game.setBlackStonesCaptured(game.getBlackStonesCaptured() + stonesBeaten);\r\n        } else if (beatenStonesColor == PlayerColor.WHITE) {\r\n          game.setWhiteStonesCaptured(game.getWhiteStonesCaptured() + stonesBeaten);\r\n        }\r\n      }\r\n    }\r\n\r\n    public boolean isFieldEmpty(FieldPosition pos) {\r\n      return board[pos.getRow()][pos.getCol()] == null;\r\n    }\r\n\r\n    public PlayerColor getStoneColor(FieldPosition pos) {\r\n      return board[pos.getRow()][pos.getCol()];\r\n    }\r\n\r\n    public Game getGame() {\r\n      return game;\r\n    }\r\n\r\n    public void setBoard(PlayerColor[][] board) {\r\n      this.board = board;\r\n    }\r\n\r\n    public void setPreviousBoard(PlayerColor[][] board) {\r\n      this.previousBoard = board;\r\n    }\r\n\r\n    public PlayerColor[][] getPreviousBoard() {\r\n      return previousBoard;\r\n    }\r\n\r\n    public void printBoards() {\r\n      DebugUtils.print(\"Board\");\r\n      DebugUtils.printBoard(board);\r\n      DebugUtils.print(\"Previous Board\");\r\n      DebugUtils.printBoard(previousBoard);\r\n    }\r\n  }\r\n\r\n  /** @author Tobias */\r\n  public static class Move {\r\n\r\n    private int row;\r\n    private int col;\r\n    private Type type;\r\n    private PlayerColor color;\r\n\r\n    public enum Type {\r\n      STONE,\r\n      PASS;\r\n    }\r\n\r\n    public Move(int row, int col, PlayerColor color) {\r\n      this.row = row;\r\n      this.col = col;\r\n      this.color = color;\r\n      this.type = Type.STONE;\r\n      if (row == -1 && col == -1) {\r\n        this.type = Type.PASS;\r\n      }\r\n    }\r\n\r\n    public static Move getPassMove(PlayerColor color) {\r\n      Move pass = new Move(-1, -1, color);\r\n      pass.setType(Type.PASS);\r\n      return pass;\r\n    }\r\n\r\n    public FieldPosition getPos() {\r\n      return new FieldPosition(row, col);\r\n    }\r\n\r\n    public int hashCode() {\r\n      final int prime = 31;\r\n      int result = 1;\r\n      result = prime * result + col;\r\n      result = prime * result + ((color == null) ? 0 : color.hashCode());\r\n      result = prime * result + row;\r\n      return result;\r\n    }\r\n\r\n    public boolean equals(Object obj) {\r\n      if (this == obj) return true;\r\n      if (obj == null) return false;\r\n      if (getClass() != obj.getClass()) return false;\r\n      Move other = (Move) obj;\r\n      if (col != other.col) return false;\r\n      if (color != other.color) return false;\r\n      if (row != other.row) return false;\r\n      return true;\r\n    }\r\n\r\n    public int getRow() {\r\n      return row;\r\n    }\r\n\r\n    public void setRow(int row) {\r\n      this.row = row;\r\n    }\r\n\r\n    public int getCol() {\r\n      return col;\r\n    }\r\n\r\n    public void setCol(int col) {\r\n      this.col = col;\r\n    }\r\n\r\n    public PlayerColor getColor() {\r\n      return color;\r\n    }\r\n\r\n    public void setColor(PlayerColor color) {\r\n      this.color = color;\r\n    }\r\n\r\n    public Type getType() {\r\n      return type;\r\n    }\r\n\r\n    public void setType(Type type) {\r\n      this.type = type;\r\n    }\r\n\r\n    public boolean isPass() {\r\n      return type == Type.PASS;\r\n    }\r\n  }\r\n}\r\n",
          "testCases": [],
          "maxPlayers": 2,
          "minPlayers": 2,
          "statements": {
            "1": "<div style=\"color:#cccccc;padding:20px;margin-right:15px;margin-left:15px;margin-bottom:10px;text-align:left\">This is a slight modification of the board game <a href=\"https://en.wikipedia.org/wiki/Go_(game)\">Go</a>\r\n<br>Click <a href=\"https://senseis.xmp.net/?BasicRulesOfGo\">here</a> for an introduction into the rules of Go.\r\n<br>Click <a href=\"https://github.com/tfassbender/codingame_atari_go\">here</a> for the Referee code<br>\r\n</div>\r\n<div class=\"statement-body\">\r\n<!-- GOAL --> \r\n    <div class=\"statement-section statement-goal\"> \r\n      <h2> \r\n        <span class=\"icon icon-goal\">&nbsp;</span> \r\n        <span>The Goal</span> \r\n      </h2> \r\n      <div class=\"statement-goal-content\"> \r\n        The game is now played on a 19x19 board and lasts 200 turns.\r\n      </div> \r\n    </div> \r\n    <!-- RULES -->\r\n    <div class=\"statement-section statement-rules\">\r\n        <h1>\r\n            <span class=\"icon icon-rules\">&nbsp;</span>\r\n            <span>Rules</span>\r\n        </h1>\r\n        <div class=\"statement-rules-content\">\r\n            Atari Go is a modification of the classical board game <a href=\"https://en.wikipedia.org/wiki/Go_(game)\">Go</a>, that is often used to teach new players the rules of Go.<br />\r\n            The rules are basically the same as the Go rules with some modifications to make the game a bit easier:\r\n            <ul>\r\n            \t<li>You don't gain points by occupying fields</li>\r\n            \t<li>The only way to gain points is to capture the stones of your opponent</li>\r\n            \t<li>The game does not end after both players have passed (the game ends after <const>200</const> turns)</li>\r\n            \t<li>All other rules stay the same as in the game of Go</li>\r\n            </ul>\r\n            \r\n            <h3>Go Rules</h3>\r\n            A game of Go is usually played on a board of 19x19 fields. In the first leagues a board of 9x9 or 13x13 fields is used, but in the later leagues a 19x19 board is used.\r\n            <br>\r\n            While playing, both players place one of their stones (per turn) on a free position on the field. The stones are not moved after they are placed. You can only add new stones.\r\n            <br>\r\n            The goal of the game is to capture the stones of your opponent. This can be done by surrounding the stones (or groups) of your opponent with your stones. If a stone or group has no free fields beneath it, it is captured and removed from the board (see example 2).\r\n            <br>\r\n            If a stone is surrounded by other stones of the same color this stone is not captured, but all stones that are directly touching each other form a group. This group shares it's free fields. So a group of stones is often stronger and more difficult to capture than a single stone (see example 1).\r\n            <br>\r\n            <br>\r\n            Beside these simple rules there are a view more rules, on where stones can be placed and where not.\r\n            <ul>\r\n            \t<li>You can only place a stone on a field where no stone is placed yet</li>\r\n            \t<li>You can not play a stone that would directly be removed (no suicidal moves). An exception to this rule is that the opponent stones are removed before this rule is applied. So if your stone seems to be directly surrounded by other stones, but it captures and removes at least one of the surrounding stones it can be played (see example 3)</li>\r\n            \t<li>You can not play a stone that would lead to the same board, like in the last turn when you played a stone. This is called the Ko-Rule (see example 4)</li>\r\n            </ul>\r\n        </div>\r\n    </div>\r\n\r\n    <!-- EXAMPLES -->\r\n    <div class=\"statement-section statement-examples\">\r\n        <h1>\r\n            <span class=\"icon icon-example\">&nbsp;</span>\r\n            <span>Examples</span>\r\n        </h1>\r\n\r\n        <div class=\"statement-examples-text\">\r\n            <div class=\"first-example\">\r\n            \t<h3>Example 1 - Groups</h3>\r\n            \tIn the image below the three white stones form a group. Therefore the two upper stones (that are completely surrounded) are not captured as long as one stone of the group is not completely captured.\r\n            \t<p><img src=\"https://senseis.xmp.net/diagrams/41/49d804c30e36bd3cf3666a6d76f39644.png\" style=\"height: 150px; width: auto;\"></img></p>\r\n            \t<br>\r\n            \t<br>\r\n            </div>\r\n            \r\n            <div class=\"second-example\">\r\n            \t<h3>Example 2 - Capturing stones</h3>\r\n            \tIn the image below the white stone is almost captured. The last free field it has is marked with a red square. The other fields (marked with red crosses) are not directly adjacent to the white stone and are therefore no free fields for the white stone.\r\n            \t<p><img src=\"https://senseis.xmp.net/diagrams/0/7cac8afadce46df1d520ee56b4eece8b.png\" style=\"height: 150px; width: auto;\"></img></p>\r\n            \tNow if the back stone is placed like in the image below...\r\n            \t<p><img src=\"https://senseis.xmp.net/diagrams/48/ceb2245b3fbf4c62872f4bdf2796ac95.png\" style=\"height: 150px; width: auto;\"></img></p>\r\n            \t...the white stone has no free fields around it and therefore it is captured. So it will be removed and after the turn of the black stone the field will look like in the image below.\r\n            \t<p><img src=\"https://senseis.xmp.net/diagrams/13/6e7dc384eb2e8b494e097f38d4259bcb.png\" style=\"height: 150px; width: auto;\"></img></p>\r\n            \t<br>\r\n            \t<br>\r\n            </div>\r\n            \r\n            <div class=\"third-example\">\r\n            \t<h3>Example 3 - Suicidal moves</h3>\r\n            \tIn the image below, a white stone that is placed in the middle of the four black stones would have no free fields beneath it and would be directly removed. Therefore a white stone can't be placed in the middle of the black stones in this case.\r\n            \t<p><img src=\"https://senseis.xmp.net/diagrams/13/6e7dc384eb2e8b494e097f38d4259bcb.png\" style=\"height: 150px; width: auto;\"></img></p>\r\n            \tAn exception to this rule is shown in the following image: In this image it seems to be the same case. A white stone that is placed in the middle of the black stones would have no free fields adjacent to it and would be removed. But in this case the white stone can be placed in the middle of the black stones as shown in the next image.\r\n            \t<p><img src=\"https://senseis.xmp.net/diagrams/37/0708d56ffed33ef1058f0185803a7f46.png\" style=\"height: 150px; width: auto;\"></img></p>\r\n            \tBefore the free fields of the white stone are counted, first the black stones are to be removed. This leads to the following field after the white stone is placed:\r\n            \t<p><img src=\"https://senseis.xmp.net/diagrams/47/00bb7694a7980ec3018ee6a2e721f212.png\" style=\"height: 150px; width: auto;\"></img></p>\r\n            \tSince the white stone now has a free field adjacent to it (where the black stone was removed) it can be played.\r\n            \t<br>\r\n            \t<br>\r\n            </div>\r\n            \r\n            <div class=\"fourth-example\">\r\n            \t<h3>Example 4 - Ko-Rule</h3>\r\n            \tIn the third example it was shown that in a field, like the one in the image below, a white stone can be placed in the middle of the four black stones...\r\n            \t<p><img src=\"https://senseis.xmp.net/diagrams/37/0708d56ffed33ef1058f0185803a7f46.png\" style=\"height: 150px; width: auto;\"></img></p>\r\n            \t... which would lead to a board that looks like this:\r\n            \t<p><img src=\"https://senseis.xmp.net/diagrams/47/00bb7694a7980ec3018ee6a2e721f212.png\" style=\"height: 150px; width: auto;\"></img></p>\r\n            \tNow it seems that a black stone could do a similar move by placing it in the middle of the four white stones like this:\r\n            \t<p><img src=\"https://senseis.xmp.net/diagrams/28/8da1b11165650ffa0964df5ff2debbe1.png\" style=\"height: 150px; width: auto;\"></img></p>\r\n            \tThis would normally be a valid move (just like in the third example), but to prevent the game to get stuck on this (both players just capturing the same stones again and again), the above move is not possible for the black stone, because it would lead to the same board like one turn before (the first image of this example).<br>\r\n            \tBut it would be possible to place a black stone on any other field, let white place a stone too, and then come back to this formation of stones and place the black stone in between the white stones (like in the image above) because now it would no longer lead to the same board like in the first image of this example (there are now two more stones placed somewhere on the board).\r\n            \t<br>\r\n            \t<br>\r\n            </div>\r\n        </div>\r\n    </div><br>\r\n\r\n    <!-- Victory conditions -->\r\n    <div class=\"statement-victory-conditions\">\r\n        <div class=\"icon victory\"></div>\r\n        <div class=\"blk\">\r\n            <div class=\"title\">Victory Conditions</div>\r\n            <div class=\"text\">\r\n                <ul style=\"padding-bottom: 0;\">\r\n                    <li>Capture more stones than your opponent</li>\r\n                    <li>If no player has captured any stones after the maximum number of turns is reached, the player that has played more stones wins (to prevent a draw if a player passes in every move)</li>\r\n                </ul>\r\n            </div>\r\n        </div>\r\n    </div>\r\n\r\n    <!-- Lose conditions -->\r\n    <div class=\"statement-lose-conditions\">\r\n        <div class=\"icon lose\"></div>\r\n        <div class=\"blk\">\r\n            <div class=\"title\">Loss Conditions</div>\r\n            <div class=\"text\">\r\n                <ul style=\"padding-bottom: 0;\">\r\n                    <li>You send an illegal move</li>\r\n                    <li>You don't respond in time or output an unrecognized command</li>\r\n                </ul>\r\n            </div>\r\n        </div>\r\n    </div>\r\n\r\n    <!-- PROTOCOL -->\r\n    <div class=\"statement-section statement-protocol\">\r\n        <h1>\r\n        <span class=\"icon icon-protocol\">&nbsp;</span>\r\n        <span>Game Input</span>\r\n    </h1>\r\n\r\n    <!-- Protocol block -->\r\n    <div class=\"blk\">\r\n        <div class=\"title\">Initial input</div>\r\n        <div class=\"text\">\r\n            <span class=\"statement-lineno\">First line</span>: <var>myColor</var>: <action>B</action> if you are playing the black stones or <action>W</action> if you're playing the white stones.\r\n            <br>\r\n            <span class=\"statement-lineno\">Next line</span>: <var>boardSize</var>: an integer representing the size of the board\r\n            <br>\r\n            <br>\r\n        </div>\r\n        <div class=\"title\">Input for one game turn</div>\r\n        <div class=\"text\">\r\n            <span class=\"statement-lineno\">First line</span>: <var>x</var> <var>y</var>: two integers representing the position of the last stone, that your opponent played (\"-1 -1\" in the first turn)\r\n            <br>\r\n            <span class=\"statement-lineno\">Next line</span>: <var>myScore</var> <var>opponentScore</var>: two integers representing your current score and your opponent's current score (the number of captured stones)\r\n            <br>\r\n            <span class=\"statement-lineno\">Next <var>boardSize</var> lines</span>: <var>line</var>: one line of the current board, where <action>B</action> marks a black stone, <action>W</action> marks a white stone and <action>.</action> marks an empty field\r\n            <br>\r\n        </div>\r\n    </div>\r\n\r\n    <!-- Protocol block -->\r\n    <div class=\"blk\">\r\n        <div class=\"title\">Output</div>\r\n        <div class=\"text\">\r\n            <span class=\"statement-lineno\">A single line containing</span>: either the <var>x</var> and <var>y</var> coordinates of the next stone you want to play or <var>PASS</var> if you don't want to play a stone (<var>PASS</var> is always a valid move)<br>\r\n        <br>\r\n        </div>\r\n    </div>\r\n\r\n    <!-- Protocol block -->\r\n    <div class=\"blk\">\r\n        <div class=\"title\">Constraints</div>\r\n        Response time first turn is \r\n        <const>1000</const> ms.\r\n        <br>Response time per turn is \r\n        <const>100</const> ms.\r\n        <br><br>The game ends after <const>200</const> turns (200 stones for each player)\r\n        </div>\r\n    </div>\r\n</div>",
            "2": "<div style=\"color:#cccccc;padding:20px;margin-right:15px;margin-left:15px;margin-bottom:10px;text-align:left\">This is a slight modification of the board game <a href=\"https://en.wikipedia.org/wiki/Go_(game)\">Go</a>\r\n<br>Click <a href=\"https://senseis.xmp.net/?BasicRulesOfGo\">here</a> for an introduction into the rules of Go.\r\n<br>Click <a href=\"https://github.com/tfassbender/codingame_atari_go\">here</a> for the Referee code<br>\r\n</div>\r\n<div class=\"statement-body\">\r\n<!-- GOAL --> \r\n    <div class=\"statement-section statement-goal\"> \r\n      <h2> \r\n        <span class=\"icon icon-goal\">&nbsp;</span> \r\n        <span>The Goal</span> \r\n      </h2> \r\n      <div class=\"statement-goal-content\"> \r\n        The game is now played on a 19x19 board and lasts 200 turns.\r\n      </div> \r\n    </div> \r\n    <!-- RULES -->\r\n    <div class=\"statement-section statement-rules\">\r\n        <h1>\r\n            <span class=\"icon icon-rules\">&nbsp;</span>\r\n            <span>Rules</span>\r\n        </h1>\r\n        <div class=\"statement-rules-content\">\r\n            Atari Go is a modification of the classical board game <a href=\"https://en.wikipedia.org/wiki/Go_(game)\">Go</a>, that is often used to teach new players the rules of Go.<br />\r\n            The rules are basically the same as the Go rules with some modifications to make the game a bit easier:\r\n            <ul>\r\n            \t<li>You don't gain points by occupying fields</li>\r\n            \t<li>The only way to gain points is to capture the stones of your opponent</li>\r\n            \t<li>The game does not end after both players have passed (the game ends after <const>200</const> turns)</li>\r\n            \t<li>All other rules stay the same as in the game of Go</li>\r\n            </ul>\r\n            \r\n            <h3>Go Rules</h3>\r\n            A game of Go is usually played on a board of 19x19 fields. In the first leagues a board of 9x9 or 13x13 fields is used, but in the later leagues a 19x19 board is used.\r\n            <br>\r\n            While playing, both players place one of their stones (per turn) on a free position on the field. The stones are not moved after they are placed. You can only add new stones.\r\n            <br>\r\n            The goal of the game is to capture the stones of your opponent. This can be done by surrounding the stones (or groups) of your opponent with your stones. If a stone or group has no free fields beneath it, it is captured and removed from the board (see example 2).\r\n            <br>\r\n            If a stone is surrounded by other stones of the same color this stone is not captured, but all stones that are directly touching each other form a group. This group shares it's free fields. So a group of stones is often stronger and more difficult to capture than a single stone (see example 1).\r\n            <br>\r\n            <br>\r\n            Beside these simple rules there are a view more rules, on where stones can be placed and where not.\r\n            <ul>\r\n            \t<li>You can only place a stone on a field where no stone is placed yet</li>\r\n            \t<li>You can not play a stone that would directly be removed (no suicidal moves). An exception to this rule is that the opponent stones are removed before this rule is applied. So if your stone seems to be directly surrounded by other stones, but it captures and removes at least one of the surrounding stones it can be played (see example 3)</li>\r\n            \t<li>You can not play a stone that would lead to the same board, like in the last turn when you played a stone. This is called the Ko-Rule (see example 4)</li>\r\n            </ul>\r\n        </div>\r\n    </div>\r\n\r\n    <!-- EXAMPLES -->\r\n    <div class=\"statement-section statement-examples\">\r\n        <h1>\r\n            <span class=\"icon icon-example\">&nbsp;</span>\r\n            <span>Examples</span>\r\n        </h1>\r\n\r\n        <div class=\"statement-examples-text\">\r\n            <div class=\"first-example\">\r\n            \t<h3>Example 1 - Groups</h3>\r\n            \tIn the image below the three white stones form a group. Therefore the two upper stones (that are completely surrounded) are not captured as long as one stone of the group is not completely captured.\r\n            \t<p><img src=\"https://senseis.xmp.net/diagrams/41/49d804c30e36bd3cf3666a6d76f39644.png\" style=\"height: 150px; width: auto;\"></img></p>\r\n            \t<br>\r\n            \t<br>\r\n            </div>\r\n            \r\n            <div class=\"second-example\">\r\n            \t<h3>Example 2 - Capturing stones</h3>\r\n            \tIn the image below the white stone is almost captured. The last free field it has is marked with a red square. The other fields (marked with red crosses) are not directly adjacent to the white stone and are therefore no free fields for the white stone.\r\n            \t<p><img src=\"https://senseis.xmp.net/diagrams/0/7cac8afadce46df1d520ee56b4eece8b.png\" style=\"height: 150px; width: auto;\"></img></p>\r\n            \tNow if the back stone is placed like in the image below...\r\n            \t<p><img src=\"https://senseis.xmp.net/diagrams/48/ceb2245b3fbf4c62872f4bdf2796ac95.png\" style=\"height: 150px; width: auto;\"></img></p>\r\n            \t...the white stone has no free fields around it and therefore it is captured. So it will be removed and after the turn of the black stone the field will look like in the image below.\r\n            \t<p><img src=\"https://senseis.xmp.net/diagrams/13/6e7dc384eb2e8b494e097f38d4259bcb.png\" style=\"height: 150px; width: auto;\"></img></p>\r\n            \t<br>\r\n            \t<br>\r\n            </div>\r\n            \r\n            <div class=\"third-example\">\r\n            \t<h3>Example 3 - Suicidal moves</h3>\r\n            \tIn the image below, a white stone that is placed in the middle of the four black stones would have no free fields beneath it and would be directly removed. Therefore a white stone can't be placed in the middle of the black stones in this case.\r\n            \t<p><img src=\"https://senseis.xmp.net/diagrams/13/6e7dc384eb2e8b494e097f38d4259bcb.png\" style=\"height: 150px; width: auto;\"></img></p>\r\n            \tAn exception to this rule is shown in the following image: In this image it seems to be the same case. A white stone that is placed in the middle of the black stones would have no free fields adjacent to it and would be removed. But in this case the white stone can be placed in the middle of the black stones as shown in the next image.\r\n            \t<p><img src=\"https://senseis.xmp.net/diagrams/37/0708d56ffed33ef1058f0185803a7f46.png\" style=\"height: 150px; width: auto;\"></img></p>\r\n            \tBefore the free fields of the white stone are counted, first the black stones are to be removed. This leads to the following field after the white stone is placed:\r\n            \t<p><img src=\"https://senseis.xmp.net/diagrams/47/00bb7694a7980ec3018ee6a2e721f212.png\" style=\"height: 150px; width: auto;\"></img></p>\r\n            \tSince the white stone now has a free field adjacent to it (where the black stone was removed) it can be played.\r\n            \t<br>\r\n            \t<br>\r\n            </div>\r\n            \r\n            <div class=\"fourth-example\">\r\n            \t<h3>Example 4 - Ko-Rule</h3>\r\n            \tIn the third example it was shown that in a field, like the one in the image below, a white stone can be placed in the middle of the four black stones...\r\n            \t<p><img src=\"https://senseis.xmp.net/diagrams/37/0708d56ffed33ef1058f0185803a7f46.png\" style=\"height: 150px; width: auto;\"></img></p>\r\n            \t... which would lead to a board that looks like this:\r\n            \t<p><img src=\"https://senseis.xmp.net/diagrams/47/00bb7694a7980ec3018ee6a2e721f212.png\" style=\"height: 150px; width: auto;\"></img></p>\r\n            \tNow it seems that a black stone could do a similar move by placing it in the middle of the four white stones like this:\r\n            \t<p><img src=\"https://senseis.xmp.net/diagrams/28/8da1b11165650ffa0964df5ff2debbe1.png\" style=\"height: 150px; width: auto;\"></img></p>\r\n            \tThis would normally be a valid move (just like in the third example), but to prevent the game to get stuck on this (both players just capturing the same stones again and again), the above move is not possible for the black stone, because it would lead to the same board like one turn before (the first image of this example).<br>\r\n            \tBut it would be possible to place a black stone on any other field, let white place a stone too, and then come back to this formation of stones and place the black stone in between the white stones (like in the image above) because now it would no longer lead to the same board like in the first image of this example (there are now two more stones placed somewhere on the board).\r\n            \t<br>\r\n            \t<br>\r\n            </div>\r\n        </div>\r\n    </div><br>\r\n\r\n    <!-- Victory conditions -->\r\n    <div class=\"statement-victory-conditions\">\r\n        <div class=\"icon victory\"></div>\r\n        <div class=\"blk\">\r\n            <div class=\"title\">Victory Conditions</div>\r\n            <div class=\"text\">\r\n                <ul style=\"padding-bottom: 0;\">\r\n                    <li>Capture more stones than your opponent</li>\r\n                    <li>If no player has captured any stones after the maximum number of turns is reached, the player that has played more stones wins (to prevent a draw if a player passes in every move)</li>\r\n                </ul>\r\n            </div>\r\n        </div>\r\n    </div>\r\n\r\n    <!-- Lose conditions -->\r\n    <div class=\"statement-lose-conditions\">\r\n        <div class=\"icon lose\"></div>\r\n        <div class=\"blk\">\r\n            <div class=\"title\">Loss Conditions</div>\r\n            <div class=\"text\">\r\n                <ul style=\"padding-bottom: 0;\">\r\n                    <li>You send an illegal move</li>\r\n                    <li>You don't respond in time or output an unrecognized command</li>\r\n                </ul>\r\n            </div>\r\n        </div>\r\n    </div>\r\n\r\n    <!-- PROTOCOL -->\r\n    <div class=\"statement-section statement-protocol\">\r\n        <h1>\r\n        <span class=\"icon icon-protocol\">&nbsp;</span>\r\n        <span>Game Input</span>\r\n    </h1>\r\n\r\n    <!-- Protocol block -->\r\n    <div class=\"blk\">\r\n        <div class=\"title\">Initial input</div>\r\n        <div class=\"text\">\r\n            <span class=\"statement-lineno\">First line</span>: <var>myColor</var>: <action>B</action> if you are playing the black stones or <action>W</action> if you're playing the white stones.\r\n            <br>\r\n            <span class=\"statement-lineno\">Next line</span>: <var>boardSize</var>: an integer representing the size of the board\r\n            <br>\r\n            <br>\r\n        </div>\r\n        <div class=\"title\">Input for one game turn</div>\r\n        <div class=\"text\">\r\n            <span class=\"statement-lineno\">First line</span>: <var>x</var> <var>y</var>: two integers representing the position of the last stone, that your opponent played (\"-1 -1\" in the first turn)\r\n            <br>\r\n            <span class=\"statement-lineno\">Next line</span>: <var>myScore</var> <var>opponentScore</var>: two integers representing your current score and your opponent's current score (the number of captured stones)\r\n            <br>\r\n            <span class=\"statement-lineno\">Next <var>boardSize</var> lines</span>: <var>line</var>: one line of the current board, where <action>B</action> marks a black stone, <action>W</action> marks a white stone and <action>.</action> marks an empty field\r\n            <br>\r\n        </div>\r\n    </div>\r\n\r\n    <!-- Protocol block -->\r\n    <div class=\"blk\">\r\n        <div class=\"title\">Output</div>\r\n        <div class=\"text\">\r\n            <span class=\"statement-lineno\">A single line containing</span>: either the <var>x</var> and <var>y</var> coordinates of the next stone you want to play or <var>PASS</var> if you don't want to play a stone (<var>PASS</var> is always a valid move)<br>\r\n        <br>\r\n        </div>\r\n    </div>\r\n\r\n    <!-- Protocol block -->\r\n    <div class=\"blk\">\r\n        <div class=\"title\">Constraints</div>\r\n        Response time first turn is \r\n        <const>1000</const> ms.\r\n        <br>Response time per turn is \r\n        <const>100</const> ms.\r\n        <br><br>The game ends after <const>200</const> turns (200 stones for each player)\r\n        </div>\r\n    </div>\r\n</div>"
          },
          "questionType": "multi",
          "stubGenerator": "read myColor:string(1)\r\nread boardSize:int\r\ngameloop\r\nread opponentX:int opponentY:int\r\nread myScore:int opponentScore:int\r\nloop boardSize read line:string(boardSize)\r\nwrite PASS\r\n\r\nSTATEMENT\r\nCapture more stones than your opponent.\r\n\r\nINPUT\r\nopponentX: The x coordinate of your opponent's last move (or -1 if the opponent passed)\r\nopponentY: The y coordinate of your opponent's last move (or -1 if the opponent passed)\r\nmyScore: Your current score (the number of captured stones)\r\nopponentScore: the opponents current score (the number of captured stones)\r\nboardSize: the size of the board (width and height)\r\nline: A row of the current board where 'B' marks a black stone, 'W' marks a white stone and '.' marks an empty field\r\n\r\nOUTPUT\r\nx and y coordinates of the stone you want to place or PASS if you don't want to place a stone",
          "welcomePopups": {
            "1": "<div style=\"text-align:center\">\r\n        <h2>You&#39;ve made it to the next league.</h2>\r\n        The game is now played on a 19x19 board.\r\n        <div class=\"small\"><img src=\"https://cdn-games.codingame.com/community/1443538-1590321517105/67db39d8eea83cf1ae98792b8fd1e377cf3d2cdcd6d173e33bbaf1b890c08502.png\" style=\"width:500px;max-width:100%\" /></div>\r\n        <div class=\"small\">See the updated statement for details.</div>\r\n</div>",
            "2": "<div style=\"text-align:center\">\r\n        <h2>You&#39;ve made it to the next league.</h2>\r\n        The game is now played on a 19x19 board.\r\n        <div class=\"small\"><img src=\"https://cdn-games.codingame.com/community/1443538-1590321517105/67db39d8eea83cf1ae98792b8fd1e377cf3d2cdcd6d173e33bbaf1b890c08502.png\" style=\"width:500px;max-width:100%\" /></div>\r\n        <div class=\"small\">See the updated statement for details.</div>\r\n</div>"
          },
          "aiCodeExtension": "java",
          "criteriaLanguageMap": {}
        }
      },
      "coverBinaryId": 45239409531087,
      "directoryPrefix": "community/1443538-1590321517105",
      "allowSourceDownload": true,
      "originalArchiveBinaryId": 47507383989316
    },
    "draft": false,
    "readyForModeration": true
  },
  "validatedFor": 174690498054,
  "avatar": 82852165040194,
  "commentCount": 50,
  "upVotes": 46,
  "downVotes": 1,
  "validateAction": {
    "actionId": 480232,
    "progress": 1,
    "alreadyDone": false
  },
  "statusHistory": [
    {
      "status": "REFUSED",
      "date": 1592917536999,
      "data": {
        "author": "SYSTEM",
        "reason": "INACTIVITY"
      }
    },
    {
      "status": "PENDING",
      "date": 1593344466893,
      "data": {
        "author": "ACTION",
        "reason": "EDIT"
      }
    },
    {
      "status": "REFUSED",
      "date": 1595937936999,
      "data": {
        "author": "SYSTEM",
        "reason": "INACTIVITY"
      }
    },
    {
      "status": "PENDING",
      "date": 1596004643528,
      "data": {
        "author": "ACTION",
        "reason": "EDIT"
      }
    },
    {
      "status": "ACCEPTED",
      "date": 1596040525770,
      "data": {
        "author": "ACTION"
      }
    }
  ],
  "editable": true,
  "draft": false,
  "readyForModeration": true
}