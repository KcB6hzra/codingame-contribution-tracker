{
  "id": 7213,
  "activeVersion": 14,
  "score": 8,
  "votableId": 19570838,
  "codingamerId": 4124486,
  "views": 217,
  "commentableId": 19469820,
  "title": "Open reading frame (ORF) Finder",
  "status": "ACCEPTED",
  "type": "CLASHOFCODE",
  "nickname": "JoTue",
  "publicHandle": "7213f36a637b9cd218133737ae0f6fe407dd",
  "codingamerHandle": "a1458d912888a882e1aa8cc2feea92786844214",
  "lastVersion": {
    "version": 14,
    "autocloseTime": 1631063262708,
    "data": {
      "title": "Open reading frame (ORF) Finder",
      "topics": [],
      "fastest": true,
      "reverse": false,
      "shortest": false,
      "solution": "s = input()\n\n# strategy: search the sequence for the pattern \"ATG\", \n# then search the subsequent sequence (in windows of three bases) for a stop codon\nstart_codon = \"ATG\"\nstop_codons = [\"TTA\", \"TAG\", \"TGG\"]\nlen_s = len(s)\norfs = []\n\nfor i in range(len_s-5):\n    if s[i:i+3] == start_codon:\n        for j in range(i+3, len_s-2, 3):\n            if s[j:j+3] in stop_codons:\n                orfs.append((i, s[i:j+3]))\n                break\norfs.sort(key=lambda x: len(x[1]), reverse=True)  # sort by length, as the sort is stable no sorting by index is necessary\nprint(len(orfs))\nfor orf in orfs:\n    print(*orf)\n",
      "statement": "Given a DNA sequence [[s]] (consisting of bases A, C, G, and T), find all the open reading frames (ORFs) in that sequence. An ORF begins at the base triplet {{ATG}} (=start codon), and ends at the first occuring stop codon: {{TTA}}, {{TAG}} or {{TGG}}. Note, that start codon and stop codon need to be in the same reading frame, which means that they have to be separated by 0, 3, 6,... bases. Also note, that ORFs can overlap.\nReport the number of found ORFs. For each ORF, report its index (0-based indexing) and the sequence (including start and stop codon) - sort them in descending order of their length and sort ORFs with equal lengths by their ascending index.",
      "testCases": [
        {
          "title": "One ORF",
          "isTest": true,
          "testIn": "CATGTAATGG",
          "testOut": "1\n1 ATGTAATGG",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Validator - One ORF",
          "isTest": false,
          "testIn": "ATGTGG",
          "testOut": "1\n0 ATGTGG",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "Two ORFs",
          "isTest": true,
          "testIn": "ATGATACGGTTAGATGTGG",
          "testOut": "2\n0 ATGATACGGTTA\n13 ATGTGG",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Validator - Two ORFs",
          "isTest": false,
          "testIn": "GGCATGCACTAGATGTTA",
          "testOut": "2\n3 ATGCACTAG\n12 ATGTTA",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "Multiple ORFs (overlapping)",
          "isTest": true,
          "testIn": "GATGCATGGATAGGTGG",
          "testOut": "2\n1 ATGCATGGATAG\n5 ATGGATAGGTGG",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Validator - Multiple ORFs (overlapping)",
          "isTest": false,
          "testIn": "TGAGGATGCAGATCGATGATGCCTAGATGGG",
          "testOut": "3\n5 ATGCAGATCGATGATGCCTAG\n15 ATGATGCCTAGATGG\n18 ATGCCTAGATGG",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "No stop codon",
          "isTest": true,
          "testIn": "GATGGATCCGCAA",
          "testOut": "0",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Validator - No stop codon",
          "isTest": false,
          "testIn": "TGATATGCTGCCATG",
          "testOut": "0",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "No ORF",
          "isTest": true,
          "testIn": "GTGGCATATGCGTAGCC",
          "testOut": "0",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Validator - No ORF",
          "isTest": false,
          "testIn": "AGCGAGCCATAT",
          "testOut": "0",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "Long sequence",
          "isTest": true,
          "testIn": "GAGCGTATGTGGATGGATGTCACCTCTATCCACAGCAAGACGTTAGTCATGCTGGACTTA",
          "testOut": "4\n12 ATGGATGTCACCTCTATCCACAGCAAGACGTTA\n16 ATGTCACCTCTATCCACAGCAAGACGTTAG\n48 ATGCTGGACTTA\n6 ATGTGG",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Validator - Long sequence",
          "isTest": false,
          "testIn": "CCATGAGCTTATATATGGTTGCCTGCCGGGGAGCTGTGATTTCGCCGGACATCTAGCGCA",
          "testOut": "2\n14 ATGGTTGCCTGCCGGGGAGCTGTGATTTCGCCGGACATCTAG\n2 ATGAGCTTA",
          "isValidator": true,
          "needValidation": true
        }
      ],
      "constraints": "6 <= length of [[s]] <= 60",
      "stubGenerator": "read s:word(60)\nwrite answer",
      "inputDescription": "<<Line 1:>> A word [[s]], which represents the DNA sequence.",
      "solutionLanguage": "Python3",
      "outputDescription": "The number of found ORFs [[n]], followed by [[n]] lines reporting the index and sequence of all ORFs. The ORFs need to be sorted by length (descending) and in case of ties by index (ascending)."
    },
    "draft": false,
    "readyForModeration": true
  },
  "validatedFor": 140894912173,
  "avatar": 56806207712751,
  "commentCount": 13,
  "upVotes": 8,
  "downVotes": 0,
  "validateAction": {
    "actionId": 585657,
    "progress": 1,
    "alreadyDone": false
  },
  "denyAction": {
    "actionId": 585711,
    "progress": 0.6666666666666666,
    "alreadyDone": false
  },
  "statusHistory": [
    {
      "status": "ACCEPTED",
      "date": 1629835427138,
      "data": {
        "author": "ACTION"
      }
    }
  ],
  "editable": true,
  "draft": false,
  "readyForModeration": true
}