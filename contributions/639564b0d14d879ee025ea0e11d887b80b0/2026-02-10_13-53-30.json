{
  "id": 639,
  "activeVersion": 19,
  "score": 4,
  "votableId": 4483987,
  "codingamerId": 1528929,
  "views": 255,
  "commentableId": 4427445,
  "title": "Xorandor",
  "status": "ACCEPTED",
  "type": "PUZZLE_INOUT",
  "nickname": "Blackfich",
  "publicHandle": "639564b0d14d879ee025ea0e11d887b80b0",
  "codingamerHandle": "5e8ab57ca4a5a21586b680a4603d41929298251",
  "lastVersion": {
    "version": 19,
    "data": {
      "title": "Xorandor",
      "topics": [
        {
          "id": 117,
          "handle": "logic",
          "category": "FUNDAMENTALS",
          "labelMap": {
            "1": "Logic",
            "2": "Logic"
          },
          "puzzleCount": 34,
          "parentTopicId": 93
        }
      ],
      "solution": "import java.io.*;\nimport java.util.*;\n\nclass Solution {\n\n\tstatic enum ComponentSymbol {\n\t\tUNKNOWN((char) 0), //\n\t\tNOT('~'), //\n\t\tAND('&'), OR('|'), XOR('+'), //\n\t\tNAND('^'), NOR('-'), XNOR('='), //\n\t\tSWITCH_LEFT('<'), SWITCH_RIGHT('>'), //\n\t\tINPUT_HI('1'), INPUT_LO('0'), //\n\t\tOUTPUT('@');\n\n\t\tfinal char value;\n\n\t\tprivate ComponentSymbol(char value) {\n\t\t\tthis.value = value;\n\t\t}\n\n\t\tstatic ComponentSymbol fromChar(char c) {\n\t\t\tfor (ComponentSymbol symbol : values()) {\n\t\t\t\tif (symbol.value == c) {\n\t\t\t\t\treturn symbol;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ComponentSymbol.UNKNOWN;\n\t\t}\n\t}\n\n\tstatic enum Direction {\n\t\tUP(0, -1), LEFT(-1, 0), RIGHT(1, 0), DOWN(0, 1);\n\n\t\tfinal int dx, dy;\n\n\t\tprivate Direction(int dx, int dy) {\n\t\t\tthis.dx = dx;\n\t\t\tthis.dy = dy;\n\t\t}\n\t}\n\n\tstatic class Pin {\n\t\tstatic class InputPin extends Pin {\n\t\t\tInputPin(Component component, int no, int x, int y) {\n\t\t\t\tsuper(component, no, x, y);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic String toString() {\n\t\t\t\tStringBuilder builder = new StringBuilder();\n\t\t\t\tbuilder.append(\"InputPin @ (\");\n\t\t\t\tbuilder.append(x);\n\t\t\t\tbuilder.append(\",\");\n\t\t\t\tbuilder.append(y);\n\t\t\t\tbuilder.append(\")\");\n\t\t\t\treturn builder.toString();\n\t\t\t}\n\t\t}\n\n\t\tstatic class OutputPin extends Pin {\n\t\t\tSet<Pin.InputPin> links = new HashSet<>();\n\n\t\t\tpublic OutputPin(Component component, int no, int x, int y) {\n\t\t\t\tsuper(component, no, x, y);\n\t\t\t}\n\n\t\t\tpublic void linkTo(Pin.InputPin pin) {\n\t\t\t\tlinks.add(pin);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void setStatus(boolean status) {\n\t\t\t\tthis.status = status;\n\t\t\t\tfor (Pin pin : links) {\n\t\t\t\t\tpin.setStatus(status);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic String toString() {\n\t\t\t\tStringBuilder builder = new StringBuilder();\n\t\t\t\tbuilder.append(\"OutputPin @ (\");\n\t\t\t\tbuilder.append(x);\n\t\t\t\tbuilder.append(\",\");\n\t\t\t\tbuilder.append(y);\n\t\t\t\tbuilder.append(\")\");\n\t\t\t\treturn builder.toString();\n\t\t\t}\n\n\t\t}\n\n\t\tfinal Component component;\n\t\tfinal int x, y;\n\t\tfinal int no;\n\t\tboolean status;\n\n\t\tPin(Component component, int no, int x, int y) {\n\t\t\tthis.component = component;\n\t\t\tthis.no = no;\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\tvoid setStatus(boolean status) {\n\t\t\tthis.status = status;\n\t\t\tcomponent.update();\n\t\t}\n\t}\n\n\tstatic abstract class Component {\n\t\tstatic abstract class Gate extends Component {\n\t\t\tPin.OutputPin output;\n\n\t\t\tGate(String name, int x1, int x2, int y) {\n\t\t\t\tsuper(name, x1, x2, y);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tvoid createPins(char[][] layout) {\n\t\t\t\tint no = 0;\n\t\t\t\tfor (int x = x1; x <= x2; x++) {\n\t\t\t\t\tif (layout[y + 1][x] == '|') {\n\t\t\t\t\t\tinputs.add(new Pin.InputPin(this, no++, x, y + 1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tno = 0;\n\t\t\t\tfor (int x = x1; x <= x2; x++) {\n\t\t\t\t\tif (layout[y - 1][x] == '|') {\n\t\t\t\t\t\toutput = new Pin.OutputPin(this, no++, x, y - 1);\n\t\t\t\t\t\toutputs.add(output);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tvoid update() {\n\t\t\t\tboolean newStatus = op(inputs);\n\t\t\t\toutput.setStatus(newStatus);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic String toString() {\n\t\t\t\tStringBuilder builder = new StringBuilder();\n\t\t\t\tbuilder.append(name);\n\t\t\t\tbuilder.append(\" Gate at (\");\n\t\t\t\tbuilder.append((x1 + x2) / 2);\n\t\t\t\tbuilder.append(\",\");\n\t\t\t\tbuilder.append(y);\n\t\t\t\tbuilder.append(\")\");\n\t\t\t\treturn builder.toString();\n\t\t\t}\n\n\t\t\tabstract boolean op(List<Pin.InputPin> inputs);\n\n\t\t\tstatic class NotGate extends Gate {\n\t\t\t\tfinal Pin.InputPin input;\n\n\t\t\t\tpublic NotGate(int x1, int x2, int y) {\n\t\t\t\t\tsuper(\"NOT\", x1, x2, y);\n\t\t\t\t\tinput = new Pin.InputPin(this, 0, (x1 + x2) / 2, y + 1);\n\t\t\t\t\toutput = new Pin.OutputPin(this, 0, (x1 + x2) / 2, y - 1);\n\t\t\t\t\tinputs.add(input);\n\t\t\t\t\toutputs.add(output);\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tvoid createPins(char[][] layout) {\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tboolean op(List<Pin.InputPin> inputs) {\n\t\t\t\t\treturn !input.status;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstatic class AndGate extends Gate {\n\n\t\t\t\tpublic AndGate(int x1, int x2, int y) {\n\t\t\t\t\tsuper(\"AND\", x1, x2, y);\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tboolean op(List<Pin.InputPin> inputs) {\n\t\t\t\t\tboolean result = true;\n\t\t\t\t\tfor (Pin.InputPin input : inputs) {\n\t\t\t\t\t\tresult &= input.status;\n\t\t\t\t\t}\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstatic class OrGate extends Gate {\n\n\t\t\t\tpublic OrGate(int x1, int x2, int y) {\n\t\t\t\t\tsuper(\"OR\", x1, x2, y);\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tboolean op(List<Pin.InputPin> inputs) {\n\t\t\t\t\tboolean result = false;\n\t\t\t\t\tfor (Pin.InputPin input : inputs) {\n\t\t\t\t\t\tresult |= input.status;\n\t\t\t\t\t}\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstatic class NandGate extends Gate {\n\n\t\t\t\tpublic NandGate(int x1, int x2, int y) {\n\t\t\t\t\tsuper(\"NAND\", x1, x2, y);\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tboolean op(List<Pin.InputPin> inputs) {\n\t\t\t\t\tboolean result = true;\n\t\t\t\t\tfor (Pin.InputPin input : inputs) {\n\t\t\t\t\t\tresult &= input.status;\n\t\t\t\t\t}\n\t\t\t\t\treturn !result;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstatic class NorGate extends Gate {\n\n\t\t\t\tpublic NorGate(int x1, int x2, int y) {\n\t\t\t\t\tsuper(\"NOR\", x1, x2, y);\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tboolean op(List<Pin.InputPin> inputs) {\n\t\t\t\t\tboolean result = false;\n\t\t\t\t\tfor (Pin.InputPin input : inputs) {\n\t\t\t\t\t\tresult |= input.status;\n\t\t\t\t\t}\n\t\t\t\t\treturn !result;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstatic class XNorGate extends Gate {\n\n\t\t\t\tpublic XNorGate(int x1, int x2, int y) {\n\t\t\t\t\tsuper(\"XNOR\", x1, x2, y);\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tboolean op(List<Pin.InputPin> inputs) {\n\t\t\t\t\tint nbOn = 0;\n\t\t\t\t\tfor (Pin.InputPin input : inputs) {\n\t\t\t\t\t\tnbOn += input.status ? 1 : 0;\n\t\t\t\t\t}\n\t\t\t\t\treturn (nbOn % 2) == 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstatic class XorGate extends Gate {\n\n\t\t\t\tpublic XorGate(int x1, int x2, int y) {\n\t\t\t\t\tsuper(\"XOR\", x1, x2, y);\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tboolean op(List<Pin.InputPin> inputs) {\n\t\t\t\t\tint nbOn = 0;\n\t\t\t\t\tfor (Pin.InputPin input : inputs) {\n\t\t\t\t\t\tnbOn += input.status ? 1 : 0;\n\t\t\t\t\t}\n\t\t\t\t\treturn (nbOn % 2) == 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tstatic class Input extends Component implements Toggleable {\n\t\t\tfinal Pin.OutputPin output;\n\n\t\t\tpublic Input(int id, int x, int y, boolean status) {\n\t\t\t\tsuper(\"I\" + id, x, x, y);\n\t\t\t\tthis.output = new Pin.OutputPin(this, 0, x, y - 1);\n\t\t\t\toutputs.add(output);\n\t\t\t\tthis.output.status = status;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic String getName() {\n\t\t\t\treturn name;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tvoid createPins(char[][] layout) {\n\t\t\t\t;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void toggle() {\n\t\t\t\toutput.setStatus(!output.status);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean getStatus() {\n\t\t\t\treturn output.status;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tvoid update() {\n\t\t\t\toutput.setStatus(output.status);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void setStatus(boolean status) {\n\t\t\t\toutput.setStatus(status);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic int hashCode() {\n\t\t\t\treturn name.hashCode();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean equals(Object obj) {\n\t\t\t\treturn this == obj || obj instanceof Input && ((Input) obj).name.equals(name);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic int compareTo(Toggleable other) {\n\t\t\t\treturn name.compareTo(other.getName());\n\t\t\t}\n\t\t}\n\n\t\tstatic class Output extends Component {\n\t\t\tboolean status;\n\n\t\t\tpublic Output(int x1, int x2, int y) {\n\t\t\t\tsuper(\"OUT\", x1, x2, y);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tvoid createPins(char[][] layout) {\n\t\t\t\tint no = 0;\n\t\t\t\tfor (int x = x1; x <= x2; x++) {\n\t\t\t\t\tif (layout[y + 1][x] == '|') {\n\t\t\t\t\t\tinputs.add(new Pin.InputPin(this, no++, x, y + 1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tvoid update() {\n\t\t\t\tstatus = true;\n\t\t\t\tfor (Pin.InputPin inputPin : inputs) {\n\t\t\t\t\tstatus &= inputPin.status;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpublic boolean getStatus() {\n\t\t\t\treturn status;\n\t\t\t}\n\t\t}\n\n\t\tstatic class Switch extends Component implements Toggleable {\n\t\t\tfinal Pin.InputPin input;\n\t\t\tboolean left;\n\n\t\t\tSwitch(int id, int x1, int x2, int y, boolean left) {\n\t\t\t\tsuper(\"K\" + id, x1, x2, y);\n\t\t\t\tthis.input = new Pin.InputPin(this, 0, (x1 + x2) / 2, y + 1);\n\t\t\t\tinputs.add(input);\n\t\t\t\tthis.left = left;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic String getName() {\n\t\t\t\treturn name;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void toggle() {\n\t\t\t\tleft = !left;\n\t\t\t\tupdate();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void setStatus(boolean status) {\n\t\t\t\tleft = status;\n\t\t\t\tupdate();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean getStatus() {\n\t\t\t\treturn left;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tvoid createPins(char[][] layout) {\n\t\t\t\toutputs.add(new Pin.OutputPin(this, 0, x1 + 1, y - 1));\n\t\t\t\toutputs.add(new Pin.OutputPin(this, 1, x2 - 1, y - 1));\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tvoid update() {\n\t\t\t\tif (left) {\n\t\t\t\t\toutputs.get(0).setStatus(input.status);\n\t\t\t\t\toutputs.get(1).setStatus(false);\n\t\t\t\t} else {\n\t\t\t\t\toutputs.get(0).setStatus(false);\n\t\t\t\t\toutputs.get(1).setStatus(input.status);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic int hashCode() {\n\t\t\t\treturn name.hashCode();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean equals(Object obj) {\n\t\t\t\treturn this == obj || obj instanceof Input && ((Input) obj).name.equals(name);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic int compareTo(Toggleable other) {\n\t\t\t\treturn name.compareTo(other.getName());\n\t\t\t}\n\t\t}\n\n\t\tstatic interface Toggleable extends Comparable<Toggleable> {\n\t\t\tString getName();\n\n\t\t\tvoid toggle();\n\n\t\t\tvoid setStatus(boolean status);\n\n\t\t\tboolean getStatus();\n\t\t}\n\n\t\tfinal String name;\n\t\tfinal int x1, x2, y;\n\t\tfinal List<Pin.InputPin> inputs;\n\t\tfinal List<Pin.OutputPin> outputs;\n\n\t\tComponent(String name, int x1, int x2, int y) {\n\t\t\tsuper();\n\t\t\tthis.name = name;\n\t\t\tthis.x1 = x1;\n\t\t\tthis.x2 = x2;\n\t\t\tthis.y = y;\n\t\t\tinputs = new ArrayList<>();\n\t\t\toutputs = new ArrayList<>();\n\t\t}\n\n\t\tabstract void createPins(char layout[][]);\n\n\t\tabstract void update();\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn name.hashCode();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object o) {\n\t\t\treturn this == o || o instanceof Component && ((Component) o).name.equals(name) && ((Component) o).x1 == x1 && ((Component) o).x2 == x2 && ((Component) o).y == y;\n\t\t}\n\t}\n\n\tstatic class Board {\n\t\tfinal int height;\n\t\tfinal int width;\n\t\tComponent.Output output;\n\t\tfinal List<Component.Input> inputs;\n\t\tfinal List<Component> components;\n\t\tfinal List<Component.Toggleable> toggleables;\n\t\tchar[][] layout;\n\n\t\tBoard(Scanner in) {\n\t\t\theight = in.nextInt();\n\t\t\twidth = in.nextInt();\n\t\t\tin.nextLine();\n\t\t\tlayout = new char[height][width];\n\t\t\tfor (int i = 0; i < height; i++) {\n\t\t\t\tlayout[i] = in.nextLine().toCharArray();\n\t\t\t}\n\n\t\t\tthis.inputs = new ArrayList<>();\n\t\t\tthis.components = new ArrayList<>();\n\t\t\tthis.toggleables = new ArrayList<>();\n\n\t\t\tparseLayout();\n\t\t\tcreatePins();\n\t\t\tcreateLinks();\n\t\t}\n\n\t\tprivate void parseLayout() {\n\t\t\tint inputId = 0;\n\t\t\tint switchId = 0;\n\t\t\t// read schema from top to bottom and create inputs, outputs and gates\n\t\t\tfor (int y = 0; y < height; y++) {\n\t\t\t\tchar[] line = layout[y];\n\t\t\t\tint gx1, gx2;\n\t\t\t\tfor (int x = 0; x < line.length; x++) {\n\t\t\t\t\tchar c = line[x];\n\t\t\t\t\tif (c == '.') {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (c == '[') {\n\t\t\t\t\t\tfor (gx1 = x++; line[x] == ' '; x++) {\n\t\t\t\t\t\t}\n\t\t\t\t\t\tchar g = line[x];\n\t\t\t\t\t\tfor (; line[x] != ']'; x++) {\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgx2 = x;\n\t\t\t\t\t\tComponent component = createComponentFromChar(g, gx1, gx2, y, switchId);\n\t\t\t\t\t\tif (component != null) {\n\t\t\t\t\t\t\taddComponent(component);\n\t\t\t\t\t\t\tif (component instanceof Component.Switch) {\n\t\t\t\t\t\t\t\tswitchId++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if (c == ComponentSymbol.INPUT_HI.value || c == ComponentSymbol.INPUT_LO.value) {\n\t\t\t\t\t\taddComponent(new Component.Input(++inputId, x, y, c == ComponentSymbol.INPUT_HI.value));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\tprivate Component createComponentFromChar(char g, int gx1, int gx2, int y, int switchId) {\n\t\t\tswitch (ComponentSymbol.fromChar(g)) {\n\t\t\t\tcase NOT:\n\t\t\t\t\treturn new Component.Gate.NotGate(gx1, gx2, y);\n\t\t\t\tcase AND:\n\t\t\t\t\treturn new Component.Gate.AndGate(gx1, gx2, y);\n\t\t\t\tcase OR:\n\t\t\t\t\treturn new Component.Gate.OrGate(gx1, gx2, y);\n\t\t\t\tcase XOR:\n\t\t\t\t\treturn new Component.Gate.XorGate(gx1, gx2, y);\n\t\t\t\tcase NAND:\n\t\t\t\t\treturn new Component.Gate.NandGate(gx1, gx2, y);\n\t\t\t\tcase NOR:\n\t\t\t\t\treturn new Component.Gate.NorGate(gx1, gx2, y);\n\t\t\t\tcase XNOR:\n\t\t\t\t\treturn new Component.Gate.XNorGate(gx1, gx2, y);\n\t\t\t\tcase OUTPUT:\n\t\t\t\t\treturn new Component.Gate.Output(gx1, gx2, y);\n\t\t\t\tcase SWITCH_LEFT:\n\t\t\t\tcase SWITCH_RIGHT:\n\t\t\t\t\treturn new Component.Switch(switchId + 1, gx1, gx2, y, g == '<');\n\t\t\t\tdefault:\n\t\t\t\t\tSystem.err.println(\"Unknown component char '\" + g + \"'\");\n\t\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\tprivate void addComponent(Component component) {\n\t\t\tcomponents.add(component);\n\t\t\tif (component instanceof Component.Toggleable) {\n\t\t\t\ttoggleables.add((Component.Toggleable) component);\n\t\t\t}\n\t\t\tif (component instanceof Component.Input) {\n\t\t\t\tinputs.add((Component.Input) component);\n\t\t\t}\n\t\t\tif (component instanceof Component.Output) {\n\t\t\t\toutput = (Component.Output) component;\n\t\t\t}\n\t\t}\n\n\t\tprivate void createPins() {\n\t\t\tfor (Component component : components) {\n\t\t\t\tcomponent.createPins(layout);\n\t\t\t}\n\t\t}\n\n\t\tprivate void createLinks() {\n\t\t\t// link output pins to input pins\n\t\t\tfor (Component component : components) {\n\t\t\t\tfor (Pin.OutputPin outputPin : component.outputs) {\n\t\t\t\t\ttrace(\"Linking %s of %s\", outputPin, component);\n\t\t\t\t\tlink(outputPin, outputPin.x, outputPin.y, Direction.UP);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Follow a wire from an OutputPin to all directly attached InputPins.\n\t\t * In case a wire splits then each fork will be handled recursively\n\t\t *\n\t\t * @param outputPin\n\t\t *            the OutputPin for which we search for InputPin to connect\n\t\t *            to\n\t\t * @param x\n\t\t *            the current x position on the diagram\n\t\t * @param y\n\t\t *            the current y position on the diagram\n\t\t * @param direction\n\t\t *            the current direction (this is used to avoid walking\n\t\t *            backwards on a fork)\n\t\t */\n\t\tvoid link(Pin.OutputPin outputPin, int x, int y, Direction direction) {\n\t\t\twhile (true) {\n\t\t\t\tchar c = layout[y][x];\n\t\t\t\tif (c == '|') {\n\t\t\t\t\ty--;\n\t\t\t\t\tdirection = Direction.UP;\n\t\t\t\t} else if (c == '-') {\n\t\t\t\t\tx += direction.dx;\n\t\t\t\t} else if (c == '+') {\n\t\t\t\t\tchar cLeft = x > 0 ? layout[y][x - 1] == '+' ? '-' : layout[y][x - 1] : '.';\n\t\t\t\t\tchar cRight = x < layout[y].length - 1 ? layout[y][x + 1] == '+' ? '-' : layout[y][x + 1] : '.';\n\t\t\t\t\tchar cTop = y > 0 ? layout[y - 1][x] == '+' ? '|' : layout[y - 1][x] : '.';\n\t\t\t\t\tif (direction == Direction.UP) {\n\t\t\t\t\t\tif (((cLeft == '-' ? 1 : 0) + (cRight == '-' ? 1 : 0) + (cTop == '|' ? 1 : 0)) > 1) {\n\t\t\t\t\t\t\t// fork\n\t\t\t\t\t\t\tif (cLeft == '-') {\n\t\t\t\t\t\t\t\tlink(outputPin, x - 1, y, Direction.LEFT);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (cTop == '|') {\n\t\t\t\t\t\t\t\tlink(outputPin, x, y - 1, Direction.UP);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (cRight == '-') {\n\t\t\t\t\t\t\t\tlink(outputPin, x + 1, y, Direction.RIGHT);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t} else if (cLeft == '-') {\n\t\t\t\t\t\t\tx--;\n\t\t\t\t\t\t\tdirection = Direction.LEFT;\n\t\t\t\t\t\t} else if (cTop == '|') {\n\t\t\t\t\t\t\ty--;\n\t\t\t\t\t\t\tdirection = Direction.UP;\n\t\t\t\t\t\t} else if (cRight == '-') {\n\t\t\t\t\t\t\tx++;\n\t\t\t\t\t\t\tdirection = Direction.RIGHT;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (direction == Direction.LEFT) {\n\t\t\t\t\t\tif (cLeft == '-' && cTop == '|') {\n\t\t\t\t\t\t\t// fork\n\t\t\t\t\t\t\tlink(outputPin, x - 1, y, Direction.LEFT);\n\t\t\t\t\t\t\tlink(outputPin, x, y - 1, Direction.UP);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t} else if (cLeft == '-') {\n\t\t\t\t\t\t\tx--;\n\t\t\t\t\t\t\tdirection = Direction.LEFT;\n\t\t\t\t\t\t} else if (cTop == '|') {\n\t\t\t\t\t\t\ty--;\n\t\t\t\t\t\t\tdirection = Direction.UP;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (direction == Direction.RIGHT) {\n\t\t\t\t\t\tif (cRight == '-' && cTop == '|') {\n\t\t\t\t\t\t\t// fork\n\t\t\t\t\t\t\tlink(outputPin, x - 1, y, Direction.RIGHT);\n\t\t\t\t\t\t\tlink(outputPin, x, y - 1, Direction.UP);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t} else if (cRight == '-') {\n\t\t\t\t\t\t\tx++;\n\t\t\t\t\t\t\tdirection = Direction.RIGHT;\n\t\t\t\t\t\t} else if (cTop == '|') {\n\t\t\t\t\t\t\ty--;\n\t\t\t\t\t\t\tdirection = Direction.UP;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new IllegalStateException(\"Invalid direction for a + : \" + direction);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// we have hit a component\n\t\t\t\t\tfor (Component component : components) {\n\t\t\t\t\t\tfor (Pin.InputPin pin : component.inputs) {\n\t\t\t\t\t\t\tif (pin.x == x && pin.y == y + 1) {\n\t\t\t\t\t\t\t\toutputPin.linkTo(pin);\n\t\t\t\t\t\t\t\ttrace(\"   linked %s of %s\", pin, component);\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\tstatic void run(InputStream inputStream) {\n\t\tinfo(\"Reading input ...\");\n\t\tlong start = System.currentTimeMillis();\n\t\tBoard board = new Board(new Scanner(inputStream));\n\n\t\tMap<Component.Toggleable, Boolean> toggleablesBackup = new HashMap<>();\n\t\tMap<String, Component.Toggleable> toggleables = new HashMap<>();\n\t\tfor (Component.Toggleable toggleable : board.toggleables) {\n\t\t\ttoggleablesBackup.put(toggleable, toggleable.getStatus());\n\t\t\ttoggleables.put(toggleable.getName(), toggleable);\n\t\t}\n\t\tinfo(\"  done in %d ms\", System.currentTimeMillis() - start);\n\n\t\tinfo(\"Solving ...\");\n\t\tstart = System.currentTimeMillis();\n\t\tint bestSolutionScore = Integer.MAX_VALUE;\n\t\tString bestSolutionString = \"\";\n\t\tList<Component.Toggleable> bestToggles = new ArrayList<>();\n\t\tSet<Component.Toggleable> toggles = new TreeSet<>();\n\t\tStringBuilder newSolution = new StringBuilder(256);\n\t\tfor (int i = 0, n = 1 << board.toggleables.size(); i < n; i++) {\n\t\t\tint nbToggles = Integer.bitCount(i);\n\t\t\tif (nbToggles > bestSolutionScore) {\n\t\t\t\t// no point testing this as we're going to try more toggles\n\t\t\t\t// than current best solution ...\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// reset board to original situation\n\t\t\tfor (Map.Entry<Component.Toggleable, Boolean> entry : toggleablesBackup.entrySet()) {\n\t\t\t\tentry.getKey().setStatus(entry.getValue());\n\t\t\t}\n\t\t\tnewSolution.setLength(0);\n\t\t\ttoggles.clear();\n\t\t\tfor (int j = 0, m = 1; j < board.toggleables.size(); j++, m <<= 1) {\n\t\t\t\tif ((i & m) == m) {\n\t\t\t\t\tboard.toggleables.get(j).toggle();\n\t\t\t\t\ttoggles.add(board.toggleables.get(j));\n\t\t\t\t\tnewSolution.append(newSolution.length() > 0 ? \" \" : \"\").append(board.toggleables.get(j).getName());\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (board.output.status) {\n\t\t\t\tif (nbToggles <= bestSolutionScore) {\n\t\t\t\t\tif (nbToggles < bestSolutionScore || newSolution.toString().compareTo(bestSolutionString) < 0) {\n\t\t\t\t\t\tinfo(\"Found new best solution in \" + nbToggles + \" moves : \" + newSolution);\n\t\t\t\t\t\tbestToggles.clear();\n\t\t\t\t\t\tbestToggles.addAll(toggles);\n\t\t\t\t\t\tbestSolutionScore = nbToggles;\n\t\t\t\t\t\tbestSolutionString = newSolution.toString();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tinfo(\"  done in %d ms\", System.currentTimeMillis() - start);\n\t\tif (bestSolutionScore == Integer.MAX_VALUE) {\n\t\t\tSystem.out.println(\"No solution\");\n\t\t} else {\n\t\t\tfor (Component.Toggleable toggle : bestToggles) {\n\t\t\t\tif (toggle instanceof Component.Switch) {\n\t\t\t\t\tSystem.out.println(toggle.getName());\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (Component.Toggleable toggle : bestToggles) {\n\t\t\t\tif (toggle instanceof Component.Input) {\n\t\t\t\t\tSystem.out.println(toggle.getName());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic int LOG_TRACE = 1;\n\tstatic int LOG_DEBUG = 2;\n\tstatic int LOG_INFO = 3;\n\n\tstatic int LOG_LEVEL = 99;\n\n\tstatic void info(String msg, Object... args) {\n\t\tlog(LOG_INFO, msg, args);\n\t}\n\n\tstatic void debug(String msg, Object... args) {\n\t\tlog(LOG_DEBUG, msg, args);\n\t}\n\n\tstatic void trace(String msg, Object... args) {\n\t\tlog(LOG_TRACE, msg, args);\n\t}\n\n\tstatic void log(int level, String msg, Object... args) {\n\t\tif (level >= LOG_LEVEL) {\n\t\t\tSystem.err.println(String.format(msg, args));\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\trun(System.in);\n\t}\n}\n",
      "statement": "The gaming company <<Intergalactical Gaming Corporation>> is about to launch a new game based on logic gates called <<Xorandor>>. The purpose of the game is to light up an LED by powering (or not) inputs and flipping (or not) switches to have the current flow through various logic gates until all inputs of the LED are powered. This has to be done in minimum steps. Each step is either powering/depowering an input or flipping a switch. Before going to retail, the CEO insists on having the game checked, especially the minimum steps required for each level.\n\nYour task is to determine and list for each proposed level the minimum steps to be performed to light the LED. In case several solutions exist, you must list the solution that would come first in top-left bottom-right order.\n\nThere are conventions to respect:\n- Inputs are named {{I1}}, {{I2}} ... {{In}}, where {{I1}} correspond to the leftmost input and {{In}} to the rightmost one.\n- Switches are named {{K1}}, {{K2}} ... {{Kn}}, in order of their appearance from top to bottom, left to right.\n\nYou are provided a representation of each level using the <<Crappy Magnificent Original Standard©®™>> (CMOS) format. In this format:\n- The [[height]] and [[width]] of the electronic circuit are given first, followed by the circuit itself.\n- The LED to light is on the first line of the circuit.\n- The INPUTs are on the last line of the circuit.\n- Each component (gate, LED, switch) is represented by a special character surrounded by {{[}} and {{]}}. There may be some spaces surrounding the special character.\n- Inputs are represented by either a {{0}} (for unpowered input) or a {{1}} for powered input and have only an output pin and no input pins.\n- The LED only has a variable number of input pins and no output pins.\n- The logic gates have only 1 output, which is always aligned with its special character.\n- The NOT gate has only 1 input, and the other gates have 2 inputs.\n- The switches have only 1 input and 2 outputs. Depending on their status they either let the current pass to the right or to the left.\n- Wires link inputs and outputs.\n- Wires can fork to link 1 output pin to several input pins.\n- Wires do not overlap each other nor do they go through/above/under a gate.\n- Current always flows from bottom to top (i.e. from inputs toward the LED).\n- Input and output pins are always represented as a {{|}} and are always attached to their component.\n\n`\n9 11 {{<-- The [[height]] and [[width]] of the layout}} \n    [@] {{<-- The LED you want to light !}} \n     |\n   [ & ]  {{<-- AND gate}}\n    | |\n  +-+ +-+  {{<-- wires linking the OR gates to the AND gate}}\n  |     |\n[ | ] [ | ]  {{<-- 2 OR GATES * }}\n | |   | |\n 0 0   0 0   {{<-- INPUTS (all set to 0) names from left to right I1, I2, I3 and I4}}\n`\n* Do not mistake the {{|}} for the OR gate with a wire. Gates are surrounded by {{[}} and {{]}}. This also applies for the XOR gate ( {{+}} ) and the NOR gate ( {{-}} ).",
      "testCases": [
        {
          "title": "Example : OrAnd",
          "isTest": true,
          "testIn": "9 11\n    [@]    \n     |     \n   [ & ]   \n    | |    \n  +-+ +-+  \n  |     |  \n[ | ] [ | ]\n | |   | | \n 0 0   0 0 ",
          "testOut": "I1\nI3",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "AndOr",
          "isTest": false,
          "testIn": "9 11\n    [@]    \n     |     \n   [ | ]   \n    | |    \n  +-+ +-+  \n  |     |  \n[ & ] [ & ]\n | |   | | \n 0 0   0 0 ",
          "testOut": "I1\nI2",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "Not ?",
          "isTest": true,
          "testIn": "11 11\n    [@]    \n     |     \n   [ & ]   \n    | |    \n  +-+ +-+  \n  |     |  \n [~]   [~] \n  |     |  \n[ | ] [ & ]\n | |   | | \n 1 1   0 1 ",
          "testOut": "I1\nI2",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Not !",
          "isTest": false,
          "testIn": "13 11\n    [@]    \n     |     \n    [~]    \n     |     \n   [ | ]   \n    | |    \n  +-+ +-+  \n  |     |  \n [~]   [~] \n  |     |  \n[ | ] [ | ]\n | |   | | \n 0 1   0 0 ",
          "testOut": "I3",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "Fork ?",
          "isTest": true,
          "testIn": "19 21\n         [@]         \n          |          \n         [~]         \n          |          \n        [ | ]        \n         | |         \n      +--+ +--+      \n      |       |      \n    [ | ]   [ | ]    \n     | |     | |     \n  +--+ +--+--+ +--+  \n  |       |       |  \n[ | ]   [ & ]   [ & ]\n | |     | |     | | \n | +--+--+ +--+--+ | \n |    |       |    | \n[~] [ & ]   [ | ] [~]\n |   | |     | |   | \n 0   1 1     1 0   0 ",
          "testOut": "I1\nI2\nI4",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Fork !",
          "isTest": false,
          "testIn": "23 18\n         [@]      \n          |       \n        [ & ]     \n         | |      \n      +--+ +--+   \n      |       |   \n    [ & ]   [ | ] \n     | |     | |  \n     | |     | +-+\n     | |     |   |\n  +--+ |    [~]  |\n  |    |     |   |\n  |    +--+--+   |\n  |       |      |\n  |     [ | ]    |\n[ & ]    | |     |\n | |    ++ +-+   |\n | +-+  |    |   |\n |   |  |  [ | ] |\n ++  | [~]  | |  |\n  |  |  |  ++ |  |\n  |  |  |  |  |  |\n  0  1  1  0  0  1",
          "testOut": "I1\nI3",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "Switch ?",
          "isTest": true,
          "testIn": "15 17\n       [@]       \n        |        \n      [ & ]      \n       | |       \n     +-+ +-+     \n     |     |     \n   [ | ] [ & ]   \n    | |   | |    \n  +-+ ++ ++ +-+  \n  |    | |    |  \n  |   [ < ]   |  \n  |     |     |  \n[ + ] [ & ] [ + ]\n | |   | |   | | \n 0 0   0 0   1 1 ",
          "testOut": "K1\nI1\nI3\nI4\nI5",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Switch !",
          "isTest": false,
          "testIn": "18 17\n       [@]       \n        |        \n      [ + ]      \n       | |       \n     +-+ +-+     \n     |     |     \n   [ & ]   +-+   \n    | |      |   \n  +-+ +----+ |   \n  |        | |   \n[ & ]     [ > ]  \n | |        |    \n | +----+   +-+  \n ++     |     |  \n  |     |     |  \n[ & ] [ | ] [ & ]\n | |   | |   | | \n 0 0   0 0   0 0 ",
          "testOut": "I5\nI6",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "Xnornandnor",
          "isTest": true,
          "testIn": "30 25\n       [    @    ]       \n        |   |   |        \n    +---+   |   +---+    \n    |       |       |    \n  [ ^ ]   [ - ]   [ ^ ]  \n   | |     | |     | |   \n  ++ |     | ++ +--+ |   \n  |  |     |  | |    |   \n  | [~]   [~] | |   [~]  \n  |  |     |  | |    |   \n  |  +-+ +-+  | |    |   \n  |    | |    | |    |   \n  |   [ < ]  [ < ]   |   \n  |     |      |     |   \n[ & ] [ & ]  [ | ] [ & ] \n | |   | |    | |   | |  \n | |   | ++   | |   | |  \n | |   |  |   | |   | |  \n | |  [~] |   | ++ ++ |  \n | +-+ |  |   |  | |  |  \n |   | |  |   |  | |  |  \n[~] [ < ] +-+-+ [ < ] |  \n |    |     |     |   |  \n |  [ & ] [ | ] [ ^ ] |  \n |   | |   | |   | |  |  \n +-+-+ |  ++ ++ ++ ++-+  \n   |   |  |   | |   |    \n [ & ] |  |   | | [ & ]  \n  | |  |  |   | |  | |   \n  0 0  0  0   0 0  0 0   ",
          "testOut": "K1\nK2\nK4\nI4\nI7\nI8",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "rondnanronX",
          "isTest": false,
          "testIn": "31 26\n       [    @    ]        \n        |   |   |         \n      +-+   |   +-+       \n      |     |     |       \n     [~]    |     |       \n      |     |     |       \n    [ = ] [ + ] [ & ]     \n     | |   | |   | |      \n   +-+ |  ++ ++  | ++     \n   |   |  |   |  |  |     \n   |   | [~] [~][~][~]    \n   |   |  |   |  |  |     \n   |   ++ |   | ++  ++    \n   |    | |   | |    |    \n   |   [ < ] [ < ]   |    \n   |     |     |     |    \n [ - ] [ & ] [ & ] [ ^ ]  \n  | |   | |   | |   | |   \n ++ |   | |   | |   | ++  \n |  |   | |   | |   |  |  \n | [~]  | ++ ++ |   |  |  \n |  |   |  | |  |   |  |  \n |  +-+-+ [ < ] +-+-+  |  \n |    |     |     |    |  \n |  [ + ] [ & ] [ = ]  |  \n |   | |   | |   | |   |  \n +-+-+ +-+-+ +-+-+ +-+-+  \n   |     |     |     |    \n [ & ] [ | ] [ & ] [ & ]  \n  | |   | |   | |   | |   \n  0 0   0 0   0 0   0 0   ",
          "testOut": "K1\nI3\nI5\nI6\nI7\nI8",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "Big one",
          "isTest": true,
          "testIn": "36 23\n       [   @   ]       \n        | | | |        \n  +-----+ | | +-----+  \n  |       | |       |  \n  |     +-+ +-+     |  \n  |     |     |     |  \n  |     |    [~]   [~] \n  |     |     |     |  \n[ + ] [ - ] [ ^ ] [ = ]\n | |   | |   | |   | | \n | |  ++ ++  | ++ ++ | \n | |  |   | [~] | |  | \n | | [~]  |  |  | |  | \n | ++ |   | ++  | |  | \n |  | |   | |   | |  | \n | [ < ] [ < ] [ < ] | \n |   |     |     |   | \n |  [~]    |    [~]  | \n |   |     |     |   | \n | [ + ] [ | ] [ | ] | \n |  | |   | |   | |  | \n |  |[~] [~]|   |[~] | \n |  | |   | |   | |  | \n |  | ++ ++ ++ ++ |  | \n |  |  | |   | |  |  | \n ++-+ [ < ] [ < ] +-++ \n  |     |     |     |  \n  |     |    [~]    |  \n  |     |     |     |  \n[ + ] [ & ] [ = ] [ + ]\n | |   | |   | |   | | \n | +-+-+ +-+-+ +-+-+ | \n |   |     |     |   | \n | [ & ] [ | ] [ & ] | \n |  | |   | |   | |  | \n 0  0 0   0 0   0 0  0 ",
          "testOut": "K1\nK4\nI2\nI3\nI4\nI6\nI7",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Big one",
          "isTest": false,
          "testIn": "31 23\n       [   @   ]       \n        | | | |        \n  +-----+ | | +-----+  \n  |       | |       |  \n  |     +-+ +-+     |  \n  |     |     |     |  \n[ = ] [ - ] [ - ] [ ^ ]\n | |   | |   | |   | | \n | ++ ++ ++ ++ ++ ++ | \n |  | |   | |   | |  | \n | [ < ] [ < ] [ < ] | \n |   |     |     |   | \n | [ + ] [ ^ ] [ | ] | \n |  | |   | |   | |  | \n ++-+ ++ ++ ++ ++ +-++ \n  |    | |   | |    |  \n  |   [ < ] [ < ]   |  \n  |     |     |     |  \n[ + ] [ + ] [ = ] [ + ]\n | |   | |   | |   | | \n | ++ ++ ++ ++ ++ ++ | \n |  | |   | |   | |  | \n | [ < ] [ < ] [ < ] | \n |   |     |     |   | \n | [ & ] [ = ] [ | ] | \n |  | |   | |   | |  | \n ++-+ +-+-+ +-+-+ +-++ \n  |     |     |     |  \n[ = ] [ & ] [ + ] [ & ]\n | |   | |   | |   | | \n 0 0   0 0   0 0   0 0 ",
          "testOut": "K4",
          "isValidator": true,
          "needValidation": true
        }
      ],
      "difficulty": "expert",
      "constraints": "1 ≤ [[height]], [[width]] ≤ 50\n0 ≤ number of switches ≤ 9\n1 ≤ number of inputs ≤ 9",
      "stubGenerator": "read height:int width:int\nloop height read line:string(width)\nwrite anwser",
      "inputDescription": "<<Line 1>>: Two space-separated integers [[height]] and [[width]] for the height and width of the layout of the electronic circuit.\n<<Next [[height]] lines>>: The layout of the electronic circuit line by line.\n\nSpecial characters used to identified the components between {{[}} and {{]}}:\n- {{@}}: LED\n- {{~}}: NOT\n- {{&}}: AND\n- {{|}}: OR\n- {{+}}: XOR\n- {{^}}: NAND\n- {{-}}: NOR\n- {{=}}: XNOR\n- {{<}}: switch forwarding to its left output pin\n- {{>}}: switch forwarding to its right output pin\n\nWires are drawn using the following characters: {{-}}, {{|}} and {{+}}.",
      "solutionLanguage": "Java",
      "outputDescription": "<<A number of lines>>: The minimum steps (i.e. which switch/input to be toggled from original setting) to be performed from top-left to bottom-right, one step per line."
    },
    "draft": false,
    "readyForModeration": true,
    "statementHTML": "<div class=\"statement-body\">\n<div class=\"statement-section statement-goal\">\n   <h2><span class=\"icon icon-goal\">&nbsp;</span><span>Goal </span></h2>\n   <span class=\"question-statement\">The gaming company <strong>Intergalactical Gaming Corporation</strong> is about to launch a new game based on logic gates called <strong>Xorandor</strong>. The purpose of the game is to light up an LED by powering (or not) inputs and flipping (or not) switches to have the current flow through various logic gates until all inputs of the LED are powered. This has to be done in minimum steps. Each step is either powering/depowering an input or flipping a switch. Before going to retail, the CEO insists on having the game checked, especially the minimum steps required for each level.<br><br>Your task is to determine and list for each proposed level the minimum steps to be performed to light the LED. In case several solutions exist, you must list the solution that would come first in top-left bottom-right order.<br><br>There are conventions to respect:<br>- Inputs are named <const>I1</const>, <const>I2</const> ... <const>In</const>, where <const>I1</const> correspond to the leftmost input and <const>In</const> to the rightmost one.<br>- Switches are named <const>K1</const>, <const>K2</const> ... <const>Kn</const>, in order of their appearance from top to bottom, left to right.<br><br>You are provided a representation of each level using the <strong>Crappy Magnificent Original Standard&copy;&reg;&trade;</strong> (CMOS) format. In this format:<br>- The <var>height</var> and <var>width</var> of the electronic circuit are given first, followed by the circuit itself.<br>- The LED to light is on the first line of the circuit.<br>- The INPUTs are on the last line of the circuit.<br>- Each component (gate, LED, switch) is represented by a special character surrounded by <const>[</const> and <const>]</const>. There may be some spaces surrounding the special character.<br>- Inputs are represented by either a <const>0</const> (for unpowered input) or a <const>1</const> for powered input and have only an output pin and no input pins.<br>- The LED only has a variable number of input pins and no output pins.<br>- The logic gates have only 1 output, which is always aligned with its special character.<br>- The NOT gate has only 1 input, and the other gates have 2 inputs.<br>- The switches have only 1 input and 2 outputs. Depending on their status they either let the current pass to the right or to the left.<br>- Wires link inputs and outputs.<br>- Wires can fork to link 1 output pin to several input pins.<br>- Wires do not overlap each other nor do they go through/above/under a gate.<br>- Current always flows from bottom to top (i.e. from inputs toward the LED).<br>- Input and output pins are always represented as a <const>|</const> and are always attached to their component.<br><br><pre style=\"font-family: monospace\"><br>9 11 <const>&lt;-- The <var>height</var> and <var>width</var> of the layout</const> <br>    [@] <const>&lt;-- The LED you want to light !</const> <br>     |<br>   [ &amp; ]  <const>&lt;-- AND gate</const><br>    | |<br>  +-+ +-+  <const>&lt;-- wires linking the OR gates to the AND gate</const><br>  |     |<br>[ | ] [ | ]  <const>&lt;-- 2 OR GATES * </const><br> | |   | |<br> 0 0   0 0   <const>&lt;-- INPUTS (all set to 0) names from left to right I1, I2, I3 and I4</const><br></pre><br>* Do not mistake the <const>|</const> for the OR gate with a wire. Gates are surrounded by <const>[</const> and <const>]</const>. This also applies for the XOR gate ( <const>+</const> ) and the NOR gate ( <const>-</const> ).</span>\n</div>\n<div class=\"statement-section statement-protocol\">\n   <div class=\"blk\">\n      <div class=\"title\">Input</div>\n      <div class=\"question-statement-input\"><strong>Line 1</strong>: Two space-separated integers <var>height</var> and <var>width</var> for the height and width of the layout of the electronic circuit.<br><strong>Next <var>height</var> lines</strong>: The layout of the electronic circuit line by line.<br><br>Special characters used to identified the components between <const>[</const> and <const>]</const>:<br>- <const>@</const>: LED<br>- <const>~</const>: NOT<br>- <const>&amp;</const>: AND<br>- <const>|</const>: OR<br>- <const>+</const>: XOR<br>- <const>^</const>: NAND<br>- <const>-</const>: NOR<br>- <const>=</const>: XNOR<br>- <const>&lt;</const>: switch forwarding to its left output pin<br>- <const>&gt;</const>: switch forwarding to its right output pin<br><br>Wires are drawn using the following characters: <const>-</const>, <const>|</const> and <const>+</const>.</div>\n   </div>\n   <div class=\"blk\">\n      <div class=\"title\">Output</div>\n      <div class=\"question-statement-output\"><strong>A number of lines</strong>: The minimum steps (i.e. which switch/input to be toggled from original setting) to be performed from top-left to bottom-right, one step per line.</div>\n   </div>\n   <div class=\"blk\">\n      <div class=\"title\">Constraints</div>\n      <div class=\"question-statement-constraints\">1 &le; <var>height</var>, <var>width</var> &le; 50<br>0 &le; number of switches &le; 9<br>1 &le; number of inputs &le; 9</div>\n   </div>\n   <div class=\"blk\">\n      <div class=\"title\">Example</div>\n      <div class=\"statement-inout\">\n         <div class=\"statement-inout-in\">\n            <div class=\"title\">Input</div>\n            <pre class=\"question-statement-example-in\">9 11\n    [@]    \n     |     \n   [ &amp; ]   \n    | |    \n  +-+ +-+  \n  |     |  \n[ | ] [ | ]\n | |   | | \n 0 0   0 0 </pre>\n         </div>\n         <div class=\"statement-inout-out\">\n            <div class=\"title\">Output</div>\n            <pre class=\"question-statement-example-out\">I1\nI3</pre>\n         </div>\n      </div>\n   </div>\n</div>"
  },
  "validatedFor": 287086629429,
  "avatar": 95780209684968,
  "commentCount": 21,
  "upVotes": 4,
  "downVotes": 0,
  "validateAction": {
    "actionId": 69203,
    "progress": 1,
    "alreadyDone": false
  },
  "statusHistory": [],
  "editable": true,
  "draft": false,
  "readyForModeration": true
}