{
  "id": 878,
  "activeVersion": 36,
  "score": 3,
  "votableId": 6155927,
  "codingamerId": 2130169,
  "views": 389,
  "commentableId": 6096774,
  "title": "Plight Of The Fellowship Of The Ring",
  "status": "ACCEPTED",
  "type": "PUZZLE_INOUT",
  "nickname": "CyberLemonade",
  "publicHandle": "878bbb082f4204c8253c1b24e304a69e824",
  "codingamerHandle": "d8a0152458f424d53995a613b5abea4f9610312",
  "lastVersion": {
    "version": 36,
    "data": {
      "title": "Plight Of The Fellowship Of The Ring",
      "topics": [
        {
          "id": 48,
          "handle": "graphs",
          "labelMap": {
            "1": "Graphes",
            "2": "Graphs"
          },
          "pageTitle": "Graphs: exercises and theory",
          "puzzleCount": 17,
          "parentTopicId": 40,
          "contentDetailsId": 75
        },
        {
          "id": 68,
          "handle": "pathfinding",
          "labelMap": {
            "1": "Recherche de chemins",
            "2": "Pathfinding"
          },
          "pageTitle": "Pathfinding: exercises and theory",
          "puzzleCount": 27,
          "parentTopicId": 41,
          "contentDetailsId": 69
        }
      ],
      "solution": "import java.util.*;\nimport java.math.*;\nimport java.io.*;\nimport java.awt.*;\npublic class Solution { // Plight Of The Fellowship\n    public static void main(String args[]) { // main method\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt(); // the number of spots\n        int M = sc.nextInt(); // the number of orcs\n        int L = sc.nextInt(); // the number of portals\n        Point spots[] = new Point[N]; // coordinates of the spots\n        Point orcs[] = new Point[M]; // coordinates of the orcs\n        boolean portal[][] = new boolean[N][N];\n        for (int i = 0; i < N; i++) {\n            int x = sc.nextInt(); // the x-coordinate of the spot\n            int y = sc.nextInt(); // the y-coordinate of the spot\n            spots[i] = new Point(x,y);\n        }\n        for (int i = 0; i < M; i++) {\n            int x = sc.nextInt(); // the x-coordinate of the orcs\n            int y = sc.nextInt(); // the y-coordinate of the orcs\n            orcs[i] = new Point(x,y);\n        }\n        for (int i = 0; i < L; i++) {\n            int N1 = sc.nextInt(); // the first node\n            int N2 = sc.nextInt(); // the second node\n            portal[N1][N2]=portal[N2][N1]=true;    \n        }\n        int S = sc.nextInt(); // the starting spot\n        int E = sc.nextInt(); // the ending spot\n        \n        int time=0; // time taken\n        Vector<Integer> oldPositions = new Vector<Integer>(); // list of positions being checked \n        Vector<Integer> newPositions = new Vector<Integer>(); // list of positions to be checked\n        oldPositions.add(S); // first position to be checked is the starting point\n        boolean checked[] = new boolean[N]; // list of checked positions\n        Vector<Path> paths = new Vector<Path>(); // list of paths\n        paths.add(new Path(S)); // all paths start at given spot\n        \n        route:\n        for (int i = 0; i < N; i++) {\n            time++;\n            for (int j = 0; j < oldPositions.size(); j++) {\n                int current = oldPositions.elementAt(j); // the current spot\n                for (int k = 0; k < N; k++) {\n                    if (portal[current][k]&&!checked[k]) { // if the spots have a valid portal\n                        if (valid(spots[k],orcs,time)) { // if the movement is possible without getting caught by orcs\n                            paths.add(new Path(paths.elementAt(0).path)); // adding a new path\n                            paths.elementAt(paths.size()-1).add(k); // adding a new point to the path\n                            if (k==E) {paths.elementAt(paths.size()-1).printPath() ;return;} // if the spot is the end point\n                            else {newPositions.add(k);} // updating positions to be checked\n                        }\n                    }\n                }\n                checked[current] = true; // updating checked spots\n                paths.removeElementAt(0); // removing the path leading to this point\n            }\n            oldPositions.removeAllElements();\n            for (; 0 < newPositions.size();) { // refreshing the set of to-be-checked positions\n                oldPositions.add(newPositions.elementAt(0));\n                newPositions.removeElementAt(0);\n            }\n        }\n        System.out.println(\"IMPOSSIBLE\");\n    }\n    \n    public static boolean valid(Point index, Point[] places, int time) { // method to check whether the move is possible\n        for (int i = 0; i < places.length; i++) {\n            double dist = Math.sqrt(Math.pow((index.x-places[i].x),2)+Math.pow((index.y-places[i].y),2)); //distance of the orc from the spot\n            if (dist<=(double)(time)) {return false;} // if orc will reach the spot in time\n        }\n        return true;\n    }\n    \n    public static class Path { // class holding a path of spots\n        Vector<Integer> path = new Vector<Integer>(); // list of covered spots\n        public Path(Vector<Integer> old) {\n            for (int i = 0; i < old.size(); i++) {\n                path.add(old.elementAt(i)); // add a new position\n            }\n        }\n        public Path(int New) {\n            path.add(New); // add a new position\n        }\n        public void add(int New) {\n            path.add(New); // add a new position\n        }\n        public int size() {\n            return path.size(); // return path length\n        }\n        public void printPath() {\n            String PATH = \"\";\n            for (int i = 0; i < path.size(); i++) {\n                PATH+=\" \"+path.elementAt(i); // display the set of spots\n            }\n            System.out.println(PATH.substring(1));\n        }\n        public void add(Vector<Integer> old) {\n            for (int i = 0; i < old.size(); i++) {\n                path.add(old.elementAt(i)); // add a new position\n            }\n        }\n    }\n}",
      "statement": "<<Story:>>\n\nHelp the fellowship! They are trapped in the mines of Moria, with orcs closing in from all sides. Their only hope is Gandalf’s wizardry. Gandalf can create portals through which they can quickly travel from one spot to another. However portals can be opened in limited spots only, and in a limited number of ways. Your program must print the path they should follow to be safely out.\n\n--------------------------------------------------- xxx ---------------------------------------------------\n\n<<Rules:>>\n\nThe Spots will be {{INDEXED}} as 0, 1, 2, 3, ...\n\nYou will be given the {{COORDINATES OF THE SPOTS}} to where Gandalf can create a portal. \n\nYou will be given the {{COORDINATES OF THE ORCS}}.\n\nYou will also be given the {{POSSIBLE PATHS}} from one spot to another. (the indexes)\n(<<note:>> the paths are double sided. this means that if a path is possible from spot [[2]] to spot [[5]], then it is possible to go from <<[[2]] to [[5]]>>, as also from <<[[5]] to [[2]]>>)\n\n--------------------------------------------------- xxx ---------------------------------------------------\n\n<<The Problem:>>\n\nYour algorithm should display the sequence of the spots in order of how the fellowship go in order to reach the end fastest, and safely. \n(<<note>>: the fellowship can travel from one spot to another along the {{POSSIBLE PATHS}} only) \n\nYou will be given the index of the {{STARTING SPOT}} and also the {{ENDING SPOT}}. \n\n--------------------------------------------------- xxx ---------------------------------------------------\n\n<<Note:>> \n\n<<1.>> For every move of the fellowship, each orc can move by a distance of 1. If you need N moves to reach a spot, and distance from the starting point of an orc to that spot is ≤ N, you cannot go there or you might be killed.\n\n<<For example,>> if spot [[2]] and spot [[5]] are connected by a path, and coordinates of [[2]] is <<(1,0)>> and [[5]] is <<(2,2)>>, and an orc is present at <<(1,2)>>, then the fellowship cannot go from spot [[2]] to spot [[5]], as time taken by the fellowship is [[1 UNIT]], and distance moved by the orc in 1 unit time is [[1 UNIT]] (<<(2,1)>> and <<(2,2)>> are separated by distance [[1 UNIT]]).\n\n<<2.>> The fellowship can only move along the paths from one spot to another. \n\n<<For example,>> if spot [[2]] and spot [[5]] are connected by a path, and coordinates of [[2]] is <<(1,0)>> and [[5]] is <<(2,2)>>, then from [[2]] the fellowship can <<move only to>> [[5]], and not to any random spot {say <<(1,2)>>} [i.e. they can only move to a <<spot>>, which is <<connected>>] .\n\n<<3.>> Distances are calculated by the distance formula: <<dist = sqrt( (p1.x-p2.x)^2 + (p1.y-p2.y)^2 )>> (i.e. distances are <<Pythagorean>>)",
      "testCases": [
        {
          "title": "One Orc",
          "isTest": true,
          "testIn": "4\n1\n4\n1 1\n2 0\n2 2\n3 1\n1 2\n0 1\n0 2\n1 3\n2 3\n0\n3",
          "testOut": "0 1 3",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Validator 1",
          "isTest": false,
          "testIn": "4\n1\n4\n1 1\n2 2\n2 0\n3 1\n1 2\n0 1\n0 2\n1 3\n2 3\n0\n3",
          "testOut": "0 2 3",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "Multiple Orcs",
          "isTest": true,
          "testIn": "9\n3\n9\n0 0\n3 0\n5 -2\n5 2\n8 2\n8 -2\n10 0\n10 4\n3 4\n8 -4\n1 4\n10 8\n0 1\n1 2\n1 3\n2 5\n3 4\n5 6\n4 7\n4 6\n3 8\n0\n6",
          "testOut": "0 1 3 4 6",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Validator 2",
          "isTest": false,
          "testIn": "9\n3\n9\n0 0\n3 0\n5 -2\n5 2\n8 2\n8 -2\n10 0\n10 4\n3 4\n8 -4\n1 4\n10 8\n0 1\n1 2\n1 3\n2 5\n3 4\n5 6\n4 7\n4 6\n3 8\n0\n6",
          "testOut": "0 1 3 4 6",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "Many choices",
          "isTest": true,
          "testIn": "12\n2\n13\n0 0\n3 0\n5 -2\n5 2\n8 2\n8 -2\n10 0\n-2 10\n5 -5\n-3 -5\n-3 0\n-3 5\n5 4\n12 5\n0 1\n1 2\n1 3\n2 5\n3 6\n5 6\n6 4\n4 7\n2 8\n8 9\n9 10\n10 11\n11 7\n0\n7",
          "testOut": "0 1 2 8 9 10 11 7",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Validator 3",
          "isTest": false,
          "testIn": "12\n2\n13\n0 0\n3 0\n5 -2\n5 2\n8 2\n8 -2\n10 0\n-2 10\n5 -5\n-3 -5\n-3 0\n-3 5\n5 4\n12 5\n0 1\n1 2\n1 3\n2 5\n3 6\n5 6\n6 4\n4 7\n2 8\n8 9\n9 10\n10 11\n11 7\n0\n7",
          "testOut": "0 1 2 8 9 10 11 7",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "Impossible",
          "isTest": true,
          "testIn": "3\n1\n2\n0 0\n3 0\n5 2\n5 3\n0 1\n1 2\n0\n2",
          "testOut": "IMPOSSIBLE",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Validator 4",
          "isTest": false,
          "testIn": "3\n1\n2\n0 0\n3 0\n5 2\n5 3\n0 1\n1 2\n0\n2",
          "testOut": "IMPOSSIBLE",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "No orcs!",
          "isTest": true,
          "testIn": "4\n0\n4\n1 1\n2 2\n2 0\n3 1\n0 1\n0 2\n1 2\n2 3\n0\n3",
          "testOut": "0 2 3",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Validator 5",
          "isTest": false,
          "testIn": "4\n0\n4\n1 1\n2 2\n2 0\n3 1\n0 1\n0 2\n1 3\n2 1\n0\n3",
          "testOut": "0 1 3",
          "isValidator": true,
          "needValidation": true
        }
      ],
      "difficulty": "medium",
      "constraints": "1 ≤ [[N]], [[L]] ≤ 100\n0 ≤ [[M]] ≤ 100",
      "coverBinaryId": 27977622121248,
      "stubGenerator": "read N:int\nread M:int\nread L:int\nloop N read XS:int YS:int\nloop M read XO:int YO:int\nloop L read N1:int N2:int\nread S:int\nread E:int\nwrite path",
      "inputDescription": "<<Line 1:>> an integer [[N]] denoting the number of spots\n<<Line 2:>> an integer [[M]] denoting the number of orcs\n<<Line 3:>> an integer [[L]] denoting the number of portals\n<<Next [[N]] lines:>> 2 integers [[XS]], [[YS]], the coordinates of the spots\n<<Next [[M]] lines:>> 2 integers [[XO]], [[YO]], the coordinates of the orcs\n<<Next [[L]] lines:>>  2 integers [[N1]], [[N2]], the indexes of 2 spots of a path forming a portal\n<<Next line:>> an integer [[S]] denoting the spot from which the \t\t\tfellowship start (the index)\n<<Next line:>> an integer [[E]] denoting the spot where the fellowship \t\tneed to reach (the index)",
      "solutionLanguage": "Java",
      "outputDescription": "Your output should consist of one line of integers separated by spaces, denoting the indexes of the spots to which the fellowship go. (in order)\nIf it is not possible to reach the end, print a single String [[IMPOSSIBLE]]"
    },
    "draft": false,
    "readyForModeration": true,
    "statementHTML": "<div class=\"statement-body\">\n<div class=\"statement-section statement-goal\">\n   <h2><span class=\"icon icon-goal\">&nbsp;</span><span>Goal </span></h2>\n   <span class=\"question-statement\"><strong>Story:</strong><br><br>Help the fellowship! They are trapped in the mines of Moria, with orcs closing in from all sides. Their only hope is Gandalf&rsquo;s wizardry. Gandalf can create portals through which they can quickly travel from one spot to another. However portals can be opened in limited spots only, and in a limited number of ways. Your program must print the path they should follow to be safely out.<br><br>--------------------------------------------------- xxx ---------------------------------------------------<br><br><strong>Rules:</strong><br><br>The Spots will be <const>INDEXED</const> as 0, 1, 2, 3, ...<br><br>You will be given the <const>COORDINATES OF THE SPOTS</const> to where Gandalf can create a portal. <br><br>You will be given the <const>COORDINATES OF THE ORCS</const>.<br><br>You will also be given the <const>POSSIBLE PATHS</const> from one spot to another. (the indexes)<br>(<strong>note:</strong> the paths are double sided. this means that if a path is possible from spot <var>2</var> to spot <var>5</var>, then it is possible to go from <strong><var>2</var> to <var>5</var></strong>, as also from <strong><var>5</var> to <var>2</var></strong>)<br><br>--------------------------------------------------- xxx ---------------------------------------------------<br><br><strong>The Problem:</strong><br><br>Your algorithm should display the sequence of the spots in order of how the fellowship go in order to reach the end fastest, and safely. <br>(<strong>note</strong>: the fellowship can travel from one spot to another along the <const>POSSIBLE PATHS</const> only) <br><br>You will be given the index of the <const>STARTING SPOT</const> and also the <const>ENDING SPOT</const>. <br><br>--------------------------------------------------- xxx ---------------------------------------------------<br><br><strong>Note:</strong> <br><br><strong>1.</strong> For every move of the fellowship, each orc can move by a distance of 1. If you need N moves to reach a spot, and distance from the starting point of an orc to that spot is &le; N, you cannot go there or you might be killed.<br><br><strong>For example,</strong> if spot <var>2</var> and spot <var>5</var> are connected by a path, and coordinates of <var>2</var> is <strong>(1,0)</strong> and <var>5</var> is <strong>(2,2)</strong>, and an orc is present at <strong>(1,2)</strong>, then the fellowship cannot go from spot <var>2</var> to spot <var>5</var>, as time taken by the fellowship is <var>1 UNIT</var>, and distance moved by the orc in 1 unit time is <var>1 UNIT</var> (<strong>(2,1)</strong> and <strong>(2,2)</strong> are separated by distance <var>1 UNIT</var>).<br><br><strong>2.</strong> The fellowship can only move along the paths from one spot to another. <br><br><strong>For example,</strong> if spot <var>2</var> and spot <var>5</var> are connected by a path, and coordinates of <var>2</var> is <strong>(1,0)</strong> and <var>5</var> is <strong>(2,2)</strong>, then from <var>2</var> the fellowship can <strong>move only to</strong> <var>5</var>, and not to any random spot {say <strong>(1,2)</strong>} [i.e. they can only move to a <strong>spot</strong>, which is <strong>connected</strong>] .<br><br><strong>3.</strong> Distances are calculated by the distance formula: <strong>dist = sqrt( (p1.x-p2.x)^2 + (p1.y-p2.y)^2 )</strong> (i.e. distances are <strong>Pythagorean</strong>)</span>\n</div>\n<div class=\"statement-section statement-protocol\">\n   <div class=\"blk\">\n      <div class=\"title\">Input</div>\n      <div class=\"question-statement-input\"><strong>Line 1:</strong> an integer <var>N</var> denoting the number of spots<br><strong>Line 2:</strong> an integer <var>M</var> denoting the number of orcs<br><strong>Line 3:</strong> an integer <var>L</var> denoting the number of portals<br><strong>Next <var>N</var> lines:</strong> 2 integers <var>XS</var>, <var>YS</var>, the coordinates of the spots<br><strong>Next <var>M</var> lines:</strong> 2 integers <var>XO</var>, <var>YO</var>, the coordinates of the orcs<br><strong>Next <var>L</var> lines:</strong>  2 integers <var>N1</var>, <var>N2</var>, the indexes of 2 spots of a path forming a portal<br><strong>Next line:</strong> an integer <var>S</var> denoting the spot from which the \t\t\tfellowship start (the index)<br><strong>Next line:</strong> an integer <var>E</var> denoting the spot where the fellowship \t\tneed to reach (the index)</div>\n   </div>\n   <div class=\"blk\">\n      <div class=\"title\">Output</div>\n      <div class=\"question-statement-output\">Your output should consist of one line of integers separated by spaces, denoting the indexes of the spots to which the fellowship go. (in order)<br>If it is not possible to reach the end, print a single String <var>IMPOSSIBLE</var></div>\n   </div>\n   <div class=\"blk\">\n      <div class=\"title\">Constraints</div>\n      <div class=\"question-statement-constraints\">1 &le; <var>N</var>, <var>L</var> &le; 100<br>0 &le; <var>M</var> &le; 100</div>\n   </div>\n   <div class=\"blk\">\n      <div class=\"title\">Example</div>\n      <div class=\"statement-inout\">\n         <div class=\"statement-inout-in\">\n            <div class=\"title\">Input</div>\n            <pre class=\"question-statement-example-in\">4\n1\n4\n1 1\n2 0\n2 2\n3 1\n1 2\n0 1\n0 2\n1 3\n2 3\n0\n3</pre>\n         </div>\n         <div class=\"statement-inout-out\">\n            <div class=\"title\">Output</div>\n            <pre class=\"question-statement-example-out\">0 1 3</pre>\n         </div>\n      </div>\n   </div>\n</div>"
  },
  "validatedFor": 257368330012,
  "avatar": 57032502077757,
  "commentCount": 21,
  "upVotes": 3,
  "downVotes": 0,
  "validateAction": {
    "actionId": 176069,
    "progress": 1,
    "alreadyDone": false
  },
  "statusHistory": [],
  "editable": true,
  "draft": false,
  "readyForModeration": true
}