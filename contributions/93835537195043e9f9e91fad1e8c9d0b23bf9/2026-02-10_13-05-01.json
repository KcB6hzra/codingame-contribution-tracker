{
  "id": 93835,
  "activeVersion": 29,
  "score": 16,
  "votableId": 33722840,
  "codingamerId": 1570464,
  "views": 253,
  "commentableId": 33574320,
  "title": "Fix the networks",
  "status": "ACCEPTED",
  "type": "PUZZLE_INOUT",
  "nickname": "dzuy",
  "publicHandle": "93835537195043e9f9e91fad1e8c9d0b23bf9",
  "codingamerHandle": "d929ddf5b112bbd01f92bda213811ba74640751",
  "lastVersion": {
    "version": 29,
    "autocloseTime": 1726190364702,
    "freezeTime": 1720215864257,
    "data": {
      "title": "Fix the networks",
      "topics": [
        {
          "id": 211,
          "handle": "numbers",
          "category": "FUNDAMENTALS",
          "labelMap": {
            "1": "Numbers",
            "2": "Numbers"
          },
          "puzzleCount": 5,
          "parentTopicId": 93
        },
        {
          "id": 112,
          "handle": "string-manipulation",
          "category": "FUNDAMENTALS",
          "labelMap": {
            "1": "String manipulation",
            "2": "String manipulation"
          },
          "puzzleCount": 65,
          "parentTopicId": 93
        },
        {
          "id": 45,
          "handle": "conditions",
          "category": "FUNDAMENTALS",
          "labelMap": {
            "1": "Conditions",
            "2": "Conditions"
          },
          "pageTitle": "Conditions: exercises and theory",
          "puzzleCount": 69,
          "parentTopicId": 39,
          "contentDetailsId": 68
        },
        {
          "labelMap": {
            "2": "Computer Network"
          }
        }
      ],
      "solution": "import sys\nimport math\n\n# Auto-generated code below aims at helping you parse\n# the standard input according to the problem statement.\n\nm = int(input())\n\n# Write an answer using print\n# To debug: print(\"Debug messages...\", file=sys.stderr, flush=True)\nfor r in range(m):\n    ip, cidr_no = input().split(\"/\")\n    ip_bins = [bin(int(s))[2:] for s in ip.split('.')]\n    ip_bin_str = \"\".join([((8 - len(i)) * \"0\") + i for i in ip_bins])\n    var_bits_no = 32 - int(cidr_no) \n    if var_bits_no == 0:\n        print(\"valid 1\")\n    elif '0'*var_bits_no == ip_bin_str[-1*var_bits_no:]:\n        print(\"valid \"+str(2**var_bits_no))\n    else:\n        var_bits_no = len(ip_bin_str.split(\"1\")[-1])\n        cidr_no = 32 - var_bits_no\n        print(f\"invalid {ip}/{cidr_no} {2**var_bits_no}\")\n\n",
      "statement": "John's boss asked him to provision some networks for the company.  John is an experienced network engineer, so the problem should be pretty straightforward. However, it was late at night, and he had a bit too much to drink, so he messed up a few of the numbers.  Please help John fix the problem!\n\nA CIDR range consists of a prefix and a suffix. The prefix consists of four 8-bit numbers [[B]] separated by a dot, which represents a 32-bit IP address. For example, {{10.0.0.8}} is an IP address. The suffix is a number [[S]] between 0 and 32 inclusive, which tells us how many bits are fixed, counting from the left. This means that the remaining bits are variable. These bits determine the number of addresses [[N]] available to the CIDR range.\nThe prefix and the suffix are separated by a forward slash. An example of a CIDR range is {{10.0.0.8/24}}.\nA CIDR range is valid if all of the variable bits are 0.\n\nFor example:\n{{192.168.2.0/24}} is a {{valid}} CIDR range because when converted to binary, the last 8 bits are all 0: \n11000000 . 10101000 . 00000010 . <<00000000>>\n\n{{192.168.10.0/20}} is an {{invalid}} range because when the prefix is converted to binary, the last 12 bits are not all 0: \n11000000 . 10101000 . 0000<<1010 . 00000000>>\n\nWe can fix it by changing the above CIDR range to {{192.168.10.0/23}}. Now the last 9 bits are all 0: \n11000000 . 10101000 . 0000101<<0 . 00000000>>\n\nGiven a [[M]] number of CIDR ranges, validate each range and print the result. If a range is {{valid}}, print the number of addresses it can hold. If it is {{invalid}}, correct the suffix so that the resulting CIDR range will have the highest number of addresses possible. Print the new CIDR range and the number of addresses.",
      "testCases": [
        {
          "title": "Test 1",
          "isTest": true,
          "testIn": "4\n10.0.0.32/32\n10.0.0.32/30\n10.0.0.32/28\n10.0.0.32/26",
          "testOut": "valid 1\nvalid 4\nvalid 16\ninvalid 10.0.0.32/27 32",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Validator 1",
          "isTest": false,
          "testIn": "4\n10.0.0.32/31\n10.0.0.32/29\n10.0.0.32/27\n10.0.0.32/25",
          "testOut": "valid 2\nvalid 8\nvalid 32\ninvalid 10.0.0.32/27 32",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "Test 2",
          "isTest": true,
          "testIn": "5\n255.0.0.0/32\n255.0.0.0/24\n255.0.0.0/16\n255.0.0.0/8\n255.0.0.0/2",
          "testOut": "valid 1\nvalid 256\nvalid 65536\nvalid 16777216\ninvalid 255.0.0.0/8 16777216",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Validator 2",
          "isTest": false,
          "testIn": "5\n255.0.0.0/30\n255.0.0.0/25\n255.0.0.0/18\n255.0.0.0/10\n255.0.0.0/4",
          "testOut": "valid 4\nvalid 128\nvalid 16384\nvalid 4194304\ninvalid 255.0.0.0/8 16777216",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "Test 3",
          "isTest": true,
          "testIn": "4\n0.10.0.10/31\n0.10.0.10/25\n0.10.0.10/10\n0.10.0.10/5",
          "testOut": "valid 2\ninvalid 0.10.0.10/31 2\ninvalid 0.10.0.10/31 2\ninvalid 0.10.0.10/31 2",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Validator 3",
          "isTest": false,
          "testIn": "4\n0.10.0.10/32\n0.10.0.10/26\n0.10.0.10/12\n0.10.0.10/2",
          "testOut": "valid 1\ninvalid 0.10.0.10/31 2\ninvalid 0.10.0.10/31 2\ninvalid 0.10.0.10/31 2",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "Test 4",
          "isTest": true,
          "testIn": "2\n0.0.0.0/0\n255.255.255.255/0",
          "testOut": "valid 4294967296\ninvalid 255.255.255.255/32 1",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Validator 4",
          "isTest": false,
          "testIn": "2\n0.0.0.0/1\n255.255.255.255/32",
          "testOut": "valid 2147483648\nvalid 1",
          "isValidator": true,
          "needValidation": true
        }
      ],
      "difficulty": "easy",
      "constraints": "1 <= [[M]] <= 5\n0 <= [[B]] <= 255\n0 <= [[S]] <= 32\n1 <= [[N]] <= 4294967296",
      "coverBinaryId": 124179905398036,
      "stubGenerator": "read m:int\nloop m read r:string(20)\nwrite answer",
      "inputDescription": "<<Line 1:>> An integer [[M]] for the number of CIDR ranges\n<<Next [[M]] lines:>> CIDR range",
      "solutionLanguage": "Python3",
      "outputDescription": "If the CIDR range is valid, print {{valid}}, and then print [[N]] for the number of addresses\nIf the CIDR range is invalid, print {{invalid}}, the new CIDR range, and then [[N]] for the number of addresses of the new range."
    },
    "draft": false,
    "readyForModeration": true,
    "statementHTML": "<div class=\"statement-body\">\n<div class=\"statement-section statement-goal\">\n   <h2><span class=\"icon icon-goal\">&nbsp;</span><span>Goal </span></h2>\n   <span class=\"question-statement\">John's boss asked him to provision some networks for the company.  John is an experienced network engineer, so the problem should be pretty straightforward. However, it was late at night, and he had a bit too much to drink, so he messed up a few of the numbers.  Please help John fix the problem!<br><br>A CIDR range consists of a prefix and a suffix. The prefix consists of four 8-bit numbers <var>B</var> separated by a dot, which represents a 32-bit IP address. For example, <const>10.0.0.8</const> is an IP address. The suffix is a number <var>S</var> between 0 and 32 inclusive, which tells us how many bits are fixed, counting from the left. This means that the remaining bits are variable. These bits determine the number of addresses <var>N</var> available to the CIDR range.<br>The prefix and the suffix are separated by a forward slash. An example of a CIDR range is <const>10.0.0.8/24</const>.<br>A CIDR range is valid if all of the variable bits are 0.<br><br>For example:<br><const>192.168.2.0/24</const> is a <const>valid</const> CIDR range because when converted to binary, the last 8 bits are all 0: <br>11000000 . 10101000 . 00000010 . <strong>00000000</strong><br><br><const>192.168.10.0/20</const> is an <const>invalid</const> range because when the prefix is converted to binary, the last 12 bits are not all 0: <br>11000000 . 10101000 . 0000<strong>1010 . 00000000</strong><br><br>We can fix it by changing the above CIDR range to <const>192.168.10.0/23</const>. Now the last 9 bits are all 0: <br>11000000 . 10101000 . 0000101<strong>0 . 00000000</strong><br><br>Given a <var>M</var> number of CIDR ranges, validate each range and print the result. If a range is <const>valid</const>, print the number of addresses it can hold. If it is <const>invalid</const>, correct the suffix so that the resulting CIDR range will have the highest number of addresses possible. Print the new CIDR range and the number of addresses.</span>\n</div>\n<div class=\"statement-section statement-protocol\">\n   <div class=\"blk\">\n      <div class=\"title\">Input</div>\n      <div class=\"question-statement-input\"><strong>Line 1:</strong> An integer <var>M</var> for the number of CIDR ranges<br><strong>Next <var>M</var> lines:</strong> CIDR range</div>\n   </div>\n   <div class=\"blk\">\n      <div class=\"title\">Output</div>\n      <div class=\"question-statement-output\">If the CIDR range is valid, print <const>valid</const>, and then print <var>N</var> for the number of addresses<br>If the CIDR range is invalid, print <const>invalid</const>, the new CIDR range, and then <var>N</var> for the number of addresses of the new range.</div>\n   </div>\n   <div class=\"blk\">\n      <div class=\"title\">Constraints</div>\n      <div class=\"question-statement-constraints\">1 &lt;= <var>M</var> &lt;= 5<br>0 &lt;= <var>B</var> &lt;= 255<br>0 &lt;= <var>S</var> &lt;= 32<br>1 &lt;= <var>N</var> &lt;= 4294967296</div>\n   </div>\n   <div class=\"blk\">\n      <div class=\"title\">Example</div>\n      <div class=\"statement-inout\">\n         <div class=\"statement-inout-in\">\n            <div class=\"title\">Input</div>\n            <pre class=\"question-statement-example-in\">4\n10.0.0.32/32\n10.0.0.32/30\n10.0.0.32/28\n10.0.0.32/26</pre>\n         </div>\n         <div class=\"statement-inout-out\">\n            <div class=\"title\">Output</div>\n            <pre class=\"question-statement-example-out\">valid 1\nvalid 4\nvalid 16\ninvalid 10.0.0.32/27 32</pre>\n         </div>\n      </div>\n   </div>\n</div>"
  },
  "validatedFor": 46971289507,
  "avatar": 122843082275603,
  "commentCount": 24,
  "upVotes": 16,
  "downVotes": 0,
  "validateAction": {
    "actionId": 984580,
    "progress": 1,
    "alreadyDone": false
  },
  "statusHistory": [
    {
      "status": "REFUSED",
      "date": 1719317137002,
      "data": {
        "author": "SYSTEM",
        "reason": "INACTIVITY"
      }
    },
    {
      "status": "PENDING",
      "date": 1719611064257,
      "data": {
        "author": "ACTION",
        "reason": "EDIT"
      }
    },
    {
      "status": "REFUSED",
      "date": 1722204337001,
      "data": {
        "author": "SYSTEM",
        "reason": "INACTIVITY"
      }
    },
    {
      "status": "PENDING",
      "date": 1723598364702,
      "data": {
        "author": "ACTION",
        "reason": "EDIT"
      }
    },
    {
      "status": "ACCEPTED",
      "date": 1723757410902,
      "data": {
        "author": "ACTION"
      }
    }
  ],
  "editable": true,
  "draft": false,
  "readyForModeration": true
}