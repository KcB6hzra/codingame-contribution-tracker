{
  "id": 5361,
  "activeVersion": 17,
  "score": 5,
  "votableId": 14787550,
  "codingamerId": 2914398,
  "views": 213,
  "commentableId": 14706562,
  "title": "Encounter surface",
  "status": "ACCEPTED",
  "type": "PUZZLE_INOUT",
  "nickname": "BLANC",
  "publicHandle": "536129a706d10fde191e6c5a46de1ff9b0f1",
  "codingamerHandle": "b12b98e075dfc70878c9c0b33f79db128934192",
  "lastVersion": {
    "version": 17,
    "autocloseTime": 1601022734329,
    "data": {
      "title": "Encounter surface",
      "topics": [
        {
          "id": 94,
          "handle": "mathematics",
          "labelMap": {
            "1": "Mathematics",
            "2": "Mathematics"
          },
          "puzzleCount": 19,
          "parentTopicId": 93
        },
        {
          "id": 95,
          "handle": "geometry",
          "labelMap": {
            "1": "Geometry",
            "2": "Geometry"
          },
          "puzzleCount": 5,
          "parentTopicId": 93
        }
      ],
      "solution": "import math\nimport copy\nfrom copy import *\nfrom math import *\n\ncoor1 = []\ncoor2 = []\nn = int(input())\nm = int(input())\nfor i in range(n):\n    x_1, y_1 = [float(j) for j in input().split()]\n    coor1.append((x_1, y_1))\nfor i in range(m):\n    x_2, y_2 = [float(j) for j in input().split()]\n    coor2.append((x_2, y_2))\n\ndef interieur(entree, point):\n    position = deepcopy(entree)\n    position.append(position[0])\n    somme = 0\n    for i in range(len(position) - 1):\n        a = position[i]\n        b = position[i + 1]\n\n        A = sqrt((a[0]- b[0])**2 +  (a[1] -b[1])**2)\n        B = sqrt((point[0]- a[0])**2 + (point[1]- a[1])**2)\n        C = sqrt((point[0]- b[0] )**2 + (point[1]- b[1])**2)\n\n        ax, ay = a[0] - point[0], a[1] - point[1]\n        bx, by = b[0] - point[0], b[1] - point[1]\n\n        if by * ax - bx * ay < 0:\n            somme += math.degrees(math.acos((B * B + C * C - A * A) / (2.0 * B * C)))\n        else:\n            somme -= math.degrees(math.acos((B * B + C * C - A * A) / (2.0 * B * C)))\n\n    if round(abs(somme)) == 360:\n        return True\n    return False\n\ndef aire(liste):\n    liste.append(liste[0])\n    somme1 = 0\n    somme2 = 0\n    for i in range(len(liste)-1):\n     \n         x1, y1 = liste[i]\n         x2, y2 = liste[i+1]\n         somme1 += x1*y2\n         somme2 += y1*x2\n\n    return -(somme1-somme2)/2\n\ndef rangement(liste):\n    sortie = []\n    sommex = sommey =0\n    for element in liste:\n        x, y = element\n        sommex += x - liste[0][0]\n        sommey += y - liste[0][1]\n\n    cx, cy = liste[0][0]+(1/len(liste))*sommex, liste[0][1]+(1/len(liste))* sommey\n\n    \n    for element in liste:\n        vecteurx = element[0] - cx\n        vecteury = element[1] - cy\n        p = -1 * vecteurx\n        if element[1] < cy:\n            angle = 360 - math.degrees(math.acos(p/(1*sqrt(vecteurx**2+vecteury**2))))\n        else:\n            angle = math.degrees(math.acos(p/(1*sqrt(vecteurx**2+vecteury**2))))\n\n        sortie.append((angle,element))\n    return [element for angle, element in sorted(sortie)]\n\n\ndef inter(x1, y1, x2, y2, x3, y3, x4, y4):\n    droite1 = droite2 = 0\n    try:\n        a1 = (y1-y2)/(x1-x2)\n    except ZeroDivisionError:\n        X1 = x1\n        droite1 = 1\n        a1 =\"\"\n\n    try:\n        a2 = (y3-y4)/(x3-x4)\n    except ZeroDivisionError:\n        X2 = x3\n        droite2 = 1\n        a2 =\"\"\n\n    if droite1 != 1:\n        try:\n            b1 = y1-(a1*x1)\n        except ZeroDivisionError:\n            b1 = y1\n\n    if droite2 !=1:\n        try:\n            b2 = y3-(a2*x3)\n        except ZeroDivisionError:\n            b2 = y3\n    \n    if not(droite1 == 1 and droite2 == 1):\n        if droite1 == 0 and droite2 == 0:\n            if a1 != a2:\n                interx = (b2-b1)/(a1-a2)\n                intery = a1*interx+b1\n                if min(x1,x2)<= interx and interx<=max(x1,x2):\n                    if min(x3,x4)<= interx and interx<=max(x3,x4):\n                        if min(y3,y4)<=intery and intery<=max(y3,y4):\n                            if min(y1,y2)<= intery and intery<=max(y1,y2):\n                                return interx, intery\n\n\n        if droite1 + droite2 == 1:\n            if droite1 == 1:\n                interx = X1\n                intery = a2*interx+b2\n                if min(y1, y2)<= intery and intery<=max(y1,y2) and min(x3,x4)<=interx and interx<=max(x3,x4):\n                    return interx,intery\n\n            if droite2 == 1:\n                interx = X2\n                intery = a1*interx+b1\n                if min(y3, y4)<= intery and intery<=max(y3,y4) and min(x1,x2)<=interx and interx<=max(x1,x2):\n                    return interx,intery\n            \n\ncoor1 = rangement(coor1)\ncoor2 = rangement(coor2)\n        \n\npolygone = []\nfor nb in range(len(coor1)):\n    x1, y1 = coor1[nb]\n    if nb+1 == len(coor1):\n        x2, y2 = coor1[0]\n    else:\n        x2, y2 = coor1[nb+1]\n\n    for nb in range(len(coor2)):\n        x3, y3 = coor2[nb]\n        if nb+1 == len(coor2):\n            x4, y4 = coor2[0]\n        else:\n            x4, y4 = coor2[nb+1]\n\n        if inter(x1, y1, x2, y2, x3, y3, x4, y4) is not None:\n            element1, element2 = inter(x1, y1, x2, y2, x3, y3, x4, y4)\n            if (round(element1,2),round(element2,2)) not in polygone:\n                polygone.append((round(element1,2),round(element2,2)))\n\n\n\n\nfor element in coor1:\n    try:\n        if interieur(coor2, element) and element not in polygone:\n            polygone.append(element)\n    except ValueError:\n        pass\n\n\nfor element in coor2:\n    try:\n        if interieur(coor1, element) and element not in polygone:\n            polygone.append(element)\n    except ValueError:\n        pass\n\n\nif len(polygone)>0:\n    polygone = rangement(polygone)\n    print(ceil(aire(polygone)))\nelse:\n    print(0)\n",
      "statement": "We consider a strategy game in which two players compete against each other. Players manipulate two armies.\nThe area that each army occupies can be modeled with a single polygon. \n\nWhen the armies fight each other, they can both cover the same zone, the area where the two polygons overlap is called the \"Encounter Surface.\"\n<<The goal of the puzzle is to create a tool that can show the players the area of this zone.>>",
      "testCases": [
        {
          "title": "First contact",
          "isTest": true,
          "testIn": "5\n4\n1 1\n1 3\n3 4\n5 2\n4 0\n3 3\n3 1\n0 0\n-1 4",
          "testOut": "5",
          "isValidator": false,
          "needValidation": false
        },
        {
          "title": "Validator First contact",
          "isTest": false,
          "testIn": "5\n5\n1 1\n1 3\n3 4\n5 2\n4 0\n3 3\n4 2\n3 1\n0 0\n-7 4",
          "testOut": "6",
          "isValidator": true,
          "needValidation": false
        },
        {
          "title": "Real case",
          "isTest": true,
          "testIn": "7\n6\n1 -2\n6 0\n0 1\n4 -4\n5 -3\n5 1\n3 -4\n4 -1\n-1 0\n4 -3\n3 0\n0 -4\n1 1",
          "testOut": "11",
          "isValidator": false,
          "needValidation": false
        },
        {
          "title": "Validator Real case",
          "isTest": false,
          "testIn": "5\n6\n5 0\n10 -15\n15 -10\n5 -10\n15 0\n-10 10\n0 -10\n15 7\n10 10\n10 -5\n-10 -10",
          "testOut": "37",
          "isValidator": true,
          "needValidation": false
        },
        {
          "title": "Great battle",
          "isTest": true,
          "testIn": "10\n10\n9 0\n11 1\n-5 5\n-1 7\n3 8\n-4 1\n-1 -1\n7 7\n4 -2\n11 4\n5 -10\n-7 0\n-5 -8\n10 1\n10 -7\n-1 6\n4 6\n-7 -4\n-6 4\n9 3",
          "testOut": "85",
          "isValidator": false,
          "needValidation": false
        },
        {
          "title": "Validator Great battle",
          "isTest": false,
          "testIn": "10\n10\n-15 10\n-3 7\n-3 12\n-2 8\n-12 -1\n-10 0\n-2 11\n-15 3\n-6 13\n-11 12\n2 12\n-7 14\n-4 15\n-7 9\n-4 8\n3 10\n-5 8\n-8 10\n0 15\n-9 12",
          "testOut": "25",
          "isValidator": true,
          "needValidation": false
        },
        {
          "title": "Huge area",
          "isTest": true,
          "testIn": "14\n12\n1 5\n-7 5\n5 0\n-8 2\n-7 -3\n-2 -5\n5 -1\n4 3\n-4 6\n1 -5\n-6 -4\n-8 4\n-3 6\n4 -3\n3 -1\n-4 7\n-7 0\n3 7\n-6 5\n4 5\n-5 -4\n-7 2\n-6 -3\n0 8\n1 -4\n1 8",
          "testOut": "88",
          "isValidator": false,
          "needValidation": false
        },
        {
          "title": "Validator Huge area",
          "isTest": false,
          "testIn": "13\n15\n5 -1\n-2 12\n-3 -2\n0 -4\n-4 10\n7 7\n1 13\n7 9\n6 2\n-5 4\n6 11\n3 -4\n-5 8\n-5 15\n4 7\n-1 -5\n2 -6\n-3 16\n-1 15\n5 -6\n-6 10\n2 11\n-5 2\n-6 7\n-4 -1\n6 -1\n-3 -3\n6 -4",
          "testOut": "129",
          "isValidator": true,
          "needValidation": false
        },
        {
          "title": "No contact",
          "isTest": true,
          "testIn": "5\n5\n6 -3\n6 -10\n3 -3\n3 -10\n0 -6\n-5 5\n-5 0\n0 0\n5 0\n0 5",
          "testOut": "0",
          "isValidator": false,
          "needValidation": false
        },
        {
          "title": "Validator No contact",
          "isTest": false,
          "testIn": "6\n5\n6 -10\n3 -3\n6 -3\n3 -10\n10 -7\n0 -6\n-5 5\n-5 0\n0 -5\n5 0\n0 5",
          "testOut": "0",
          "isValidator": true,
          "needValidation": false
        },
        {
          "title": "Side superposition",
          "isTest": true,
          "testIn": "4\n4\n0 0\n5 5\n5 0\n0 5\n-2 5\n3 0\n-2 0\n3 5",
          "testOut": "15",
          "isValidator": false,
          "needValidation": false
        },
        {
          "title": "Validator Side superposition",
          "isTest": false,
          "testIn": "6\n6\n9 3\n0 3\n6 6\n0 0\n3 6\n9 0\n12 -2\n0 -2\n7 5\n12 0\n0 2\n3 5",
          "testOut": "39",
          "isValidator": true,
          "needValidation": false
        }
      ],
      "difficulty": "hard",
      "constraints": "¤ -16 ≤ [[x_1]], [[y_1]], [[x_2]], [[y_2]] ≤ 16\n¤ 4 ≤ [[n]], [[m]] ≤ 15\n¤ The vertices of the polygons are not necessarily given in the order.\n¤ The polygons representing the armies are convex polygons.\n¤ There is at most one encounter surface.\n¤ The sides of the polygons can be superposed that is to say that the sides of the polygons are merged together.",
      "coverBinaryId": 48936903686707,
      "stubGenerator": "read n:int\nread m:int\nloop n read x1:int y1:int\nloop m read x2:int y2:int\nwrite 5",
      "inputDescription": "<<Line 1:>> An integer [[n]] representing the number of vertices of the polygon modeling army 1.\n<<Line 2:>> An integer [[m]] representing the number of vertices of the polygon modeling army 2.\n<<Next [[n]] lines:>> Two integers [[x_1]] and [[y_1]] representing the coordinates of each vertex of polygon 1.\n<<Next [[m]] lines:>> Two integers [[x_2]] and [[y_2]] representing the coordinates of each vertex of polygon 2.",
      "solutionLanguage": "Python3",
      "outputDescription": "An integer (round up) representing the area of the \"Encounter Surface.\""
    },
    "draft": false,
    "readyForModeration": true,
    "statementHTML": "<div class=\"statement-body\">\n<div class=\"statement-section statement-goal\">\n   <h2><span class=\"icon icon-goal\">&nbsp;</span><span>Goal </span></h2>\n   <span class=\"question-statement\">We consider a strategy game in which two players compete against each other. Players manipulate two armies.<br>The area that each army occupies can be modeled with a single polygon. <br><br>When the armies fight each other, they can both cover the same zone, the area where the two polygons overlap is called the &quot;Encounter Surface.&quot;<br><strong>The goal of the puzzle is to create a tool that can show the players the area of this zone.</strong></span>\n</div>\n<div class=\"statement-section statement-protocol\">\n   <div class=\"blk\">\n      <div class=\"title\">Input</div>\n      <div class=\"question-statement-input\"><strong>Line 1:</strong> An integer <var>n</var> representing the number of vertices of the polygon modeling army 1.<br><strong>Line 2:</strong> An integer <var>m</var> representing the number of vertices of the polygon modeling army 2.<br><strong>Next <var>n</var> lines:</strong> Two integers <var>x_1</var> and <var>y_1</var> representing the coordinates of each vertex of polygon 1.<br><strong>Next <var>m</var> lines:</strong> Two integers <var>x_2</var> and <var>y_2</var> representing the coordinates of each vertex of polygon 2.</div>\n   </div>\n   <div class=\"blk\">\n      <div class=\"title\">Output</div>\n      <div class=\"question-statement-output\">An integer (round up) representing the area of the &quot;Encounter Surface.&quot;</div>\n   </div>\n   <div class=\"blk\">\n      <div class=\"title\">Constraints</div>\n      <div class=\"question-statement-constraints\">&curren; -16 &le; <var>x_1</var>, <var>y_1</var>, <var>x_2</var>, <var>y_2</var> &le; 16<br>&curren; 4 &le; <var>n</var>, <var>m</var> &le; 15<br>&curren; The vertices of the polygons are not necessarily given in the order.<br>&curren; The polygons representing the armies are convex polygons.<br>&curren; There is at most one encounter surface.<br>&curren; The sides of the polygons can be superposed that is to say that the sides of the polygons are merged together.</div>\n   </div>\n   <div class=\"blk\">\n      <div class=\"title\">Example</div>\n      <div class=\"statement-inout\">\n         <div class=\"statement-inout-in\">\n            <div class=\"title\">Input</div>\n            <pre class=\"question-statement-example-in\">5\n4\n1 1\n1 3\n3 4\n5 2\n4 0\n3 3\n3 1\n0 0\n-1 4</pre>\n         </div>\n         <div class=\"statement-inout-out\">\n            <div class=\"title\">Output</div>\n            <pre class=\"question-statement-example-out\">5</pre>\n         </div>\n      </div>\n   </div>\n</div>"
  },
  "validatedFor": 171179252626,
  "avatar": 46459187054094,
  "commentCount": 25,
  "upVotes": 5,
  "downVotes": 0,
  "validateAction": {
    "actionId": 488690,
    "progress": 1,
    "alreadyDone": false
  },
  "statusHistory": [
    {
      "status": "ACCEPTED",
      "date": 1599551692276,
      "data": {
        "author": "ACTION"
      }
    }
  ],
  "editable": true,
  "draft": false,
  "readyForModeration": true
}