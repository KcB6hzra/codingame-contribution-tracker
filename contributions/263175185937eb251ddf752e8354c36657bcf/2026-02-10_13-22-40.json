{
  "id": 26317,
  "activeVersion": 11,
  "score": 7,
  "votableId": 24751966,
  "codingamerId": 4964147,
  "views": 265,
  "commentableId": 24633264,
  "title": "Frog Exchange",
  "status": "ACCEPTED",
  "type": "PUZZLE_INOUT",
  "nickname": "Ah3n0bar6us",
  "publicHandle": "263175185937eb251ddf752e8354c36657bcf",
  "codingamerHandle": "1baef31501f525ce852e7bd5544c63e57414694",
  "lastVersion": {
    "version": 11,
    "autocloseTime": 1661499038438,
    "data": {
      "title": "Frog Exchange",
      "topics": [
        {
          "id": 112,
          "handle": "string-manipulation",
          "category": "FUNDAMENTALS",
          "labelMap": {
            "1": "String manipulation",
            "2": "String manipulation"
          },
          "puzzleCount": 37,
          "parentTopicId": 93
        },
        {
          "id": 45,
          "handle": "conditions",
          "category": "FUNDAMENTALS",
          "labelMap": {
            "1": "Conditions",
            "2": "Conditions"
          },
          "pageTitle": "Conditions: exercises and theory",
          "puzzleCount": 60,
          "parentTopicId": 39,
          "contentDetailsId": 68
        },
        {
          "id": 54,
          "handle": "BFS",
          "category": "ADVANCED",
          "labelMap": {
            "1": "Parcours en largeur",
            "2": "BFS"
          },
          "pageTitle": "BFS: exercises and theory",
          "puzzleCount": 33,
          "parentTopicId": 41,
          "contentDetailsId": 84
        },
        {
          "id": 55,
          "handle": "DFS",
          "category": "ADVANCED",
          "labelMap": {
            "1": "Parcours en profondeur",
            "2": "DFS"
          },
          "pageTitle": "DFS: exercises and theory",
          "puzzleCount": 21,
          "parentTopicId": 41,
          "contentDetailsId": 79
        }
      ],
      "solution": "import re\na = input().split()\naLen = len(a)\n# copy list without reference\nchangedList = a.copy()\n\n# check if  any frog is available (just one check needed bc m=f)\nif ('m' in a):\n\n    # Schema: f=m=3 -> len(a)=7\n    # run1: f 1time\n    # run2: m 2times\n    # run3: f 3times\n    # run4: m 3times\n    # run5: f 3times\n    # run6: m 2times\n    # run7: f 1time\n\n    print(\" \".join(changedList))\n    gender='f'\n    if 'f' in a[0]:\n        maleLeft=True\n    else:\n        maleLeft=False\n    # run the first half of the jump sequence\n    for jumps in range(1, (len(changedList)//2+1)): #jumps = 2*m+1 or 2*f+1 = len(a)\n        # check #jumps-frogs from one site \n        for frog in range(jumps):\n            freeStone = changedList.index('s')\n            if maleLeft:\n                changedList[[m.start() for m in re.finditer(gender,\"\".join(changedList))][::-1][frog]] = 's'\n                changedList[freeStone] = gender\n            else:\n                changedList[[m.start() for m in re.finditer(gender,\"\".join(changedList))][frog]] = 's'\n                changedList[freeStone] = gender\n            print(\" \".join(changedList))\n        if 'f' in gender: \n            gender='m' \n        else: gender='f'\n        if maleLeft: \n            maleLeft=False \n        else: maleLeft=True\n\n    # run the middle of the sequence once\n    for frog in range(len(a)//2):\n        freeStone = changedList.index('s')\n        if maleLeft:\n            changedList[[m.start() for m in re.finditer(gender,\"\".join(changedList))][::-1][frog]] = 's'\n            changedList[freeStone] = gender\n        else:\n            changedList[[m.start() for m in re.finditer(gender,\"\".join(changedList))][frog]] = 's'\n            changedList[freeStone] = gender\n        print(\" \".join(changedList))\n    if 'f' in gender: \n        gender='m' \n    else: gender='f'\n    if maleLeft: \n        maleLeft=False \n    else: maleLeft=True\n\n    # run the second half of the jump sequence\n    for jumps in reversed(range(1, (len(changedList)//2+1))): #jumps = 2*m+1 or 2*f+1 = len(a)\n        # check #jumps-frogs from one site \n        for frog in range(jumps):\n            freeStone = changedList.index('s')\n            if maleLeft:\n                changedList[[m.start() for m in re.finditer(gender,\"\".join(changedList))][jumps-1-frog]] = 's'\n                changedList[freeStone] = gender\n            else:\n                changedList[[m.start() for m in re.finditer(gender,\"\".join(changedList))][::-1][jumps-1-frog]] = 's'\n                changedList[freeStone] = gender\n            print(\" \".join(changedList))\n        if 'f' in gender: \n            gender='m' \n        else: gender='f'\n        if maleLeft: \n            maleLeft=False \n        else: maleLeft=True\nelse:\n    print(\" \".join(changedList))",
      "statement": "@@\n( — )\n(>___<)\n^^'''^^\n\nAvoid deadlocks:\nGiven are [[n]] stones as array. The middle stone {{s}} is unoccupied at the start. On each of the left ([[n]]-1)/2 stones sits a male {{m}} frog looking to the right; on each of the right ([[n]]-1)/2 stones is a female {{f}} frog looking to the left.\n(m)> (m)> (m)> (m)> ... (m)> s <(f) ... <(f) <(f) <(f) <(f)\n\nThe frogs can only jump in the direction they are facing. If the corresponding neighboring stone is free, the frog can jump directly to this stone. It is also possible to jump over <<one>> neighboring frog in order to get to a corresponding free stone.\n\nWe are looking for a sequence of jumps such that all male frogs are on the right (n-1)/2 stones and all female frogs are on the left (n-1)/2 stones. if there is no frog, return the input.\n\nMale and female start positions can also be reversed, in which case their end position is also reversed.\n\nSchematic example:\nn=3, m=f=1\n(m s f) -> start with f and jump just to the left\n(m f s) -> a new stone is free\n(m f s) -> consider the next possible male frog(s) and jump to the free stone\n(s f m) -> a new stone is free\n(s f m) -> consider the next possible female fog(s) and jump to the free stone\n(f s m) -> a new stone is free\n(f s m) -> result \n\nOutput:\nReturn the state of the array on a separate line after each round.\n\n<<Be courteous and start with the ladies.>>",
      "testCases": [
        {
          "title": "n=3 m starts left",
          "isTest": true,
          "testIn": "m s f",
          "testOut": "m s f\nm f s\ns f m\nf s m",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "n=3 f starts left",
          "isTest": false,
          "testIn": "f s m",
          "testOut": "f s m\ns f m\nm f s\nm s f",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "n=5 f starts left",
          "isTest": true,
          "testIn": "f f s m m",
          "testOut": "f f s m m\nf s f m m\nf m f s m\nf m f m s\nf m s m f\ns m f m f\nm s f m f\nm m f s f\nm m s f f",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "n=5 m starts left",
          "isTest": false,
          "testIn": "m m s f f",
          "testOut": "m m s f f\nm m f s f\nm s f m f\ns m f m f\nf m s m f\nf m f m s\nf m f s m\nf s f m m\nf f s m m",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "n=11 m starts left",
          "isTest": true,
          "testIn": "m m m m m s f f f f f",
          "testOut": "m m m m m s f f f f f\nm m m m m f s f f f f\nm m m m s f m f f f f\nm m m s m f m f f f f\nm m m f m s m f f f f\nm m m f m f m s f f f\nm m m f m f m f s f f\nm m m f m f s f m f f\nm m m f s f m f m f f\nm m s f m f m f m f f\nm s m f m f m f m f f\nm f m s m f m f m f f\nm f m f m s m f m f f\nm f m f m f m s m f f\nm f m f m f m f m s f\nm f m f m f m f m f s\nm f m f m f m f s f m\nm f m f m f s f m f m\nm f m f s f m f m f m\nm f s f m f m f m f m\ns f m f m f m f m f m\nf s m f m f m f m f m\nf f m s m f m f m f m\nf f m f m s m f m f m\nf f m f m f m s m f m\nf f m f m f m f m s m\nf f m f m f m f s m m\nf f m f m f s f m m m\nf f m f s f m f m m m\nf f s f m f m f m m m\nf f f s m f m f m m m\nf f f f m s m f m m m\nf f f f m f m s m m m\nf f f f m f s m m m m\nf f f f s f m m m m m\nf f f f f s m m m m m",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "n=11 f starts left",
          "isTest": false,
          "testIn": "f f f f f s m m m m m",
          "testOut": "f f f f f s m m m m m\nf f f f s f m m m m m\nf f f f m f s m m m m\nf f f f m f m s m m m\nf f f f m s m f m m m\nf f f s m f m f m m m\nf f s f m f m f m m m\nf f m f s f m f m m m\nf f m f m f s f m m m\nf f m f m f m f s m m\nf f m f m f m f m s m\nf f m f m f m s m f m\nf f m f m s m f m f m\nf f m s m f m f m f m\nf s m f m f m f m f m\ns f m f m f m f m f m\nm f s f m f m f m f m\nm f m f s f m f m f m\nm f m f m f s f m f m\nm f m f m f m f s f m\nm f m f m f m f m f s\nm f m f m f m f m s f\nm f m f m f m s m f f\nm f m f m s m f m f f\nm f m s m f m f m f f\nm s m f m f m f m f f\nm m s f m f m f m f f\nm m m f s f m f m f f\nm m m f m f s f m f f\nm m m f m f m f s f f\nm m m f m f m s f f f\nm m m f m s m f f f f\nm m m s m f m f f f f\nm m m m s f m f f f f\nm m m m m f s f f f f\nm m m m m s f f f f f",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "No frog one stone",
          "isTest": true,
          "testIn": "s",
          "testOut": "s",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "No frog one stone",
          "isTest": false,
          "testIn": "s",
          "testOut": "s",
          "isValidator": true,
          "needValidation": true
        }
      ],
      "difficulty": "medium",
      "constraints": "1 ≤ [[n]] ≤ 11\n[[n]] is odd\nnumber of {{m}} = number of {{f}}",
      "coverBinaryId": 87748729811125,
      "stubGenerator": "read A:string(256)\n\nwrite m s f\ns m f\nf m s\nf s m",
      "inputDescription": "<<Line 1:>> A string with frog position",
      "solutionLanguage": "Python3",
      "outputDescription": "<<Line 1:>> starting grid\n<<Line 2:>> first move\n..\n<<Last line:>> final grid"
    },
    "draft": false,
    "readyForModeration": true,
    "statementHTML": "<div class=\"statement-body\">\n<div class=\"statement-section statement-goal\">\n   <h2><span class=\"icon icon-goal\">&nbsp;</span><span>Goal </span></h2>\n   <span class=\"question-statement\">@@<br>( &mdash; )<br>(&gt;___&lt;)<br>^^'''^^<br><br>Avoid deadlocks:<br>Given are <var>n</var> stones as array. The middle stone <const>s</const> is unoccupied at the start. On each of the left (<var>n</var>-1)/2 stones sits a male <const>m</const> frog looking to the right; on each of the right (<var>n</var>-1)/2 stones is a female <const>f</const> frog looking to the left.<br>(m)&gt; (m)&gt; (m)&gt; (m)&gt; ... (m)&gt; s &lt;(f) ... &lt;(f) &lt;(f) &lt;(f) &lt;(f)<br><br>The frogs can only jump in the direction they are facing. If the corresponding neighboring stone is free, the frog can jump directly to this stone. It is also possible to jump over <strong>one</strong> neighboring frog in order to get to a corresponding free stone.<br><br>We are looking for a sequence of jumps such that all male frogs are on the right (n-1)/2 stones and all female frogs are on the left (n-1)/2 stones. if there is no frog, return the input.<br><br>Male and female start positions can also be reversed, in which case their end position is also reversed.<br><br>Schematic example:<br>n=3, m=f=1<br>(m s f) -&gt; start with f and jump just to the left<br>(m f s) -&gt; a new stone is free<br>(m f s) -&gt; consider the next possible male frog(s) and jump to the free stone<br>(s f m) -&gt; a new stone is free<br>(s f m) -&gt; consider the next possible female fog(s) and jump to the free stone<br>(f s m) -&gt; a new stone is free<br>(f s m) -&gt; result <br><br>Output:<br>Return the state of the array on a separate line after each round.<br><br><strong>Be courteous and start with the ladies.</strong></span>\n</div>\n<div class=\"statement-section statement-protocol\">\n   <div class=\"blk\">\n      <div class=\"title\">Input</div>\n      <div class=\"question-statement-input\"><strong>Line 1:</strong> A string with frog position</div>\n   </div>\n   <div class=\"blk\">\n      <div class=\"title\">Output</div>\n      <div class=\"question-statement-output\"><strong>Line 1:</strong> starting grid<br><strong>Line 2:</strong> first move<br>..<br><strong>Last line:</strong> final grid</div>\n   </div>\n   <div class=\"blk\">\n      <div class=\"title\">Constraints</div>\n      <div class=\"question-statement-constraints\">1 &le; <var>n</var> &le; 11<br><var>n</var> is odd<br>number of <const>m</const> = number of <const>f</const></div>\n   </div>\n   <div class=\"blk\">\n      <div class=\"title\">Example</div>\n      <div class=\"statement-inout\">\n         <div class=\"statement-inout-in\">\n            <div class=\"title\">Input</div>\n            <pre class=\"question-statement-example-in\">m s f</pre>\n         </div>\n         <div class=\"statement-inout-out\">\n            <div class=\"title\">Output</div>\n            <pre class=\"question-statement-example-out\">m s f\nm f s\ns f m\nf s m</pre>\n         </div>\n      </div>\n   </div>\n</div>"
  },
  "validatedFor": 109301369375,
  "avatar": 86774786488648,
  "commentCount": 17,
  "upVotes": 10,
  "downVotes": 3,
  "validateAction": {
    "actionId": 685348,
    "progress": 1,
    "alreadyDone": false
  },
  "statusHistory": [
    {
      "status": "ACCEPTED",
      "date": 1661428389327,
      "data": {
        "author": "ACTION"
      }
    }
  ],
  "editable": true,
  "draft": false,
  "readyForModeration": true
}