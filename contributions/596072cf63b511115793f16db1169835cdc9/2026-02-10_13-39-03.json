{
  "id": 5960,
  "activeVersion": 4,
  "score": 37,
  "votableId": 16452453,
  "codingamerId": 1400179,
  "views": 780,
  "commentableId": 16364513,
  "title": "Chess",
  "status": "ACCEPTED",
  "type": "PUZZLE_MULTI",
  "nickname": "reCurse",
  "publicHandle": "596072cf63b511115793f16db1169835cdc9",
  "codingamerHandle": "e16f1e97c5a70becf16fa6a096e5f9459710041",
  "lastVersion": {
    "version": 4,
    "autocloseTime": 1613576374732,
    "data": {
      "title": "Chess",
      "topics": [
        {
          "id": 137,
          "handle": "chess",
          "labelMap": {
            "1": "chess",
            "2": "chess"
          },
          "puzzleCount": 4,
          "parentTopicId": 93
        }
      ],
      "refereeMd5": "1400179/f7aab2986793df636ebddce96f864eef",
      "testHandle": "865494807d115f7493e0b7fa465bc5d2780647",
      "viewerCode": "var Drawer=function(e){var t={};function r(n){if(t[n])return t[n].exports;var i=t[n]={i:n,l:!1,exports:{}};return e[n].call(i.exports,i,i.exports,r),i.l=!0,i.exports}return r.m=e,r.c=t,r.d=function(e,t,n){r.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:n})},r.r=function(e){\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(e,\"__esModule\",{value:!0})},r.t=function(e,t){if(1&t&&(e=r(e)),8&t)return e;if(4&t&&\"object\"==typeof e&&e&&e.__esModule)return e;var n=Object.create(null);if(r.r(n),Object.defineProperty(n,\"default\",{enumerable:!0,value:e}),2&t&&\"string\"!=typeof e)for(var i in e)r.d(n,i,function(t){return e[t]}.bind(null,i));return n},r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,\"a\",t),t},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r.p=\"\",r(r.s=0)}([function(e,t,r){\"use strict\";r.r(t),r.d(t,\"Drawer\",(function(){return j}));var n={baseUrl:\"https://cdn-games.codingame.com/community/1400179-1608661730422/\",images:{\"BlackQueen.png\":\"9c6ea733e3e2658672a0467a96d7c0164ae0e70f4c5621cf3844466d06f3b738.png\",\"SmallWhiteBishop.png\":\"7057b1c1ba0ba1c978efc84da7315a3454337bcc05bea5267010f8c726e70d1e.png\",\"SmallWhiteRook.png\":\"59b18fbe3f09f119b9ce91b80dbf83da64181ac57bd264eff463e154854f8aca.png\",\"WhiteKnight.png\":\"c086448c1b8270f6b53a1708b431437bd455fb23a14f758cd9b4c4b015c84d76.png\",\"PromotedWhiteRook.png\":\"102d029bc97ff6ea628881dfffaa8646e5066178fefc954d2d19992c4603a6f6.png\",\"WhiteRook.png\":\"c32613c64447dee3d5aecccdf9d505de8686a1cd8a4bf3e08aa621defc20a254.png\",\"BlackKing.png\":\"4d5be1cef221eff09b7c02342f8e70774b2dc78015e54abcdc37ae7364cb4844.png\",\"PromotedWhitePawn.png\":\"9fd611e000e8868d408a57a7f5ec549765201630653c60506f9e996975c2f945.png\",\"PromotedBlackQueen.png\":\"3d53e18c60bf6cf1c418b934e77703fcbbab84f8f1608374ecba3526938876ba.png\",\"PromotedBlackRook.png\":\"4b8bc4275758574eaa0372dca8f6d1813d79b38aef21155bb5254c4ae17f86cd.png\",\"SmallBlackKnight.png\":\"e6b0990f200a0879562b9e465d6378188ed5de5be141ad206565c1b403a188d8.png\",\"SmallWhiteQueen.png\":\"d6959784c7173bc6443c563bea31f6bdd1539f1a5f753bafec36bb6a6d46c980.png\",\"BlackKnight.png\":\"49b89b956bce3b2be6094c80a357130f88ee980e580669880d521f2ec22e2390.png\",\"PromotedBlackKnight.png\":\"40b79549826a7c0dedb879caadeb6ed1c0fbf8207870897e03d6ce8daab0dcff.png\",\"BlackRook.png\":\"614f2641f554d36de765dbc4cbe37f18e71f631b0e0b49911890eda865b9c111.png\",\"WhitePawn.png\":\"49aa8ee491b66428a7bb5ea9ded544912d45a73d865de1ed92c3c93f16ef0c74.png\",\"BlackPawn.png\":\"e9040ba588886bd0084b478f6a81c06b14581553847823b605201e41fb407343.png\",\"SmallWhitePawn.png\":\"64257f2fcf64e42792a3cf93dd6c4104f4b12f057a9df1071987a396c6b8e878.png\",\"SmallBlackRook.png\":\"ea33eebcc4c50fcd16a5a1365a19540dae21b0632d9fb2d2e286a58790b9e240.png\",\"SmallBlackPawn.png\":\"7f50a8aa2bea4012055b61efc2c4be5d68b554d2b1b03dedbabc55236687467a.png\",\"SmallBlackQueen.png\":\"d711df9220ebf21bb1d29a075cc5f9388b3af9fd6803b48722e97db12eb9aa79.png\",\"WhiteKing.png\":\"86ed79678e932c4afb75d1a728bf0164add60837c7f86daedeba6e06e21dee8a.png\",\"PromotedWhiteKing.png\":\"186cad61643d7c15ee16edac67f5f6f03c979940dbc90b9dd9f39e518cde2d18.png\",\"SmallWhiteKing.png\":\"2ef81eda1da338ced44ee0ec4771a50d1b231db6c99a2b0e4652900f09851d4e.png\",\"SmallBlackKing.png\":\"8d9f1f6d6adace963d8719c1ee22d5b8b933fe2ff8fa0a8a473b03e44ad7bd56.png\",\"SmallWhiteKnight.png\":\"8b772967830d48771670371a1dbc653c1a1fe6065ee3cb7904f24edd1ee466a6.png\",\"PromotedWhiteKnight.png\":\"6305e9a974dd479741dc3125faa021c767d59f88e1d28bd308d6c58665af0653.png\",\"WhiteBishop.png\":\"17f5235cd935c08dd3dfc13b1ee0c8dca76ed5583d97c5453240b691bcf26cf9.png\",\"PromotedBlackBishop.png\":\"0ad29fb94514a05f88e182a766cd954307566d86f5dd2d99165795a9597ad3de.png\",\"PromotedBlackKing.png\":\"3a9883560d76b5645292e563ca016354a7d66a6f995c395a45efa0b3acb65806.png\",\"PromotedBlackPawn.png\":\"e9040ba588886bd0084b478f6a81c06b14581553847823b605201e41fb407343.png\",\"SmallBlackBishop.png\":\"328777a73a6bc5a59e7aabf80d7ab1f0bd106f73d9bd24fba97154844131b073.png\",\"PromotedWhiteBishop.png\":\"0b7b5fb92c51d6ea2d3acf76d973225090dc00d84c33f4a376be4e1b7f2bc871.png\",\"WhiteQueen.png\":\"8f8002d564fdc02bc77fa4be338db3158b747978045dc229845d8db743cf3228.png\",\"BlackBishop.png\":\"f9d106865e4dad527734938ed1c89511fc355c08579e4e2b5dced9c3c1989922.png\",\"PromotedWhiteQueen.png\":\"7fe56d99534c3691927ffd79313789a69e962896fab6934d13b82a61c40bea71.png\"},sprites:[],fonts:[]},i=1920,a=1080,s=8,o=8,c=40,h=125,u=48;function d(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}var l=function(){function e(t){!function(t){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}(this),this.factory=t,this.objects=[]}var t,r;return t=e,(r=[{key:\"acquire\",value:function(){return 0!=this.objects.length?this.objects.pop():this.factory()}},{key:\"release\",value:function(e){e&&this.objects.push(e)}},{key:\"clear\",value:function(){this.objects.length=0}}])&&d(t.prototype,r),e}();function f(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}var p=function(){function e(){!function(t){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}(this)}var t,r;return t=e,(r=[{key:\"init\",value:function(){var e=[\"WhitePawn.png\",\"WhiteKnight.png\",\"WhiteBishop.png\",\"WhiteRook.png\",\"WhiteQueen.png\",\"WhiteKing.png\",\"BlackPawn.png\",\"BlackKnight.png\",\"BlackBishop.png\",\"BlackRook.png\",\"BlackQueen.png\",\"BlackKing.png\"];this.textures=e.map((function(e){return PIXI.Texture.from(e)})),this.texturesSmall=e.map((function(e){return PIXI.Texture.from(\"Small\"+e)})),this.texturesPromoted=e.map((function(e){return PIXI.Texture.from(\"Promoted\"+e)})),this.pieces=\"PNBRQKpnbrqk\",this.sprites=new l((function(){return new PIXI.Sprite}))}},{key:\"close\",value:function(){}},{key:\"getTexture\",value:function(e,t){if(-1!=(e=this.pieces.indexOf(e)))return(\"small\"==t?this.texturesSmall:\"promoted\"==t?this.texturesPromoted:this.textures)[e]}},{key:\"acquireSprite\",value:function(e,t){var r=this.sprites.acquire();return r.texture=this.getTexture(e,t),r}},{key:\"releaseSprite\",value:function(e){this.sprites.release(e)}}])&&f(t.prototype,r),e}();function m(e,t){return function(e){if(Array.isArray(e))return e}(e)||function(e,t){if(\"undefined\"!=typeof Symbol&&Symbol.iterator in Object(e)){var r=[],n=!0,i=!1,a=void 0;try{for(var s,o=e[Symbol.iterator]();!(n=(s=o.next()).done)&&(r.push(s.value),!t||r.length!==t);n=!0);}catch(e){i=!0,a=e}finally{try{n||null==o.return||o.return()}finally{if(i)throw a}}return r}}(e,t)||y(e,t)||function(){throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\")}()}function g(e,t){var r;if(\"undefined\"==typeof Symbol||null==e[Symbol.iterator]){if(Array.isArray(e)||(r=y(e))||t&&e&&\"number\"==typeof e.length){r&&(e=r);var n=0;return{s:t=function(){},n:function(){return n>=e.length?{done:!0}:{done:!1,value:e[n++]}},e:function(e){throw e},f:t}}throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\")}var i,a=!0,s=!1;return{s:function(){r=e[Symbol.iterator]()},n:function(){var e=r.next();return a=e.done,e},e:function(e){s=!0,i=e},f:function(){try{a||null==r.return||r.return()}finally{if(s)throw i}}}}function y(e,t){if(e){if(\"string\"==typeof e)return v(e,t);var r=Object.prototype.toString.call(e).slice(8,-1);return\"Object\"===r&&e.constructor&&(r=e.constructor.name),\"Map\"===r||\"Set\"===r?Array.from(e):\"Arguments\"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)?v(e,t):void 0}}function v(e,t){(null==t||t>e.length)&&(t=e.length);for(var r=0,n=new Array(t);r<t;r++)n[r]=e[r];return n}function b(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}function x(e,t,r){return t&&b(e.prototype,t),r&&b(e,r),e}var T=[function(){function e(){!function(t){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}(this),this.resources=new p}return x(e,null,[{key:\"name\",get:function(){return\"chess\"}}]),x(e,[{key:\"handleFrameData\",value:function(e,t){t.frame=e.number;var r=t.fen.split(\" \");e=r[0];t.pieces=[];var n,i=\"pnbrq\",a=[0,0,0,0,0],c=[[0,0,0,0,0],[0,0,0,0,0]],h=0,u=o-1,d=g(e);try{for(d.s();!(n=d.n()).done;)\"/\"==(f=n.value)?(u--,h=0):f.charCodeAt(0)>=\"1\".charCodeAt(0)&&f<=\"9\".charCodeAt(0)?h+=f.charCodeAt(0)-\"0\".charCodeAt(0):\"~\"==f?t.pieces[t.pieces.length-1].promoted=!0:(n=i.indexOf(f.toLowerCase()),0<=u&&u<o&&0<=h&&h<s?(t.pieces.push({pieceChar:f,column:h,row:u}),-1!=n&&(a[n]+=f==f.toUpperCase()?1:-1)):u<0&&-1!=n&&c[f==f.toUpperCase()?0:1][n]++,h++)}catch(e){d.e(e)}finally{d.f()}t.color=\"w\"==r[1]?\"b\":\"w\",t.castling=r[2],t.fiftyMove=r[4]/2,t.moveText=t.move?r[5]-(\"w\"==t.color?0:1)+(\"w\"==t.color?\".\":\"..\")+\" \"+t.move:\"\",t.captured=[\"\",\"\"];for(var l=0;l<5;l++)if(this.globalData.crazyHouse)for(var f=0;f<2;f++){var p=i[l];0==f&&(p=p.toUpperCase()),t.captured[f]+=p.repeat(c[f][l])}else 0<a[l]?t.captured[0]+=i[l].repeat(a[l]):a[l]<0&&(t.captured[1]+=i[l].toUpperCase().repeat(-a[l]));if(r=t.highlights,t.highlights=[],r){var m=g(r);try{for(m.s();!(y=m.n()).done;){var y=y.value;2==y.length&&(h=y.charCodeAt(0)-\"a\".charCodeAt(0),u=y.charCodeAt(1)-\"1\".charCodeAt(0),t.highlights.push([h,u]))}}catch(e){m.e(e)}finally{m.f()}}return this.frames.push(t),t}},{key:\"handleGlobalData\",value:function(e,t){this.players=e,this.globalData=t,this.frames=[];var r=document.getElementsByClassName(\"settings_panel_form\")[0];t=function(e,t,n){var i=document.getElementById(n);if(i)return i;var a=document.createElement(\"div\");a.className=\"settings_option\";var s=document.createElement(\"h3\");return s.innerText=e,a.appendChild(s),(i=document.createElement(t)).className=\"settings_button\",i.id=n,i.style.width=\"100%\",i.style.background=\"transparent\",i.style.color=\"#b3b9ad\",i.style.padding=\"3px\",i.readOnly=!0,i.onfocus=function(){this.select()},i.onfocusout=function(){this.selectionStart=this.selectionEnd},a.appendChild(i),r.appendChild(a),i};this.fenInput=t(\"FEN\",\"input\",\"chess_fen\"),this.fenInput.type=\"text\",this.pgnArea=t(\"PGN\",\"textarea\",\"chess_pgn\"),this.pgnArea.style.resize=\"none\",this.pgnArea.style.height=\"200px\",this.pgnArea.style.whiteSpace=\"pre\",this.pgnArea.value=\"\"}},{key:\"updateScene\",value:function(e,t,r,n){var i=1==r?t:e;if(this.frameNumber!==i.frame){if(this.frameNumber=i.frame,this.frameData=i,this.highlights&&this.container.removeChild(this.highlights),this.sprites){var s,d=g(this.sprites);try{for(d.s();!(s=d.n()).done;)(F=s.value).container&&(F.container.removeChild(F),delete F.container),this.resources.releaseSprite(F)}catch(e){d.e(e)}finally{d.f()}}this.sprites=[],this.highlights=new PIXI.Graphics;var l=g(i.highlights);try{for(l.s();!(f=l.n()).done;){var f=(p=m(f.value,2))[0],p=p[1];this.highlights.beginFill(15907603,.5),this.highlights.drawRect(c+f*h,c+(o-1-p)*h,h,h)}}catch(e){l.e(e)}finally{l.f()}this.container.addChild(this.highlights);var y,v=g(i.pieces);try{for(v.s();!(y=v.n()).done;){var b=y.value;null!=(F=this.resources.acquireSprite(b.pieceChar,b.promoted?\"promoted\":\"\"))&&(F.x=c+b.column*h,F.y=c+(o-1-b.row)*h,F.width=h,F.height=h,F.container=this.container,this.container.addChild(F),this.sprites.push(F))}}catch(e){v.e(e)}finally{v.f()}this.moveText.style.fill=\"w\"==i.color?\"#ebeef1\":\"#abaea1\",this.moveText.text=i.moveText,this.castlingText.text=i.castling,this.fiftyMoveText.text=i.fiftyMove,this.gameText.text=i.game+1,this.statusText.text=i.status,this.commentText.text=i.comment;for(var x=0;x<2;x++){var T=0==x?a-c-h:c,w=0==i.game?x:1-x;this.playerContainers[w].y=T,(T=this.playerNames[w].style).fill=0==x?\"#ebeef1\":\"#24211e\",T.stroke=0==x?\"#34312ee0\":\"#abaea1e0\",T.strokeThickness=0==x?10:6;var S,I,P=this.playerCaptureds[w],k=0,C=g(i.captured[x]);try{for(C.s();!(I=C.n()).done;){var F;b=I.value;null!=(F=this.resources.acquireSprite(b,\"small\"))&&(b==S&&(k-=u/2+5),F.x=k,F.y=0,F.width=u,F.height=u,(F.container=P).addChild(F),this.sprites.push(F),k+=u),S=b}}catch(e){C.e(e)}finally{C.f()}w=\"\",1<i.scores[x]&&(w+=Math.floor(i.scores[x]/2)),i.scores[x]%2==1&&(w+=\"Â½\"),w=w||\"0\",this.playerScores[x].text=w}this.fenInput.value=i.fen}}},{key:\"reinitScene\",value:function(e,t){this.resources.close(),delete this.frameNumber,delete this.highlights,delete this.sprites,this.container=e,this.resources.init();var r=new PIXI.Graphics;r.beginFill(856085),r.drawRect(0,0,i,a);for(var n=0;n<o;n++)for(var u=0;u<s;u++){var d=1&(u^n);r.beginFill(d?14607334:9216685),r.drawRect(c+u*h,c+(o-1-n)*h,h,h)}for(e.addChild(r),u=0;u<s;u++)(l=new PIXI.Text(String.fromCharCode(\"a\".charCodeAt(0)+u)+\" \",new PIXI.TextStyle({fontSize:25,fill:\"#ebeef1\",stroke:\"#14110e\",strokeThickness:3,lineJoin:\"round\"}))).anchor.set(.5,0),l.x=c+h*(u+.5),l.y=a-c,e.addChild(l);var l;for(n=0;n<o;n++)(l=new PIXI.Text(String.fromCharCode(\"1\".charCodeAt(0)+n)+\" \",new PIXI.TextStyle({fontSize:25,fill:\"#ebeef1\",stroke:\"#14110e\",strokeThickness:3,lineJoin:\"round\"}))).anchor.set(1,.5),l.x=c,l.y=a-c-h*(n+.5),e.addChild(l);var f=2*c+h*s;this.playerContainers=[],this.playerNames=[],this.playerCaptureds=[],this.playerScores=[];for(var p=0;p<2;p++){var m=this.players[p],y=new PIXI.Graphics;y.x=f,e.addChild(y),this.playerContainers.push(y),y.beginFill(m.color),y.drawRect(-10,0,4,h),y.beginFill(m.color,.04),y.drawRect(0,0,i-c-y.x,h);var v=new PIXI.Sprite(m.avatar);v.width=v.height=116,v.y=(h-v.height)/2,y.addChild(v);var b=new PIXI.Text(m.name,new PIXI.TextStyle({fontSize:50,fontWeight:900,lineJoin:\"round\"}));b.x=v.x+v.width+10,b.y=v.y,y.addChild(b),this.playerNames.push(b),(v=new PIXI.Container).x=b.x+2,v.y=b.y+b.height+10,this.playerCaptureds.push(v),y.addChild(v),(m=new PIXI.Text(\"0\",new PIXI.TextStyle({fontSize:35,fill:m.color}))).x=i-c-y.x-20,m.y=h/2,m.anchor.set(1,.5),this.playerScores.push(m),y.addChild(m)}var x=new PIXI.TextStyle({fontSize:25,fontWeight:700,fill:\"#f2bb13\"}),T=new PIXI.TextStyle({fontSize:35,fill:\"#ebeef1\"});if(this.moveHeaderText=new PIXI.Text(\"CURRENT MOVE\",x),this.moveHeaderText.x=f,this.moveHeaderText.y=c+2.5*h+16,e.addChild(this.moveHeaderText),this.moveText=new PIXI.Text(\"\",new PIXI.TextStyle({fontSize:35})),this.moveText.x=this.moveHeaderText.x,this.moveText.y=this.moveHeaderText.y+40,e.addChild(this.moveText),this.castlingHeaderText=new PIXI.Text(\"CASTLING\",x),this.castlingHeaderText.x=this.moveHeaderText.x+250,this.castlingHeaderText.y=this.moveHeaderText.y,e.addChild(this.castlingHeaderText),this.castlingText=new PIXI.Text(\"\",T),this.castlingText.x=this.castlingHeaderText.x,this.castlingText.y=this.castlingHeaderText.y+40,e.addChild(this.castlingText),this.fiftyMoveHeaderText=new PIXI.Text(\"FIFTY-MOVE\",x),this.fiftyMoveHeaderText.x=this.castlingHeaderText.x+200,this.fiftyMoveHeaderText.y=this.moveHeaderText.y,e.addChild(this.fiftyMoveHeaderText),this.fiftyMoveText=new PIXI.Text(\"\",T),this.fiftyMoveText.x=this.fiftyMoveHeaderText.x,this.fiftyMoveText.y=this.fiftyMoveHeaderText.y+40,e.addChild(this.fiftyMoveText),this.gameHeaderText=new PIXI.Text(\"GAME\",x),this.gameHeaderText.x=this.fiftyMoveHeaderText.x+200,this.gameHeaderText.y=this.moveHeaderText.y,e.addChild(this.gameHeaderText),this.gameText=new PIXI.Text(\"\",T),this.gameText.x=this.gameHeaderText.x,this.gameText.y=this.gameHeaderText.y+40,e.addChild(this.gameText),this.statusHeaderText=new PIXI.Text(\"STATUS\",x),this.statusHeaderText.x=f,this.statusHeaderText.y=c+3.5*h+16,e.addChild(this.statusHeaderText),this.statusText=new PIXI.Text(\"\",new PIXI.TextStyle({fontSize:30,fill:\"#ebeef1\",lineHeight:40})),this.statusText.x=this.statusHeaderText.x,this.statusText.y=this.statusHeaderText.y+40,e.addChild(this.statusText),this.commentHeaderText=new PIXI.Text(\"COMMENT\",x),this.commentHeaderText.x=f,this.commentHeaderText.y=c+4.5*h+16,e.addChild(this.commentHeaderText),this.commentText=new PIXI.Text(\"\",new PIXI.TextStyle({fontSize:30,fill:\"#ebeef1\",lineHeight:40})),this.commentText.x=this.commentHeaderText.x,this.commentText.y=this.commentHeaderText.y+40,e.addChild(this.commentText),!this.pgnArea.value){var w,S=[],I=g(this.frames);try{for(I.s();!(w=I.n()).done;)(k=w.value).result&&S.push(k.result)}catch(e){I.e(e)}finally{I.f()}var P,k,C=\"\",F=-1,H=this.frames[0].fen,A=0,R=g(this.frames);try{for(R.s();!(P=R.n()).done;)F!=(k=P.value).game&&(0<=F&&(C+=\" \"+S[F]+\"\\n\\n\"),F++,A=0,C+='[Event \"Codingame Chess Bot Game\"]\\n',C+='[Site \"https://www.codingame.com/\"]\\n',C+='[Date \"??\"]\\n',C+='[Round \"??\"]\\n',C+='[White \"'+this.players[F].name.replace('\"','\\\\\"')+'\"]\\n',C+='[Black \"'+this.players[1-F].name.replace('\"','\\\\\"')+'\"]\\n',C+='[Result \"'+S[F]+'\"]\\n',this.globalData.crazyHouse&&(C+='[Variant \"Crazyhouse\"]\\n'),C+='[FEN \"'+H+'\"]\\n',C+=\"\\n\"),k.move&&(A%2==0&&(0<A&&(C+=\"\\n\"),C+=1+Math.floor(A/2)+\".\"),C+=\" \"+k.move,A++)}catch(e){R.e(e)}finally{R.f()}C+=\" \"+S[F],this.pgnArea.value=C}}},{key:\"animateScene\",value:function(e){}}]),e}()];function w(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}var S=[],I=[],P=function(){function e(){!function(t){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}(this)}var t,r;return t=e,r=[{key:\"listen\",value:function(e){if(\"function\"!=typeof e)throw new TypeError(e+\" is not a function\");I.push(e)}},{key:\"push\",value:function(e){S.push(e),I.forEach((function(t){return t(e)}))}}],null&&w(t.prototype,null),r&&w(t,r),e}(),k={views:['KEY_FRAME 0\\n{\"global\":{\"chess\":{\"crazyHouse\":false}},\"frame\":{\"chess\":{\"game\":0,\"scores\":[0,0],\"fen\":\"rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w AHah - 0 1\"}}}\\n','KEY_FRAME 1\\n{\"chess\":{\"game\":0,\"scores\":[0,0],\"fen\":\"rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w AHah - 0 1\"}}\\n'],agents:[{index:0,name:\"Player 0\",avatar:\"https://static.codingame.com/servlet/fileservlet?id=16085734516701&format=viewer_avatar\",agentId:0},{index:1,name:\"Player 1\",avatar:\"https://static.codingame.com/servlet/fileservlet?id=16085846089817&format=viewer_avatar\",agentId:1}]},C=[];function F(e){return(F=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&\"function\"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?\"symbol\":typeof e})(e)}function H(e){var t=\"function\"==typeof Map?new Map:void 0;return(H=function(e){if(null===e||(r=e,-1===Function.toString.call(r).indexOf(\"[native code]\")))return e;var r;if(\"function\"!=typeof e)throw new TypeError(\"Super expression must either be null or a function\");if(void 0!==t){if(t.has(e))return t.get(e);t.set(e,n)}function n(){return A(e,arguments,E(this).constructor)}return n.prototype=Object.create(e.prototype,{constructor:{value:n,enumerable:!1,writable:!0,configurable:!0}}),O(n,e)})(e)}function A(e,t,r){return(A=R()?Reflect.construct:function(e,t,r){var n=[null];return n.push.apply(n,t),n=new(Function.bind.apply(e,n)),r&&O(n,r.prototype),n}).apply(null,arguments)}function R(){if(\"undefined\"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if(\"function\"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],(function(){}))),!0}catch(e){return!1}}function O(e,t){return(O=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e})(e,t)}function E(e){return(E=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}var M=function(){!function(e,t){if(\"function\"!=typeof t&&null!==t)throw new TypeError(\"Super expression must either be null or a function\");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),t&&O(e,t)}(t,H(Error));var e=function(e){var t=R();return function(){var r,n=E(e);return r=t?(r=E(this).constructor,Reflect.construct(n,arguments,r)):n.apply(this,arguments),n=this,!(r=r)||\"object\"!==F(r)&&\"function\"!=typeof r?function(e){if(void 0!==e)return e;throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\")}(n):r}}(t);function t(r,n){return function(e){if(!(e instanceof t))throw new TypeError(\"Cannot call a class as a function\")}(this),(r=e.call(this,'<Error in module \"'+r+'\">')).cause=n,r.name=\"ModuleError\",r}return t}();function B(e,t){var r,n=Object.keys(e);return Object.getOwnPropertySymbols&&(r=Object.getOwnPropertySymbols(e),t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)),n}function D(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?B(Object(r),!0).forEach((function(t){var n,i;n=e,t=r[i=t],i in n?Object.defineProperty(n,i,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[i]=t})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):B(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function X(e,t){(null==t||t>e.length)&&(t=e.length);for(var r=0,n=new Array(t);r<t;r++)n[r]=e[r];return n}function W(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}var j=function(){function e(t){!function(t){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}(this),this.toDestroy=[],this.stepByStepAnimateSpeed=null;var r=t||k;r?(t=r.views,r=r.agents,this.demo={playerCount:r.length,logo:\"logo.png\",overlayAlpha:.2,agents:r,frames:t},this.demo.agents.forEach((function(t){t.color=e.playerColors[t.index]}))):this.demo=void 0}var t,r,s;return t=e,s=[{key:\"getGameRatio\",value:function(){return e.WIDTH/e.HEIGHT}},{key:\"requirements\",get:function(){return{PIXI:\"PIXI4\"}}},{key:\"VERSION\",get:function(){return 2}},{key:\"WIDTH\",get:function(){return i}},{key:\"HEIGHT\",get:function(){return a}},{key:\"playerColors\",get:function(){return[\"#ff1d5c\",\"#22a1e4\",\"#ff8f16\",\"#6ac371\",\"#9975e2\",\"#3ac5ca\",\"#de6ddf\",\"#ff0000\"]}},{key:\"SDK_GAME\",get:function(){return!0}},{key:\"RenderTimeout\",get:function(){return\"localhost\"===window.location.hostname?1/0:2e4}}],(r=[{key:\"getDefaultOverSampling\",value:function(){return 2}},{key:\"handleModuleError\",value:function(e,t){P.push(new M(e,t)),console.error(t),P.push({message:'<Module \"'.concat(e,'\" disabled>\\n')}),delete this.modules[e]}},{key:\"instantiateModules\",value:function(){this.modules={};var e,t=function(e,t){var r;if(\"undefined\"==typeof Symbol||null==e[Symbol.iterator]){if(Array.isArray(e)||(r=function(e,t){if(e){if(\"string\"==typeof e)return X(e,t);var r=Object.prototype.toString.call(e).slice(8,-1);return\"Object\"===r&&e.constructor&&(r=e.constructor.name),\"Map\"===r||\"Set\"===r?Array.from(e):\"Arguments\"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)?X(e,t):void 0}}(e))||t&&e&&\"number\"==typeof e.length){r&&(e=r);var n=0;return{s:t=function(){},n:function(){return n>=e.length?{done:!0}:{done:!1,value:e[n++]}},e:function(e){throw e},f:t}}throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\")}var i,a=!0,s=!1;return{s:function(){r=e[Symbol.iterator]()},n:function(){var e=r.next();return a=e.done,e},e:function(e){s=!0,i=e},f:function(){try{a||null==r.return||r.return()}finally{if(s)throw i}}}}(T);try{for(t.s();!(e=t.n()).done;){var r=e.value;try{this.modules[r.name]=new r(n)}catch(e){this.handleModuleError(r.name,e)}}}catch(e){t.e(e)}finally{t.f()}}},{key:\"destroy\",value:function(){this.alreadyLoaded&&(this.renderer.destroy(),this.endCallback=null),this.destroyed=!0}},{key:\"destroyScene\",value:function(e){!function(){for(var e=0,t=C.length;e<t;++e)C[e].destroy(!0);C=[]}()}},{key:\"getGameName\",value:function(){}},{key:\"canSwapPlayers\",value:function(){return!1}},{key:\"addErrorListener\",value:function(e){P.listen(e)}},{key:\"getResources\",value:function(){return Object.assign({baseUrl:\"\",images:{},spines:{},sprites:[],fonts:[],others:[]},n)}},{key:\"getOptions\",value:function(){return[]}},{key:\"setDebug\",value:function(t){this.asyncRenderingTime=e.RenderTimeout}},{key:\"initPreload\",value:function(e,t,r,n,i){e.canvasWidth=n,e.canvasHeight=i,e.loaderProgress=new PIXI.Text(\"100\",{fontSize:.117*i||30,fontFamily:\"Lato\",fontWeight:\"900\",fill:\"white\",align:\"center\"}),e.loaderProgress.anchor.y=1,e.loaderProgress.anchor.x=1.3,e.progress=e.realProgress=r,e.loaderProgress.position.y=i,e.progressBar=new PIXI.Graphics,t.addChild(e.progressBar),t.addChild(e.loaderProgress)}},{key:\"preload\",value:function(e,t,r,n,i,a){e.progress=r}},{key:\"renderPreloadScene\",value:function(e,t){return t=Math.pow(.998,t),e.realProgress=t*e.realProgress+(1-t)*e.progress,e.loaderProgress.text=(100*e.realProgress).toFixed(0),e.loaderProgress.position.x=e.realProgress*e.canvasWidth,e.progressBar.clear(),e.progressBar.beginFill(0,1),e.progressBar.drawRect(0,0,e.canvasWidth*e.realProgress+1,e.canvasHeight),e.progressBar.endFill(),e.progressBar.beginFill(4146246,1),e.progressBar.drawRect(e.canvasWidth*e.realProgress,0,e.canvasWidth,e.canvasHeight),e.progressBar.endFill(),!0}},{key:\"initDefaultScene\",value:function(t,r,n,i){var a,s,o,c,h,u=new PIXI.Container;if(t.drawer=this,t.time=0,this.demo){if(this.demo.logo)try{var d=PIXI.Sprite.fromFrame(this.demo.logo);d.position.set(e.WIDTH/2,e.HEIGHT/2),d.anchor.set(.5),d.baseScale=(a=d.texture.width,s=d.texture.height,o=2*e.WIDTH/3,c=e.HEIGHT/2,h=(h=0)||0,Math.min(o/(a+h),c/(s+h))),u.addChild(d),t.logo=d}catch(r){P.push({cause:r,message:'Missing \"logo.png\" to complete replay.'}),t.logo=new PIXI.Container,t.logo.baseScale=1,u.addChild(t.logo),t.missingLogo=!0}var l=new PIXI.Graphics;t.missingLogo||(l.beginFill(0,this.demo.overlayAlpha||0),l.drawRect(0,0,e.WIDTH+20,e.HEIGHT+20),l.endFill(),l.x-=10,l.y-=10);var f=new PIXI.Container;try{this.initDefaultFrames(this.demo.playerCount,this.demo.frames,this.demo.agents),this.preconstructScene(this.scope,r,this.initWidth,this.initHeight),this.initScene(this.scope,f,this.frames,!0),this.updateScene(this.scope,this.question,this.frames,this.currentFrame,this.progress,1,this.reasons[this.currentFrame],!0)}catch(r){P.push({cause:r,message:\"Cannot load demo, you might want to reset the demo\"})}t.demo=f,t.demotime=0,this.currentFrame=-1,r.addChild(f),r.addChild(l),r.addChild(u)}t.updateTime=0,t.frameTime=0}},{key:\"initDefaultFrames\",value:function(t,r,n){var i=this;this.instantiateModules(),this.playerInfo=n.map((function(e,t){return{name:e.name||\"Anonymous\",color:e.color?i.parseColor(e.color):\"#ffffff\",number:t,index:e.index,type:e.type,isMe:\"CODINGAMER\"===e.type&&e.typeData.me,avatar:e.avatarTexture}})),this.instantiateModules(),this._frames=r.map((function(e){var t,r=e.split(\"\\n\");e=r[0].split(\" \");try{t=JSON.parse(r.slice(1).join(\"\\n\"))}catch(e){t={}}return D(D({},t),{},{key:\"KEY_FRAME\"===e[0]})})).filter((function(e){return e.key})),this.parseGlobalData(this._frames[0].global),this.playerCount=t,this.reasons=[],this.frames=[],this.currentFrame=0,this.currentFrameDuration=1e3,this.progress=1,(t=this._frames[0].frame).key=this._frames[0].key,this.frames.push(this.parseFrame(t,this.frames));for(var a=1;a<this._frames.length;++a)this.frames.push(this.parseFrame(this._frames[a],this.frames));this.asyncRenderingTime=e.RenderTimeout}},{key:\"renderDefaultScene\",value:function(e,t){if(t=Math.min(80,t),void 0===this.demo)return!1;this.currentFrame=this.currentFrameTemp||0,e.frameTime+=t,e.updateTime+=t,e.demotime+=t/1e3;var r=Math.max(0,Math.min(1,(e.demotime-1)/.5));e.logo&&(e.logo.alpha=r,e.logo.scale.x=e.logo.scale.y=(3-2*r)*e.logo.baseScale),!e.missingLogo&&1.5<e.demotime&&e.demotime<=2.2?(i=15*Math.max(0,1-(e.demotime-1.5)/.7),e.demo.x=(2*Math.random()-1)*i,e.demo.y=(2*Math.random()-1)*i):e.demo.x=e.demo.y=0;var n,i,a=this.getFrameDuration(this.currentFrame);return 30<=e.updateTime&&(e.updateTime-=30,0===this.currentFrame?this.progress=1:this.progress=(n=0,r=a,i=e.frameTime,Math.min(1,Math.max(0,(i-(n=n))/(r-n)))),this.updateScene(this.scope,this.question,this.frames,this.currentFrame,this.progress,1,this.reasons[this.currentFrame],!0)),e.frameTime>=a&&(e.frameTime-=a,this.currentFrame=(this.currentFrame+1)%this.frames.length),this.renderScene(this.scope,this.question,this.frames,this.currentFrame,this.progress,1,this.reasons[this.currentFrame],t,!0),this.currentFrameTemp=this.currentFrame,this.currentFrame=-1,!0}},{key:\"endDefaultScene\",value:function(e,t){return!0}},{key:\"parseGlobalData\",value:function(e){for(var t in this.modules){var r=this.modules[t];\"function\"==typeof r.handleGlobalData&&r.handleGlobalData(this.playerInfo,e[t])}}},{key:\"parseFrame\",value:function(e,t){var r,n={data:{},frameInfo:{number:t.length}};if(n.previous=t[t.length-1]||n,n!==n.previous&&(n.previous.next=n),!e.key)return n.previous;for(r in e.duration&&(this.currentFrameDuration=e.duration),n.frameInfo.frameDuration=this.currentFrameDuration,n===n.previous?(n.frameInfo.date=0,n.frameInfo.frameDuration=0):n.frameInfo.date=n.previous.frameInfo.date+n.previous.frameInfo.frameDuration,this.modules){var i=this.modules[r];\"function\"==typeof i.handleFrameData&&(n.data[r]=i.handleFrameData(n.frameInfo,e[r]))}return n}},{key:\"preconstructScene\",value:function(t,r,n,i){t.canvasHeight=i,t.canvasWidth=n,t.time=0,t.endTime=0,t.playerInfo=this.playerInfo,r.scale.x=n/e.WIDTH,r.scale.y=i/e.HEIGHT}},{key:\"initScene\",value:function(e,t,r){for(var n in this.modules){var i=this.modules[n],a=new PIXI.Container;try{i.reinitScene(a,{width:e.canvasWidth,height:e.canvasHeight,oversampling:this.oversampling})}catch(e){this.handleModuleError(n,e)}t.addChild(a)}}},{key:\"updateScene\",value:function(e,t,r,n,i,a,s,o,c){var h,u=r[n];if(!c&&this.stepByStepAnimateSpeed){if(this.checkSteppedToNextFrame(e,u,i))return void this.startAsynchronousAnimation(e,u);if(this.checkSteppedToPreviousFrame(e,u,i))return void this.startAsynchronousAnimation(e,e.currentFrame,!0);e.targetProgress=null}for(h in e.currentFrame=u,e.currentProgress=i,e.reason=s,this.modules){var d=this.modules[h];if(u.data.hasOwnProperty(h))try{d.updateScene(u.previous.data[h],u.data[h],i,a)}catch(e){this.handleModuleError(h,e)}}}},{key:\"startAsynchronousAnimation\",value:function(e,t){var r=2<arguments.length&&void 0!==arguments[2]&&arguments[2];e.targetProgress=r?0:1,r||1!==e.currentProgress||(e.currentProgress=0),e.currentFrame=t,e.reverseAsynchronousAnimation=r}},{key:\"checkStepped\",value:function(e,t,r){return e.currentFrame&&0===this.speed&&1===r}},{key:\"checkSteppedToNextFrame\",value:function(e,t,r){return this.checkStepped(e,t,r)&&(e.currentFrame===t.previous&&e.currentFrame!==t||e.currentFrame===t&&e.currentProgress!==r)}},{key:\"checkSteppedToPreviousFrame\",value:function(e,t,r){return this.checkStepped(e,t,r)&&e.currentFrame.previous===t&&e.currentFrame!==t}},{key:\"initEndScene\",value:function(e,t){e.endSceneViewed=!1}},{key:\"destroyEndScene\",value:function(e){}},{key:\"renderEndScene\",value:function(e,t,r){0===e.endTime&&this.initEndScene(e,r),e.endTime+=t,void 0<=e.endTime&&!e.endSceneViewed&&(this.endCallback&&this.endCallback(),e.endSceneViewed=!0)}},{key:\"renderScene\",value:function(e,t,r,n,i,a,s,o){var c,h;for(h in o=Math.min(80,o),this.debugMode||n!==r.length-1||1!==i?(0<e.endTime&&this.destroyEndScene(e),e.endTime=0):this.renderEndScene(e,o,\"Win\"!==s),this.stepByStepAnimateSpeed&&this.isAsynchronousAnimationOngoing(e)&&(i=this.currentFrame,e.reverseAsynchronousAnimation&&i++,s=o/200*this.getFrameSpeed(i)*this.stepByStepAnimateSpeed,e.reverseAsynchronousAnimation?(c=e.currentProgress-s)<=0&&(i=this.currentFrame,c=1,e.targetProgress=1):(c=e.currentProgress+s,c=Math.min(e.targetProgress,c)),this.updateScene(this.scope,this.question,this.frames,i,c,this.speed,this.reasons[i],!1,!0)),this.modules){var u=this.modules[h];if(\"function\"==typeof u.animateScene)try{u.animateScene(o)}catch(e){this.handleModuleError(h,e)}}return!0}},{key:\"isAsynchronousAnimationOngoing\",value:function(e){return null!=e.targetProgress&&e.currentProgress!==e.targetProgress}},{key:\"getFrameSpeed\",value:function(e){return 500/this.getFrameDuration(e)}},{key:\"getFrameDuration\",value:function(e){return this.frames&&this.frames[e]&&this.frames[e].frameInfo.frameDuration||1e3}},{key:\"enableAsyncRendering\",value:function(t){this.asyncRendering=t,this.asyncRenderingTime=e.RenderTimeout}},{key:\"purge\",value:function(){this.scope={},this.changed=!0,this.container.interactiveChildren=!1,this.container.destroy({texture:!1,children:!0}),delete this.container,this.container=new PIXI.Container}},{key:\"reinitScene\",value:function(){1<=this.loaded&&(this.destroyScene(this.scope),this.purge(),this.asyncRenderingTime=e.RenderTimeout,this.preconstructScene(this.scope,this.container,this.initWidth,this.initHeight),this.initScene(this.scope,this.container,this.frames),this.updateScene(this.scope,this.question,this.frames,this.currentFrame,this.progress,this.speed,this.reasons[this.currentFrame]),this.changed=!0)}},{key:\"reinitDefaultScene\",value:function(){1<=this.loaded&&(this.intro=!0,this.destroyScene(this.scope),this.purge(),this.asyncRenderingTime=e.RenderTimeout,this.initDefaultScene(this.scope,this.container,this.initWidth,this.initHeight),this.changed=!0)}},{key:\"reinitLoadingScene\",value:function(){this.loaded<1&&(this.purge(),this.asyncRenderingTime=e.RenderTimeout,this.initPreload(this.scope,this.container,this.loaded,this.initWidth,this.initHeight))}},{key:\"reinit\",value:function(e){1<=this.loaded&&!this.loading?0<=this.currentFrame&&!this.intro?this.reinitScene():this.intro&&!e||this.reinitDefaultScene():this.reinitLoadingScene()}},{key:\"animate\",value:function(e){var t;this.destroyed||(this.lastRenderTime||(this.lastRenderTime=e),t=e-this.lastRenderTime,this.asynchronousStep&&(t=this.asynchronousStep),this.onBeforeRender&&this.onBeforeRender(),this.loading||(this.loaded<1?this.changed|=this.renderPreloadScene(this.scope,t):(this.changed||this.asyncRendering&&0<this.asyncRenderingTime||this.isAsynchronousAnimationOngoing(this.scope))&&(this.currentFrame<0?this.changed|=this.renderDefaultScene(this.scope,t):this.intro?(this.changed=!0,this.endDefaultScene(this.scope,t)&&(this.intro=!1,this.reinit(!0))):this.changed|=this.renderScene(this.scope,this.question,this.frames,this.currentFrame,this.progress,this.speed,this.reasons[this.currentFrame],t)),this.changed&&(this.renderer.render(this.container),this.changed=!1)),this.onAfterRender&&this.onAfterRender(),this.lastRenderTime=e,this.destroyed||requestAnimationFrame(this.animate.bind(this)),this.asyncRenderingTime-=t)}},{key:\"_initFrames\",value:function(e,t){this.instantiateModules(),this._frames=t.map((function(e){var t,r=e[0].split(\" \");try{t=JSON.parse(e.slice(1).join(\"\\n\"))}catch(e){t={}}return D(D({},t),{},{key:\"KEY_FRAME\"===r[0]})})),this.parseGlobalData(this._frames[0].global),this.playerCount=e,this.reasons=[],this.frames=[],this.currentFrame=0,this.currentFrameDuration=1e3,this.progress=1,(e=this._frames[0].frame).key=this._frames[0].key,this.frames.push(this.parseFrame(e,this.frames));for(var r=1;r<this._frames.length;++r)this.frames.push(this.parseFrame(this._frames[r],this.frames))}},{key:\"isTurnBasedGame\",value:function(){return!1}},{key:\"initFrames\",value:function(e,t){this.playerInfo&&this.playerInfo.forEach((function(e){e.avatar&&e.avatar.destroy(!0)}));var r=this,n=new PIXI.loaders.Loader(window.location.origin);function i(){r._initFrames(t.length,e),r.loading=!1,r.reinit(!1),a=!0}this.playerInfo=t.map((function(e,t){var i={name:e.name||\"Anonymous\",color:e.color?r.parseColor(e.color):\"#ffffff\",number:t,index:e.index,type:e.type,isMe:\"CODINGAMER\"===e.type&&e.typeData.me,avatar:null};return null!=e.avatar&&n.add(\"avatar\"+t,e.avatar,{loadType:2,crossOrigin:!0},(function(e){i.avatar=e.texture,PIXI.Texture.addToCache(e.texture,\"$\"+i.index)})),i}));var a=!(this.loading=!0);n.on(\"complete\",i),n.on(\"error\",(function(e){console.warn(e),a||i()})),n.load()}},{key:\"update\",value:function(t,r,n){0<=this.currentFrame&&(this.asyncRenderingTime=e.RenderTimeout,this.changed=!0,this.speed=n,this.currentFrame=t,this.progress=r,1<=this.loaded&&!this.intro&&this.updateScene(this.scope,this.question,this.frames,t,r,this.speed,this.reasons[this.currentFrame]))}},{key:\"parseColor\",value:function(e){if(Array.isArray(e)){for(var t=[],r=0;r<e.length;++r)t.push(this.parseColor(e[r]));return t}return parseInt(e.substring(1),16)}},{key:\"init\",value:function(t,r,n,i,a,s,o){var c,h=this;window.PIXI=e.PIXI||window.PIXI,this.oversampling=a||1,a=function(){0<=h.currentFrame&&(h.changed=!0)},this.canvas=$(t),this.canvas.off(\"mousemove\"),this.canvas.off(\"wheel\"),this.canvas.bind(\"wheel\",a),this.canvas.mousemove(a),i&&(this.colors=this.parseColor(i)),\"ide\"===o&&(this.debugModeSetByUser||(this.debugMode=!0),P.listen((function(e){return console.error(e.cause||e)}))),this.asyncRendering=!0,this.asyncRenderingTime=0,this.destroyed=!1,this.asynchronousStep=null;var u=this;if(this.initWidth=0|r,this.initHeight=0|n,this.endCallback=s||this.endCallback,this.alreadyLoaded)this.changed=!0,this.renderer.resize(this.initWidth,this.initHeight),this.reinit(!0);else{this.alreadyLoaded=!0,this.question=null,this.scope=null,this.currentFrame=-1,this.loaded=0,this.container=new PIXI.Container;var d=this.getResources();this.renderer=this.createRenderer(this.initWidth,this.initHeight,t),s=this.renderer;var l,f=new PIXI.loaders.Loader(d.baseUrl);for(c in d.images)f.add(c,d.images[c],{crossOrigin:!0});for(l=0;l<d.sprites.length;++l)f.add(d.sprites[l],{crossOrigin:!0});for(l=0;l<d.fonts.length;++l)f.add(d.fonts[l],{crossOrigin:!0});for(c in d.spines)f.add(c,d.spines[c],{crossOrigin:!0});for(l=0;l<d.others.length;++l)f.add(d.others[l],{crossOrigin:!0});this.demo&&this.demo.agents.forEach((function(e){f.add(\"avatar\"+e.index,e.avatar,{loadType:2,crossOrigin:!0},(function(t){e.avatarTexture=t.texture,PIXI.Texture.addToCache(t.texture,\"$\"+e.index)}))})),u.scope={},t=function(e,t){requestAnimationFrame(u.animate.bind(u)),u.initPreload(u.scope,u.container,u.loaded=0,u.initWidth,u.initHeight)},f.on(\"start\",t),f.on(\"progress\",(function(e,t){e.progress<100&&u.preload(u.scope,u.container,u.loaded=e.progress/100,u.initWidth,u.initHeight,t)})),s=function(){for(var e in d.images)d.images.hasOwnProperty(e)&&f.resources[e].texture&&PIXI.Texture.addToCache(f.resources[e].texture,e);for(e in d.spines)d.spines.hasOwnProperty(e)&&(PIXI.AnimCache[e]=PIXI.AnimCache[d.baseUrl+d.spines[e]]);u.loaded=1,u.reinit(!0),u.changed=!0},f.on(\"complete\",s),f.on(\"error\",(function(e){console.warn(e)})),Object.keys(f.resources).length?f.load():(t(),s())}}},{key:\"createRenderer\",value:function(e,t,r){return PIXI.autoDetectRenderer(e,t,{view:r,clearBeforeRender:!0,preserveDrawingBuffer:!1})}},{key:\"isReady\",value:function(){return 1<=this.loaded}}])&&W(t.prototype,r),s&&W(t,s),e}()}]).Drawer;",
      "levelParams": {
        "0": {
          "aiCode": "import java.util.*;\r\nimport java.io.*;\r\nimport java.math.*;\r\n\r\nimport java.text.ParseException;\r\nimport java.util.function.BiConsumer;\r\nimport java.util.stream.Collectors;\r\n\r\nclass Player {\r\n\r\n    public static class Board {\r\n        // Board cells with piece when present, null when not.\r\n        private Piece[][] cells = new Piece[Constants.Columns][Constants.Rows];\r\n        // Castlings that may still be available.\r\n        private List<Castling> castlings = new ArrayList<Castling>();\r\n        // En-passant square when last move is pawn moving 2 squares from initial row.\r\n        private Square enPassantSquare = null;\r\n        // Number of half-moves since the last capture or pawn advance, used for the fifty-move draw.\r\n        private int halfMoveClock = 0;\r\n        // Number of half-moves since the start of the game.\r\n        private int halfMoves = 0;\r\n        // Whether crazyhouse rules are enabled.\r\n        private boolean crazyHouse = false;\r\n        // Reserve pieces for each color, used for crazyhouse.\r\n        private int[][] reservePieces = new int[Constants.Colors][Constants.ReservePieces.length];\r\n        // List of squares of highlight to show last move in viewer.\r\n        private List<Square> highlightSquares = new ArrayList<Square>();\r\n\r\n        public Board(Board other) {\r\n            for (int column = 0; column < Constants.Columns; column++) {\r\n                for (int row = 0; row < Constants.Rows; row++)\r\n                    cells[column][row] = other.cells[column][row];\r\n            }\r\n            for (Castling castling : other.castlings)\r\n                castlings.add(new Castling(castling));\r\n            enPassantSquare = other.enPassantSquare;\r\n            halfMoveClock = other.halfMoveClock;\r\n            halfMoves = other.halfMoves;\r\n            crazyHouse = other.crazyHouse;\r\n            for (int color = 0; color < Constants.Colors; color++) {\r\n                for (int i = 0; i < Constants.ReservePieces.length; i++)\r\n                    reservePieces[color][i] = other.reservePieces[color][i];\r\n            }\r\n        }\r\n\r\n        public Board(long seed, boolean crazyHouse) {\r\n            this.crazyHouse = crazyHouse;\r\n\r\n            if (seed == 0) {\r\n                // seed=0 means classic chess initial row.\r\n                PieceType[] initialRow = { PieceType.Rook, PieceType.Knight, PieceType.Bishop, PieceType.Queen, PieceType.King, PieceType.Bishop, PieceType.Knight, PieceType.Rook};\r\n                int row = getInitialRow(Color.White);\r\n                for (int column = 0; column < initialRow.length; column++)\r\n                    set(new Square(column, row), new Piece(initialRow[column], Color.White));\r\n            } else {\r\n                // Random picks on initial row for a total of 960 combinations.\r\n                // Following procedure as described at https://en.wikipedia.org/wiki/Chess960#Setup\r\n                int row = getInitialRow(Color.White);\r\n                Random rng = new Random(seed);\r\n                set(new Square(rng.nextInt(4) * 2, row), new Piece(PieceType.Bishop, Color.White));\r\n                set(new Square(rng.nextInt(4) * 2 + 1, row), new Piece(PieceType.Bishop, Color.White));\r\n                BiConsumer<Integer, PieceType> placePiece = (Integer emptyColumn, PieceType pieceType) -> {\r\n                    for (int column = 0; column < Constants.Columns; column++) {\r\n                        Square square = new Square(column, row);\r\n                        if (get(square) != null) continue;\r\n                        if (emptyColumn == 0) {\r\n                            set(square, new Piece(pieceType, Color.White));\r\n                            return;\r\n                        }\r\n                        emptyColumn--;\r\n                    }\r\n                    throw new IllegalArgumentException(\"Not enough empty columns to satisfy argument\");\r\n                };\r\n                placePiece.accept(rng.nextInt(6), PieceType.Queen);\r\n                placePiece.accept(rng.nextInt(5), PieceType.Knight);\r\n                placePiece.accept(rng.nextInt(4), PieceType.Knight);\r\n                placePiece.accept(0, PieceType.Rook);\r\n                placePiece.accept(0, PieceType.King);\r\n                placePiece.accept(0, PieceType.Rook);\r\n            }\r\n            \r\n            for (int column = 0; column < Constants.Columns; column++) {\r\n                Piece piece = get(new Square(column, getInitialRow(Color.White)));\r\n                // Copy initial row on black side.\r\n                set(new Square(column, getInitialRow(Color.Black)), piece.invert());\r\n                // Create pawns on second row of each side.\r\n                set(new Square(column, getPawnRow(Color.White)), new Piece(PieceType.Pawn, Color.White));\r\n                set(new Square(column, getPawnRow(Color.Black)), new Piece(PieceType.Pawn, Color.Black));\r\n                // Keep track of castling columns.\r\n                if (piece.getPieceType() == PieceType.Rook)\r\n                    castlings.add(new Castling(column, true));\r\n            }\r\n        }\r\n\r\n        // Parse from FEN representation. https://en.wikipedia.org/wiki/Forsyth-Edwards_Notation\r\n        public Board(String fen, boolean crazyHouse) throws ParseException {\r\n            this.crazyHouse = crazyHouse;\r\n\r\n            String[] parts = fen.split(\" \");\r\n            if (parts.length != 6) throw new ParseException(\"FEN string is malformed, needs 6 fields.\", 0);\r\n            {\r\n                int column = 0, row = Constants.Rows - 1;\r\n                for (char c : parts[0].toCharArray()) {\r\n                    if (c == '/') {\r\n                        row--;\r\n                        column = 0;\r\n                    }\r\n                    else if (c >= '1' && c <= '9')\r\n                        column += c - '0';\r\n                    else {\r\n                        if (row >= 0 && row < Constants.Rows && column >= 0 && column < Constants.Columns) {\r\n                            if (crazyHouse && c == '~') {\r\n                                column--;\r\n                                Square square = new Square(column, row);\r\n                                Piece piece = get(square);\r\n                                if (piece == null) throw new ParseException(\"Found ~ symbol without an associated piece.\", 0);\r\n                                set(square, piece.promote());\r\n                            } else\r\n                                set(new Square(column, row), Piece.fromChar(c));\r\n                        } else if (crazyHouse && row < 0) {\r\n                            PieceType pieceType = PieceType.fromChar(c);\r\n                            if (pieceType == PieceType.King) throw new ParseException(\"Found a king in a reserve.\", 0);\r\n                            addReserve(Character.isUpperCase(c) ? Color.White : Color.Black, pieceType, 1);\r\n                        }\r\n                        column++;\r\n                    }\r\n                }\r\n            }\r\n            Color colorToPlay = Color.fromChar(parts[1].charAt(0));\r\n            if (!parts[2].equals(\"-\")) {\r\n                for (char c : parts[2].toCharArray()) {\r\n                    int column = Square.charToColumn(c);\r\n                    Castling castling = null;\r\n                    for (Castling iter : castlings) {\r\n                        if (iter.getColumn() != column) continue;\r\n                        castling = iter;\r\n                        break;\r\n                    }\r\n                    if (castling == null) {\r\n                        if (castlings.size() >= Constants.Castlings) throw new ParseException(\"Too many castlings found.\", 0);\r\n                        castling = new Castling(column, false);\r\n                        castlings.add(castling);\r\n                    }\r\n                    castling.setAllowed(Character.isUpperCase(c) ? Color.White : Color.Black, true);\r\n                }\r\n            }\r\n            if (!parts[3].equals(\"-\"))\r\n                enPassantSquare = new Square(parts[3]);\r\n            halfMoveClock = Integer.parseInt(parts[4]);\r\n            if (halfMoveClock < 0) throw new ParseException(\"Half-move clock must be greater or equal to zero.\", 0);\r\n            halfMoves = (Integer.parseInt(parts[5]) - 1) * 2 + (colorToPlay == Color.White ? 0 : 1);\r\n            if (halfMoves < 0) throw new ParseException(\"Fullmove number must be greater than zero.\", 0);\r\n        }\r\n\r\n        public Piece get(Square square) { return cells[square.getColumn()][square.getRow()]; }\r\n        private void set(Square square, Piece piece) { cells[square.getColumn()][square.getRow()] = piece; }\r\n\r\n        public Color getColorToPlay() { return halfMoves % 2 == 0 ? Color.White : Color.Black; }\r\n        public int getInitialRow(Color color) { return color == Color.White ? 0 : Constants.Rows - 1; }\r\n        public int getPawnRow(Color color) { return color == Color.White ? 1 : Constants.Rows - 2; }\r\n        public int getPawnFront(Color color) { return color == Color.White ? 1 : -1; }\r\n        public List<Square> getHighlightSquares() { return highlightSquares; }\r\n\r\n        public int getHalfMoves() { return halfMoves; }\r\n        public int getHalfMoveClock() { return halfMoveClock; }\r\n\r\n        public int getReserve(Color color, PieceType pieceType) {\r\n            if (pieceType == PieceType.King) throw new IllegalArgumentException(\"Reserve pieces does not include kings.\");\r\n            return reservePieces[color.ordinal()][pieceType.ordinal()];\r\n        }\r\n        public void addReserve(Color color, PieceType pieceType, int count) { \r\n            if (pieceType == PieceType.King) throw new IllegalArgumentException(\"Reserve pieces does not include kings.\");\r\n            reservePieces[color.ordinal()][pieceType.ordinal()] += count;\r\n            if (reservePieces[color.ordinal()][pieceType.ordinal()] < 0) throw new IllegalArgumentException(\"Reserve count has become negative.\");\r\n        }\r\n\r\n        // Encode board to FEN representation. https://en.wikipedia.org/wiki/Forsyth-Edwards_Notation\r\n        public String toFenString(boolean forRepetition) {\r\n            StringBuilder sb = new StringBuilder();\r\n            for (int row = Constants.Rows - 1; row >= 0; row--) {\r\n                int empty = 0;\r\n                for (int column = 0; column < Constants.Columns; column++) {\r\n                    Square square = new Square(column, row);\r\n                    Piece piece = get(square);\r\n                    if (piece == null)\r\n                        empty++;\r\n                    else {\r\n                        if (empty > 0) {\r\n                            sb.append((char)('0' + empty));\r\n                            empty = 0;\r\n                        }\r\n                        sb.append(piece.toChar());\r\n                        // Follow lichess crazyhouse convention and add symbol to indicate promoted pawn.\r\n                        if (crazyHouse && piece.isPromoted())\r\n                            sb.append('~');\r\n                    }\r\n                }\r\n                // Copy-paste because Java lambdas are exceptionally weak.\r\n                if (empty > 0) {\r\n                    sb.append((char)('0' + empty));\r\n                    empty = 0;\r\n                }\r\n                if (row > 0)\r\n                    sb.append('/');\r\n            }\r\n            // Follow lichess crazyhouse convention and encode reserve as an extra row.\r\n            if (crazyHouse) {\r\n                sb.append('/');\r\n                for (Color color : Color.values()) {\r\n                    for (PieceType pieceType : Constants.ReservePieces) {\r\n                        int count = getReserve(color, pieceType);\r\n                        if (count == 0) continue;\r\n                        for (int j = 0; j < count; j++)\r\n                            sb.append(pieceType.toChar(color));\r\n                    }\r\n                }\r\n            }\r\n            sb.append(' ');\r\n            sb.append(getColorToPlay().toChar());\r\n            sb.append(' ');\r\n            int beforeCastling = sb.length();\r\n            for (Color color : Color.values()) {\r\n                for (Castling castling : castlings) {\r\n                    char c = Square.columnToChar(castling.getColumn());\r\n                    if (castling.isAllowed(color)) sb.append(color == Color.White ? Character.toUpperCase(c) : c);\r\n                }\r\n            }\r\n            if (sb.length() == beforeCastling) sb.append('-');\r\n            sb.append(' ');\r\n            if (!forRepetition || enPassantSquare == null)\r\n                sb.append(enPassantSquare != null ? enPassantSquare.toString() : '-');\r\n            else {\r\n                // For repetition check, only print en-passant square if such a capture was possible.\r\n                boolean printSquare = false;\r\n                int front = getPawnFront(getColorToPlay());\r\n                for (int column = -1; column <= 1; column += 2) {\r\n                    Square square = enPassantSquare.offset(column, -front);\r\n                    if (square == null) continue;\r\n                    Piece piece = get(square);\r\n                    if (piece == null) continue;\r\n                    if (piece.getPieceType() == PieceType.Pawn && piece.getColor() == getColorToPlay()) {\r\n                        printSquare = true;\r\n                        break;\r\n                    }\r\n                }\r\n                sb.append(printSquare ? enPassantSquare.toString() : '-');\r\n            }\r\n            // These fields do not matter for repetition check.\r\n            if (!forRepetition) {\r\n                sb.append(' ');\r\n                sb.append(halfMoveClock);\r\n                sb.append(' ');\r\n                sb.append(1 + halfMoves / 2);\r\n            }\r\n            return sb.toString();\r\n        }\r\n\r\n        // Computes whether either side has enough material to deliver a checkmate in theory. https://en.wikipedia.org/wiki/Draw_(chess)#Draws_in_all_games\r\n        public boolean hasSufficientMaterial() {\r\n            // Can always drop pieces in crazyhouse.\r\n            if (crazyHouse) return true;\r\n            \r\n            Piece lastPiece = null;\r\n            Square lastSquare = null;\r\n            for (int column = 0; column < Constants.Columns; column++) {\r\n                for (int row = 0; row < Constants.Rows; row++) {\r\n                    Square square = new Square(column, row);\r\n                    Piece piece = get(square);\r\n                    if (piece == null) continue;\r\n                    PieceType pieceType = piece.getPieceType();\r\n                    if (pieceType == PieceType.King) continue;\r\n                    // Those pieces are always enough.\r\n                    if (pieceType == PieceType.Pawn || pieceType == PieceType.Rook || pieceType == PieceType.Queen)\r\n                        return true;\r\n                    if (lastPiece == null) {\r\n                        lastPiece = piece;\r\n                        lastSquare = square;\r\n                        continue;\r\n                    }\r\n                    // Each side with one bishop on the same color is not enough.\r\n                    if (lastPiece.getColor() != piece.getColor() && lastPiece.getPieceType() == PieceType.Bishop && piece.getPieceType() == PieceType.Bishop && lastSquare.isLight() == square.isLight())\r\n                        continue;\r\n                    // Two pieces on board is otherwise enough.\r\n                    return true;\r\n                }\r\n            }\r\n\r\n            // One or zero minor piece with no other piece is not enough to checkmate.\r\n            return false;\r\n        }\r\n\r\n        private void addRangeMoves(List<Move> moves, Square from, int limit, int deltaColumn, int deltaRow) {\r\n            Color selfColor = getColorToPlay();\r\n            Square to = from;\r\n            for (int range = 0; range < limit; range++) {\r\n                to = to.offset(deltaColumn, deltaRow);\r\n                if (to == null) return;\r\n                Piece toPiece = get(to);\r\n                if (toPiece == null || toPiece.getColor() != selfColor)\r\n                    moves.add(new Move(from, to));\r\n                if (toPiece != null) return;\r\n            }\r\n        }\r\n\r\n        private void addDiagonalMoves(List<Move> moves, Square from, int limit) {\r\n            addRangeMoves(moves, from, limit, -1, -1);\r\n            addRangeMoves(moves, from, limit, -1,  1);\r\n            addRangeMoves(moves, from, limit,  1, -1);\r\n            addRangeMoves(moves, from, limit,  1,  1);\r\n        }\r\n\r\n        private void addStraightMoves(List<Move> moves, Square from, int limit) {\r\n            addRangeMoves(moves, from, limit,  0, -1);\r\n            addRangeMoves(moves, from, limit,  0,  1);\r\n            addRangeMoves(moves, from, limit, -1,  0);\r\n            addRangeMoves(moves, from, limit,  1,  0);\r\n        }\r\n\r\n        // Check if a square can be attacked by an opponent piece.\r\n        private boolean isSquareAttacked(Square to, Color selfColor) {\r\n            // Check range in all directions.\r\n            for (int deltaColumn = -1; deltaColumn <= 1; deltaColumn++) {\r\n                for (int deltaRow = -1; deltaRow <= 1; deltaRow++) {\r\n                    if (deltaRow == 0 && deltaColumn == 0) continue;\r\n                    boolean isDiagonal = Math.abs(deltaRow) == Math.abs(deltaColumn);\r\n                    Square from = to;\r\n                    for (int range = 0; range < Constants.RangeLimit; range++) {\r\n                        from = from.offset(deltaColumn, deltaRow);\r\n                        if (from == null) break;\r\n                        Piece fromPiece = get(from);\r\n                        if (fromPiece == null) continue;\r\n                        if (fromPiece.getColor() == selfColor) break;\r\n\r\n                        PieceType pieceType = fromPiece.getPieceType();\r\n                        if (pieceType == PieceType.Pawn && isDiagonal && to.getRow() - from.getRow() == getPawnFront(selfColor.opposite()))\r\n                            return true;\r\n                        if (pieceType == PieceType.Queen || (pieceType == PieceType.King && range == 0))\r\n                            return true;\r\n                        if (pieceType == (isDiagonal ? PieceType.Bishop : PieceType.Rook))\r\n                            return true;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Check knights.\r\n            for (int i = 0; i < Constants.KnightMoves; i++) {\r\n                Square from = to.offset(Constants.KnightDeltaColumn[i], Constants.KnightDeltaRow[i]);\r\n                if (from == null) continue;\r\n                Piece fromPiece = get(from);\r\n                if (fromPiece != null && fromPiece.getColor() != selfColor && fromPiece.getPieceType() == PieceType.Knight)\r\n                    return true;\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        // Find the square where the king of given color is located. Cannot be null.\r\n        private Square findKingSquare(Color color) {\r\n            for (int column = 0; column < Constants.Columns; column++) {\r\n                for (int row = 0; row < Constants.Rows; row++) {\r\n                    Square square = new Square(column, row);\r\n                    Piece piece = get(square);\r\n                    if (piece != null && piece.getColor() == color && piece.getPieceType() == PieceType.King)\r\n                        return square;\r\n                }\r\n            }\r\n            throw new IllegalStateException(\"Unable to find own king\");\r\n        }\r\n\r\n        // Returns whether the king of given color is under check.\r\n        public boolean isKingAttacked(Color color) {\r\n            return isSquareAttacked(findKingSquare(color), color);\r\n        }\r\n\r\n        // Generate all legal moves from current position.\r\n        public List<Move> generateMoves() {\r\n            List<Move> moves = new ArrayList<Move>();\r\n            Color selfColor = getColorToPlay();\r\n            Color opponentColor = selfColor.opposite();\r\n\r\n            for (int fromColumn = 0; fromColumn < Constants.Columns; fromColumn++) {\r\n                for (int fromRow = 0; fromRow < Constants.Rows; fromRow++) {\r\n                    Square from = new Square(fromColumn, fromRow);\r\n                    Piece piece = get(from);\r\n\r\n                    // Drop reserve pieces on empty squares.\r\n                    if (crazyHouse && piece == null) {\r\n                        for (PieceType pieceType : Constants.ReservePieces) {\r\n                            if (getReserve(selfColor, pieceType) == 0) continue;\r\n                            // Cannot drop pawns on initial rows.\r\n                            if (pieceType == PieceType.Pawn && (fromRow == 0 || fromRow == Constants.Rows - 1)) continue;\r\n                            moves.add(new Move(null, from, pieceType));\r\n                        }\r\n                    }\r\n\r\n                    if (piece == null || piece.getColor() != selfColor) continue;\r\n                    PieceType pieceType = piece.getPieceType();\r\n\r\n                    if (pieceType == PieceType.Pawn) {\r\n                        // Handle promotion cases when pawn ends on opponent's initial row.\r\n                        BiConsumer<Square, Square> addPromotionMoves = (Square f, Square t) -> {\r\n                            if (t.getRow() != getInitialRow(opponentColor))\r\n                                moves.add(new Move(f, t));\r\n                            else {\r\n                                moves.add(new Move(f, t, PieceType.Knight));\r\n                                moves.add(new Move(f, t, PieceType.Bishop));\r\n                                moves.add(new Move(f, t, PieceType.Rook));\r\n                                moves.add(new Move(f, t, PieceType.Queen));\r\n                            }\r\n                        };\r\n                        // Move pawn ahead.\r\n                        int front = getPawnFront(selfColor);\r\n                        Square to = from.offset(0, front);\r\n                        if (to != null && get(to) == null) {\r\n                            addPromotionMoves.accept(from, to);\r\n                            // Can move 2 squares from pawn row.\r\n                            if (from.getRow() == getPawnRow(selfColor)) {\r\n                                Square to2 = from.offset(0, front*2);\r\n                                if (to2 != null && get(to2) == null)\r\n                                    moves.add(new Move(from, to2));\r\n                            }\r\n                        }\r\n                        // Pawn capture on diagonals including en-passant.\r\n                        for (int deltaColumn = -1; deltaColumn <= 1; deltaColumn += 2) {\r\n                            to = from.offset(deltaColumn, front);\r\n                            if (to == null) continue;\r\n                            Piece toPiece = get(to);\r\n                            if ((toPiece != null && toPiece.getColor() == opponentColor) || to.equals(enPassantSquare))\r\n                                addPromotionMoves.accept(from, to);\r\n                        }\r\n                    } else if (pieceType == PieceType.Knight) {\r\n                        // Check all L shapes.\r\n                        for (int i = 0; i < Constants.KnightMoves; i++) {\r\n                            Square to = from.offset(Constants.KnightDeltaColumn[i], Constants.KnightDeltaRow[i]);\r\n                            if (to == null) continue;\r\n                            Piece toPiece = get(to);\r\n                            if (toPiece != null && toPiece.getColor() == selfColor) continue;\r\n                            moves.add(new Move(from, to));\r\n                        }\r\n                    } else if (pieceType == PieceType.Bishop)\r\n                        addDiagonalMoves(moves, from, Constants.RangeLimit);\r\n                    else if (pieceType == PieceType.Rook)\r\n                        addStraightMoves(moves, from, Constants.RangeLimit);\r\n                    else if (pieceType == PieceType.Queen) {\r\n                        addDiagonalMoves(moves, from, Constants.RangeLimit);\r\n                        addStraightMoves(moves, from, Constants.RangeLimit);\r\n                    } else if (pieceType == PieceType.King) {\r\n                        addDiagonalMoves(moves, from, 1);\r\n                        addStraightMoves(moves, from, 1);\r\n                        // Check for castling move.\r\n                        for (Castling castling : castlings) {\r\n                            if (!castling.isAllowed(selfColor)) continue;\r\n                            int rookFromColumn = castling.getColumn();\r\n                            int kingFromColumn = fromColumn;\r\n                            boolean queenCastling = rookFromColumn < kingFromColumn;\r\n                            int deltaColumn = queenCastling ? -1 : 1;\r\n                            int rookToColumn = queenCastling ? Constants.QueenCastlingRookColumn : Constants.KingCastlingRookColumn;\r\n                            int kingToColumn = queenCastling ? Constants.QueenCastlingKingColumn : Constants.KingCastlingKingColumn;\r\n\r\n                            boolean valid = true;\r\n                            // The final squares must not be occupied by other pieces.\r\n                            valid &= rookToColumn == kingFromColumn || rookToColumn == rookFromColumn || get(new Square(rookToColumn, fromRow)) == null;\r\n                            valid &= kingToColumn == kingFromColumn || kingToColumn == rookFromColumn || get(new Square(kingToColumn, fromRow)) == null;\r\n                            // There must be no piece obstructing between king and rook.\r\n                            for (int column = kingFromColumn + deltaColumn; valid && column != rookFromColumn; column += deltaColumn)\r\n                                valid &= get(new Square(column, fromRow)) == null;\r\n                            // There must be no enemy piece attacking the squares between king's initial and final position.\r\n                            for (int column = kingFromColumn; valid && column != kingToColumn + deltaColumn; column += deltaColumn)\r\n                                valid &= !isSquareAttacked(new Square(column, fromRow), selfColor);\r\n                            if (valid)\r\n                                moves.add(new Move(from, new Square(rookFromColumn, fromRow)));\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Remove moves that would leave the king under check.\r\n            moves.removeIf(move -> {\r\n                Board nextBoard = new Board(this);\r\n                nextBoard.applyMoveUnsafe(move);\r\n                return nextBoard.isKingAttacked(selfColor);\r\n            });\r\n\r\n            return moves;\r\n        }\r\n\r\n        public boolean isMoveCastling(Move move) {\r\n            if (move.getFrom() == null)\r\n                return false;\r\n            Piece fromPiece = get(move.getFrom());\r\n            Piece toPiece = get(move.getTo());\r\n            return fromPiece.getPieceType() == PieceType.King && toPiece != null && toPiece.getPieceType() == PieceType.Rook && toPiece.getColor() == fromPiece.getColor();\r\n        }\r\n\r\n        // Simply performs a move assuming it is **valid** and **legal**!\r\n        public void applyMoveUnsafe(Move move) {\r\n            highlightSquares.clear();\r\n\r\n            Square from = move.getFrom(), to = move.getTo();\r\n            Piece fromPiece = from != null ? get(from) : null, toPiece = get(to);\r\n            Color selfColor = getColorToPlay();\r\n            Color opponentColor = selfColor.opposite();\r\n\r\n            if (from == null) {\r\n                if (!crazyHouse) throw new IllegalArgumentException(\"Attempted to apply a drop piece move in a non-crazyhouse game.\");\r\n                PieceType pieceType = move.getPieceType().get();\r\n                set(move.getTo(), new Piece(pieceType, selfColor));\r\n                addReserve(selfColor, pieceType, -1);\r\n            } else {\r\n                if (fromPiece != null) {\r\n                    // When king moves, invalidate its castlings.\r\n                    if (fromPiece.getPieceType() == PieceType.King) {\r\n                        for (Castling castling : castlings)\r\n                            castling.setAllowed(selfColor, false);\r\n                    }\r\n\r\n                    // If rook moved from initial position, invalidate its castling.\r\n                    if (fromPiece.getPieceType() == PieceType.Rook && from.getRow() == getInitialRow(selfColor)) {\r\n                        for (Castling castling : castlings) {\r\n                            if (castling.getColumn() != from.getColumn()) continue;\r\n                            castling.setAllowed(selfColor, false);\r\n                        }\r\n                    }\r\n\r\n                    // Pawn moving to en-passant square implies it captured en-passant.\r\n                    if (enPassantSquare != null && fromPiece.getPieceType() == PieceType.Pawn && to.equals(enPassantSquare))\r\n                        set(new Square(to.getColumn(), from.getRow()), null);\r\n\r\n                    // Update en-passant square if pawn moved 2 rows.\r\n                    enPassantSquare = null;\r\n                    if (fromPiece.getPieceType() == PieceType.Pawn && Math.abs(from.getRow() - to.getRow()) == 2)\r\n                        enPassantSquare = new Square(from.getColumn(), (from.getRow() + to.getRow()) / 2);\r\n                }\r\n\r\n                // A captured rook on its initial row invalidates its castling.\r\n                if (toPiece != null && toPiece.getPieceType() == PieceType.Rook && toPiece.getColor() == opponentColor && to.getRow() == getInitialRow(opponentColor)) {\r\n                    for (Castling castling : castlings) {\r\n                        if (castling.getColumn() != to.getColumn()) continue;\r\n                        castling.setAllowed(opponentColor, false);\r\n                    }\r\n                }\r\n\r\n                // Update the board.\r\n                if (isMoveCastling(move)) {\r\n                    set(from, null);\r\n                    set(to, null);\r\n                    int row = getInitialRow(selfColor);\r\n                    boolean queenCastling = to.getColumn() < from.getColumn();\r\n                    Square rookSquare = new Square(queenCastling ? Constants.QueenCastlingRookColumn : Constants.KingCastlingRookColumn, row);\r\n                    Square kingSquare = new Square(queenCastling ? Constants.QueenCastlingKingColumn : Constants.KingCastlingKingColumn, row);\r\n                    set(rookSquare, toPiece);\r\n                    set(kingSquare, fromPiece);\r\n                    highlightSquares.add(rookSquare);\r\n                    highlightSquares.add(kingSquare);\r\n                } else {\r\n                    // Add captured piece to reserve in crazyhouse.\r\n                    if (crazyHouse && toPiece != null) {\r\n                        PieceType pieceType = toPiece.getPieceType();\r\n                        if (toPiece.isPromoted())\r\n                            pieceType = PieceType.Pawn;\r\n                        addReserve(selfColor, pieceType, 1);\r\n                    }\r\n\r\n                    if (move.getPieceType().isPresent())\r\n                        set(move.getTo(), new Piece(move.getPieceType().get(), selfColor, true));\r\n                    else\r\n                        set(move.getTo(), get(move.getFrom()));\r\n                    set(move.getFrom(), null);\r\n                }\r\n            }\r\n\r\n            if (from != null) highlightSquares.add(from);\r\n            highlightSquares.add(to);\r\n\r\n            // Update clocks.\r\n            // Halfmove clock is reset when a pawn moves or a capture occurs.\r\n            if ((fromPiece != null && fromPiece.getPieceType() == PieceType.Pawn) || (toPiece != null && toPiece.getColor() != selfColor))\r\n                halfMoveClock = 0;\r\n            else\r\n                halfMoveClock++;\r\n            halfMoves++;\r\n        }\r\n\r\n        // To be called on the position before the move is made, assuming it is **valid** and **legal**!\r\n        // https://en.wikipedia.org/wiki/Algebraic_notation_(chess)\r\n        public String getAlgebraicMoveUnsafe(Move move) {\r\n            StringBuilder sb = new StringBuilder();\r\n            if (move.getFrom() == null) {\r\n                sb.append(move.getPieceType().get().toChar());\r\n                sb.append('@');\r\n                sb.append(move.getTo().toString());\r\n            } else if (isMoveCastling(move))\r\n                sb.append(move.getTo().getColumn() < move.getFrom().getColumn() ? \"O-O-O\" : \"O-O\");\r\n            else {\r\n                Piece fromPiece = get(move.getFrom());\r\n                Piece toPiece = get(move.getTo());\r\n                boolean takes = toPiece != null || (fromPiece.getPieceType() == PieceType.Pawn && move.getFrom().getColumn() != move.getTo().getColumn());\r\n\r\n                if (fromPiece.getPieceType() != PieceType.Pawn) {\r\n                    sb.append(fromPiece.getPieceType().toChar());\r\n                    // Check for disambiguation.\r\n                    List<Move> moves = generateMoves();\r\n                    moves.removeIf(x -> x.getFrom() == null || !x.getTo().equals(move.getTo()) || get(x.getFrom()).getPieceType() != fromPiece.getPieceType());\r\n                    if (moves.size() > 1) {\r\n                        moves.removeIf(x -> x.getFrom().getColumn() != move.getFrom().getColumn());\r\n                        if (moves.size() == 1)\r\n                            sb.append(Square.columnToChar(move.getFrom().getColumn()));\r\n                        else {\r\n                            moves.removeIf(x -> x.getFrom().getRow() != move.getFrom().getRow());\r\n                            if (moves.size() == 1)\r\n                                sb.append(Square.rowToChar(move.getFrom().getRow()));\r\n                            else {\r\n                                sb.append(Square.columnToChar(move.getFrom().getColumn()));\r\n                                sb.append(Square.rowToChar(move.getFrom().getRow()));\r\n                            }\r\n                        }\r\n                    }\r\n                } else if (takes)\r\n                    sb.append(Square.columnToChar(move.getFrom().getColumn()));\r\n                if (takes)\r\n                    sb.append('x');\r\n                sb.append(move.getTo().toString());\r\n\r\n                if (move.getPieceType().isPresent()) {\r\n                    sb.append('=');\r\n                    sb.append(move.getPieceType().get().toChar());\r\n                }\r\n            }\r\n\r\n            Board nextBoard = new Board(this);\r\n            nextBoard.applyMoveUnsafe(move);\r\n            if (nextBoard.isKingAttacked(nextBoard.getColorToPlay())) {\r\n                if (nextBoard.generateMoves().size() == 0)\r\n                    sb.append('#'); // Checkmate\r\n                else\r\n                    sb.append('+'); // Check\r\n            }\r\n\r\n            return sb.toString();\r\n        }\r\n    }\r\n\r\n    public static class Castling {\r\n        // Initial rook column.\r\n        private int column;\r\n        // Whether this castling is allowed for each color.\r\n        private boolean[] colorAllowed = new boolean[Constants.Colors];\r\n\r\n        public Castling(int column, boolean allowed) {\r\n            this.column = column;\r\n            for (int i = 0; i < colorAllowed.length; i++)\r\n                colorAllowed[i] = allowed;\r\n        }\r\n\r\n        public Castling(Castling other) {\r\n            column = other.column;\r\n            for (int i = 0; i < colorAllowed.length; i++)\r\n                colorAllowed[i] = other.colorAllowed[i];\r\n        }\r\n\r\n        public int getColumn() { return column; }\r\n        public boolean isAllowed(Color color) { return colorAllowed[color.ordinal()]; }\r\n        public void setAllowed(Color color, boolean allowed) { colorAllowed[color.ordinal()] = allowed; }\r\n    }\r\n\r\n    public enum Color {\r\n        White,\r\n        Black;\r\n\r\n        public Color opposite() { return this == White ? Black : White; }\r\n        public char toChar() { return this == White ? 'w' : 'b'; }\r\n\r\n        public static Color fromChar(char c) throws ParseException {\r\n            switch (c)\r\n            {\r\n                case 'w': return White;\r\n                case 'b': return Black;\r\n            }\r\n            throw new ParseException(String.format(\"Character '%c' does not designate a color.\", c), 0);\r\n        }\r\n    }\r\n\r\n    public static class Constants {\r\n        public static final int Columns = 8;\r\n        public static final int Rows = 8;\r\n        public static final int RangeLimit = 7;\r\n        public static final int Colors = 2;\r\n        public static final int Castlings = 2;\r\n\r\n        public static final int QueenCastlingKingColumn = 2;\r\n        public static final int QueenCastlingRookColumn = 3;\r\n        public static final int KingCastlingKingColumn = 6;\r\n        public static final int KingCastlingRookColumn = 5;\r\n        public static final int KnightMoves = 8;\r\n        public static final int[] KnightDeltaColumn = {-1,  1, -2,  2, -2,  2, -1,  1};\r\n        public static final int[] KnightDeltaRow    = {-2, -2, -1, -1,  1,  1,  2,  2};\r\n\r\n        public static final PieceType[] ReservePieces = { PieceType.Pawn, PieceType.Knight, PieceType.Bishop, PieceType.Rook, PieceType.Queen };\r\n\r\n        public static final int MaxMovesPerGame = 125;\r\n        public static final int MaxCommentLength = 30;\r\n    }\r\n\r\n    public static class Game {\r\n        private Board board;\r\n        private List<String> positionHistory = new ArrayList<String>();\r\n        private GameResult gameResult = GameResult.Undecided;\r\n\r\n        public Game(long seed, boolean crazyHouse) {\r\n            board = new Board(seed, crazyHouse);\r\n            positionHistory.add(board.toFenString(true));\r\n        }\r\n\r\n        public Board getBoard() { return board; }\r\n\r\n        public ViewData applyMove(Move move) throws GameException {\r\n            List<Move> moves = board.generateMoves();\r\n            if (!moves.contains(move)) throw new GameException(String.format(\"'%s' is not a legal move\", move.toString()));\r\n\r\n            ViewData viewData = new ViewData();\r\n            viewData.setMove(board, move);\r\n\r\n            board.applyMoveUnsafe(move);\r\n            positionHistory.add(board.toFenString(true));\r\n\r\n            viewData.setBoard(board);\r\n            viewData.setHighlights(board);\r\n            return viewData;\r\n        }\r\n\r\n        public ViewData getViewData() {\r\n            ViewData viewData = new ViewData();\r\n            viewData.setBoard(board);\r\n            return viewData;\r\n        }\r\n\r\n        public GameResult getGameResult() {\r\n            if (gameResult == GameResult.Undecided)\r\n                gameResult = computeGameResult();\r\n            return gameResult;\r\n        }\r\n\r\n        public void setGameResult(GameResult gameResult) { this.gameResult = gameResult; }\r\n\r\n        private GameResult computeGameResult() {\r\n            // No move possible means checkmate or stalemate.\r\n            if (board.generateMoves().size() == 0) {\r\n                if (board.isKingAttacked(board.getColorToPlay()))\r\n                    return board.getColorToPlay() == Color.White ? GameResult.BlackWins : GameResult.WhiteWins;\r\n                return GameResult.Stalemate;\r\n            }\r\n\r\n            // Check for threefold repetition.\r\n            if (positionHistory.size() > 0) {\r\n                int count = 0;\r\n                String lastPosition = positionHistory.get(positionHistory.size() - 1);\r\n                for (int i = 0; i < positionHistory.size() - 1; i++) {\r\n                    if (!positionHistory.get(i).equals(lastPosition)) continue;\r\n                    count++;\r\n                    if (count == 2)\r\n                        return GameResult.Repetition;\r\n                }\r\n            }\r\n\r\n            if (!board.hasSufficientMaterial())\r\n                return GameResult.InsufficientMaterial;\r\n\r\n            if (board.getHalfMoveClock() >= 100)\r\n                return GameResult.FiftyMove;\r\n\r\n            if (board.getHalfMoves() >= Constants.MaxMovesPerGame * 2)\r\n                return GameResult.ForcedDraw;\r\n\r\n            return GameResult.Undecided;\r\n        }\r\n    }\r\n\r\n    @SuppressWarnings(\"serial\")\r\n    public static class GameException extends Exception {\r\n        public GameException(String string) {\r\n            super(string);\r\n        }\r\n    }\r\n\r\n    public enum GameResult {\r\n        Undecided,\r\n        WhiteWins,\r\n        BlackWins,\r\n        Stalemate,\r\n        Repetition,\r\n        InsufficientMaterial,\r\n        FiftyMove,\r\n        ForcedDraw,\r\n        DrawByAgreement,\r\n        WhiteResigns,\r\n        BlackResigns,\r\n    }\r\n\r\n    public static class Move {\r\n        // If null, move is a drop.\r\n        private Square from = null;\r\n        private Square to = null;\r\n        // Used for promotion or drop.\r\n        private Optional<PieceType> pieceType = Optional.empty();\r\n\r\n        public Move(Square from, Square to) {\r\n            this.from = from;\r\n            this.to = to;\r\n        }\r\n        public Move(Square from, Square to, PieceType pieceType) {\r\n            this(from, to);\r\n            this.pieceType = Optional.of(pieceType);\r\n        }\r\n\r\n        // Parse from UCI representation. https://en.wikipedia.org/wiki/Universal_Chess_Interface\r\n        public Move(String str) throws ParseException {\r\n            if (str.length() < 4) throw new ParseException(\"Move string needs to be at least 4 characters.\", 0);\r\n            if (str.charAt(1) == '@') {\r\n                to = new Square(str.substring(2, 4));\r\n                pieceType = Optional.of(PieceType.fromChar(str.charAt(0)));\r\n                if (pieceType.get() == PieceType.King) throw new ParseException(\"Drop piece is invalid.\", 0);\r\n                return;\r\n            }\r\n            from = new Square(str.substring(0, 2));\r\n            to = new Square(str.substring(2, 4));\r\n            if (str.length() == 5) {\r\n                PieceType pieceType = PieceType.fromChar(str.charAt(4));\r\n                if (pieceType == PieceType.Pawn || pieceType == PieceType.King) throw new ParseException(\"Promotion piece is invalid.\", 0);\r\n                this.pieceType = Optional.of(pieceType);\r\n            }\r\n        }\r\n\r\n        public Square getFrom() { return from; }\r\n        public Square getTo() { return to; }\r\n        public Optional<PieceType> getPieceType() { return pieceType; }\r\n\r\n        // Encode move to UCI representation. https://en.wikipedia.org/wiki/Universal_Chess_Interface\r\n        public String toString() throws IllegalStateException {\r\n            if (to == null) throw new IllegalStateException(\"Move has no destination square.\");\r\n            if (from == null) {\r\n                if (!pieceType.isPresent()) throw new IllegalStateException(\"Drop move has no piece type.\");\r\n                return pieceType.get().toString() + \"@\" + to.toString();\r\n            }\r\n            String result = from.toString() + to.toString();\r\n            if (pieceType.isPresent())\r\n                result += Character.toString(Character.toLowerCase(pieceType.get().toChar()));\r\n            return result;\r\n        }\r\n\r\n        @Override public boolean equals(Object o) {\r\n            if (o == this) return true;\r\n            if (o == null || getClass() != o.getClass()) return false;\r\n            Move other = (Move)o;\r\n            return Objects.equals(from, other.from) && Objects.equals(to, other.to) && Objects.equals(pieceType, other.pieceType);\r\n        }\r\n        \r\n        @Override public int hashCode() {\r\n            return Objects.hash(from, to, pieceType);\r\n        }\r\n    }\r\n\r\n    public static class Piece {\r\n        private PieceType pieceType;\r\n        private Color color;\r\n        private boolean promoted;\r\n\r\n        public Piece(PieceType pieceType, Color color) { this(pieceType, color, false); }\r\n        public Piece(PieceType pieceType, Color color, boolean promoted) { this.pieceType = pieceType; this.color = color; this.promoted = promoted; }\r\n\r\n        public PieceType getPieceType() { return pieceType; }\r\n        public Color getColor() { return color; }\r\n        public boolean isPromoted() { return promoted; }\r\n\r\n        public Piece invert() { return new Piece(pieceType, color.opposite()); }\r\n        public Piece promote() { return new Piece(pieceType, color, true); }\r\n\r\n        public char toChar() { return pieceType.toChar(color); }\r\n        public String toString() { return Character.toString(toChar()); }\r\n\r\n        public static Piece fromChar(char c) throws ParseException {\r\n            PieceType pieceType = PieceType.fromChar(c);\r\n            Color color = Character.isUpperCase(c) ? Color.White : Color.Black;\r\n            return new Piece(pieceType, color);\r\n        }\r\n    }\r\n\r\n    public enum PieceType {\r\n        Pawn,\r\n        Knight,\r\n        Bishop,\r\n        Rook,\r\n        Queen,\r\n        King;\r\n\r\n        public char toChar() {\r\n            switch (this) {\r\n                case Pawn:   return 'P';\r\n                case Knight: return 'N';\r\n                case Bishop: return 'B';\r\n                case Rook:   return 'R';\r\n                case Queen:  return 'Q';\r\n                case King:   return 'K';\r\n            }\r\n            throw new IllegalStateException(\"Unrecognized piece type.\");\r\n        }\r\n\r\n        public char toChar(Color color) {\r\n            char c = toChar();\r\n            if (color == Color.Black) c = Character.toLowerCase(c);\r\n            return c;\r\n        }\r\n\r\n        public String toString() { return Character.toString(toChar()); }\r\n\r\n        public static PieceType fromChar(char c) throws ParseException {\r\n            switch (Character.toUpperCase(c)) {\r\n                case 'P': return Pawn;\r\n                case 'N': return Knight;\r\n                case 'B': return Bishop;\r\n                case 'R': return Rook;\r\n                case 'Q': return Queen;\r\n                case 'K': return King;\r\n            }\r\n            throw new ParseException(String.format(\"Character '%c' does not designate a piece.\", c), 0);\r\n        }\r\n    }\r\n\r\n    public static class Square {\r\n        private int column = 0, row = 0;\r\n\r\n        public Square(int column, int row) { this.column = column; this.row = row; }\r\n        public Square(String str) throws ParseException {\r\n            if (str.length() != 2) throw new ParseException(String.format(\"'%s' is not a square.\", str), 0);\r\n            column = charToColumn(str.charAt(0));\r\n            row = charToRow(str.charAt(1));\r\n        }\r\n\r\n        public int getColumn()   { return column; }\r\n        public int getRow()      { return row; }\r\n\r\n        // Returns whether this square is a light or dark square.\r\n        public boolean isLight() { return ((column & 1) != 0) ^ ((row & 1) != 0); }\r\n\r\n        // Returns a new square offset by the given directions or null if invalid.\r\n        public Square offset(int deltaColumn, int deltaRow) {\r\n            int newColumn = column + deltaColumn;\r\n            int newRow = row + deltaRow;\r\n            if (newColumn < 0 || newColumn >= Constants.Columns || newRow < 0 || newRow >= Constants.Rows)\r\n                return null;\r\n            return new Square(newColumn, newRow);\r\n        }\r\n\r\n        @Override public String toString() { return Character.toString(columnToChar(column)) + rowToChar(row); }\r\n\r\n        @Override public boolean equals(Object o) {\r\n            if (o == this) return true;\r\n            if (o == null || getClass() != o.getClass()) return false;\r\n            Square other = (Square)o;\r\n            return column == other.column && row == other.row;\r\n        }\r\n        @Override public int hashCode() { return row * 8 + column; }\r\n\r\n        public static char columnToChar(int column) { return (char)('a' + column); }\r\n\r\n        public static char rowToChar(int row) { return (char)('1' + row); }\r\n\r\n        public static int charToColumn(char c) throws ParseException {\r\n            c = Character.toLowerCase(c);\r\n            if (c < 'a' || c > 'h') throw new ParseException(String.format(\"Character '%c' is not a column.\", c), 0);\r\n            return c - 'a';\r\n        }\r\n\r\n        public static int charToRow(char c) throws ParseException {\r\n            if (c < '1' || c > '8') throw new ParseException(String.format(\"Character '%c' is not a row.\", c), 0);\r\n            return c - '1';\r\n        }\r\n    }\r\n\r\n    public static class ViewData {\r\n        private int game;\r\n        private int[] scores = new int[2];\r\n        private String result;\r\n        private String fen;\r\n        private List<String> highlights;\r\n        private String move;\r\n        private String status;\r\n        private String comment;\r\n\r\n        public int getGame() { return game; }\r\n        public void setGame(int game) { this.game = game; }\r\n\r\n        public int[] getScores() { return scores; }\r\n        public void setScores(int score1, int score2) {\r\n            scores[0] = score1;\r\n            scores[1] = score2;\r\n        }\r\n\r\n        public String getResult() { return result; }\r\n        public void setResult(String result) { this.result = result; }\r\n\r\n        public String getFen() { return fen; }\r\n        public void setBoard(Board board) { fen = board.toFenString(false); }\r\n\r\n        public List<String> getHighlights() { return highlights; }\r\n        public void setHighlights(Board board) {\r\n            this.highlights = board.getHighlightSquares().stream().map(square -> square.toString()).collect(Collectors.toList());\r\n        }\r\n\r\n        public String getMove() { return move; }\r\n        public void setMove(String move) {\r\n            this.move = move;\r\n        }\r\n        public void setMove(Board board, Move move) {\r\n            this.move = board.getAlgebraicMoveUnsafe(move);\r\n        }\r\n\r\n        public String getStatus() { return status; }\r\n        public void setStatus(String status) { this.status = status; }\r\n\r\n        public String getComment() { return comment; }\r\n        public void setComment(String comment) { this.comment = comment; }\r\n    }\r\n\r\n    public static class ViewGlobalData {\r\n        private boolean crazyHouse = false;\r\n        \r\n        public boolean getCrazyHouse() { return crazyHouse; }\r\n        public void setCrazyHouse(boolean crazyHouse) { this.crazyHouse = crazyHouse; }\r\n    }\r\n\r\n    public static int getScore(Board board) {\r\n        int score = 0;\r\n        for (Piece[] pieces : board.cells) {\r\n            for (Piece piece : pieces) {\r\n                if (piece == null) continue;\r\n                int pieceScore = 0;\r\n                switch (piece.getPieceType()) {\r\n                    case Pawn: pieceScore += 1; break;\r\n                    case Knight: pieceScore += 3; break;\r\n                    case Bishop: pieceScore += 3; break;\r\n                    case Rook: pieceScore += 5; break;\r\n                    case Queen: pieceScore += 8; break;\r\n                }\r\n                if (piece.getColor() != board.getColorToPlay())\r\n                    pieceScore = -pieceScore;\r\n                score += pieceScore;\r\n            }\r\n        }\r\n        return score;\r\n    }\r\n\r\n    public static int search(Board board, int depth) {\r\n        if (depth == 0)\r\n            return getScore(board);\r\n        List<Move> moves = board.generateMoves();\r\n        int bestScore = -999;\r\n        if (moves.isEmpty()) {\r\n            if (board.isKingAttacked(board.getColorToPlay()))\r\n                return -999;\r\n            return 0;\r\n        }\r\n        for (Move move : moves) {\r\n            Board newBoard = new Board(board);\r\n            newBoard.applyMoveUnsafe(move);\r\n            int score = -search(newBoard, depth - 1);\r\n            if (score > bestScore)\r\n                bestScore = score;\r\n        }\r\n        return bestScore;\r\n    }\r\n\r\n    public static void main(String args[]) throws ParseException {\r\n        Scanner in = new Scanner(System.in);\r\n        int constantsCount = in.nextInt();\r\n        for (int i = 0; i < constantsCount; i++) {\r\n            String name = in.next();\r\n            String value = in.next();\r\n        }\r\n        in.nextLine();\r\n\r\n        System.out.println(\"fen\");\r\n\r\n        while (true) {\r\n            String fen = in.nextLine();\r\n            Board board = new Board(fen, false);\r\n\r\n            Move bestMove = null;\r\n            int bestScore = -999;\r\n            List<Move> moves = board.generateMoves();\r\n            Collections.shuffle(moves);\r\n            for (Move move : moves) {\r\n                Board newBoard = new Board(board);\r\n                newBoard.applyMoveUnsafe(move);\r\n                int score = -search(newBoard, 1);\r\n                if (score > bestScore) {\r\n                    System.err.println(move.toString() + \" = \" + score);\r\n                    bestScore = score;\r\n                    bestMove = move;\r\n                }\r\n            }\r\n\r\n            System.out.println(bestMove.toString());\r\n        }\r\n    }\r\n}",
          "testCases": [],
          "maxPlayers": 2,
          "minPlayers": 2,
          "statements": {
            "1": "<div id=\"statement_back\" class=\"statement_back\" style=\"display:none\"></div>\r\n<div class=\"statement-body\">\r\n  <!-- GOAL -->\r\n  <div class=\"statement-section statement-goal\">\r\n    <h1>\r\n      <span class=\"icon icon-goal\">&nbsp;</span>\r\n      <span>The Game</span>\r\n    </h1>\r\n    <div class=\"statement-goal-content\">\r\n      <p>Chess, the Game of Kings, is a classical board game that has been played for centuries, and has also been a cornerstone of artificial intelligence development for decades. You can easily learn all about how this game is played by doing an online search or reading this <a href='https://en.wikipedia.org/wiki/Chess'>Wikipedia article</a>.</p>\r\n      <br>\r\n      <p>This Codingame implementation makes use of the <a href='https://en.wikipedia.org/wiki/Chess960'>Chess960</a> rules, also known as Fischer Random Chess, where the initial starting position is randomly shuffled among 960 possibilities. This is done to promote variety as well as to prevent the hardcoding of initial moves using an opening book.</p>\r\n      <br>\r\n      <p>Special thanks to the <a href='http://mip.noekeon.org/HTMLTTChess/chess_merida_unicode.html'>Chess Merida Unicode</a> font for the rendering of piece graphics and <a href='https://commons.wikimedia.org/wiki/File:Chess_Set.jpg'>Wikimedia Commons</a> for the cover picture.</p>\r\n    </div>\r\n  </div>\r\n  <!-- RULES -->\r\n  <div class=\"statement-section statement-rules\">\r\n    <h1>\r\n      <span class=\"icon icon-rules\">&nbsp;</span>\r\n      <span>Rules</span>\r\n    </h1>\r\n    <div>\r\n      <div class=\"statement-rules-content\">\r\n        <p>Play <const>2</const> games against your opponent, once as each color  using the same starting position, where a win gives <const>1</const> point and a draw gives <const>Â½</const> point.</p>\r\n        <br>\r\n        <p>If any of the following happens, the current game will result into a draw:</p>\r\n        <ul>\r\n          <li>A player is unable to make a legal move while their king is not being under check, a <a href='https://en.wikipedia.org/wiki/Stalemate'>Stalemate</a> occurs.\r\n          <li>The same position occurring for the third time, also known as a <a href='https://en.wikipedia.org/wiki/Threefold_repetition'>Threefold Repetition</a>.</li>\r\n          <li>There is insufficient material for either player to deliver a checkmate. This includes:\r\n            <ul>\r\n              <li>King vs king</li>\r\n              <li>King+knight vs king</li>\r\n              <li>King+bishop vs king</li>\r\n              <li>King+bishop vs king+bishop if both bishops are on the same square color.</li>\r\n            </ul>\r\n          </li>\r\n          <li>No piece capture and no pawn has moved for 50 moves, using the <a href='https://en.wikipedia.org/wiki/Fifty-move_rule'>Fifty-Move rule</a>.</li>\r\n          <li>After <var>maxMoves</var> moves are played.</li>\r\n          <li>If one side offers a draw and the other side accepts it, also known as a draw by agreement.\r\n        </ul>\r\n        <br>\r\n        <div class=\"statement-victory-conditions\">\r\n          <div class=\"icon victory\"></div>\r\n          <div class=\"blk\">\r\n            <div class=\"title\">Victory Conditions</div>\r\n            <div class=\"text\">\r\n              <ul>\r\n                <li>You complete both matches having more points than your opponent.</li>\r\n                <li>Your opponent loses.</li>\r\n              </ul>\r\n            </div>\r\n          </div>\r\n        </div>\r\n        <div class=\"statement-lose-conditions\">\r\n          <div class=\"icon lose\"></div>\r\n          <div class=\"blk\">\r\n            <div class=\"title\">Defeat Conditions</div>\r\n            <div class=\"text\">\r\n              <ul>\r\n                <li>You attempt to make an illegal move.</li>\r\n                <li>You do not provide an output in the alloted time.</li>\r\n              </ul>\r\n            </div>\r\n          </div>\r\n        </div>\r\n        <br>\r\n      </div>\r\n    </div>\r\n  </div>\r\n  <!-- EXPERT RULES -->\r\n  <div class=\"statement-section statement-expertrules\">\r\n    <h1>\r\n      <span class=\"icon icon-expertrules\">&nbsp;</span>\r\n      <span>Technical details</span>\r\n    </h1>\r\n    <div class=\"statement-expert-rules-content\">\r\n      <ul>\r\n        <li>The current game state is encoded as a single line using the <a href='https://en.wikipedia.org/wiki/Forsyth-Edwards_Notation'>ForsythâEdwards Notation</a>, hereby referred to as FEN.</li>\r\n        <li>Game moves are internally encoded as done in the <a href='https://en.wikipedia.org/wiki/Universal_Chess_Interface'>Universal Chess Interface</a> protocol, hereby referred to as UCI.</li>\r\n        <li>Game moves are displayed in the viewer using the <a href='https://en.wikipedia.org/wiki/Algebraic_notation_(chess)'>Algebraic Notation</a>.</li>\r\n        <li>Piece characters are using the english language, therefore P for pawns, N for knights, B for bishops, R for rooks, Q for queens and K for kings.</li> \r\n        <li>You can access and copy/paste the FEN of the current position and PGN (<a href='https://en.wikipedia.org/wiki/Portable_Game_Notation'>Portable Game Notation</a>) of both games by opening the settings panel (<img style=\"opacity:.8;background:#20252a;\"\r\n        height=\"18\" src=\"https://www.codingame.com/servlet/fileservlet?id=3463235186409\" width=\"18\">).</li>\r\n        <li>You can force the initial position to be the classical one by specifying <const>seed=0</const> in the game options.\r\n      </ul>\r\n      <p>The source code of this game is available on <a href='https://github.com/recurs3/codingame-chess/'>GitHub</a>.</p>\r\n    </div>\r\n  </div>\r\n  <!-- EXAMPLES -->\r\n  <div class=\"statement-section statement-examples\">\r\n    <h1>\r\n      <span class=\"icon icon-example\">&nbsp;</span>\r\n      <span>Notes and examples</span>\r\n    </h1>\r\n    <div class=\"statement-examples-text\">\r\n      <p>Draw offers only last for one turn. If the opponent does not accept it, it is revoked.</p>\r\n      <br>\r\n      <h1>Input</h1>\r\n      <p>Because of Chess960, the castling field of the FEN string does not make use of <const>KQkq</const>. The column names are used instead, so the classical castling positions would be encoded as <const>AHah</const>.</p>\r\n      <br>\r\n      <p>The presence of an en-passant square in the FEN does not mean that a legal en-passant capture is possible.</p>\r\n      <br>\r\n      <h1>Output</h1>\r\n      <p>As mentioned above, specifying the move to make is done through the UCI protocol. It is simply the source square immediately followed by the destination square. For example, the classical king's pawn opening 1. e4 would be encoded as <const>e2e4</const>.</p>\r\n      <br>\r\n      <p>Piece promotion is specified by appending the piece character at the end. For example, <const>h7h8q</const> would promote the white h pawn to a queen.</p>\r\n      <br>\r\n      <p>Castling is done as a king moving to its own rook. In a classical starting position, a king-side castling would be <const>e1h1</const>, and a queen-side castling would be <const>e1a1</const>. Because of the Chess960 setup, a king moving by 2 squares to signal castling is <b>not</b> allowed.</p>\r\n      <br>\r\n      <p>You can make use of the <var>moves</var> input to validate your own move generation and the move you make as output.</p>\r\n    </div>\r\n  </div>\r\n  <!-- EXAMPLES -->\r\n  <div class=\"statement-section statement-examples\">\r\n    <h1>\r\n      <span class=\"icon icon-example\">&nbsp;</span>\r\n      <span>External resources</span>\r\n    </h1>\r\n    <div class=\"statement-examples-text\">\r\n      <ul>\r\n        <li><a href=\"https://www.chessprogramming.org/\">Chess programming wiki</a></li>\r\n      </ul>\r\n    </div>\r\n  </div>\r\n  <!-- PROTOCOL -->\r\n  <div class=\"statement-section statement-protocol\">\r\n    <h1>\r\n      <span class=\"icon icon-protocol\">&nbsp;</span>\r\n      <span>Game Protocol</span>\r\n    </h1>\r\n    <!-- Protocol block -->\r\n    <div class=\"blk\">\r\n      <div class=\"text\">The first turn is used for the referee to communicate the <b>game constants</b> and for the bot to configure its desired <b>inputs</b>.</div>\r\n    </div>\r\n\r\n    <!-- Protocol block -->\r\n    <div class=\"blk\">\r\n      <div class=\"title\">Input</div>\r\n      <div class=\"text\">\r\n        <p><span class=\"statement-lineno\">Line 1: </span> <var>constantsCount</var>, the number of constants communicated by the game referee.</p>\r\n        <p><span class=\"statement-lineno\">Next <var>constantsCount</var> lines: </span> <const>2</const> space-separated values indicating the <var>name</var> and <var>value</var> of the constant.</p>\r\n        <br>\r\n        <p>Currently defined constants are:</p>\r\n        <li><var>crazyHouse</var>: Boolean integer with <const>0</const> as false and <const>1</const> as true, indicating whether crazyhouse rules are enabled. Always <const>0</const> for this arena.</li>\r\n        <li><var>maxMoves</var>: Integer indicating the maximum number of moves per player per game. After this, a draw will be forced as a game result. Currently set at <const>125</const>.\r\n      </div>\r\n    </div>\r\n\r\n    <!-- Protocol block -->\r\n    <div class=\"blk\">\r\n      <div class=\"title\">Output</div>\r\n      <div class=\"text\">\r\n        <span class=\"statement-lineno\">A single line</span> configuring which inputs will be sent by the referee on each game turn. You can write any of the following values separated with spaces to receive the associated input, in the same order that is given.\r\n        <ul>\r\n          <li><const>fen</const>: The <a href='https://en.wikipedia.org/wiki/Forsyth-Edwards_Notation'>FEN representation</a> of the current game. <b>Strongly recommended</b>.</li>\r\n          <li><const>moves</const>: The list of legal moves.</li>\r\n          <li><const>lastmove</const>: The last move made by the opponent.</li>\r\n          <li><const>draw</const>: Whether the opponent has made a draw offer.</li>\r\n          <li><const>game</const>: The game number currently being played.\r\n          <li><const>score</const>: The current score for each player.\r\n        </ul>\r\n        <br>\r\n      </div>\r\n    </div>\r\n\r\n    <!-- Protocol block -->\r\n    <div class=\"blk\">\r\n      <div class=\"text\">For all the following turns this protocol is used to play out the games.</div>\r\n    </div>\r\n\r\n    <!-- Protocol block -->\r\n    <div class=\"blk\">\r\n      <div class=\"title\">Input</div>\r\n      <div class=\"text\">\r\n        <p>The values sent are in accordance with the configuration sent on the first turn, in the same order they were given.</p>\r\n        <ul>\r\n          <li><var>fen</var>: A line containing <const>6</const> fields <var>board</var> <var>color</var> <var>castling</var> <var>enPassant</var> <var>halfMoveClock</var> <var>fullMove</var> separated with spaces, representing a <a href='https://en.wikipedia.org/wiki/Forsyth-Edwards_Notation'>FEN string</a>.</li>\r\n          <li><var>moves</var>: A line containing an integer <var>movesCount</var>, followed by <var>movesCount</var> lines having one <var>move</var> per line, a string with a UCI move.</li>\r\n          <li><var>lastmove</var>: A line with a string containing the UCI move played by the opponent last turn, or <const>none</const> if it is the first turn of the game.</li>\r\n          <li><var>draw</var>: A line containing a boolean integer, <const>1</const> if a draw was offered last turn by the opponent, <const>0</const> otherwise.</li>\r\n          <li><var>game</var>: A line containing an integer representing the current game number, starting at <const>1</const> for the first game.</li>\r\n          <li><var>score</var>: A line containing <const>2</const> integers separated by a space, the score of the current player followed by the score of the opponent. The score is given in half-points, so <const>Â½</const> = <const>1</const>.\r\n        </ul>\r\n      </div>\r\n    </div>\r\n\r\n    <!-- Protocol block -->\r\n    <div class=\"blk\">\r\n      <div class=\"title\">Output</div>\r\n      <div class=\"text\">\r\n        <span class=\"statement-lineno\">A single line</span> with the move to be made, encoded with the UCI protocol.\r\n        <ul>\r\n          <li>A comment can be added to be displayed in the viewer by adding a space after the move and writing its content.</li>\r\n          <li>You can offer a draw to your opponent by adding <const>=</const> right after the move, without a space.</li>\r\n          <li>You can accept a draw offer by outputting <const>draw</const> instead of a move. Note that this is only legal if a draw offer was made the previous turn! Make sure to check the input first.</li>\r\n          <li>You can resign the current game by outputting <const>resign</const> instead of a move. This will proceed to the next game or end the match if no more is to be played.</li>\r\n          <li>You can play a random move by outputting <const>random</const> instead of a move. This is admittedly only useful for stub code generation.</li>\r\n        </ul>\r\n        <br>\r\n      </div>\r\n    </div>\r\n\r\n    <!-- Protocol block -->\r\n    <div class=\"blk\">\r\n      <div class=\"title\">Constraints</div>\r\n      <div class=\"text\">\r\n        Response time per turn â¤ <const>50</const> milliseconds.<br>\r\n        Response time for the first turn â¤ <const>1</const> second.</div>\r\n    </div>\r\n  </div>\r\n</div>",
            "2": "<div id=\"statement_back\" class=\"statement_back\" style=\"display:none\"></div>\r\n<div class=\"statement-body\">\r\n  <!-- GOAL -->\r\n  <div class=\"statement-section statement-goal\">\r\n    <h1>\r\n      <span class=\"icon icon-goal\">&nbsp;</span>\r\n      <span>The Game</span>\r\n    </h1>\r\n    <div class=\"statement-goal-content\">\r\n      <p>Chess, the Game of Kings, is a classical board game that has been played for centuries, and has also been a cornerstone of artificial intelligence development for decades. You can easily learn all about how this game is played by doing an online search or reading this <a href='https://en.wikipedia.org/wiki/Chess'>Wikipedia article</a>.</p>\r\n      <br>\r\n      <p>This Codingame implementation makes use of the <a href='https://en.wikipedia.org/wiki/Chess960'>Chess960</a> rules, also known as Fischer Random Chess, where the initial starting position is randomly shuffled among 960 possibilities. This is done to promote variety as well as to prevent the hardcoding of initial moves using an opening book.</p>\r\n      <br>\r\n      <p>Special thanks to the <a href='http://mip.noekeon.org/HTMLTTChess/chess_merida_unicode.html'>Chess Merida Unicode</a> font for the rendering of piece graphics and <a href='https://commons.wikimedia.org/wiki/File:Chess_Set.jpg'>Wikimedia Commons</a> for the cover picture.</p>\r\n    </div>\r\n  </div>\r\n  <!-- RULES -->\r\n  <div class=\"statement-section statement-rules\">\r\n    <h1>\r\n      <span class=\"icon icon-rules\">&nbsp;</span>\r\n      <span>Rules</span>\r\n    </h1>\r\n    <div>\r\n      <div class=\"statement-rules-content\">\r\n        <p>Play <const>2</const> games against your opponent, once as each color  using the same starting position, where a win gives <const>1</const> point and a draw gives <const>Â½</const> point.</p>\r\n        <br>\r\n        <p>If any of the following happens, the current game will result into a draw:</p>\r\n        <ul>\r\n          <li>A player is unable to make a legal move while their king is not being under check, a <a href='https://en.wikipedia.org/wiki/Stalemate'>Stalemate</a> occurs.\r\n          <li>The same position occurring for the third time, also known as a <a href='https://en.wikipedia.org/wiki/Threefold_repetition'>Threefold Repetition</a>.</li>\r\n          <li>There is insufficient material for either player to deliver a checkmate. This includes:\r\n            <ul>\r\n              <li>King vs king</li>\r\n              <li>King+knight vs king</li>\r\n              <li>King+bishop vs king</li>\r\n              <li>King+bishop vs king+bishop if both bishops are on the same square color.</li>\r\n            </ul>\r\n          </li>\r\n          <li>No piece capture and no pawn has moved for 50 moves, using the <a href='https://en.wikipedia.org/wiki/Fifty-move_rule'>Fifty-Move rule</a>.</li>\r\n          <li>After <var>maxMoves</var> moves are played.</li>\r\n          <li>If one side offers a draw and the other side accepts it, also known as a draw by agreement.\r\n        </ul>\r\n        <br>\r\n        <div class=\"statement-victory-conditions\">\r\n          <div class=\"icon victory\"></div>\r\n          <div class=\"blk\">\r\n            <div class=\"title\">Victory Conditions</div>\r\n            <div class=\"text\">\r\n              <ul>\r\n                <li>You complete both matches having more points than your opponent.</li>\r\n                <li>Your opponent loses.</li>\r\n              </ul>\r\n            </div>\r\n          </div>\r\n        </div>\r\n        <div class=\"statement-lose-conditions\">\r\n          <div class=\"icon lose\"></div>\r\n          <div class=\"blk\">\r\n            <div class=\"title\">Defeat Conditions</div>\r\n            <div class=\"text\">\r\n              <ul>\r\n                <li>You attempt to make an illegal move.</li>\r\n                <li>You do not provide an output in the alloted time.</li>\r\n              </ul>\r\n            </div>\r\n          </div>\r\n        </div>\r\n        <br>\r\n      </div>\r\n    </div>\r\n  </div>\r\n  <!-- EXPERT RULES -->\r\n  <div class=\"statement-section statement-expertrules\">\r\n    <h1>\r\n      <span class=\"icon icon-expertrules\">&nbsp;</span>\r\n      <span>Technical details</span>\r\n    </h1>\r\n    <div class=\"statement-expert-rules-content\">\r\n      <ul>\r\n        <li>The current game state is encoded as a single line using the <a href='https://en.wikipedia.org/wiki/Forsyth-Edwards_Notation'>ForsythâEdwards Notation</a>, hereby referred to as FEN.</li>\r\n        <li>Game moves are internally encoded as done in the <a href='https://en.wikipedia.org/wiki/Universal_Chess_Interface'>Universal Chess Interface</a> protocol, hereby referred to as UCI.</li>\r\n        <li>Game moves are displayed in the viewer using the <a href='https://en.wikipedia.org/wiki/Algebraic_notation_(chess)'>Algebraic Notation</a>.</li>\r\n        <li>Piece characters are using the english language, therefore P for pawns, N for knights, B for bishops, R for rooks, Q for queens and K for kings.</li> \r\n        <li>You can access and copy/paste the FEN of the current position and PGN (<a href='https://en.wikipedia.org/wiki/Portable_Game_Notation'>Portable Game Notation</a>) of both games by opening the settings panel (<img style=\"opacity:.8;background:#20252a;\"\r\n        height=\"18\" src=\"https://www.codingame.com/servlet/fileservlet?id=3463235186409\" width=\"18\">).</li>\r\n        <li>You can force the initial position to be the classical one by specifying <const>seed=0</const> in the game options.\r\n      </ul>\r\n      <p>The source code of this game is available on <a href='https://github.com/recurs3/codingame-chess/'>GitHub</a>.</p>\r\n    </div>\r\n  </div>\r\n  <!-- EXAMPLES -->\r\n  <div class=\"statement-section statement-examples\">\r\n    <h1>\r\n      <span class=\"icon icon-example\">&nbsp;</span>\r\n      <span>Notes and examples</span>\r\n    </h1>\r\n    <div class=\"statement-examples-text\">\r\n      <p>Draw offers only last for one turn. If the opponent does not accept it, it is revoked.</p>\r\n      <br>\r\n      <h1>Input</h1>\r\n      <p>Because of Chess960, the castling field of the FEN string does not make use of <const>KQkq</const>. The column names are used instead, so the classical castling positions would be encoded as <const>AHah</const>.</p>\r\n      <br>\r\n      <p>The presence of an en-passant square in the FEN does not mean that a legal en-passant capture is possible.</p>\r\n      <br>\r\n      <h1>Output</h1>\r\n      <p>As mentioned above, specifying the move to make is done through the UCI protocol. It is simply the source square immediately followed by the destination square. For example, the classical king's pawn opening 1. e4 would be encoded as <const>e2e4</const>.</p>\r\n      <br>\r\n      <p>Piece promotion is specified by appending the piece character at the end. For example, <const>h7h8q</const> would promote the white h pawn to a queen.</p>\r\n      <br>\r\n      <p>Castling is done as a king moving to its own rook. In a classical starting position, a king-side castling would be <const>e1h1</const>, and a queen-side castling would be <const>e1a1</const>. Because of the Chess960 setup, a king moving by 2 squares to signal castling is <b>not</b> allowed.</p>\r\n      <br>\r\n      <p>You can make use of the <var>moves</var> input to validate your own move generation and the move you make as output.</p>\r\n    </div>\r\n  </div>\r\n  <!-- EXAMPLES -->\r\n  <div class=\"statement-section statement-examples\">\r\n    <h1>\r\n      <span class=\"icon icon-example\">&nbsp;</span>\r\n      <span>External resources</span>\r\n    </h1>\r\n    <div class=\"statement-examples-text\">\r\n      <ul>\r\n        <li><a href=\"https://www.chessprogramming.org/\">Chess programming wiki</a></li>\r\n      </ul>\r\n    </div>\r\n  </div>\r\n  <!-- PROTOCOL -->\r\n  <div class=\"statement-section statement-protocol\">\r\n    <h1>\r\n      <span class=\"icon icon-protocol\">&nbsp;</span>\r\n      <span>Game Protocol</span>\r\n    </h1>\r\n    <!-- Protocol block -->\r\n    <div class=\"blk\">\r\n      <div class=\"text\">The first turn is used for the referee to communicate the <b>game constants</b> and for the bot to configure its desired <b>inputs</b>.</div>\r\n    </div>\r\n\r\n    <!-- Protocol block -->\r\n    <div class=\"blk\">\r\n      <div class=\"title\">Input</div>\r\n      <div class=\"text\">\r\n        <p><span class=\"statement-lineno\">Line 1: </span> <var>constantsCount</var>, the number of constants communicated by the game referee.</p>\r\n        <p><span class=\"statement-lineno\">Next <var>constantsCount</var> lines: </span> <const>2</const> space-separated values indicating the <var>name</var> and <var>value</var> of the constant.</p>\r\n        <br>\r\n        <p>Currently defined constants are:</p>\r\n        <li><var>crazyHouse</var>: Boolean integer with <const>0</const> as false and <const>1</const> as true, indicating whether crazyhouse rules are enabled. Always <const>0</const> for this arena.</li>\r\n        <li><var>maxMoves</var>: Integer indicating the maximum number of moves per player per game. After this, a draw will be forced as a game result. Currently set at <const>125</const>.\r\n      </div>\r\n    </div>\r\n\r\n    <!-- Protocol block -->\r\n    <div class=\"blk\">\r\n      <div class=\"title\">Output</div>\r\n      <div class=\"text\">\r\n        <span class=\"statement-lineno\">A single line</span> configuring which inputs will be sent by the referee on each game turn. You can write any of the following values separated with spaces to receive the associated input, in the same order that is given.\r\n        <ul>\r\n          <li><const>fen</const>: The <a href='https://en.wikipedia.org/wiki/Forsyth-Edwards_Notation'>FEN representation</a> of the current game. <b>Strongly recommended</b>.</li>\r\n          <li><const>moves</const>: The list of legal moves.</li>\r\n          <li><const>lastmove</const>: The last move made by the opponent.</li>\r\n          <li><const>draw</const>: Whether the opponent has made a draw offer.</li>\r\n          <li><const>game</const>: The game number currently being played.\r\n          <li><const>score</const>: The current score for each player.\r\n        </ul>\r\n        <br>\r\n      </div>\r\n    </div>\r\n\r\n    <!-- Protocol block -->\r\n    <div class=\"blk\">\r\n      <div class=\"text\">For all the following turns this protocol is used to play out the games.</div>\r\n    </div>\r\n\r\n    <!-- Protocol block -->\r\n    <div class=\"blk\">\r\n      <div class=\"title\">Input</div>\r\n      <div class=\"text\">\r\n        <p>The values sent are in accordance with the configuration sent on the first turn, in the same order they were given.</p>\r\n        <ul>\r\n          <li><var>fen</var>: A line containing <const>6</const> fields <var>board</var> <var>color</var> <var>castling</var> <var>enPassant</var> <var>halfMoveClock</var> <var>fullMove</var> separated with spaces, representing a <a href='https://en.wikipedia.org/wiki/Forsyth-Edwards_Notation'>FEN string</a>.</li>\r\n          <li><var>moves</var>: A line containing an integer <var>movesCount</var>, followed by <var>movesCount</var> lines having one <var>move</var> per line, a string with a UCI move.</li>\r\n          <li><var>lastmove</var>: A line with a string containing the UCI move played by the opponent last turn, or <const>none</const> if it is the first turn of the game.</li>\r\n          <li><var>draw</var>: A line containing a boolean integer, <const>1</const> if a draw was offered last turn by the opponent, <const>0</const> otherwise.</li>\r\n          <li><var>game</var>: A line containing an integer representing the current game number, starting at <const>1</const> for the first game.</li>\r\n          <li><var>score</var>: A line containing <const>2</const> integers separated by a space, the score of the current player followed by the score of the opponent. The score is given in half-points, so <const>Â½</const> = <const>1</const>.\r\n        </ul>\r\n      </div>\r\n    </div>\r\n\r\n    <!-- Protocol block -->\r\n    <div class=\"blk\">\r\n      <div class=\"title\">Output</div>\r\n      <div class=\"text\">\r\n        <span class=\"statement-lineno\">A single line</span> with the move to be made, encoded with the UCI protocol.\r\n        <ul>\r\n          <li>A comment can be added to be displayed in the viewer by adding a space after the move and writing its content.</li>\r\n          <li>You can offer a draw to your opponent by adding <const>=</const> right after the move, without a space.</li>\r\n          <li>You can accept a draw offer by outputting <const>draw</const> instead of a move. Note that this is only legal if a draw offer was made the previous turn! Make sure to check the input first.</li>\r\n          <li>You can resign the current game by outputting <const>resign</const> instead of a move. This will proceed to the next game or end the match if no more is to be played.</li>\r\n          <li>You can play a random move by outputting <const>random</const> instead of a move. This is admittedly only useful for stub code generation.</li>\r\n        </ul>\r\n        <br>\r\n      </div>\r\n    </div>\r\n\r\n    <!-- Protocol block -->\r\n    <div class=\"blk\">\r\n      <div class=\"title\">Constraints</div>\r\n      <div class=\"text\">\r\n        Response time per turn â¤ <const>50</const> milliseconds.<br>\r\n        Response time for the first turn â¤ <const>1</const> second.</div>\r\n    </div>\r\n  </div>\r\n</div>"
          },
          "questionType": "multi",
          "stubGenerator": "read constantsCount:int\nloop constantsCount read name:word(256) value:word(256)\nwrite fen\n\ngameloop\nread board:word(256) color:word(1) castling:word(4) enPassant:word(2) halfMoveClock:int fullMove:int\nwrite random\n",
          "welcomePopups": {},
          "aiCodeExtension": "java",
          "criteriaLanguageMap": {}
        },
        "1": {
          "aiCode": "import java.util.*;\r\nimport java.io.*;\r\nimport java.math.*;\r\n\r\nimport java.text.ParseException;\r\nimport java.util.function.BiConsumer;\r\nimport java.util.stream.Collectors;\r\n\r\nclass Player {\r\n\r\n    public static class Board {\r\n        // Board cells with piece when present, null when not.\r\n        private Piece[][] cells = new Piece[Constants.Columns][Constants.Rows];\r\n        // Castlings that may still be available.\r\n        private List<Castling> castlings = new ArrayList<Castling>();\r\n        // En-passant square when last move is pawn moving 2 squares from initial row.\r\n        private Square enPassantSquare = null;\r\n        // Number of half-moves since the last capture or pawn advance, used for the fifty-move draw.\r\n        private int halfMoveClock = 0;\r\n        // Number of half-moves since the start of the game.\r\n        private int halfMoves = 0;\r\n        // Whether crazyhouse rules are enabled.\r\n        private boolean crazyHouse = false;\r\n        // Reserve pieces for each color, used for crazyhouse.\r\n        private int[][] reservePieces = new int[Constants.Colors][Constants.ReservePieces.length];\r\n        // List of squares of highlight to show last move in viewer.\r\n        private List<Square> highlightSquares = new ArrayList<Square>();\r\n\r\n        public Board(Board other) {\r\n            for (int column = 0; column < Constants.Columns; column++) {\r\n                for (int row = 0; row < Constants.Rows; row++)\r\n                    cells[column][row] = other.cells[column][row];\r\n            }\r\n            for (Castling castling : other.castlings)\r\n                castlings.add(new Castling(castling));\r\n            enPassantSquare = other.enPassantSquare;\r\n            halfMoveClock = other.halfMoveClock;\r\n            halfMoves = other.halfMoves;\r\n            crazyHouse = other.crazyHouse;\r\n            for (int color = 0; color < Constants.Colors; color++) {\r\n                for (int i = 0; i < Constants.ReservePieces.length; i++)\r\n                    reservePieces[color][i] = other.reservePieces[color][i];\r\n            }\r\n        }\r\n\r\n        public Board(long seed, boolean crazyHouse) {\r\n            this.crazyHouse = crazyHouse;\r\n\r\n            if (seed == 0) {\r\n                // seed=0 means classic chess initial row.\r\n                PieceType[] initialRow = { PieceType.Rook, PieceType.Knight, PieceType.Bishop, PieceType.Queen, PieceType.King, PieceType.Bishop, PieceType.Knight, PieceType.Rook};\r\n                int row = getInitialRow(Color.White);\r\n                for (int column = 0; column < initialRow.length; column++)\r\n                    set(new Square(column, row), new Piece(initialRow[column], Color.White));\r\n            } else {\r\n                // Random picks on initial row for a total of 960 combinations.\r\n                // Following procedure as described at https://en.wikipedia.org/wiki/Chess960#Setup\r\n                int row = getInitialRow(Color.White);\r\n                Random rng = new Random(seed);\r\n                set(new Square(rng.nextInt(4) * 2, row), new Piece(PieceType.Bishop, Color.White));\r\n                set(new Square(rng.nextInt(4) * 2 + 1, row), new Piece(PieceType.Bishop, Color.White));\r\n                BiConsumer<Integer, PieceType> placePiece = (Integer emptyColumn, PieceType pieceType) -> {\r\n                    for (int column = 0; column < Constants.Columns; column++) {\r\n                        Square square = new Square(column, row);\r\n                        if (get(square) != null) continue;\r\n                        if (emptyColumn == 0) {\r\n                            set(square, new Piece(pieceType, Color.White));\r\n                            return;\r\n                        }\r\n                        emptyColumn--;\r\n                    }\r\n                    throw new IllegalArgumentException(\"Not enough empty columns to satisfy argument\");\r\n                };\r\n                placePiece.accept(rng.nextInt(6), PieceType.Queen);\r\n                placePiece.accept(rng.nextInt(5), PieceType.Knight);\r\n                placePiece.accept(rng.nextInt(4), PieceType.Knight);\r\n                placePiece.accept(0, PieceType.Rook);\r\n                placePiece.accept(0, PieceType.King);\r\n                placePiece.accept(0, PieceType.Rook);\r\n            }\r\n            \r\n            for (int column = 0; column < Constants.Columns; column++) {\r\n                Piece piece = get(new Square(column, getInitialRow(Color.White)));\r\n                // Copy initial row on black side.\r\n                set(new Square(column, getInitialRow(Color.Black)), piece.invert());\r\n                // Create pawns on second row of each side.\r\n                set(new Square(column, getPawnRow(Color.White)), new Piece(PieceType.Pawn, Color.White));\r\n                set(new Square(column, getPawnRow(Color.Black)), new Piece(PieceType.Pawn, Color.Black));\r\n                // Keep track of castling columns.\r\n                if (piece.getPieceType() == PieceType.Rook)\r\n                    castlings.add(new Castling(column, true));\r\n            }\r\n        }\r\n\r\n        // Parse from FEN representation. https://en.wikipedia.org/wiki/Forsyth-Edwards_Notation\r\n        public Board(String fen, boolean crazyHouse) throws ParseException {\r\n            this.crazyHouse = crazyHouse;\r\n\r\n            String[] parts = fen.split(\" \");\r\n            if (parts.length != 6) throw new ParseException(\"FEN string is malformed, needs 6 fields.\", 0);\r\n            {\r\n                int column = 0, row = Constants.Rows - 1;\r\n                for (char c : parts[0].toCharArray()) {\r\n                    if (c == '/') {\r\n                        row--;\r\n                        column = 0;\r\n                    }\r\n                    else if (c >= '1' && c <= '9')\r\n                        column += c - '0';\r\n                    else {\r\n                        if (row >= 0 && row < Constants.Rows && column >= 0 && column < Constants.Columns) {\r\n                            if (crazyHouse && c == '~') {\r\n                                column--;\r\n                                Square square = new Square(column, row);\r\n                                Piece piece = get(square);\r\n                                if (piece == null) throw new ParseException(\"Found ~ symbol without an associated piece.\", 0);\r\n                                set(square, piece.promote());\r\n                            } else\r\n                                set(new Square(column, row), Piece.fromChar(c));\r\n                        } else if (crazyHouse && row < 0) {\r\n                            PieceType pieceType = PieceType.fromChar(c);\r\n                            if (pieceType == PieceType.King) throw new ParseException(\"Found a king in a reserve.\", 0);\r\n                            addReserve(Character.isUpperCase(c) ? Color.White : Color.Black, pieceType, 1);\r\n                        }\r\n                        column++;\r\n                    }\r\n                }\r\n            }\r\n            Color colorToPlay = Color.fromChar(parts[1].charAt(0));\r\n            if (!parts[2].equals(\"-\")) {\r\n                for (char c : parts[2].toCharArray()) {\r\n                    int column = Square.charToColumn(c);\r\n                    Castling castling = null;\r\n                    for (Castling iter : castlings) {\r\n                        if (iter.getColumn() != column) continue;\r\n                        castling = iter;\r\n                        break;\r\n                    }\r\n                    if (castling == null) {\r\n                        if (castlings.size() >= Constants.Castlings) throw new ParseException(\"Too many castlings found.\", 0);\r\n                        castling = new Castling(column, false);\r\n                        castlings.add(castling);\r\n                    }\r\n                    castling.setAllowed(Character.isUpperCase(c) ? Color.White : Color.Black, true);\r\n                }\r\n            }\r\n            if (!parts[3].equals(\"-\"))\r\n                enPassantSquare = new Square(parts[3]);\r\n            halfMoveClock = Integer.parseInt(parts[4]);\r\n            if (halfMoveClock < 0) throw new ParseException(\"Half-move clock must be greater or equal to zero.\", 0);\r\n            halfMoves = (Integer.parseInt(parts[5]) - 1) * 2 + (colorToPlay == Color.White ? 0 : 1);\r\n            if (halfMoves < 0) throw new ParseException(\"Fullmove number must be greater than zero.\", 0);\r\n        }\r\n\r\n        public Piece get(Square square) { return cells[square.getColumn()][square.getRow()]; }\r\n        private void set(Square square, Piece piece) { cells[square.getColumn()][square.getRow()] = piece; }\r\n\r\n        public Color getColorToPlay() { return halfMoves % 2 == 0 ? Color.White : Color.Black; }\r\n        public int getInitialRow(Color color) { return color == Color.White ? 0 : Constants.Rows - 1; }\r\n        public int getPawnRow(Color color) { return color == Color.White ? 1 : Constants.Rows - 2; }\r\n        public int getPawnFront(Color color) { return color == Color.White ? 1 : -1; }\r\n        public List<Square> getHighlightSquares() { return highlightSquares; }\r\n\r\n        public int getHalfMoves() { return halfMoves; }\r\n        public int getHalfMoveClock() { return halfMoveClock; }\r\n\r\n        public int getReserve(Color color, PieceType pieceType) {\r\n            if (pieceType == PieceType.King) throw new IllegalArgumentException(\"Reserve pieces does not include kings.\");\r\n            return reservePieces[color.ordinal()][pieceType.ordinal()];\r\n        }\r\n        public void addReserve(Color color, PieceType pieceType, int count) { \r\n            if (pieceType == PieceType.King) throw new IllegalArgumentException(\"Reserve pieces does not include kings.\");\r\n            reservePieces[color.ordinal()][pieceType.ordinal()] += count;\r\n            if (reservePieces[color.ordinal()][pieceType.ordinal()] < 0) throw new IllegalArgumentException(\"Reserve count has become negative.\");\r\n        }\r\n\r\n        // Encode board to FEN representation. https://en.wikipedia.org/wiki/Forsyth-Edwards_Notation\r\n        public String toFenString(boolean forRepetition) {\r\n            StringBuilder sb = new StringBuilder();\r\n            for (int row = Constants.Rows - 1; row >= 0; row--) {\r\n                int empty = 0;\r\n                for (int column = 0; column < Constants.Columns; column++) {\r\n                    Square square = new Square(column, row);\r\n                    Piece piece = get(square);\r\n                    if (piece == null)\r\n                        empty++;\r\n                    else {\r\n                        if (empty > 0) {\r\n                            sb.append((char)('0' + empty));\r\n                            empty = 0;\r\n                        }\r\n                        sb.append(piece.toChar());\r\n                        // Follow lichess crazyhouse convention and add symbol to indicate promoted pawn.\r\n                        if (crazyHouse && piece.isPromoted())\r\n                            sb.append('~');\r\n                    }\r\n                }\r\n                // Copy-paste because Java lambdas are exceptionally weak.\r\n                if (empty > 0) {\r\n                    sb.append((char)('0' + empty));\r\n                    empty = 0;\r\n                }\r\n                if (row > 0)\r\n                    sb.append('/');\r\n            }\r\n            // Follow lichess crazyhouse convention and encode reserve as an extra row.\r\n            if (crazyHouse) {\r\n                sb.append('/');\r\n                for (Color color : Color.values()) {\r\n                    for (PieceType pieceType : Constants.ReservePieces) {\r\n                        int count = getReserve(color, pieceType);\r\n                        if (count == 0) continue;\r\n                        for (int j = 0; j < count; j++)\r\n                            sb.append(pieceType.toChar(color));\r\n                    }\r\n                }\r\n            }\r\n            sb.append(' ');\r\n            sb.append(getColorToPlay().toChar());\r\n            sb.append(' ');\r\n            int beforeCastling = sb.length();\r\n            for (Color color : Color.values()) {\r\n                for (Castling castling : castlings) {\r\n                    char c = Square.columnToChar(castling.getColumn());\r\n                    if (castling.isAllowed(color)) sb.append(color == Color.White ? Character.toUpperCase(c) : c);\r\n                }\r\n            }\r\n            if (sb.length() == beforeCastling) sb.append('-');\r\n            sb.append(' ');\r\n            if (!forRepetition || enPassantSquare == null)\r\n                sb.append(enPassantSquare != null ? enPassantSquare.toString() : '-');\r\n            else {\r\n                // For repetition check, only print en-passant square if such a capture was possible.\r\n                boolean printSquare = false;\r\n                int front = getPawnFront(getColorToPlay());\r\n                for (int column = -1; column <= 1; column += 2) {\r\n                    Square square = enPassantSquare.offset(column, -front);\r\n                    if (square == null) continue;\r\n                    Piece piece = get(square);\r\n                    if (piece == null) continue;\r\n                    if (piece.getPieceType() == PieceType.Pawn && piece.getColor() == getColorToPlay()) {\r\n                        printSquare = true;\r\n                        break;\r\n                    }\r\n                }\r\n                sb.append(printSquare ? enPassantSquare.toString() : '-');\r\n            }\r\n            // These fields do not matter for repetition check.\r\n            if (!forRepetition) {\r\n                sb.append(' ');\r\n                sb.append(halfMoveClock);\r\n                sb.append(' ');\r\n                sb.append(1 + halfMoves / 2);\r\n            }\r\n            return sb.toString();\r\n        }\r\n\r\n        // Computes whether either side has enough material to deliver a checkmate in theory. https://en.wikipedia.org/wiki/Draw_(chess)#Draws_in_all_games\r\n        public boolean hasSufficientMaterial() {\r\n            // Can always drop pieces in crazyhouse.\r\n            if (crazyHouse) return true;\r\n            \r\n            Piece lastPiece = null;\r\n            Square lastSquare = null;\r\n            for (int column = 0; column < Constants.Columns; column++) {\r\n                for (int row = 0; row < Constants.Rows; row++) {\r\n                    Square square = new Square(column, row);\r\n                    Piece piece = get(square);\r\n                    if (piece == null) continue;\r\n                    PieceType pieceType = piece.getPieceType();\r\n                    if (pieceType == PieceType.King) continue;\r\n                    // Those pieces are always enough.\r\n                    if (pieceType == PieceType.Pawn || pieceType == PieceType.Rook || pieceType == PieceType.Queen)\r\n                        return true;\r\n                    if (lastPiece == null) {\r\n                        lastPiece = piece;\r\n                        lastSquare = square;\r\n                        continue;\r\n                    }\r\n                    // Each side with one bishop on the same color is not enough.\r\n                    if (lastPiece.getColor() != piece.getColor() && lastPiece.getPieceType() == PieceType.Bishop && piece.getPieceType() == PieceType.Bishop && lastSquare.isLight() == square.isLight())\r\n                        continue;\r\n                    // Two pieces on board is otherwise enough.\r\n                    return true;\r\n                }\r\n            }\r\n\r\n            // One or zero minor piece with no other piece is not enough to checkmate.\r\n            return false;\r\n        }\r\n\r\n        private void addRangeMoves(List<Move> moves, Square from, int limit, int deltaColumn, int deltaRow) {\r\n            Color selfColor = getColorToPlay();\r\n            Square to = from;\r\n            for (int range = 0; range < limit; range++) {\r\n                to = to.offset(deltaColumn, deltaRow);\r\n                if (to == null) return;\r\n                Piece toPiece = get(to);\r\n                if (toPiece == null || toPiece.getColor() != selfColor)\r\n                    moves.add(new Move(from, to));\r\n                if (toPiece != null) return;\r\n            }\r\n        }\r\n\r\n        private void addDiagonalMoves(List<Move> moves, Square from, int limit) {\r\n            addRangeMoves(moves, from, limit, -1, -1);\r\n            addRangeMoves(moves, from, limit, -1,  1);\r\n            addRangeMoves(moves, from, limit,  1, -1);\r\n            addRangeMoves(moves, from, limit,  1,  1);\r\n        }\r\n\r\n        private void addStraightMoves(List<Move> moves, Square from, int limit) {\r\n            addRangeMoves(moves, from, limit,  0, -1);\r\n            addRangeMoves(moves, from, limit,  0,  1);\r\n            addRangeMoves(moves, from, limit, -1,  0);\r\n            addRangeMoves(moves, from, limit,  1,  0);\r\n        }\r\n\r\n        // Check if a square can be attacked by an opponent piece.\r\n        private boolean isSquareAttacked(Square to, Color selfColor) {\r\n            // Check range in all directions.\r\n            for (int deltaColumn = -1; deltaColumn <= 1; deltaColumn++) {\r\n                for (int deltaRow = -1; deltaRow <= 1; deltaRow++) {\r\n                    if (deltaRow == 0 && deltaColumn == 0) continue;\r\n                    boolean isDiagonal = Math.abs(deltaRow) == Math.abs(deltaColumn);\r\n                    Square from = to;\r\n                    for (int range = 0; range < Constants.RangeLimit; range++) {\r\n                        from = from.offset(deltaColumn, deltaRow);\r\n                        if (from == null) break;\r\n                        Piece fromPiece = get(from);\r\n                        if (fromPiece == null) continue;\r\n                        if (fromPiece.getColor() == selfColor) break;\r\n\r\n                        PieceType pieceType = fromPiece.getPieceType();\r\n                        if (pieceType == PieceType.Pawn && isDiagonal && to.getRow() - from.getRow() == getPawnFront(selfColor.opposite()))\r\n                            return true;\r\n                        if (pieceType == PieceType.Queen || (pieceType == PieceType.King && range == 0))\r\n                            return true;\r\n                        if (pieceType == (isDiagonal ? PieceType.Bishop : PieceType.Rook))\r\n                            return true;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Check knights.\r\n            for (int i = 0; i < Constants.KnightMoves; i++) {\r\n                Square from = to.offset(Constants.KnightDeltaColumn[i], Constants.KnightDeltaRow[i]);\r\n                if (from == null) continue;\r\n                Piece fromPiece = get(from);\r\n                if (fromPiece != null && fromPiece.getColor() != selfColor && fromPiece.getPieceType() == PieceType.Knight)\r\n                    return true;\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        // Find the square where the king of given color is located. Cannot be null.\r\n        private Square findKingSquare(Color color) {\r\n            for (int column = 0; column < Constants.Columns; column++) {\r\n                for (int row = 0; row < Constants.Rows; row++) {\r\n                    Square square = new Square(column, row);\r\n                    Piece piece = get(square);\r\n                    if (piece != null && piece.getColor() == color && piece.getPieceType() == PieceType.King)\r\n                        return square;\r\n                }\r\n            }\r\n            throw new IllegalStateException(\"Unable to find own king\");\r\n        }\r\n\r\n        // Returns whether the king of given color is under check.\r\n        public boolean isKingAttacked(Color color) {\r\n            return isSquareAttacked(findKingSquare(color), color);\r\n        }\r\n\r\n        // Generate all legal moves from current position.\r\n        public List<Move> generateMoves() {\r\n            List<Move> moves = new ArrayList<Move>();\r\n            Color selfColor = getColorToPlay();\r\n            Color opponentColor = selfColor.opposite();\r\n\r\n            for (int fromColumn = 0; fromColumn < Constants.Columns; fromColumn++) {\r\n                for (int fromRow = 0; fromRow < Constants.Rows; fromRow++) {\r\n                    Square from = new Square(fromColumn, fromRow);\r\n                    Piece piece = get(from);\r\n\r\n                    // Drop reserve pieces on empty squares.\r\n                    if (crazyHouse && piece == null) {\r\n                        for (PieceType pieceType : Constants.ReservePieces) {\r\n                            if (getReserve(selfColor, pieceType) == 0) continue;\r\n                            // Cannot drop pawns on initial rows.\r\n                            if (pieceType == PieceType.Pawn && (fromRow == 0 || fromRow == Constants.Rows - 1)) continue;\r\n                            moves.add(new Move(null, from, pieceType));\r\n                        }\r\n                    }\r\n\r\n                    if (piece == null || piece.getColor() != selfColor) continue;\r\n                    PieceType pieceType = piece.getPieceType();\r\n\r\n                    if (pieceType == PieceType.Pawn) {\r\n                        // Handle promotion cases when pawn ends on opponent's initial row.\r\n                        BiConsumer<Square, Square> addPromotionMoves = (Square f, Square t) -> {\r\n                            if (t.getRow() != getInitialRow(opponentColor))\r\n                                moves.add(new Move(f, t));\r\n                            else {\r\n                                moves.add(new Move(f, t, PieceType.Knight));\r\n                                moves.add(new Move(f, t, PieceType.Bishop));\r\n                                moves.add(new Move(f, t, PieceType.Rook));\r\n                                moves.add(new Move(f, t, PieceType.Queen));\r\n                            }\r\n                        };\r\n                        // Move pawn ahead.\r\n                        int front = getPawnFront(selfColor);\r\n                        Square to = from.offset(0, front);\r\n                        if (to != null && get(to) == null) {\r\n                            addPromotionMoves.accept(from, to);\r\n                            // Can move 2 squares from pawn row.\r\n                            if (from.getRow() == getPawnRow(selfColor)) {\r\n                                Square to2 = from.offset(0, front*2);\r\n                                if (to2 != null && get(to2) == null)\r\n                                    moves.add(new Move(from, to2));\r\n                            }\r\n                        }\r\n                        // Pawn capture on diagonals including en-passant.\r\n                        for (int deltaColumn = -1; deltaColumn <= 1; deltaColumn += 2) {\r\n                            to = from.offset(deltaColumn, front);\r\n                            if (to == null) continue;\r\n                            Piece toPiece = get(to);\r\n                            if ((toPiece != null && toPiece.getColor() == opponentColor) || to.equals(enPassantSquare))\r\n                                addPromotionMoves.accept(from, to);\r\n                        }\r\n                    } else if (pieceType == PieceType.Knight) {\r\n                        // Check all L shapes.\r\n                        for (int i = 0; i < Constants.KnightMoves; i++) {\r\n                            Square to = from.offset(Constants.KnightDeltaColumn[i], Constants.KnightDeltaRow[i]);\r\n                            if (to == null) continue;\r\n                            Piece toPiece = get(to);\r\n                            if (toPiece != null && toPiece.getColor() == selfColor) continue;\r\n                            moves.add(new Move(from, to));\r\n                        }\r\n                    } else if (pieceType == PieceType.Bishop)\r\n                        addDiagonalMoves(moves, from, Constants.RangeLimit);\r\n                    else if (pieceType == PieceType.Rook)\r\n                        addStraightMoves(moves, from, Constants.RangeLimit);\r\n                    else if (pieceType == PieceType.Queen) {\r\n                        addDiagonalMoves(moves, from, Constants.RangeLimit);\r\n                        addStraightMoves(moves, from, Constants.RangeLimit);\r\n                    } else if (pieceType == PieceType.King) {\r\n                        addDiagonalMoves(moves, from, 1);\r\n                        addStraightMoves(moves, from, 1);\r\n                        // Check for castling move.\r\n                        for (Castling castling : castlings) {\r\n                            if (!castling.isAllowed(selfColor)) continue;\r\n                            int rookFromColumn = castling.getColumn();\r\n                            int kingFromColumn = fromColumn;\r\n                            boolean queenCastling = rookFromColumn < kingFromColumn;\r\n                            int deltaColumn = queenCastling ? -1 : 1;\r\n                            int rookToColumn = queenCastling ? Constants.QueenCastlingRookColumn : Constants.KingCastlingRookColumn;\r\n                            int kingToColumn = queenCastling ? Constants.QueenCastlingKingColumn : Constants.KingCastlingKingColumn;\r\n\r\n                            boolean valid = true;\r\n                            // The final squares must not be occupied by other pieces.\r\n                            valid &= rookToColumn == kingFromColumn || rookToColumn == rookFromColumn || get(new Square(rookToColumn, fromRow)) == null;\r\n                            valid &= kingToColumn == kingFromColumn || kingToColumn == rookFromColumn || get(new Square(kingToColumn, fromRow)) == null;\r\n                            // There must be no piece obstructing between king and rook.\r\n                            for (int column = kingFromColumn + deltaColumn; valid && column != rookFromColumn; column += deltaColumn)\r\n                                valid &= get(new Square(column, fromRow)) == null;\r\n                            // There must be no enemy piece attacking the squares between king's initial and final position.\r\n                            for (int column = kingFromColumn; valid && column != kingToColumn + deltaColumn; column += deltaColumn)\r\n                                valid &= !isSquareAttacked(new Square(column, fromRow), selfColor);\r\n                            if (valid)\r\n                                moves.add(new Move(from, new Square(rookFromColumn, fromRow)));\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Remove moves that would leave the king under check.\r\n            moves.removeIf(move -> {\r\n                Board nextBoard = new Board(this);\r\n                nextBoard.applyMoveUnsafe(move);\r\n                return nextBoard.isKingAttacked(selfColor);\r\n            });\r\n\r\n            return moves;\r\n        }\r\n\r\n        public boolean isMoveCastling(Move move) {\r\n            if (move.getFrom() == null)\r\n                return false;\r\n            Piece fromPiece = get(move.getFrom());\r\n            Piece toPiece = get(move.getTo());\r\n            return fromPiece.getPieceType() == PieceType.King && toPiece != null && toPiece.getPieceType() == PieceType.Rook && toPiece.getColor() == fromPiece.getColor();\r\n        }\r\n\r\n        // Simply performs a move assuming it is **valid** and **legal**!\r\n        public void applyMoveUnsafe(Move move) {\r\n            highlightSquares.clear();\r\n\r\n            Square from = move.getFrom(), to = move.getTo();\r\n            Piece fromPiece = from != null ? get(from) : null, toPiece = get(to);\r\n            Color selfColor = getColorToPlay();\r\n            Color opponentColor = selfColor.opposite();\r\n\r\n            if (from == null) {\r\n                if (!crazyHouse) throw new IllegalArgumentException(\"Attempted to apply a drop piece move in a non-crazyhouse game.\");\r\n                PieceType pieceType = move.getPieceType().get();\r\n                set(move.getTo(), new Piece(pieceType, selfColor));\r\n                addReserve(selfColor, pieceType, -1);\r\n            } else {\r\n                if (fromPiece != null) {\r\n                    // When king moves, invalidate its castlings.\r\n                    if (fromPiece.getPieceType() == PieceType.King) {\r\n                        for (Castling castling : castlings)\r\n                            castling.setAllowed(selfColor, false);\r\n                    }\r\n\r\n                    // If rook moved from initial position, invalidate its castling.\r\n                    if (fromPiece.getPieceType() == PieceType.Rook && from.getRow() == getInitialRow(selfColor)) {\r\n                        for (Castling castling : castlings) {\r\n                            if (castling.getColumn() != from.getColumn()) continue;\r\n                            castling.setAllowed(selfColor, false);\r\n                        }\r\n                    }\r\n\r\n                    // Pawn moving to en-passant square implies it captured en-passant.\r\n                    if (enPassantSquare != null && fromPiece.getPieceType() == PieceType.Pawn && to.equals(enPassantSquare))\r\n                        set(new Square(to.getColumn(), from.getRow()), null);\r\n\r\n                    // Update en-passant square if pawn moved 2 rows.\r\n                    enPassantSquare = null;\r\n                    if (fromPiece.getPieceType() == PieceType.Pawn && Math.abs(from.getRow() - to.getRow()) == 2)\r\n                        enPassantSquare = new Square(from.getColumn(), (from.getRow() + to.getRow()) / 2);\r\n                }\r\n\r\n                // A captured rook on its initial row invalidates its castling.\r\n                if (toPiece != null && toPiece.getPieceType() == PieceType.Rook && toPiece.getColor() == opponentColor && to.getRow() == getInitialRow(opponentColor)) {\r\n                    for (Castling castling : castlings) {\r\n                        if (castling.getColumn() != to.getColumn()) continue;\r\n                        castling.setAllowed(opponentColor, false);\r\n                    }\r\n                }\r\n\r\n                // Update the board.\r\n                if (isMoveCastling(move)) {\r\n                    set(from, null);\r\n                    set(to, null);\r\n                    int row = getInitialRow(selfColor);\r\n                    boolean queenCastling = to.getColumn() < from.getColumn();\r\n                    Square rookSquare = new Square(queenCastling ? Constants.QueenCastlingRookColumn : Constants.KingCastlingRookColumn, row);\r\n                    Square kingSquare = new Square(queenCastling ? Constants.QueenCastlingKingColumn : Constants.KingCastlingKingColumn, row);\r\n                    set(rookSquare, toPiece);\r\n                    set(kingSquare, fromPiece);\r\n                    highlightSquares.add(rookSquare);\r\n                    highlightSquares.add(kingSquare);\r\n                } else {\r\n                    // Add captured piece to reserve in crazyhouse.\r\n                    if (crazyHouse && toPiece != null) {\r\n                        PieceType pieceType = toPiece.getPieceType();\r\n                        if (toPiece.isPromoted())\r\n                            pieceType = PieceType.Pawn;\r\n                        addReserve(selfColor, pieceType, 1);\r\n                    }\r\n\r\n                    if (move.getPieceType().isPresent())\r\n                        set(move.getTo(), new Piece(move.getPieceType().get(), selfColor, true));\r\n                    else\r\n                        set(move.getTo(), get(move.getFrom()));\r\n                    set(move.getFrom(), null);\r\n                }\r\n            }\r\n\r\n            if (from != null) highlightSquares.add(from);\r\n            highlightSquares.add(to);\r\n\r\n            // Update clocks.\r\n            // Halfmove clock is reset when a pawn moves or a capture occurs.\r\n            if ((fromPiece != null && fromPiece.getPieceType() == PieceType.Pawn) || (toPiece != null && toPiece.getColor() != selfColor))\r\n                halfMoveClock = 0;\r\n            else\r\n                halfMoveClock++;\r\n            halfMoves++;\r\n        }\r\n\r\n        // To be called on the position before the move is made, assuming it is **valid** and **legal**!\r\n        // https://en.wikipedia.org/wiki/Algebraic_notation_(chess)\r\n        public String getAlgebraicMoveUnsafe(Move move) {\r\n            StringBuilder sb = new StringBuilder();\r\n            if (move.getFrom() == null) {\r\n                sb.append(move.getPieceType().get().toChar());\r\n                sb.append('@');\r\n                sb.append(move.getTo().toString());\r\n            } else if (isMoveCastling(move))\r\n                sb.append(move.getTo().getColumn() < move.getFrom().getColumn() ? \"O-O-O\" : \"O-O\");\r\n            else {\r\n                Piece fromPiece = get(move.getFrom());\r\n                Piece toPiece = get(move.getTo());\r\n                boolean takes = toPiece != null || (fromPiece.getPieceType() == PieceType.Pawn && move.getFrom().getColumn() != move.getTo().getColumn());\r\n\r\n                if (fromPiece.getPieceType() != PieceType.Pawn) {\r\n                    sb.append(fromPiece.getPieceType().toChar());\r\n                    // Check for disambiguation.\r\n                    List<Move> moves = generateMoves();\r\n                    moves.removeIf(x -> x.getFrom() == null || !x.getTo().equals(move.getTo()) || get(x.getFrom()).getPieceType() != fromPiece.getPieceType());\r\n                    if (moves.size() > 1) {\r\n                        moves.removeIf(x -> x.getFrom().getColumn() != move.getFrom().getColumn());\r\n                        if (moves.size() == 1)\r\n                            sb.append(Square.columnToChar(move.getFrom().getColumn()));\r\n                        else {\r\n                            moves.removeIf(x -> x.getFrom().getRow() != move.getFrom().getRow());\r\n                            if (moves.size() == 1)\r\n                                sb.append(Square.rowToChar(move.getFrom().getRow()));\r\n                            else {\r\n                                sb.append(Square.columnToChar(move.getFrom().getColumn()));\r\n                                sb.append(Square.rowToChar(move.getFrom().getRow()));\r\n                            }\r\n                        }\r\n                    }\r\n                } else if (takes)\r\n                    sb.append(Square.columnToChar(move.getFrom().getColumn()));\r\n                if (takes)\r\n                    sb.append('x');\r\n                sb.append(move.getTo().toString());\r\n\r\n                if (move.getPieceType().isPresent()) {\r\n                    sb.append('=');\r\n                    sb.append(move.getPieceType().get().toChar());\r\n                }\r\n            }\r\n\r\n            Board nextBoard = new Board(this);\r\n            nextBoard.applyMoveUnsafe(move);\r\n            if (nextBoard.isKingAttacked(nextBoard.getColorToPlay())) {\r\n                if (nextBoard.generateMoves().size() == 0)\r\n                    sb.append('#'); // Checkmate\r\n                else\r\n                    sb.append('+'); // Check\r\n            }\r\n\r\n            return sb.toString();\r\n        }\r\n    }\r\n\r\n    public static class Castling {\r\n        // Initial rook column.\r\n        private int column;\r\n        // Whether this castling is allowed for each color.\r\n        private boolean[] colorAllowed = new boolean[Constants.Colors];\r\n\r\n        public Castling(int column, boolean allowed) {\r\n            this.column = column;\r\n            for (int i = 0; i < colorAllowed.length; i++)\r\n                colorAllowed[i] = allowed;\r\n        }\r\n\r\n        public Castling(Castling other) {\r\n            column = other.column;\r\n            for (int i = 0; i < colorAllowed.length; i++)\r\n                colorAllowed[i] = other.colorAllowed[i];\r\n        }\r\n\r\n        public int getColumn() { return column; }\r\n        public boolean isAllowed(Color color) { return colorAllowed[color.ordinal()]; }\r\n        public void setAllowed(Color color, boolean allowed) { colorAllowed[color.ordinal()] = allowed; }\r\n    }\r\n\r\n    public enum Color {\r\n        White,\r\n        Black;\r\n\r\n        public Color opposite() { return this == White ? Black : White; }\r\n        public char toChar() { return this == White ? 'w' : 'b'; }\r\n\r\n        public static Color fromChar(char c) throws ParseException {\r\n            switch (c)\r\n            {\r\n                case 'w': return White;\r\n                case 'b': return Black;\r\n            }\r\n            throw new ParseException(String.format(\"Character '%c' does not designate a color.\", c), 0);\r\n        }\r\n    }\r\n\r\n    public static class Constants {\r\n        public static final int Columns = 8;\r\n        public static final int Rows = 8;\r\n        public static final int RangeLimit = 7;\r\n        public static final int Colors = 2;\r\n        public static final int Castlings = 2;\r\n\r\n        public static final int QueenCastlingKingColumn = 2;\r\n        public static final int QueenCastlingRookColumn = 3;\r\n        public static final int KingCastlingKingColumn = 6;\r\n        public static final int KingCastlingRookColumn = 5;\r\n        public static final int KnightMoves = 8;\r\n        public static final int[] KnightDeltaColumn = {-1,  1, -2,  2, -2,  2, -1,  1};\r\n        public static final int[] KnightDeltaRow    = {-2, -2, -1, -1,  1,  1,  2,  2};\r\n\r\n        public static final PieceType[] ReservePieces = { PieceType.Pawn, PieceType.Knight, PieceType.Bishop, PieceType.Rook, PieceType.Queen };\r\n\r\n        public static final int MaxMovesPerGame = 125;\r\n        public static final int MaxCommentLength = 30;\r\n    }\r\n\r\n    public static class Game {\r\n        private Board board;\r\n        private List<String> positionHistory = new ArrayList<String>();\r\n        private GameResult gameResult = GameResult.Undecided;\r\n\r\n        public Game(long seed, boolean crazyHouse) {\r\n            board = new Board(seed, crazyHouse);\r\n            positionHistory.add(board.toFenString(true));\r\n        }\r\n\r\n        public Board getBoard() { return board; }\r\n\r\n        public ViewData applyMove(Move move) throws GameException {\r\n            List<Move> moves = board.generateMoves();\r\n            if (!moves.contains(move)) throw new GameException(String.format(\"'%s' is not a legal move\", move.toString()));\r\n\r\n            ViewData viewData = new ViewData();\r\n            viewData.setMove(board, move);\r\n\r\n            board.applyMoveUnsafe(move);\r\n            positionHistory.add(board.toFenString(true));\r\n\r\n            viewData.setBoard(board);\r\n            viewData.setHighlights(board);\r\n            return viewData;\r\n        }\r\n\r\n        public ViewData getViewData() {\r\n            ViewData viewData = new ViewData();\r\n            viewData.setBoard(board);\r\n            return viewData;\r\n        }\r\n\r\n        public GameResult getGameResult() {\r\n            if (gameResult == GameResult.Undecided)\r\n                gameResult = computeGameResult();\r\n            return gameResult;\r\n        }\r\n\r\n        public void setGameResult(GameResult gameResult) { this.gameResult = gameResult; }\r\n\r\n        private GameResult computeGameResult() {\r\n            // No move possible means checkmate or stalemate.\r\n            if (board.generateMoves().size() == 0) {\r\n                if (board.isKingAttacked(board.getColorToPlay()))\r\n                    return board.getColorToPlay() == Color.White ? GameResult.BlackWins : GameResult.WhiteWins;\r\n                return GameResult.Stalemate;\r\n            }\r\n\r\n            // Check for threefold repetition.\r\n            if (positionHistory.size() > 0) {\r\n                int count = 0;\r\n                String lastPosition = positionHistory.get(positionHistory.size() - 1);\r\n                for (int i = 0; i < positionHistory.size() - 1; i++) {\r\n                    if (!positionHistory.get(i).equals(lastPosition)) continue;\r\n                    count++;\r\n                    if (count == 2)\r\n                        return GameResult.Repetition;\r\n                }\r\n            }\r\n\r\n            if (!board.hasSufficientMaterial())\r\n                return GameResult.InsufficientMaterial;\r\n\r\n            if (board.getHalfMoveClock() >= 100)\r\n                return GameResult.FiftyMove;\r\n\r\n            if (board.getHalfMoves() >= Constants.MaxMovesPerGame * 2)\r\n                return GameResult.ForcedDraw;\r\n\r\n            return GameResult.Undecided;\r\n        }\r\n    }\r\n\r\n    @SuppressWarnings(\"serial\")\r\n    public static class GameException extends Exception {\r\n        public GameException(String string) {\r\n            super(string);\r\n        }\r\n    }\r\n\r\n    public enum GameResult {\r\n        Undecided,\r\n        WhiteWins,\r\n        BlackWins,\r\n        Stalemate,\r\n        Repetition,\r\n        InsufficientMaterial,\r\n        FiftyMove,\r\n        ForcedDraw,\r\n        DrawByAgreement,\r\n        WhiteResigns,\r\n        BlackResigns,\r\n    }\r\n\r\n    public static class Move {\r\n        // If null, move is a drop.\r\n        private Square from = null;\r\n        private Square to = null;\r\n        // Used for promotion or drop.\r\n        private Optional<PieceType> pieceType = Optional.empty();\r\n\r\n        public Move(Square from, Square to) {\r\n            this.from = from;\r\n            this.to = to;\r\n        }\r\n        public Move(Square from, Square to, PieceType pieceType) {\r\n            this(from, to);\r\n            this.pieceType = Optional.of(pieceType);\r\n        }\r\n\r\n        // Parse from UCI representation. https://en.wikipedia.org/wiki/Universal_Chess_Interface\r\n        public Move(String str) throws ParseException {\r\n            if (str.length() < 4) throw new ParseException(\"Move string needs to be at least 4 characters.\", 0);\r\n            if (str.charAt(1) == '@') {\r\n                to = new Square(str.substring(2, 4));\r\n                pieceType = Optional.of(PieceType.fromChar(str.charAt(0)));\r\n                if (pieceType.get() == PieceType.King) throw new ParseException(\"Drop piece is invalid.\", 0);\r\n                return;\r\n            }\r\n            from = new Square(str.substring(0, 2));\r\n            to = new Square(str.substring(2, 4));\r\n            if (str.length() == 5) {\r\n                PieceType pieceType = PieceType.fromChar(str.charAt(4));\r\n                if (pieceType == PieceType.Pawn || pieceType == PieceType.King) throw new ParseException(\"Promotion piece is invalid.\", 0);\r\n                this.pieceType = Optional.of(pieceType);\r\n            }\r\n        }\r\n\r\n        public Square getFrom() { return from; }\r\n        public Square getTo() { return to; }\r\n        public Optional<PieceType> getPieceType() { return pieceType; }\r\n\r\n        // Encode move to UCI representation. https://en.wikipedia.org/wiki/Universal_Chess_Interface\r\n        public String toString() throws IllegalStateException {\r\n            if (to == null) throw new IllegalStateException(\"Move has no destination square.\");\r\n            if (from == null) {\r\n                if (!pieceType.isPresent()) throw new IllegalStateException(\"Drop move has no piece type.\");\r\n                return pieceType.get().toString() + \"@\" + to.toString();\r\n            }\r\n            String result = from.toString() + to.toString();\r\n            if (pieceType.isPresent())\r\n                result += Character.toString(Character.toLowerCase(pieceType.get().toChar()));\r\n            return result;\r\n        }\r\n\r\n        @Override public boolean equals(Object o) {\r\n            if (o == this) return true;\r\n            if (o == null || getClass() != o.getClass()) return false;\r\n            Move other = (Move)o;\r\n            return Objects.equals(from, other.from) && Objects.equals(to, other.to) && Objects.equals(pieceType, other.pieceType);\r\n        }\r\n        \r\n        @Override public int hashCode() {\r\n            return Objects.hash(from, to, pieceType);\r\n        }\r\n    }\r\n\r\n    public static class Piece {\r\n        private PieceType pieceType;\r\n        private Color color;\r\n        private boolean promoted;\r\n\r\n        public Piece(PieceType pieceType, Color color) { this(pieceType, color, false); }\r\n        public Piece(PieceType pieceType, Color color, boolean promoted) { this.pieceType = pieceType; this.color = color; this.promoted = promoted; }\r\n\r\n        public PieceType getPieceType() { return pieceType; }\r\n        public Color getColor() { return color; }\r\n        public boolean isPromoted() { return promoted; }\r\n\r\n        public Piece invert() { return new Piece(pieceType, color.opposite()); }\r\n        public Piece promote() { return new Piece(pieceType, color, true); }\r\n\r\n        public char toChar() { return pieceType.toChar(color); }\r\n        public String toString() { return Character.toString(toChar()); }\r\n\r\n        public static Piece fromChar(char c) throws ParseException {\r\n            PieceType pieceType = PieceType.fromChar(c);\r\n            Color color = Character.isUpperCase(c) ? Color.White : Color.Black;\r\n            return new Piece(pieceType, color);\r\n        }\r\n    }\r\n\r\n    public enum PieceType {\r\n        Pawn,\r\n        Knight,\r\n        Bishop,\r\n        Rook,\r\n        Queen,\r\n        King;\r\n\r\n        public char toChar() {\r\n            switch (this) {\r\n                case Pawn:   return 'P';\r\n                case Knight: return 'N';\r\n                case Bishop: return 'B';\r\n                case Rook:   return 'R';\r\n                case Queen:  return 'Q';\r\n                case King:   return 'K';\r\n            }\r\n            throw new IllegalStateException(\"Unrecognized piece type.\");\r\n        }\r\n\r\n        public char toChar(Color color) {\r\n            char c = toChar();\r\n            if (color == Color.Black) c = Character.toLowerCase(c);\r\n            return c;\r\n        }\r\n\r\n        public String toString() { return Character.toString(toChar()); }\r\n\r\n        public static PieceType fromChar(char c) throws ParseException {\r\n            switch (Character.toUpperCase(c)) {\r\n                case 'P': return Pawn;\r\n                case 'N': return Knight;\r\n                case 'B': return Bishop;\r\n                case 'R': return Rook;\r\n                case 'Q': return Queen;\r\n                case 'K': return King;\r\n            }\r\n            throw new ParseException(String.format(\"Character '%c' does not designate a piece.\", c), 0);\r\n        }\r\n    }\r\n\r\n    public static class Square {\r\n        private int column = 0, row = 0;\r\n\r\n        public Square(int column, int row) { this.column = column; this.row = row; }\r\n        public Square(String str) throws ParseException {\r\n            if (str.length() != 2) throw new ParseException(String.format(\"'%s' is not a square.\", str), 0);\r\n            column = charToColumn(str.charAt(0));\r\n            row = charToRow(str.charAt(1));\r\n        }\r\n\r\n        public int getColumn()   { return column; }\r\n        public int getRow()      { return row; }\r\n\r\n        // Returns whether this square is a light or dark square.\r\n        public boolean isLight() { return ((column & 1) != 0) ^ ((row & 1) != 0); }\r\n\r\n        // Returns a new square offset by the given directions or null if invalid.\r\n        public Square offset(int deltaColumn, int deltaRow) {\r\n            int newColumn = column + deltaColumn;\r\n            int newRow = row + deltaRow;\r\n            if (newColumn < 0 || newColumn >= Constants.Columns || newRow < 0 || newRow >= Constants.Rows)\r\n                return null;\r\n            return new Square(newColumn, newRow);\r\n        }\r\n\r\n        @Override public String toString() { return Character.toString(columnToChar(column)) + rowToChar(row); }\r\n\r\n        @Override public boolean equals(Object o) {\r\n            if (o == this) return true;\r\n            if (o == null || getClass() != o.getClass()) return false;\r\n            Square other = (Square)o;\r\n            return column == other.column && row == other.row;\r\n        }\r\n        @Override public int hashCode() { return row * 8 + column; }\r\n\r\n        public static char columnToChar(int column) { return (char)('a' + column); }\r\n\r\n        public static char rowToChar(int row) { return (char)('1' + row); }\r\n\r\n        public static int charToColumn(char c) throws ParseException {\r\n            c = Character.toLowerCase(c);\r\n            if (c < 'a' || c > 'h') throw new ParseException(String.format(\"Character '%c' is not a column.\", c), 0);\r\n            return c - 'a';\r\n        }\r\n\r\n        public static int charToRow(char c) throws ParseException {\r\n            if (c < '1' || c > '8') throw new ParseException(String.format(\"Character '%c' is not a row.\", c), 0);\r\n            return c - '1';\r\n        }\r\n    }\r\n\r\n    public static class ViewData {\r\n        private int game;\r\n        private int[] scores = new int[2];\r\n        private String result;\r\n        private String fen;\r\n        private List<String> highlights;\r\n        private String move;\r\n        private String status;\r\n        private String comment;\r\n\r\n        public int getGame() { return game; }\r\n        public void setGame(int game) { this.game = game; }\r\n\r\n        public int[] getScores() { return scores; }\r\n        public void setScores(int score1, int score2) {\r\n            scores[0] = score1;\r\n            scores[1] = score2;\r\n        }\r\n\r\n        public String getResult() { return result; }\r\n        public void setResult(String result) { this.result = result; }\r\n\r\n        public String getFen() { return fen; }\r\n        public void setBoard(Board board) { fen = board.toFenString(false); }\r\n\r\n        public List<String> getHighlights() { return highlights; }\r\n        public void setHighlights(Board board) {\r\n            this.highlights = board.getHighlightSquares().stream().map(square -> square.toString()).collect(Collectors.toList());\r\n        }\r\n\r\n        public String getMove() { return move; }\r\n        public void setMove(String move) {\r\n            this.move = move;\r\n        }\r\n        public void setMove(Board board, Move move) {\r\n            this.move = board.getAlgebraicMoveUnsafe(move);\r\n        }\r\n\r\n        public String getStatus() { return status; }\r\n        public void setStatus(String status) { this.status = status; }\r\n\r\n        public String getComment() { return comment; }\r\n        public void setComment(String comment) { this.comment = comment; }\r\n    }\r\n\r\n    public static class ViewGlobalData {\r\n        private boolean crazyHouse = false;\r\n        \r\n        public boolean getCrazyHouse() { return crazyHouse; }\r\n        public void setCrazyHouse(boolean crazyHouse) { this.crazyHouse = crazyHouse; }\r\n    }\r\n\r\n    public static int getScore(Board board) {\r\n        int score = 0;\r\n        for (Piece[] pieces : board.cells) {\r\n            for (Piece piece : pieces) {\r\n                if (piece == null) continue;\r\n                int pieceScore = 0;\r\n                switch (piece.getPieceType()) {\r\n                    case Pawn: pieceScore += 1; break;\r\n                    case Knight: pieceScore += 3; break;\r\n                    case Bishop: pieceScore += 3; break;\r\n                    case Rook: pieceScore += 5; break;\r\n                    case Queen: pieceScore += 8; break;\r\n                }\r\n                if (piece.getColor() != board.getColorToPlay())\r\n                    pieceScore = -pieceScore;\r\n                score += pieceScore;\r\n            }\r\n        }\r\n        return score;\r\n    }\r\n\r\n    public static int search(Board board, int depth) {\r\n        if (depth == 0)\r\n            return getScore(board);\r\n        List<Move> moves = board.generateMoves();\r\n        int bestScore = -999;\r\n        if (moves.isEmpty()) {\r\n            if (board.isKingAttacked(board.getColorToPlay()))\r\n                return -999;\r\n            return 0;\r\n        }\r\n        for (Move move : moves) {\r\n            Board newBoard = new Board(board);\r\n            newBoard.applyMoveUnsafe(move);\r\n            int score = -search(newBoard, depth - 1);\r\n            if (score > bestScore)\r\n                bestScore = score;\r\n        }\r\n        return bestScore;\r\n    }\r\n\r\n    public static void main(String args[]) throws ParseException {\r\n        Scanner in = new Scanner(System.in);\r\n        int constantsCount = in.nextInt();\r\n        for (int i = 0; i < constantsCount; i++) {\r\n            String name = in.next();\r\n            String value = in.next();\r\n        }\r\n        in.nextLine();\r\n\r\n        System.out.println(\"fen\");\r\n\r\n        while (true) {\r\n            String fen = in.nextLine();\r\n            Board board = new Board(fen, false);\r\n\r\n            Move bestMove = null;\r\n            int bestScore = -999;\r\n            List<Move> moves = board.generateMoves();\r\n            Collections.shuffle(moves);\r\n            for (Move move : moves) {\r\n                Board newBoard = new Board(board);\r\n                newBoard.applyMoveUnsafe(move);\r\n                int score = -search(newBoard, 1);\r\n                if (score > bestScore) {\r\n                    System.err.println(move.toString() + \" = \" + score);\r\n                    bestScore = score;\r\n                    bestMove = move;\r\n                }\r\n            }\r\n\r\n            System.out.println(bestMove.toString());\r\n        }\r\n    }\r\n}",
          "testCases": [],
          "maxPlayers": 2,
          "minPlayers": 2,
          "statements": {
            "1": "<div id=\"statement_back\" class=\"statement_back\" style=\"display:none\"></div>\r\n<div class=\"statement-body\">\r\n  <!-- GOAL -->\r\n  <div class=\"statement-section statement-goal\">\r\n    <h1>\r\n      <span class=\"icon icon-goal\">&nbsp;</span>\r\n      <span>The Game</span>\r\n    </h1>\r\n    <div class=\"statement-goal-content\">\r\n      <p>Chess, the Game of Kings, is a classical board game that has been played for centuries, and has also been a cornerstone of artificial intelligence development for decades. You can easily learn all about how this game is played by doing an online search or reading this <a href='https://en.wikipedia.org/wiki/Chess'>Wikipedia article</a>.</p>\r\n      <br>\r\n      <p>This Codingame implementation makes use of the <a href='https://en.wikipedia.org/wiki/Chess960'>Chess960</a> rules, also known as Fischer Random Chess, where the initial starting position is randomly shuffled among 960 possibilities. This is done to promote variety as well as to prevent the hardcoding of initial moves using an opening book.</p>\r\n      <br>\r\n      <p>Special thanks to the <a href='http://mip.noekeon.org/HTMLTTChess/chess_merida_unicode.html'>Chess Merida Unicode</a> font for the rendering of piece graphics and <a href='https://commons.wikimedia.org/wiki/File:Chess_Set.jpg'>Wikimedia Commons</a> for the cover picture.</p>\r\n    </div>\r\n  </div>\r\n  <!-- RULES -->\r\n  <div class=\"statement-section statement-rules\">\r\n    <h1>\r\n      <span class=\"icon icon-rules\">&nbsp;</span>\r\n      <span>Rules</span>\r\n    </h1>\r\n    <div>\r\n      <div class=\"statement-rules-content\">\r\n        <p>Play <const>2</const> games against your opponent, once as each color  using the same starting position, where a win gives <const>1</const> point and a draw gives <const>Â½</const> point.</p>\r\n        <br>\r\n        <p>If any of the following happens, the current game will result into a draw:</p>\r\n        <ul>\r\n          <li>A player is unable to make a legal move while their king is not being under check, a <a href='https://en.wikipedia.org/wiki/Stalemate'>Stalemate</a> occurs.\r\n          <li>The same position occurring for the third time, also known as a <a href='https://en.wikipedia.org/wiki/Threefold_repetition'>Threefold Repetition</a>.</li>\r\n          <li>There is insufficient material for either player to deliver a checkmate. This includes:\r\n            <ul>\r\n              <li>King vs king</li>\r\n              <li>King+knight vs king</li>\r\n              <li>King+bishop vs king</li>\r\n              <li>King+bishop vs king+bishop if both bishops are on the same square color.</li>\r\n            </ul>\r\n          </li>\r\n          <li>No piece capture and no pawn has moved for 50 moves, using the <a href='https://en.wikipedia.org/wiki/Fifty-move_rule'>Fifty-Move rule</a>.</li>\r\n          <li>After <var>maxMoves</var> moves are played.</li>\r\n          <li>If one side offers a draw and the other side accepts it, also known as a draw by agreement.\r\n        </ul>\r\n        <br>\r\n        <div class=\"statement-victory-conditions\">\r\n          <div class=\"icon victory\"></div>\r\n          <div class=\"blk\">\r\n            <div class=\"title\">Victory Conditions</div>\r\n            <div class=\"text\">\r\n              <ul>\r\n                <li>You complete both matches having more points than your opponent.</li>\r\n                <li>Your opponent loses.</li>\r\n              </ul>\r\n            </div>\r\n          </div>\r\n        </div>\r\n        <div class=\"statement-lose-conditions\">\r\n          <div class=\"icon lose\"></div>\r\n          <div class=\"blk\">\r\n            <div class=\"title\">Defeat Conditions</div>\r\n            <div class=\"text\">\r\n              <ul>\r\n                <li>You attempt to make an illegal move.</li>\r\n                <li>You do not provide an output in the alloted time.</li>\r\n              </ul>\r\n            </div>\r\n          </div>\r\n        </div>\r\n        <br>\r\n      </div>\r\n    </div>\r\n  </div>\r\n  <!-- EXPERT RULES -->\r\n  <div class=\"statement-section statement-expertrules\">\r\n    <h1>\r\n      <span class=\"icon icon-expertrules\">&nbsp;</span>\r\n      <span>Technical details</span>\r\n    </h1>\r\n    <div class=\"statement-expert-rules-content\">\r\n      <ul>\r\n        <li>The current game state is encoded as a single line using the <a href='https://en.wikipedia.org/wiki/Forsyth-Edwards_Notation'>ForsythâEdwards Notation</a>, hereby referred to as FEN.</li>\r\n        <li>Game moves are internally encoded as done in the <a href='https://en.wikipedia.org/wiki/Universal_Chess_Interface'>Universal Chess Interface</a> protocol, hereby referred to as UCI.</li>\r\n        <li>Game moves are displayed in the viewer using the <a href='https://en.wikipedia.org/wiki/Algebraic_notation_(chess)'>Algebraic Notation</a>.</li>\r\n        <li>Piece characters are using the english language, therefore P for pawns, N for knights, B for bishops, R for rooks, Q for queens and K for kings.</li> \r\n        <li>You can access and copy/paste the FEN of the current position and PGN (<a href='https://en.wikipedia.org/wiki/Portable_Game_Notation'>Portable Game Notation</a>) of both games by opening the settings panel (<img style=\"opacity:.8;background:#20252a;\"\r\n        height=\"18\" src=\"https://www.codingame.com/servlet/fileservlet?id=3463235186409\" width=\"18\">).</li>\r\n        <li>You can force the initial position to be the classical one by specifying <const>seed=0</const> in the game options.\r\n      </ul>\r\n      <p>The source code of this game is available on <a href='https://github.com/recurs3/codingame-chess/'>GitHub</a>.</p>\r\n    </div>\r\n  </div>\r\n  <!-- EXAMPLES -->\r\n  <div class=\"statement-section statement-examples\">\r\n    <h1>\r\n      <span class=\"icon icon-example\">&nbsp;</span>\r\n      <span>Notes and examples</span>\r\n    </h1>\r\n    <div class=\"statement-examples-text\">\r\n      <p>Draw offers only last for one turn. If the opponent does not accept it, it is revoked.</p>\r\n      <br>\r\n      <h1>Input</h1>\r\n      <p>Because of Chess960, the castling field of the FEN string does not make use of <const>KQkq</const>. The column names are used instead, so the classical castling positions would be encoded as <const>AHah</const>.</p>\r\n      <br>\r\n      <p>The presence of an en-passant square in the FEN does not mean that a legal en-passant capture is possible.</p>\r\n      <br>\r\n      <h1>Output</h1>\r\n      <p>As mentioned above, specifying the move to make is done through the UCI protocol. It is simply the source square immediately followed by the destination square. For example, the classical king's pawn opening 1. e4 would be encoded as <const>e2e4</const>.</p>\r\n      <br>\r\n      <p>Piece promotion is specified by appending the piece character at the end. For example, <const>h7h8q</const> would promote the white h pawn to a queen.</p>\r\n      <br>\r\n      <p>Castling is done as a king moving to its own rook. In a classical starting position, a king-side castling would be <const>e1h1</const>, and a queen-side castling would be <const>e1a1</const>. Because of the Chess960 setup, a king moving by 2 squares to signal castling is <b>not</b> allowed.</p>\r\n      <br>\r\n      <p>You can make use of the <var>moves</var> input to validate your own move generation and the move you make as output.</p>\r\n    </div>\r\n  </div>\r\n  <!-- EXAMPLES -->\r\n  <div class=\"statement-section statement-examples\">\r\n    <h1>\r\n      <span class=\"icon icon-example\">&nbsp;</span>\r\n      <span>External resources</span>\r\n    </h1>\r\n    <div class=\"statement-examples-text\">\r\n      <ul>\r\n        <li><a href=\"https://www.chessprogramming.org/\">Chess programming wiki</a></li>\r\n      </ul>\r\n    </div>\r\n  </div>\r\n  <!-- PROTOCOL -->\r\n  <div class=\"statement-section statement-protocol\">\r\n    <h1>\r\n      <span class=\"icon icon-protocol\">&nbsp;</span>\r\n      <span>Game Protocol</span>\r\n    </h1>\r\n    <!-- Protocol block -->\r\n    <div class=\"blk\">\r\n      <div class=\"text\">The first turn is used for the referee to communicate the <b>game constants</b> and for the bot to configure its desired <b>inputs</b>.</div>\r\n    </div>\r\n\r\n    <!-- Protocol block -->\r\n    <div class=\"blk\">\r\n      <div class=\"title\">Input</div>\r\n      <div class=\"text\">\r\n        <p><span class=\"statement-lineno\">Line 1: </span> <var>constantsCount</var>, the number of constants communicated by the game referee.</p>\r\n        <p><span class=\"statement-lineno\">Next <var>constantsCount</var> lines: </span> <const>2</const> space-separated values indicating the <var>name</var> and <var>value</var> of the constant.</p>\r\n        <br>\r\n        <p>Currently defined constants are:</p>\r\n        <li><var>crazyHouse</var>: Boolean integer with <const>0</const> as false and <const>1</const> as true, indicating whether crazyhouse rules are enabled. Always <const>0</const> for this arena.</li>\r\n        <li><var>maxMoves</var>: Integer indicating the maximum number of moves per player per game. After this, a draw will be forced as a game result. Currently set at <const>125</const>.\r\n      </div>\r\n    </div>\r\n\r\n    <!-- Protocol block -->\r\n    <div class=\"blk\">\r\n      <div class=\"title\">Output</div>\r\n      <div class=\"text\">\r\n        <span class=\"statement-lineno\">A single line</span> configuring which inputs will be sent by the referee on each game turn. You can write any of the following values separated with spaces to receive the associated input, in the same order that is given.\r\n        <ul>\r\n          <li><const>fen</const>: The <a href='https://en.wikipedia.org/wiki/Forsyth-Edwards_Notation'>FEN representation</a> of the current game. <b>Strongly recommended</b>.</li>\r\n          <li><const>moves</const>: The list of legal moves.</li>\r\n          <li><const>lastmove</const>: The last move made by the opponent.</li>\r\n          <li><const>draw</const>: Whether the opponent has made a draw offer.</li>\r\n          <li><const>game</const>: The game number currently being played.\r\n          <li><const>score</const>: The current score for each player.\r\n        </ul>\r\n        <br>\r\n      </div>\r\n    </div>\r\n\r\n    <!-- Protocol block -->\r\n    <div class=\"blk\">\r\n      <div class=\"text\">For all the following turns this protocol is used to play out the games.</div>\r\n    </div>\r\n\r\n    <!-- Protocol block -->\r\n    <div class=\"blk\">\r\n      <div class=\"title\">Input</div>\r\n      <div class=\"text\">\r\n        <p>The values sent are in accordance with the configuration sent on the first turn, in the same order they were given.</p>\r\n        <ul>\r\n          <li><var>fen</var>: A line containing <const>6</const> fields <var>board</var> <var>color</var> <var>castling</var> <var>enPassant</var> <var>halfMoveClock</var> <var>fullMove</var> separated with spaces, representing a <a href='https://en.wikipedia.org/wiki/Forsyth-Edwards_Notation'>FEN string</a>.</li>\r\n          <li><var>moves</var>: A line containing an integer <var>movesCount</var>, followed by <var>movesCount</var> lines having one <var>move</var> per line, a string with a UCI move.</li>\r\n          <li><var>lastmove</var>: A line with a string containing the UCI move played by the opponent last turn, or <const>none</const> if it is the first turn of the game.</li>\r\n          <li><var>draw</var>: A line containing a boolean integer, <const>1</const> if a draw was offered last turn by the opponent, <const>0</const> otherwise.</li>\r\n          <li><var>game</var>: A line containing an integer representing the current game number, starting at <const>1</const> for the first game.</li>\r\n          <li><var>score</var>: A line containing <const>2</const> integers separated by a space, the score of the current player followed by the score of the opponent. The score is given in half-points, so <const>Â½</const> = <const>1</const>.\r\n        </ul>\r\n      </div>\r\n    </div>\r\n\r\n    <!-- Protocol block -->\r\n    <div class=\"blk\">\r\n      <div class=\"title\">Output</div>\r\n      <div class=\"text\">\r\n        <span class=\"statement-lineno\">A single line</span> with the move to be made, encoded with the UCI protocol.\r\n        <ul>\r\n          <li>A comment can be added to be displayed in the viewer by adding a space after the move and writing its content.</li>\r\n          <li>You can offer a draw to your opponent by adding <const>=</const> right after the move, without a space.</li>\r\n          <li>You can accept a draw offer by outputting <const>draw</const> instead of a move. Note that this is only legal if a draw offer was made the previous turn! Make sure to check the input first.</li>\r\n          <li>You can resign the current game by outputting <const>resign</const> instead of a move. This will proceed to the next game or end the match if no more is to be played.</li>\r\n          <li>You can play a random move by outputting <const>random</const> instead of a move. This is admittedly only useful for stub code generation.</li>\r\n        </ul>\r\n        <br>\r\n      </div>\r\n    </div>\r\n\r\n    <!-- Protocol block -->\r\n    <div class=\"blk\">\r\n      <div class=\"title\">Constraints</div>\r\n      <div class=\"text\">\r\n        Response time per turn â¤ <const>50</const> milliseconds.<br>\r\n        Response time for the first turn â¤ <const>1</const> second.</div>\r\n    </div>\r\n  </div>\r\n</div>",
            "2": "<div id=\"statement_back\" class=\"statement_back\" style=\"display:none\"></div>\r\n<div class=\"statement-body\">\r\n  <!-- GOAL -->\r\n  <div class=\"statement-section statement-goal\">\r\n    <h1>\r\n      <span class=\"icon icon-goal\">&nbsp;</span>\r\n      <span>The Game</span>\r\n    </h1>\r\n    <div class=\"statement-goal-content\">\r\n      <p>Chess, the Game of Kings, is a classical board game that has been played for centuries, and has also been a cornerstone of artificial intelligence development for decades. You can easily learn all about how this game is played by doing an online search or reading this <a href='https://en.wikipedia.org/wiki/Chess'>Wikipedia article</a>.</p>\r\n      <br>\r\n      <p>This Codingame implementation makes use of the <a href='https://en.wikipedia.org/wiki/Chess960'>Chess960</a> rules, also known as Fischer Random Chess, where the initial starting position is randomly shuffled among 960 possibilities. This is done to promote variety as well as to prevent the hardcoding of initial moves using an opening book.</p>\r\n      <br>\r\n      <p>Special thanks to the <a href='http://mip.noekeon.org/HTMLTTChess/chess_merida_unicode.html'>Chess Merida Unicode</a> font for the rendering of piece graphics and <a href='https://commons.wikimedia.org/wiki/File:Chess_Set.jpg'>Wikimedia Commons</a> for the cover picture.</p>\r\n    </div>\r\n  </div>\r\n  <!-- RULES -->\r\n  <div class=\"statement-section statement-rules\">\r\n    <h1>\r\n      <span class=\"icon icon-rules\">&nbsp;</span>\r\n      <span>Rules</span>\r\n    </h1>\r\n    <div>\r\n      <div class=\"statement-rules-content\">\r\n        <p>Play <const>2</const> games against your opponent, once as each color  using the same starting position, where a win gives <const>1</const> point and a draw gives <const>Â½</const> point.</p>\r\n        <br>\r\n        <p>If any of the following happens, the current game will result into a draw:</p>\r\n        <ul>\r\n          <li>A player is unable to make a legal move while their king is not being under check, a <a href='https://en.wikipedia.org/wiki/Stalemate'>Stalemate</a> occurs.\r\n          <li>The same position occurring for the third time, also known as a <a href='https://en.wikipedia.org/wiki/Threefold_repetition'>Threefold Repetition</a>.</li>\r\n          <li>There is insufficient material for either player to deliver a checkmate. This includes:\r\n            <ul>\r\n              <li>King vs king</li>\r\n              <li>King+knight vs king</li>\r\n              <li>King+bishop vs king</li>\r\n              <li>King+bishop vs king+bishop if both bishops are on the same square color.</li>\r\n            </ul>\r\n          </li>\r\n          <li>No piece capture and no pawn has moved for 50 moves, using the <a href='https://en.wikipedia.org/wiki/Fifty-move_rule'>Fifty-Move rule</a>.</li>\r\n          <li>After <var>maxMoves</var> moves are played.</li>\r\n          <li>If one side offers a draw and the other side accepts it, also known as a draw by agreement.\r\n        </ul>\r\n        <br>\r\n        <div class=\"statement-victory-conditions\">\r\n          <div class=\"icon victory\"></div>\r\n          <div class=\"blk\">\r\n            <div class=\"title\">Victory Conditions</div>\r\n            <div class=\"text\">\r\n              <ul>\r\n                <li>You complete both matches having more points than your opponent.</li>\r\n                <li>Your opponent loses.</li>\r\n              </ul>\r\n            </div>\r\n          </div>\r\n        </div>\r\n        <div class=\"statement-lose-conditions\">\r\n          <div class=\"icon lose\"></div>\r\n          <div class=\"blk\">\r\n            <div class=\"title\">Defeat Conditions</div>\r\n            <div class=\"text\">\r\n              <ul>\r\n                <li>You attempt to make an illegal move.</li>\r\n                <li>You do not provide an output in the alloted time.</li>\r\n              </ul>\r\n            </div>\r\n          </div>\r\n        </div>\r\n        <br>\r\n      </div>\r\n    </div>\r\n  </div>\r\n  <!-- EXPERT RULES -->\r\n  <div class=\"statement-section statement-expertrules\">\r\n    <h1>\r\n      <span class=\"icon icon-expertrules\">&nbsp;</span>\r\n      <span>Technical details</span>\r\n    </h1>\r\n    <div class=\"statement-expert-rules-content\">\r\n      <ul>\r\n        <li>The current game state is encoded as a single line using the <a href='https://en.wikipedia.org/wiki/Forsyth-Edwards_Notation'>ForsythâEdwards Notation</a>, hereby referred to as FEN.</li>\r\n        <li>Game moves are internally encoded as done in the <a href='https://en.wikipedia.org/wiki/Universal_Chess_Interface'>Universal Chess Interface</a> protocol, hereby referred to as UCI.</li>\r\n        <li>Game moves are displayed in the viewer using the <a href='https://en.wikipedia.org/wiki/Algebraic_notation_(chess)'>Algebraic Notation</a>.</li>\r\n        <li>Piece characters are using the english language, therefore P for pawns, N for knights, B for bishops, R for rooks, Q for queens and K for kings.</li> \r\n        <li>You can access and copy/paste the FEN of the current position and PGN (<a href='https://en.wikipedia.org/wiki/Portable_Game_Notation'>Portable Game Notation</a>) of both games by opening the settings panel (<img style=\"opacity:.8;background:#20252a;\"\r\n        height=\"18\" src=\"https://www.codingame.com/servlet/fileservlet?id=3463235186409\" width=\"18\">).</li>\r\n        <li>You can force the initial position to be the classical one by specifying <const>seed=0</const> in the game options.\r\n      </ul>\r\n      <p>The source code of this game is available on <a href='https://github.com/recurs3/codingame-chess/'>GitHub</a>.</p>\r\n    </div>\r\n  </div>\r\n  <!-- EXAMPLES -->\r\n  <div class=\"statement-section statement-examples\">\r\n    <h1>\r\n      <span class=\"icon icon-example\">&nbsp;</span>\r\n      <span>Notes and examples</span>\r\n    </h1>\r\n    <div class=\"statement-examples-text\">\r\n      <p>Draw offers only last for one turn. If the opponent does not accept it, it is revoked.</p>\r\n      <br>\r\n      <h1>Input</h1>\r\n      <p>Because of Chess960, the castling field of the FEN string does not make use of <const>KQkq</const>. The column names are used instead, so the classical castling positions would be encoded as <const>AHah</const>.</p>\r\n      <br>\r\n      <p>The presence of an en-passant square in the FEN does not mean that a legal en-passant capture is possible.</p>\r\n      <br>\r\n      <h1>Output</h1>\r\n      <p>As mentioned above, specifying the move to make is done through the UCI protocol. It is simply the source square immediately followed by the destination square. For example, the classical king's pawn opening 1. e4 would be encoded as <const>e2e4</const>.</p>\r\n      <br>\r\n      <p>Piece promotion is specified by appending the piece character at the end. For example, <const>h7h8q</const> would promote the white h pawn to a queen.</p>\r\n      <br>\r\n      <p>Castling is done as a king moving to its own rook. In a classical starting position, a king-side castling would be <const>e1h1</const>, and a queen-side castling would be <const>e1a1</const>. Because of the Chess960 setup, a king moving by 2 squares to signal castling is <b>not</b> allowed.</p>\r\n      <br>\r\n      <p>You can make use of the <var>moves</var> input to validate your own move generation and the move you make as output.</p>\r\n    </div>\r\n  </div>\r\n  <!-- EXAMPLES -->\r\n  <div class=\"statement-section statement-examples\">\r\n    <h1>\r\n      <span class=\"icon icon-example\">&nbsp;</span>\r\n      <span>External resources</span>\r\n    </h1>\r\n    <div class=\"statement-examples-text\">\r\n      <ul>\r\n        <li><a href=\"https://www.chessprogramming.org/\">Chess programming wiki</a></li>\r\n      </ul>\r\n    </div>\r\n  </div>\r\n  <!-- PROTOCOL -->\r\n  <div class=\"statement-section statement-protocol\">\r\n    <h1>\r\n      <span class=\"icon icon-protocol\">&nbsp;</span>\r\n      <span>Game Protocol</span>\r\n    </h1>\r\n    <!-- Protocol block -->\r\n    <div class=\"blk\">\r\n      <div class=\"text\">The first turn is used for the referee to communicate the <b>game constants</b> and for the bot to configure its desired <b>inputs</b>.</div>\r\n    </div>\r\n\r\n    <!-- Protocol block -->\r\n    <div class=\"blk\">\r\n      <div class=\"title\">Input</div>\r\n      <div class=\"text\">\r\n        <p><span class=\"statement-lineno\">Line 1: </span> <var>constantsCount</var>, the number of constants communicated by the game referee.</p>\r\n        <p><span class=\"statement-lineno\">Next <var>constantsCount</var> lines: </span> <const>2</const> space-separated values indicating the <var>name</var> and <var>value</var> of the constant.</p>\r\n        <br>\r\n        <p>Currently defined constants are:</p>\r\n        <li><var>crazyHouse</var>: Boolean integer with <const>0</const> as false and <const>1</const> as true, indicating whether crazyhouse rules are enabled. Always <const>0</const> for this arena.</li>\r\n        <li><var>maxMoves</var>: Integer indicating the maximum number of moves per player per game. After this, a draw will be forced as a game result. Currently set at <const>125</const>.\r\n      </div>\r\n    </div>\r\n\r\n    <!-- Protocol block -->\r\n    <div class=\"blk\">\r\n      <div class=\"title\">Output</div>\r\n      <div class=\"text\">\r\n        <span class=\"statement-lineno\">A single line</span> configuring which inputs will be sent by the referee on each game turn. You can write any of the following values separated with spaces to receive the associated input, in the same order that is given.\r\n        <ul>\r\n          <li><const>fen</const>: The <a href='https://en.wikipedia.org/wiki/Forsyth-Edwards_Notation'>FEN representation</a> of the current game. <b>Strongly recommended</b>.</li>\r\n          <li><const>moves</const>: The list of legal moves.</li>\r\n          <li><const>lastmove</const>: The last move made by the opponent.</li>\r\n          <li><const>draw</const>: Whether the opponent has made a draw offer.</li>\r\n          <li><const>game</const>: The game number currently being played.\r\n          <li><const>score</const>: The current score for each player.\r\n        </ul>\r\n        <br>\r\n      </div>\r\n    </div>\r\n\r\n    <!-- Protocol block -->\r\n    <div class=\"blk\">\r\n      <div class=\"text\">For all the following turns this protocol is used to play out the games.</div>\r\n    </div>\r\n\r\n    <!-- Protocol block -->\r\n    <div class=\"blk\">\r\n      <div class=\"title\">Input</div>\r\n      <div class=\"text\">\r\n        <p>The values sent are in accordance with the configuration sent on the first turn, in the same order they were given.</p>\r\n        <ul>\r\n          <li><var>fen</var>: A line containing <const>6</const> fields <var>board</var> <var>color</var> <var>castling</var> <var>enPassant</var> <var>halfMoveClock</var> <var>fullMove</var> separated with spaces, representing a <a href='https://en.wikipedia.org/wiki/Forsyth-Edwards_Notation'>FEN string</a>.</li>\r\n          <li><var>moves</var>: A line containing an integer <var>movesCount</var>, followed by <var>movesCount</var> lines having one <var>move</var> per line, a string with a UCI move.</li>\r\n          <li><var>lastmove</var>: A line with a string containing the UCI move played by the opponent last turn, or <const>none</const> if it is the first turn of the game.</li>\r\n          <li><var>draw</var>: A line containing a boolean integer, <const>1</const> if a draw was offered last turn by the opponent, <const>0</const> otherwise.</li>\r\n          <li><var>game</var>: A line containing an integer representing the current game number, starting at <const>1</const> for the first game.</li>\r\n          <li><var>score</var>: A line containing <const>2</const> integers separated by a space, the score of the current player followed by the score of the opponent. The score is given in half-points, so <const>Â½</const> = <const>1</const>.\r\n        </ul>\r\n      </div>\r\n    </div>\r\n\r\n    <!-- Protocol block -->\r\n    <div class=\"blk\">\r\n      <div class=\"title\">Output</div>\r\n      <div class=\"text\">\r\n        <span class=\"statement-lineno\">A single line</span> with the move to be made, encoded with the UCI protocol.\r\n        <ul>\r\n          <li>A comment can be added to be displayed in the viewer by adding a space after the move and writing its content.</li>\r\n          <li>You can offer a draw to your opponent by adding <const>=</const> right after the move, without a space.</li>\r\n          <li>You can accept a draw offer by outputting <const>draw</const> instead of a move. Note that this is only legal if a draw offer was made the previous turn! Make sure to check the input first.</li>\r\n          <li>You can resign the current game by outputting <const>resign</const> instead of a move. This will proceed to the next game or end the match if no more is to be played.</li>\r\n          <li>You can play a random move by outputting <const>random</const> instead of a move. This is admittedly only useful for stub code generation.</li>\r\n        </ul>\r\n        <br>\r\n      </div>\r\n    </div>\r\n\r\n    <!-- Protocol block -->\r\n    <div class=\"blk\">\r\n      <div class=\"title\">Constraints</div>\r\n      <div class=\"text\">\r\n        Response time per turn â¤ <const>50</const> milliseconds.<br>\r\n        Response time for the first turn â¤ <const>1</const> second.</div>\r\n    </div>\r\n  </div>\r\n</div>"
          },
          "questionType": "multi",
          "stubGenerator": "read constantsCount:int\nloop constantsCount read name:word(256) value:word(256)\nwrite fen\n\ngameloop\nread board:word(256) color:word(1) castling:word(4) enPassant:word(2) halfMoveClock:int fullMove:int\nwrite random\n",
          "welcomePopups": {},
          "aiCodeExtension": "java",
          "criteriaLanguageMap": {}
        }
      },
      "coverBinaryId": 56268463562477,
      "directoryPrefix": "community/1400179-1608661730422",
      "allowSourceDownload": false
    },
    "draft": false,
    "readyForModeration": true
  },
  "validatedFor": 159668531532,
  "avatar": 58850847098890,
  "commentCount": 26,
  "upVotes": 39,
  "downVotes": 2,
  "validateAction": {
    "actionId": 526020,
    "progress": 1,
    "alreadyDone": false
  },
  "statusHistory": [
    {
      "status": "ACCEPTED",
      "date": 1611062210208,
      "data": {
        "author": "ACTION"
      }
    }
  ],
  "editable": true,
  "draft": false,
  "readyForModeration": true
}