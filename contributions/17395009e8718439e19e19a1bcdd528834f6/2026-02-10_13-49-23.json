{
  "id": 1739,
  "activeVersion": 18,
  "score": 6,
  "votableId": 9246412,
  "codingamerId": 2716329,
  "views": 238,
  "commentableId": 9180547,
  "title": "Spaghetti code",
  "status": "ACCEPTED",
  "type": "CLASHOFCODE",
  "nickname": "Recher",
  "publicHandle": "17395009e8718439e19e19a1bcdd528834f6",
  "codingamerHandle": "496bc5e8fd0fde14aacaa21b21b1d1fc9236172",
  "lastVersion": {
    "version": 18,
    "autocloseTime": 1544187985102,
    "data": {
      "title": "Spaghetti code",
      "topics": [],
      "fastest": true,
      "reverse": true,
      "shortest": true,
      "solution": "n=int(input())\nd={}\nfor a in[0]*n:l=input();d[l[0]]=l[1:]\ns=k='A'\nwhile d:s+=d.pop(k);k=s[-1]\nprint(s)\n\n# Time taken : about 10 minutes to code a correct solution, not shortened.\n# 4 more minutes to code this short solution.\n\n\ndef a_clearer_solution():\n    \n    nb_spagh = int(input())\n    # dict with all the spaghetti parts.\n    # key : the first character of the part.\n    # value : the part, without its first character.\n    spagh_parts = {}\n    for _ in range(nb_spagh):\n        spagh_part = input()\n        first_char = spagh_part[0]\n        other_chars = spagh_part[1:]\n        spagh_parts[first_char] = other_chars\n        \n    current_extremity = 'A'\n    whole_spagh = 'A'\n    while current_extremity != 'Z':\n        next_part = spagh_parts[current_extremity]\n        whole_spagh += next_part\n        current_extremity = whole_spagh[-1]\n\n    print(whole_spagh)\n\n",
      "statement": "You are served some spaghetti. Each strand was a part cut off from the same giant spaghetti strand.\n\nYou want to reconstitute this original spaghetti strand.\n\nIt always starts with the character {{A}} and ends with the character {{Z}}.\n\nTwo parts can be matched when the last character of the first part corresponds to the first character of the second part.\n\nWarning : when printing the giant spaghetti, <<the extremity characters used to match the parts must be written only once>>.",
      "testCases": [
        {
          "title": "Simple case",
          "isTest": true,
          "testIn": "4\nA------X\n*-+-+-+-+-+-+-#\nX====*\n#_____Z",
          "testOut": "A------X====*-+-+-+-+-+-+-#_____Z",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Validator 1",
          "isTest": false,
          "testIn": "4\nA------0\n1-+-+-+-+-+-+-+-+-+-+-:\n0==1\n:_____Z",
          "testOut": "A------0==1-+-+-+-+-+-+-+-+-+-+-:_____Z",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "Only two parts",
          "isTest": true,
          "testIn": "2\n+...........Z\nA..............+",
          "testOut": "A..............+...........Z",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Validator 2",
          "isTest": false,
          "testIn": "2\n@****Z\nA*********@",
          "testOut": "A*********@****Z",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "Many little parts",
          "isTest": true,
          "testIn": "10\n'.\n:Z\n-*\n.,\n,:\n=/\n/'\nA+\n+-\n*=",
          "testOut": "A+-*=/'.,:Z",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Validator 3",
          "isTest": false,
          "testIn": "10\n/'\n*=\n:Z\n=+\n':\n.,\n,*\nA-\n-.\n+/",
          "testOut": "A-.,*=+/':Z",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "Extremities character are not specific",
          "isTest": true,
          "testIn": "3\n-----+++++++++\nA------\n++++++=======Z",
          "testOut": "A----------++++++++++++++=======Z",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Validator 4",
          "isTest": false,
          "testIn": "3\n+++++++-----\n----=====Z\nA+++",
          "testOut": "A+++++++++--------=====Z",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "Only one part",
          "isTest": true,
          "testIn": "1\nA_-_-_-_-_-_-_Z",
          "testOut": "A_-_-_-_-_-_-_Z",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Validator 5",
          "isTest": false,
          "testIn": "1\nA-*-*-*-Z",
          "testOut": "A-*-*-*-Z",
          "isValidator": true,
          "needValidation": true
        }
      ],
      "constraints": "1 <= [[N]] <= 10\nYou may have a single part like : \"A------Z\".\n\nThere is ambiguity in the parts:\n- only one part with an 'A',\n- only one part with a 'Z',\n - the other extremity characters appear only once as a start, and once as an end.",
      "stubGenerator": "read N:int\nloop N read spaghettiPart:string(1024)\n\nwrite the complete spaghetto\n",
      "inputDescription": "<<Line 1>> : number of spaghetti parts [[N]].\n<<Following lines >> : a [[spaghettiPart]] string. Each part has at least 2 characters.",
      "solutionLanguage": "Python3",
      "outputDescription": "One single string, representing the complete original spaghetto."
    },
    "draft": false,
    "readyForModeration": true,
    "statementHTML": "<div class=\"statement-body\">\n<div class=\"statement-section statement-goal\">\n   <h2><span class=\"icon icon-goal\">&nbsp;</span><span>Goal </span></h2>\n   <span class=\"question-statement\">You are served some spaghetti. Each strand was a part cut off from the same giant spaghetti strand.<br><br>You want to reconstitute this original spaghetti strand.<br><br>It always starts with the character <const>A</const> and ends with the character <const>Z</const>.<br><br>Two parts can be matched when the last character of the first part corresponds to the first character of the second part.<br><br>Warning : when printing the giant spaghetti, <strong>the extremity characters used to match the parts must be written only once</strong>.</span>\n</div>\n<div class=\"statement-section statement-protocol\">\n   <div class=\"blk\">\n      <div class=\"title\">Input</div>\n      <div class=\"question-statement-input\"><strong>Line 1</strong> : number of spaghetti parts <var>N</var>.<br><strong>Following lines </strong> : a <var>spaghettiPart</var> string. Each part has at least 2 characters.</div>\n   </div>\n   <div class=\"blk\">\n      <div class=\"title\">Output</div>\n      <div class=\"question-statement-output\">One single string, representing the complete original spaghetto.</div>\n   </div>\n   <div class=\"blk\">\n      <div class=\"title\">Constraints</div>\n      <div class=\"question-statement-constraints\">1 &lt;= <var>N</var> &lt;= 10<br>You may have a single part like : &quot;A------Z&quot;.<br><br>There is ambiguity in the parts:<br>- only one part with an 'A',<br>- only one part with a 'Z',<br> - the other extremity characters appear only once as a start, and once as an end.</div>\n   </div>\n   <div class=\"blk\">\n      <div class=\"title\">Example</div>\n      <div class=\"statement-inout\">\n         <div class=\"statement-inout-in\">\n            <div class=\"title\">Input</div>\n            <pre class=\"question-statement-example-in\">4\nA------X\n*-+-+-+-+-+-+-#\nX====*\n#_____Z</pre>\n         </div>\n         <div class=\"statement-inout-out\">\n            <div class=\"title\">Output</div>\n            <pre class=\"question-statement-example-out\">A------X====*-+-+-+-+-+-+-#_____Z</pre>\n         </div>\n      </div>\n   </div>\n</div>"
  },
  "validatedFor": 229133241154,
  "avatar": 19985093844366,
  "commentCount": 3,
  "upVotes": 8,
  "downVotes": 2,
  "validateAction": {
    "actionId": 280975,
    "progress": 1,
    "alreadyDone": false
  },
  "statusHistory": [],
  "editable": true,
  "draft": false,
  "readyForModeration": true
}