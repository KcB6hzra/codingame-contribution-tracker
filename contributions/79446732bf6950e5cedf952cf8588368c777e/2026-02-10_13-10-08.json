{
  "id": 79446,
  "activeVersion": 14,
  "score": 9,
  "votableId": 31977444,
  "codingamerId": 5846256,
  "views": 187,
  "commentableId": 31835470,
  "title": "The Other Side",
  "status": "ACCEPTED",
  "type": "PUZZLE_INOUT",
  "nickname": "Suryyy",
  "publicHandle": "79446732bf6950e5cedf952cf8588368c777e",
  "codingamerHandle": "99d843ec69f461126882c8d5409ffb4b6526485",
  "lastVersion": {
    "version": 14,
    "autocloseTime": 1705541059339,
    "data": {
      "title": "The Other Side",
      "topics": [
        {
          "id": 54,
          "handle": "BFS",
          "category": "ADVANCED",
          "labelMap": {
            "1": "Parcours en largeur",
            "2": "BFS"
          },
          "pageTitle": "BFS: exercises and theory",
          "puzzleCount": 27,
          "parentTopicId": 41,
          "contentDetailsId": 84
        },
        {
          "id": 62,
          "handle": "flood-fill",
          "category": "ADVANCED",
          "labelMap": {
            "1": "Remplissage par diffusion",
            "2": "Flood fill"
          },
          "pageTitle": "Flood fill: exercises and theory",
          "puzzleCount": 17,
          "parentTopicId": 41,
          "contentDetailsId": 81
        },
        {
          "id": 55,
          "handle": "DFS",
          "category": "ADVANCED",
          "labelMap": {
            "1": "Parcours en profondeur",
            "2": "DFS"
          },
          "pageTitle": "DFS: exercises and theory",
          "puzzleCount": 13,
          "parentTopicId": 41,
          "contentDetailsId": 79
        },
        {
          "id": 150,
          "handle": "graph-traversal",
          "category": "INTERMEDIATE",
          "labelMap": {
            "1": "graph traversal",
            "2": "graph traversal"
          },
          "puzzleCount": 6,
          "parentTopicId": 93
        }
      ],
      "solution": "import copy\n\nh = int(input())\nw = int(input())\n\nG0 = []\nfor i in range(h):\n    row = input()\n    G0 += [[c for c in row.split(\" \")]]\n\nstartis = []\nfor i in range(h):\n    if G0[i][0] == \"+\":\n        startis += [(i, 0)]\n\n# the list of indices to visit\ncount = 0\nwhile len(startis) > 0:\n    \n    stack = [startis.pop()]\n    G = copy.deepcopy(G0)\n    while len(stack) > 0:\n\n        i, j = stack.pop()\n        \n        if G[i][j] == \"+\":\n            if j==w-1:\n                count += 1\n                stack = []\n            else:\n                G[i][j] = \"*\" # mark as visited\n\n                if j!=0   and G[i][j-1] == \"+\": stack += [(i, j-1)]\n                if j!=w-1 and G[i][j+1] == \"+\": stack += [(i, j+1)]\n                if i!=0   and G[i-1][j] == \"+\": stack += [(i-1, j)]\n                if i!=h-1 and G[i+1][j] == \"+\": stack += [(i+1, j)]\n\nprint(count)",
      "statement": "Placrates, the labyrinth engineer, is facing a simple puzzle. Given an [[h]]×[[w]] grid made of {{+}} and {{#}} characters, the objective is to <<count the number of {{+}} characters in the leftmost column from which there exists a path to the rightmost column>>. \n\nThe path can be traced through a series of moves. Each move can be either horizontal or vertical, but not diagonal. Finally, valid moves pass through {{+}} characters only.",
      "testCases": [
        {
          "title": "Direct path",
          "isTest": true,
          "testIn": "2\n3\n+ + +\n+ + +",
          "testOut": "2",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Validator 1",
          "isTest": false,
          "testIn": "3\n4\n+ + + +\n+ + + +\n+ + + +",
          "testOut": "3",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "Nowhere to stand",
          "isTest": true,
          "testIn": "2\n2\n# #\n# #",
          "testOut": "0",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Validator 2",
          "isTest": false,
          "testIn": "2\n3\n# # #\n# # #",
          "testOut": "0",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "Fully horizontal path",
          "isTest": true,
          "testIn": "3\n4\n+ + + +\n# # # #\n# # # #",
          "testOut": "1",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Validator 3",
          "isTest": false,
          "testIn": "5\n4\n# # # #\n# # # #\n+ + + +\n# # # #\n# # # #",
          "testOut": "1",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "Stalemate",
          "isTest": true,
          "testIn": "3\n10\n# # # # # # # # # +\n+ + + + + + + + # +\n# # # # # # # # # +",
          "testOut": "0",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Validator 4",
          "isTest": false,
          "testIn": "3\n10\n+ + + + + + + + # +\n# # # # # # # # # +\n# # # # # # # + + +",
          "testOut": "0",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "Zigzag",
          "isTest": true,
          "testIn": "5\n5\n+ + + + #\n# # + + #\n+ # + + +\n+ + + # #\n# # + + +",
          "testOut": "3",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Validator 5",
          "isTest": false,
          "testIn": "5\n5\n+ # # + #\n+ + + + #\n# + + # #\n+ # # + +\n+ + + + #",
          "testOut": "2",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "No way",
          "isTest": true,
          "testIn": "4\n4\n+ + + #\n# + # #\n+ + + #\n+ # + #",
          "testOut": "0",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Validator 6",
          "isTest": false,
          "testIn": "4\n5\n# + # # +\n+ + + # +\n# # + # #\n+ # + + #",
          "testOut": "0",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "One step back",
          "isTest": true,
          "testIn": "7\n6\n+ # + # + #\n+ + + + # +\n+ # # + # +\n+ # + + # +\n# # + # # +\n+ # + + + +\n# + # # # #",
          "testOut": "4",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Validator 7",
          "isTest": false,
          "testIn": "7\n6\n+ + + # + #\n+ # + + # +\n+ + # + # +\n+ # + + # +\n# # + # # +\n+ # + + + #\n# # + # + +",
          "testOut": "4",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "No diagonal moves",
          "isTest": true,
          "testIn": "2\n5\n+ # + # +\n# + # + #",
          "testOut": "0",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Validator 8",
          "isTest": false,
          "testIn": "3\n4\n# + # +\n+ # + #\n# + # +",
          "testOut": "0",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "The other side",
          "isTest": true,
          "testIn": "12\n6\n# # # # # +\n+ + + + + #\n# # + # + #\n+ + # + # +\n# + + # + #\n+ + + + + #\n# + # # # #\n+ + + # + +\n# + + + + #\n+ # + # + #\n# # + + + #\n+ + + # + +",
          "testOut": "4",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Validator 9",
          "isTest": false,
          "testIn": "10\n11\n+ # # + + + + # + + #\n+ + + # + # + # + # #\n# + # + + # + + + + +\n+ + + # + # # # # # +\n# # + # + # + + + + #\n# + + + + # + # # + #\n# + + # + + + + + + #\n+ + + # # + # # + + #\n+ + + + + + # + # + #\n# + + # + + + + + + #",
          "testOut": "5",
          "isValidator": true,
          "needValidation": true
        }
      ],
      "difficulty": "easy",
      "constraints": "2 ≤ [[h]],[[w]] ≤ 12",
      "coverBinaryId": 116538646793489,
      "stubGenerator": "read h:int\nread w:int\nloop h read row:string(1024)\n\nwrite count",
      "inputDescription": "<<Line 1 :>> The height [[h]] of the grid.\n<<Line 2 :>> The width [[w]] of the grid.\n<<Next [[h]] lines:>> The rows of the grid, where each row is composed of [[w]] space separated characters.",
      "solutionLanguage": "Python3",
      "outputDescription": "<<Line 1 :>> The number of {{+}} characters in the leftmost column from which there exists a path to the rightmost column."
    },
    "draft": false,
    "readyForModeration": true,
    "statementHTML": "<div class=\"statement-body\">\n<div class=\"statement-section statement-goal\">\n   <h2><span class=\"icon icon-goal\">&nbsp;</span><span>Goal </span></h2>\n   <span class=\"question-statement\">Placrates, the labyrinth engineer, is facing a simple puzzle. Given an <var>h</var>&times;<var>w</var> grid made of <const>+</const> and <const>#</const> characters, the objective is to <strong>count the number of <const>+</const> characters in the leftmost column from which there exists a path to the rightmost column</strong>. <br><br>The path can be traced through a series of moves. Each move can be either horizontal or vertical, but not diagonal. Finally, valid moves pass through <const>+</const> characters only.</span>\n</div>\n<div class=\"statement-section statement-protocol\">\n   <div class=\"blk\">\n      <div class=\"title\">Input</div>\n      <div class=\"question-statement-input\"><strong>Line 1 :</strong> The height <var>h</var> of the grid.<br><strong>Line 2 :</strong> The width <var>w</var> of the grid.<br><strong>Next <var>h</var> lines:</strong> The rows of the grid, where each row is composed of <var>w</var> space separated characters.</div>\n   </div>\n   <div class=\"blk\">\n      <div class=\"title\">Output</div>\n      <div class=\"question-statement-output\"><strong>Line 1 :</strong> The number of <const>+</const> characters in the leftmost column from which there exists a path to the rightmost column.</div>\n   </div>\n   <div class=\"blk\">\n      <div class=\"title\">Constraints</div>\n      <div class=\"question-statement-constraints\">2 &le; <var>h</var>,<var>w</var> &le; 12</div>\n   </div>\n   <div class=\"blk\">\n      <div class=\"title\">Example</div>\n      <div class=\"statement-inout\">\n         <div class=\"statement-inout-in\">\n            <div class=\"title\">Input</div>\n            <pre class=\"question-statement-example-in\">2\n3\n+ + +\n+ + +</pre>\n         </div>\n         <div class=\"statement-inout-out\">\n            <div class=\"title\">Output</div>\n            <pre class=\"question-statement-example-out\">2</pre>\n         </div>\n      </div>\n   </div>\n</div>"
  },
  "validatedFor": 65312952375,
  "avatar": 145184720089323,
  "commentCount": 17,
  "upVotes": 10,
  "downVotes": 1,
  "validateAction": {
    "actionId": 908598,
    "progress": 1,
    "alreadyDone": false
  },
  "statusHistory": [
    {
      "status": "ACCEPTED",
      "date": 1705416054493,
      "data": {
        "author": "ACTION"
      }
    }
  ],
  "editable": true,
  "draft": false,
  "readyForModeration": true
}