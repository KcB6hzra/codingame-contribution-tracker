{
  "id": 914,
  "activeVersion": 21,
  "score": 1,
  "votableId": 6354327,
  "codingamerId": 484004,
  "views": 296,
  "commentableId": 6294640,
  "title": "A-star exercise",
  "status": "ACCEPTED",
  "type": "PUZZLE_INOUT",
  "nickname": "aCat",
  "publicHandle": "9142d2fb6502d5137ee80d977027bd0bd77",
  "codingamerHandle": "b528dd3b279d7578674a1129305918e0400484",
  "lastVersion": {
    "version": 21,
    "data": {
      "title": "A-star exercise",
      "topics": [
        {
          "id": 160,
          "handle": "a*",
          "labelMap": {
            "1": "A*",
            "2": "A*"
          },
          "puzzleCount": 1,
          "parentTopicId": 93
        },
        {
          "id": 68,
          "handle": "pathfinding",
          "labelMap": {
            "1": "Recherche de chemins",
            "2": "Pathfinding"
          },
          "pageTitle": "Pathfinding: exercises and theory",
          "puzzleCount": 21,
          "parentTopicId": 41,
          "contentDetailsId": 69
        },
        {
          "labelMap": {
            "2": "Heuristic search"
          }
        }
      ],
      "solution": "import heapq # https://docs.python.org/3.6/library/heapq.html\n\nh = {}\ng = {}\nedges = {}\n\nqueue = []\nopen = set([])\nclosed = set([])\n\nn, e, start, goal = [int(i) for i in input().split()]\ng[start] = 0\nh = list(map(int, input().split()))\nfor i in range(n):\n    edges[i] = {}\nfor i in range(e):\n    x, y, c = map(int,input().split())\n    edges[x][y] = c\n    edges[y][x] = c\n\nopen.add(start)\nheapq.heappush(queue, (g[start] + h[start], start))\n\nwhile len(queue) > 0:\n    currentf, current = heapq.heappop(queue)\n    if current in open: open.remove(current)\n    if current in closed: continue\n    closed.add(current)\n\n    print ('{} {}'.format(current, currentf))\n    if current == goal: break\n\n    for neighbor, cost in edges[current].items():\n        if neighbor in closed: continue\n        f = g[current] + cost + h[neighbor]\n        if neighbor not in open or g[neighbor]+h[neighbor] > f:\n            heapq.heappush(queue, (f, neighbor))\n            open.add(neighbor)\n            g[neighbor] = g[current] + cost\n\n",
      "statement": "You are given an undirected graph with weighted edges, a [[start]] and a [[goal]] node, and for each node the heuristic value, which is the estimated distance to the end. Your task is to trace a canonical A* execution (see https://en.wikipedia.org/wiki/A*_search_algorithm ) by computing a shortest path from the start to the goal.\n\nWe recall that the A* algorithm will rely on three values for each node [[v]]:\n- the {{g-value}}, which is the minimum distance from the [[start]] to [[v]];\n- the {{h-value}}, which is an estimation of the minimum distance from [[v]] to the [[goal]] and is given by the heuristic provided in input;\n- the {{f-value}}, which is the sum of the g-value and h-value.\n\nThere is always a path between the start and the goal. The given heuristic is admissible and consistent, meaning that the A* algorithm will always find a shortest path from the start to the goal.\n\nWhen some nodes have the same f-value, the one with the smaller identifier is considered first.",
      "testCases": [
        {
          "title": "3-node Graph",
          "isTest": true,
          "testIn": "3 3 0 2\n33 11 0\n0 1 10\n0 2 40\n1 2 20",
          "testOut": "0 33\n1 21\n2 30",
          "isValidator": false,
          "needValidation": false
        },
        {
          "title": "Another 3-node Graph",
          "isTest": false,
          "testIn": "3 3 0 2\n22 11 0\n0 1 10\n0 2 25\n1 2 20",
          "testOut": "0 22\n1 21\n2 25",
          "isValidator": true,
          "needValidation": false
        },
        {
          "title": "Small Graph A",
          "isTest": true,
          "testIn": "5 7 0 4\n7 6 4 2 0\n0 1 1\n0 2 4\n1 2 2\n1 3 5\n1 4 12\n2 3 2\n3 4 3",
          "testOut": "0 7\n1 7\n2 7\n3 7\n4 8",
          "isValidator": false,
          "needValidation": false
        },
        {
          "title": "Small Graph B",
          "isTest": false,
          "testIn": "5 6 0 4\n7 10 9 5 0\n1 0 1\n1 2 9\n2 0 1\n2 3 6\n2 4 12\n3 4 5",
          "testOut": "0 7\n2 10\n1 11\n3 12\n4 12",
          "isValidator": true,
          "needValidation": false
        },
        {
          "title": "Small Graph A'",
          "isTest": true,
          "testIn": "5 7 4 0\n0 1 3 5 7\n0 1 1\n0 2 4\n1 2 2\n1 3 5\n1 4 12\n2 3 2\n3 4 3",
          "testOut": "4 7\n3 8\n2 8\n1 8\n0 8",
          "isValidator": false,
          "needValidation": false
        },
        {
          "title": "Small Graph B'",
          "isTest": false,
          "testIn": "5 6 1 4\n7 10 9 5 0\n1 0 1\n1 2 9\n2 0 1\n2 3 6\n2 4 12\n3 4 5",
          "testOut": "1 10\n0 8\n2 11\n3 13\n4 13",
          "isValidator": true,
          "needValidation": false
        },
        {
          "title": "Slightly Larger Graph",
          "isTest": true,
          "testIn": "8 10 0 7\n15 10 11 4 4 4 1 0\n0 1 6\n0 2 5\n0 3 10\n5 1 6\n5 2 6\n5 6 4\n4 2 7\n4 3 6\n4 6 6\n6 7 3",
          "testOut": "0 15\n3 14\n1 16\n2 16\n5 15\n4 16\n6 16\n7 18",
          "isValidator": false,
          "needValidation": false
        },
        {
          "title": "Slightly Larger Graph (different heuristic)",
          "isTest": false,
          "testIn": "8 10 0 7\n10 9 9 3 3 3 1 0\n0 1 6\n0 2 5\n0 3 10\n5 1 6\n5 2 6\n5 6 4\n4 2 7\n4 3 6\n4 6 6\n6 7 3",
          "testOut": "0 10\n3 13\n2 14\n5 14\n1 15\n4 15\n6 16\n7 18",
          "isValidator": true,
          "needValidation": false
        },
        {
          "title": "From Arad To Bucharest",
          "isTest": true,
          "testIn": "20 23 0 1\n366 0 160 242 161 178 77 151 226 244 241 234 380 98 193 253 329 80 199 374\n12 19 71\n12 15 151\n0 19 75\n0 15 140\n0 16 118\n16 9 111\n9 10 70\n10 3 75\n3 2 120\n2 13 138\n2 14 146\n14 13 97\n14 15 80\n15 5 99\n5 1 211\n13 1 101\n1 6 90\n1 17 85\n17 7 98\n7 4 86\n17 18 142\n18 8 92\n8 11 87",
          "testOut": "0 366\n15 393\n14 413\n13 415\n5 417\n1 418",
          "isValidator": false,
          "needValidation": false
        },
        {
          "title": "From Timisoara To Bucharest",
          "isTest": false,
          "testIn": "20 23 16 1\n366 0 160 242 161 178 77 151 226 244 241 234 380 98 193 253 329 80 199 374\n12 19 71\n12 15 151\n0 19 75\n0 15 140\n0 16 118\n16 9 111\n9 10 70\n10 3 75\n3 2 120\n2 13 138\n2 14 146\n14 13 97\n14 15 80\n15 5 99\n5 1 211\n13 1 101\n1 6 90\n1 17 85\n17 7 98\n7 4 86\n17 18 142\n18 8 92\n8 11 87",
          "testOut": "16 329\n9 355\n10 422\n0 484\n3 498\n15 511\n14 531\n13 533\n5 535\n1 536",
          "isValidator": true,
          "needValidation": false
        },
        {
          "title": "Equal f-value",
          "isTest": true,
          "testIn": "4 4 0 3\n5 3 3 0\n0 1 2\n0 2 2\n1 3 4\n2 3 4",
          "testOut": "0 5\n1 5\n2 5\n3 6",
          "isValidator": false,
          "needValidation": false
        },
        {
          "title": "Equal f-value II",
          "isTest": false,
          "testIn": "8 8 2 6\n3 5 10 6 4 3 0 2\n0 1 2\n1 2 4\n2 3 3\n3 4 2\n4 5 1\n5 6 4\n6 7 3\n7 0 1",
          "testOut": "2 10\n1 9\n0 9\n3 9\n4 9\n5 9\n7 9\n6 10",
          "isValidator": true,
          "needValidation": false
        }
      ],
      "difficulty": "medium",
      "constraints": "0 < [[N]] < 100\n0 < [[E]] < 10000\n0 < [[C]] < 1000",
      "coverBinaryId": 138088549481397,
      "stubGenerator": "read N:int E:int S:int G:int\nloopline N  node:int\nloop E read x:int y:int c:int\n\nwrite 0 0",
      "inputDescription": "<<Line 1:>> 4 space-separated integers: \n[[N]] - the number of nodes in the graph (nodes are identified by integers from [[0]] to [[N-1]]),\n[[E]] - the number of edges in the graph,\n[[S]] - the identifier of the [[start]] node,\n[[G]] - the identifier of the [[goal]] node\n\n<<Line 2:>> [[N]] space-separated integers - estimated distances to the goal (heuristics) for each node from [[0]] to [[N-1]]\n\n<<Next [[E]] lines:>> three space-separated integers [[X]] [[Y]] [[C]] that indicate the edge between nodes [[X]] and [[Y]] with the cost [[C]]. Notice that, since the graph is undirected, there is also an edge from [[Y]] to [[X]] with the same cost.",
      "solutionLanguage": "Python3",
      "outputDescription": "A sequence of lines containing information about the node expanded in each step of the algorithm: the node's identifier, followed by a space, followed by its f-value."
    },
    "draft": false,
    "readyForModeration": true,
    "statementHTML": "<div class=\"statement-body\">\n<div class=\"statement-section statement-goal\">\n   <h2><span class=\"icon icon-goal\">&nbsp;</span><span>Goal </span></h2>\n   <span class=\"question-statement\">You are given an undirected graph with weighted edges, a <var>start</var> and a <var>goal</var> node, and for each node the heuristic value, which is the estimated distance to the end. Your task is to trace a canonical A* execution (see https://en.wikipedia.org/wiki/A*_search_algorithm ) by computing a shortest path from the start to the goal.<br><br>We recall that the A* algorithm will rely on three values for each node <var>v</var>:<br>- the <const>g-value</const>, which is the minimum distance from the <var>start</var> to <var>v</var>;<br>- the <const>h-value</const>, which is an estimation of the minimum distance from <var>v</var> to the <var>goal</var> and is given by the heuristic provided in input;<br>- the <const>f-value</const>, which is the sum of the g-value and h-value.<br><br>There is always a path between the start and the goal. The given heuristic is admissible and consistent, meaning that the A* algorithm will always find a shortest path from the start to the goal.<br><br>When some nodes have the same f-value, the one with the smaller identifier is considered first.</span>\n</div>\n<div class=\"statement-section statement-protocol\">\n   <div class=\"blk\">\n      <div class=\"title\">Input</div>\n      <div class=\"question-statement-input\"><strong>Line 1:</strong> 4 space-separated integers: <br><var>N</var> - the number of nodes in the graph (nodes are identified by integers from <var>0</var> to <var>N-1</var>),<br><var>E</var> - the number of edges in the graph,<br><var>S</var> - the identifier of the <var>start</var> node,<br><var>G</var> - the identifier of the <var>goal</var> node<br><br><strong>Line 2:</strong> <var>N</var> space-separated integers - estimated distances to the goal (heuristics) for each node from <var>0</var> to <var>N-1</var><br><br><strong>Next <var>E</var> lines:</strong> three space-separated integers <var>X</var> <var>Y</var> <var>C</var> that indicate the edge between nodes <var>X</var> and <var>Y</var> with the cost <var>C</var>. Notice that, since the graph is undirected, there is also an edge from <var>Y</var> to <var>X</var> with the same cost.</div>\n   </div>\n   <div class=\"blk\">\n      <div class=\"title\">Output</div>\n      <div class=\"question-statement-output\">A sequence of lines containing information about the node expanded in each step of the algorithm: the node's identifier, followed by a space, followed by its f-value.</div>\n   </div>\n   <div class=\"blk\">\n      <div class=\"title\">Constraints</div>\n      <div class=\"question-statement-constraints\">0 &lt; <var>N</var> &lt; 100<br>0 &lt; <var>E</var> &lt; 10000<br>0 &lt; <var>C</var> &lt; 1000</div>\n   </div>\n   <div class=\"blk\">\n      <div class=\"title\">Example</div>\n      <div class=\"statement-inout\">\n         <div class=\"statement-inout-in\">\n            <div class=\"title\">Input</div>\n            <pre class=\"question-statement-example-in\">3 3 0 2\n33 11 0\n0 1 10\n0 2 40\n1 2 20</pre>\n         </div>\n         <div class=\"statement-inout-out\">\n            <div class=\"title\">Output</div>\n            <pre class=\"question-statement-example-out\">0 33\n1 21\n2 30</pre>\n         </div>\n      </div>\n   </div>\n</div>"
  },
  "validatedFor": 263837956548,
  "avatar": 4210501575817,
  "commentCount": 21,
  "upVotes": 2,
  "downVotes": 1,
  "validateAction": {
    "actionId": 154509,
    "progress": 1,
    "alreadyDone": false
  },
  "statusHistory": [],
  "editable": true,
  "draft": false,
  "readyForModeration": true
}