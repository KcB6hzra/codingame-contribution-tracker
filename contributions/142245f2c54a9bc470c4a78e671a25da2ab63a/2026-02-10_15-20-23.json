{
  "id": 142245,
  "activeVersion": 7,
  "score": -3,
  "votableId": 39089753,
  "codingamerId": 5377868,
  "views": 111,
  "commentableId": 38922381,
  "title": "Chaos Protocol",
  "status": "PENDING",
  "type": "PUZZLE_INOUT",
  "nickname": "YALOKGAR",
  "publicHandle": "142245f2c54a9bc470c4a78e671a25da2ab63a",
  "codingamerHandle": "71ce77dc02b52055debde214148067dc8687735",
  "lastVersion": {
    "version": 7,
    "autocloseTime": 1772720214151,
    "freezeTime": 1770733014151,
    "data": {
      "title": "Chaos Protocol",
      "topics": [
        {
          "id": 67,
          "handle": "parsing",
          "category": "FUNDAMENTALS",
          "labelMap": {
            "1": "Parsing",
            "2": "Parsing"
          },
          "pageTitle": "Parsing: exercises and theory",
          "puzzleCount": 46,
          "parentTopicId": 41,
          "contentDetailsId": 102
        },
        {
          "id": 48,
          "handle": "graphs",
          "category": "INTERMEDIATE",
          "labelMap": {
            "1": "Graphes",
            "2": "Graphs"
          },
          "pageTitle": "Graphs: exercises and theory",
          "puzzleCount": 44,
          "parentTopicId": 40,
          "contentDetailsId": 75
        },
        {
          "id": 60,
          "handle": "dynamic-programming",
          "category": "ADVANCED",
          "labelMap": {
            "1": "Programmation dynamique",
            "2": "Dynamic programming"
          },
          "pageTitle": "Dynamic programming: exercises and theory",
          "puzzleCount": 36,
          "parentTopicId": 41,
          "contentDetailsId": 85
        },
        {
          "id": 86,
          "handle": "simulation",
          "category": "INTERMEDIATE",
          "labelMap": {
            "1": "Simulation",
            "2": "Simulation"
          },
          "pageTitle": "Simulation: exercises and theory",
          "puzzleCount": 51,
          "parentTopicId": 42,
          "contentDetailsId": 72
        },
        {
          "id": 122,
          "handle": "string",
          "category": "FUNDAMENTALS",
          "labelMap": {
            "1": "string",
            "2": "string"
          },
          "puzzleCount": 1,
          "parentTopicId": 93
        }
      ],
      "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAX_BUF 8192\n#define MOD_FIB 1000000007LL\n#define INF 999999999\n\nstatic const char b64[] = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\nint b64idx(char c) {\n    char *p = strchr(b64, c);\n    return p ? (int)(p - b64) : -1;\n}\n\nint decodeBase64(const char *in, char *out) {\n    int len = strlen(in), j = 0;\n    for (int i = 0; i < len; i += 4) {\n        int a = b64idx(in[i]);\n        int b = (i+1 < len) ? b64idx(in[i+1]) : 0;\n        int c = (i+2 < len && in[i+2] != '=') ? b64idx(in[i+2]) : -1;\n        int d = (i+3 < len && in[i+3] != '=') ? b64idx(in[i+3]) : -1;\n        out[j++] = (a << 2) | (b >> 4);\n        if (c >= 0) out[j++] = ((b & 0xF) << 4) | (c >> 2);\n        if (d >= 0) out[j++] = ((c & 0x3) << 6) | d;\n    }\n    out[j] = '\\0';\n    return j;\n}\n\ntypedef struct { char key[32]; char val[4096]; } KV;\nKV kvStore[64];\nint kvCount = 0;\n\nvoid parseKV(const char *data) {\n    char buf[MAX_BUF];\n    strncpy(buf, data, MAX_BUF - 1);\n    buf[MAX_BUF - 1] = '\\0';\n    char *line = strtok(buf, \"\\n\");\n    while (line) {\n        char *sep = strchr(line, ':');\n        if (sep) {\n            *sep = '\\0';\n            strncpy(kvStore[kvCount].key, line, 31);\n            strncpy(kvStore[kvCount].val, sep + 1, 4095);\n            kvCount++;\n        }\n        line = strtok(NULL, \"\\n\");\n    }\n}\n\nchar *getVal(const char *key) {\n    for (int i = 0; i < kvCount; i++)\n        if (strcmp(kvStore[i].key, key) == 0) return kvStore[i].val;\n    return \"\";\n}\n\ntypedef struct { int to; int w; int next; } Edge;\nEdge edges[1024];\nint head[256], edgeCnt;\n\nvoid addEdge(int u, int v, int w) {\n    edges[edgeCnt] = (Edge){v, w, head[u]};\n    head[u] = edgeCnt++;\n    edges[edgeCnt] = (Edge){u, w, head[v]};\n    head[v] = edgeCnt++;\n}\n\nint nodeId(const char *name, char names[][16], int *cnt) {\n    for (int i = 0; i < *cnt; i++)\n        if (strcmp(names[i], name) == 0) return i;\n    strcpy(names[*cnt], name);\n    return (*cnt)++;\n}\n\nlong long solveGraph(const char *str) {\n    char buf[4096], names[256][16];\n    int cnt = 0;\n    memset(head, -1, sizeof(head));\n    edgeCnt = 0;\n    strncpy(buf, str, 4095);\n\n    char *tok = strtok(buf, \",\");\n    while (tok) {\n        while (*tok == ' ') tok++;\n        char a[32], b[32]; int w;\n        char *dash = strchr(tok, '-');\n        char *colon = strrchr(tok, ':');\n        if (dash && colon) {\n            *dash = '\\0'; *colon = '\\0';\n            strcpy(a, tok); strcpy(b, dash + 1);\n            w = atoi(colon + 1);\n            int u = nodeId(a, names, &cnt);\n            int v = nodeId(b, names, &cnt);\n            addEdge(u, v, w);\n        }\n        tok = strtok(NULL, \",\");\n    }\n\n    int startNode = -1, endNode = -1;\n    for (int i = 0; i < cnt; i++) {\n        if (strcmp(names[i], \"S\") == 0) startNode = i;\n        if (strcmp(names[i], \"E\") == 0) endNode = i;\n    }\n    if (startNode < 0 || endNode < 0) return 0;\n\n    int dist[256], visited[256];\n    for (int i = 0; i < cnt; i++) { dist[i] = INF; visited[i] = 0; }\n    dist[startNode] = 0;\n\n    for (int iter = 0; iter < cnt; iter++) {\n        int u = -1;\n        for (int i = 0; i < cnt; i++)\n            if (!visited[i] && (u < 0 || dist[i] < dist[u])) u = i;\n        if (u < 0 || dist[u] == INF) break;\n        visited[u] = 1;\n        for (int e = head[u]; e != -1; e = edges[e].next) {\n            int v = edges[e].to, nd = dist[u] + edges[e].w;\n            if (nd < dist[v]) dist[v] = nd;\n        }\n    }\n    return dist[endNode];\n}\n\nlong long solveKnapsack(const char *itemsStr, int cap) {\n    char buf[4096];\n    strncpy(buf, itemsStr, 4095);\n    int weights[30], values[30], n = 0;\n\n    char *tok = strtok(buf, \";\");\n    while (tok && n < 30) {\n        char *c1 = strchr(tok, ',');\n        if (c1) {\n            char *c2 = strchr(c1 + 1, ',');\n            if (c2) {\n                weights[n] = atoi(c1 + 1);\n                values[n] = atoi(c2 + 1);\n                n++;\n            }\n        }\n        tok = strtok(NULL, \";\");\n    }\n\n    int *dp = calloc(cap + 1, sizeof(int));\n    for (int i = 0; i < n; i++)\n        for (int c = cap; c >= weights[i]; c--)\n            if (dp[c - weights[i]] + values[i] > dp[c])\n                dp[c] = dp[c - weights[i]] + values[i];\n    int result = dp[cap];\n    free(dp);\n    return result;\n}\n\nlong long solveGuards(const char *str, int tx, int ty) {\n    if (strlen(str) == 0) return 0;\n\n    int gx[10], gy[10], gn = 0;\n    char paths[10][256];\n    int pathLen[10];\n    char buf[2048];\n    strncpy(buf, str, 2047);\n\n    char *tok = strtok(buf, \";\");\n    while (tok && gn < 10) {\n        while (*tok == ' ') tok++;\n        char *c1 = strchr(tok, ',');\n        if (!c1) { tok = strtok(NULL, \";\"); continue; }\n        char *c2 = strchr(c1 + 1, ',');\n        *c1 = '\\0';\n        gx[gn] = atoi(tok);\n        if (c2) {\n            *c2 = '\\0';\n            gy[gn] = atoi(c1 + 1);\n            strcpy(paths[gn], c2 + 1);\n            pathLen[gn] = strlen(paths[gn]);\n        } else {\n            gy[gn] = atoi(c1 + 1);\n            paths[gn][0] = '\\0';\n            pathLen[gn] = 0;\n        }\n        gn++;\n        tok = strtok(NULL, \";\");\n    }\n\n    for (int t = 0; t < 200000; t++) {\n        int safe = 1;\n        for (int g = 0; g < gn && safe; g++) {\n            if (pathLen[g] == 0) continue;\n            int cx = gx[g], cy = gy[g];\n            for (int s = 0; s < t; s++) {\n                char m = paths[g][s % pathLen[g]];\n                if (m == 'U') cy++;\n                else if (m == 'D') cy--;\n                else if (m == 'R') cx++;\n                else if (m == 'L') cx--;\n            }\n            int dx = cx > tx ? cx - tx : tx - cx;\n            int dy = cy > ty ? cy - ty : ty - cy;\n            if (dx + dy <= 1) safe = 0;\n        }\n        if (safe) return t;\n    }\n    return 0;\n}\n\nint levenDist(const char *s, const char *t) {\n    int ls = strlen(s), lt = strlen(t);\n    int *prev = malloc((lt + 1) * sizeof(int));\n    int *curr = malloc((lt + 1) * sizeof(int));\n    for (int j = 0; j <= lt; j++) prev[j] = j;\n\n    for (int i = 1; i <= ls; i++) {\n        curr[0] = i;\n        for (int j = 1; j <= lt; j++) {\n            int cost = s[i-1] != t[j-1];\n            int a = prev[j] + 1;\n            int b = curr[j-1] + 1;\n            int c = prev[j-1] + cost;\n            curr[j] = a < b ? (a < c ? a : c) : (b < c ? b : c);\n        }\n        int *tmp = prev; prev = curr; curr = tmp;\n    }\n    int r = prev[lt];\n    free(prev); free(curr);\n    return r;\n}\n\nvoid solvePattern(const char *str, char *out) {\n    char buf[4096];\n    strncpy(buf, str, 4095);\n    char *parts[64];\n    int partCount = 0;\n\n    char *tok = strtok(buf, \",\");\n    while (tok && partCount < 64) {\n        parts[partCount++] = tok;\n        tok = strtok(NULL, \",\");\n    }\n    if (partCount < 2) { strcpy(out, \"\"); return; }\n\n    char *target = parts[0];\n    int bestDist = INT_MAX;\n    char *bestWord = NULL;\n\n    for (int i = 1; i < partCount; i++) {\n        int d = levenDist(target, parts[i]);\n        if (d < bestDist || (d == bestDist && strcmp(parts[i], bestWord) < 0)) {\n            bestDist = d;\n            bestWord = parts[i];\n        }\n    }\n    strcpy(out, bestWord ? bestWord : \"\");\n}\n\nlong long solveFactor(long long n) {\n    long long sum = 0;\n    while (n % 2 == 0) { sum += 2; n /= 2; }\n    for (long long i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) { sum += i; n /= i; }\n    }\n    if (n > 1) sum += n;\n    return sum;\n}\n\ntypedef struct { long long m[2][2]; } Mat;\n\nMat matMul(Mat A, Mat B) {\n    Mat R;\n    for (int i = 0; i < 2; i++)\n        for (int j = 0; j < 2; j++) {\n            R.m[i][j] = 0;\n            for (int k = 0; k < 2; k++)\n                R.m[i][j] = (R.m[i][j] + A.m[i][k] * B.m[k][j]) % MOD_FIB;\n        }\n    return R;\n}\n\nMat matPow(Mat base, long long exp) {\n    Mat result = {{{1,0},{0,1}}};\n    while (exp > 0) {\n        if (exp & 1) result = matMul(result, base);\n        base = matMul(base, base);\n        exp >>= 1;\n    }\n    return result;\n}\n\nlong long solveFib(long long n) {\n    if (n <= 0) return 0;\n    if (n == 1) return 1;\n    Mat base = {{{1,1},{1,0}}};\n    Mat r = matPow(base, n);\n    return r.m[0][1];\n}\n\ntypedef struct { int pos; const char *expr; } Parser;\n\nlong long parseExpr(Parser *p);\nlong long parseTerm(Parser *p);\nlong long parseFactor(Parser *p);\n\nlong long parseExpr(Parser *p) {\n    long long val = parseTerm(p);\n    while (p->pos < (int)strlen(p->expr) && (p->expr[p->pos] == '+' || p->expr[p->pos] == '-')) {\n        char op = p->expr[p->pos++];\n        long long right = parseTerm(p);\n        val = op == '+' ? val + right : val - right;\n    }\n    return val;\n}\n\nlong long parseTerm(Parser *p) {\n    long long val = parseFactor(p);\n    while (p->pos < (int)strlen(p->expr) && (p->expr[p->pos] == '*' || p->expr[p->pos] == '/')) {\n        char op = p->expr[p->pos++];\n        long long right = parseFactor(p);\n        val = op == '*' ? val * right : val / right;\n    }\n    return val;\n}\n\nlong long parseFactor(Parser *p) {\n    if (p->expr[p->pos] == '(') {\n        p->pos++;\n        long long val = parseExpr(p);\n        p->pos++;\n        return val;\n    }\n    int neg = 0;\n    if (p->pos < (int)strlen(p->expr) && p->expr[p->pos] == '-') {\n        neg = 1; p->pos++;\n    }\n    long long val = 0;\n    while (p->pos < (int)strlen(p->expr) && p->expr[p->pos] >= '0' && p->expr[p->pos] <= '9')\n        val = val * 10 + (p->expr[p->pos++] - '0');\n    return neg ? -val : val;\n}\n\nlong long solveEval(const char *expr) {\n    Parser p = {0, expr};\n    return parseExpr(&p);\n}\n\nlong long solveLCS(const char *s1, const char *s2) {\n    int n = strlen(s1), m = strlen(s2);\n    int *prev = calloc(m + 1, sizeof(int));\n    int *curr = calloc(m + 1, sizeof(int));\n\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= m; j++) {\n            if (s1[i-1] == s2[j-1])\n                curr[j] = prev[j-1] + 1;\n            else\n                curr[j] = prev[j] > curr[j-1] ? prev[j] : curr[j-1];\n        }\n        int *tmp = prev; prev = curr; curr = tmp;\n        memset(curr, 0, (m + 1) * sizeof(int));\n    }\n    long long r = prev[m];\n    free(prev); free(curr);\n    return r;\n}\n\nvoid solveTopo(const char *str, char *out) {\n    char buf[4096];\n    strncpy(buf, str, 4095);\n    char nodeNames[128][32];\n    int nodeCnt = 0;\n    int adj[128][128], adjCnt[128], indeg[128];\n    memset(adjCnt, 0, sizeof(adjCnt));\n    memset(indeg, 0, sizeof(indeg));\n\n    int fromList[256], toList[256];\n    int edgeCount = 0;\n\n    char *tok = strtok(buf, \",\");\n    while (tok) {\n        while (*tok == ' ') tok++;\n        char *gt = strchr(tok, '>');\n        if (gt) {\n            *gt = '\\0';\n            char *parent = tok, *child = gt + 1;\n            int pid = -1, cid = -1;\n            for (int i = 0; i < nodeCnt; i++) {\n                if (strcmp(nodeNames[i], parent) == 0) pid = i;\n                if (strcmp(nodeNames[i], child) == 0) cid = i;\n            }\n            if (pid < 0) { strcpy(nodeNames[nodeCnt], parent); pid = nodeCnt++; }\n            if (cid < 0) { strcpy(nodeNames[nodeCnt], child); cid = nodeCnt++; }\n            fromList[edgeCount] = pid;\n            toList[edgeCount] = cid;\n            edgeCount++;\n        }\n        tok = strtok(NULL, \",\");\n    }\n\n    for (int i = 0; i < edgeCount; i++) {\n        adj[fromList[i]][adjCnt[fromList[i]]++] = toList[i];\n        indeg[toList[i]]++;\n    }\n\n    for (int i = 0; i < nodeCnt; i++) {\n        for (int a = 0; a < adjCnt[i] - 1; a++)\n            for (int b = a + 1; b < adjCnt[i]; b++)\n                if (strcmp(nodeNames[adj[i][a]], nodeNames[adj[i][b]]) > 0) {\n                    int tmp = adj[i][a]; adj[i][a] = adj[i][b]; adj[i][b] = tmp;\n                }\n    }\n\n    int queue[128], qf = 0, qb = 0;\n    for (int i = 0; i < nodeCnt; i++)\n        if (indeg[i] == 0) queue[qb++] = i;\n\n    for (int a = 0; a < qb - 1; a++)\n        for (int b = a + 1; b < qb; b++)\n            if (strcmp(nodeNames[queue[a]], nodeNames[queue[b]]) > 0) {\n                int tmp = queue[a]; queue[a] = queue[b]; queue[b] = tmp;\n            }\n\n    out[0] = '\\0';\n    int first = 1;\n    while (qf < qb) {\n        int u = queue[qf++];\n        if (!first) strcat(out, \",\");\n        strcat(out, nodeNames[u]);\n        first = 0;\n\n        int newNodes[128], nn = 0;\n        for (int i = 0; i < adjCnt[u]; i++) {\n            int v = adj[u][i];\n            indeg[v]--;\n            if (indeg[v] == 0) newNodes[nn++] = v;\n        }\n\n        for (int a = 0; a < nn - 1; a++)\n            for (int b = a + 1; b < nn; b++)\n                if (strcmp(nodeNames[newNodes[a]], nodeNames[newNodes[b]]) > 0) {\n                    int tmp = newNodes[a]; newNodes[a] = newNodes[b]; newNodes[b] = tmp;\n                }\n\n        int allSorted[128], allCnt = 0;\n        for (int i = qf; i < qb; i++) allSorted[allCnt++] = queue[i];\n        for (int i = 0; i < nn; i++) allSorted[allCnt++] = newNodes[i];\n\n        for (int a = 0; a < allCnt - 1; a++)\n            for (int b = a + 1; b < allCnt; b++)\n                if (strcmp(nodeNames[allSorted[a]], nodeNames[allSorted[b]]) > 0) {\n                    int tmp = allSorted[a]; allSorted[a] = allSorted[b]; allSorted[b] = tmp;\n                }\n\n        qb = qf;\n        for (int i = 0; i < allCnt; i++) queue[qb++] = allSorted[i];\n    }\n}\n\nlong long solvePowmod(long long base, long long exp, long long mod) {\n    long long result = 1;\n    base %= mod;\n    while (exp > 0) {\n        if (exp & 1) result = (__int128)result * base % mod;\n        base = (__int128)base * base % mod;\n        exp >>= 1;\n    }\n    return result;\n}\n\nint main() {\n    char encoded[4096], decoded[MAX_BUF];\n    fgets(encoded, 4096, stdin);\n    encoded[strcspn(encoded, \"\\r\\n\")] = '\\0';\n\n    decodeBase64(encoded, decoded);\n    parseKV(decoded);\n\n    long long rGraph = solveGraph(getVal(\"GRAPH\"));\n    long long rKnapsack = solveKnapsack(getVal(\"ITEMS\"), atoi(getVal(\"CAP\")));\n    long long rGuards = solveGuards(getVal(\"GUARDS\"), atoi(getVal(\"TX\")), atoi(getVal(\"TY\")));\n\n    char patternResult[256];\n    solvePattern(getVal(\"PATTERN\"), patternResult);\n\n    long long rFactor = solveFactor(atoll(getVal(\"FACTOR\")));\n    long long rFib = solveFib(atoll(getVal(\"FIB\")));\n    long long rEval = solveEval(getVal(\"EXPR\"));\n\n    char lcsStr[4096];\n    strncpy(lcsStr, getVal(\"LCS\"), 4095);\n    char *lcsComma = strchr(lcsStr, ',');\n    long long rLcs = 0;\n    if (lcsComma) {\n        *lcsComma = '\\0';\n        rLcs = solveLCS(lcsStr, lcsComma + 1);\n    }\n\n    char topoResult[2048];\n    solveTopo(getVal(\"TOPO\"), topoResult);\n\n    char powStr[256];\n    strncpy(powStr, getVal(\"POWER\"), 255);\n    long long pb = 0, pe = 0, pm = 0;\n    char *pt1 = strtok(powStr, \",\");\n    char *pt2 = strtok(NULL, \",\");\n    char *pt3 = strtok(NULL, \",\");\n    if (pt1) pb = atoll(pt1);\n    if (pt2) pe = atoll(pt2);\n    if (pt3) pm = atoll(pt3);\n    long long rPowmod = solvePowmod(pb, pe, pm);\n\n    long long numericSum = rGraph + rKnapsack + rGuards + rFactor + rFib + rEval + rLcs + rPowmod;\n\n    long long asciiPattern = 0;\n    for (int i = 0; patternResult[i]; i++) asciiPattern += patternResult[i];\n    long long asciiTopo = 0;\n    for (int i = 0; topoResult[i]; i++) asciiTopo += topoResult[i];\n    long long asciiSum = asciiPattern + asciiTopo;\n\n    long long result = numericSum ^ asciiSum;\n    printf(\"%lld\\n\", result);\n    return 0;\n}",
      "statement": "You intercepted a transmission from the NEXUS mainframe. Your mission: decode it and solve <<10>> independent tasks to compute the access code.\n\n<<Step 1 — DECODE>>\nThe input is a single Base64-encoded string. Decode it to obtain the raw mission data.\n\n<<Step 2 — PARSE>>\nThe decoded text contains lines in [[KEY]]{{:}}[[VALUE]] format. Each line corresponds to one parameter. Each task below reads its own set of keys from this parsed data.\n\n<<Step 3 — TASKS>>\nAll tasks are independent of each other.\n\n<<GRAPH>> — Shortest Path\nThe key [[GRAPH]] contains a comma-separated list of edges. Each edge is formatted as [[A]]{{-}}[[B]]{{:}}[[W]], meaning a bidirectional edge between nodes [[A]] and [[B]] with integer weight [[W]]. Find the shortest path from the node named {{S}} to the node named {{E}} and return the total path weight.\n\n<<KNAPSACK>> — 0/1 Knapsack\nThe key [[ITEMS]] contains a semicolon-separated list of items. Each item is formatted as [[NAME]]{{,}}[[WEIGHT]]{{,}}[[VALUE]]. The key [[CAP]] is the maximum weight capacity. Select a subset of items such that their total weight does not exceed [[CAP]] and their total value is maximized. Each item may be selected at most once. Return the maximum total value.\n\n<<GUARDS>> — Patrol Simulation\nThe key [[GUARDS]] contains a semicolon-separated list of guards. Each guard is formatted as [[GX]]{{,}}[[GY]]{{,}}[[PATH]]. A guard starts at position ([[GX]], [[GY]]). The keys [[TX]] and [[TY]] define the target position. Each guard moves one step per unit of time, cycling through its [[PATH]] string ({{U}}: Y+1, {{D}}: Y-1, {{R}}: X+1, {{L}}: X-1). At time [[t]], a guard has completed exactly [[t]] moves. Find the smallest non-negative integer [[t]] such that the target is safe: the Manhattan distance from the target to every guard is strictly greater than {{1}}. If [[GUARDS]] is empty, return {{0}}.\n\n<<PATTERN>> — Edit Distance Matching\nThe key [[PATTERN]] contains a comma-separated list of strings. The first string is the target; the remaining strings are candidates. Compute the Levenshtein (edit) distance from the target to each candidate. Return the candidate with the smallest distance. If there is a tie, return the lexicographically smallest candidate. The result is the string itself, not a number.\n\n<<FACTOR>> — Prime Factorization Sum\nThe key [[FACTOR]] contains a single integer [[N]]. Decompose [[N]] into its prime factors, counting each factor as many times as it divides [[N]] (with multiplicity). Return the sum of all those prime factors. For example, {{12}} = {{2}} × {{2}} × {{3}}, so the sum is {{7}}.\n\n<<FIB>> — Fibonacci Number\nThe key [[FIB]] contains a single integer [[N]]. Compute the [[N]]-th Fibonacci number modulo {{10^9+7}}. The Fibonacci sequence is defined as F({{0}}) = {{0}}, F({{1}}) = {{1}}, and F([[k]]) = F([[k]] - {{1}}) + F([[k]] - {{2}}) for [[k]] ≥ {{2}}. Return F([[N]]) mod {{10^9+7}}.\n\n<<EVAL>> — Expression Evaluation\nThe key [[EXPR]] contains an arithmetic expression built from non-negative integers, the operators {{+}}, {{-}}, {{*}}, {{/}} (integer division, truncated toward zero), and parentheses. Standard operator precedence applies: {{*}} and {{/}} bind tighter than {{+}} and {{-}}. Evaluate the expression and return the integer result.\n\n<<LCS>> — Longest Common Subsequence\nThe key [[LCS]] contains two strings separated by a comma. Compute the length of the longest common subsequence (not substring) of these two strings. Return the length as an integer.\n\n<<TOPO>> — Topological Sort\nThe key [[TOPO]] contains a comma-separated list of directed edges. Each edge is formatted as [[P]]{{>}}[[C]], meaning a directed edge from node [[P]] to node [[C]]. Perform a topological sort on the resulting directed acyclic graph. When multiple nodes have zero in-degree simultaneously, process them in lexicographic order. Return the sorted node names joined by commas.\n\n<<POWMOD>> — Modular Exponentiation\nThe key [[POWER]] contains three comma-separated integers [[BASE]]{{,}}[[EXP]]{{,}}[[MOD]]. Compute [[BASE]] raised to the power [[EXP]], modulo [[MOD]], using fast exponentiation. Return the result.\n\n<<Step 4 — FINAL COMPUTATION>>\nSum all numeric task results: {{GRAPH}} + {{KNAPSACK}} + {{GUARDS}} + {{FACTOR}} + {{FIB}} + {{EVAL}} + {{LCS}} + {{POWMOD}}. Then compute the sum of ASCII values of every character in the {{PATTERN}} result string, and the sum of ASCII values of every character in the {{TOPO}} result string. Add those two ASCII sums together. Finally, XOR the numeric sum with the combined ASCII sum. Output the result.",
      "testCases": [
        {
          "title": "Minimal",
          "isTest": true,
          "testIn": "R1JBUEg6Uy1FOjEKSVRFTVM6eCwxLDEKQ0FQOjEKR1VBUkRTOgpUWDowClRZOjAKUEFUVEVSTjphLGIsYwpGQUNUT1I6MgpGSUI6MApFWFBSOjErMQpMQ1M6YSxhClRPUE86QT5CClBPV0VSOjEsMSwy",
          "testOut": "281",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Ghost",
          "isTest": false,
          "testIn": "R1JBUEg6Uy1FOjUKSVRFTVM6eSwyLDMKQ0FQOjIKR1VBUkRTOgpUWDowClRZOjAKUEFUVEVSTjpiLGEsYwpGQUNUT1I6MwpGSUI6MQpFWFBSOjIrMwpMQ1M6eCx5ClRPUE86QT5CClBPV0VSOjIsMiwz",
          "testOut": "258",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "Breach",
          "isTest": true,
          "testIn": "R1JBUEg6Uy1BOjMsUy1COjcsQS1DOjIsQi1DOjEsQS1FOjE1LEMtRTo4LFMtRDo0LEQtQzozLEQtRToxMixCLUQ6MgpJVEVNUzpjaGlwLDMsNDA7YmxhZGUsNSw3MDtrZXksMiwzMDtkcml2ZSw3LDkwO3dpcmUsNCw1MDttZW0sNiw2NTtyb20sMSwxNTtodWIsOCw5NQpDQVA6MjAKR1VBUkRTOjEsMCxSUjswLDEsVVUKVFg6MgpUWToxClBBVFRFUk46YWxnb3JpdGhtLGFsZ29yaXRtLGFsZ2FyaXRobSxhbGdvcnl0aG0sYWxvZ3JpdG0KRkFDVE9SOjIzMTAKRklCOjEwMDAwMDAwMDAwMDAwMDAwMDAKRVhQUjozKyg0KjUtMikvMysxMApMQ1M6YWJjZGVmLGFlY2RmZwpUT1BPOkE+QixBPkMsQj5ELEM+RCxEPkUKUE9XRVI6MiwxMDAwMDAwMDAwMDAwMDAwMDAwLDEwMDAwMDAwMDc=",
          "testOut": "929261490",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Infiltration",
          "isTest": false,
          "testIn": "R1JBUEg6Uy1BOjQsUy1COjYsQS1DOjMsQi1DOjIsQS1FOjE0LEMtRTo5LFMtRDo1LEQtQzo0LEQtRToxMSxCLUQ6MwpJVEVNUzpyb20sNCw0NTtkaXNrLDYsODA7dXNiLDIsMzU7Y2FyZCw4LDEwMDt0YXBlLDMsNDA7cGx1Zyw1LDU1O3BvcnQsNyw3NTtzbG90LDEsMTIKQ0FQOjIyCkdVQVJEUzoyLDEsUlJVVUxMREQ7MCwyLEREUlJVVUxMClRYOjMKVFk6MgpQQVRURVJOOmRhdGFiYXNlLGRhdGFic2UsZGF0YmFzZSxkdGFiYXNlLGRhdGFiYXMsZGF0YWFzZQpGQUNUT1I6NDYyMApGSUI6NTAwMDAwMDAwMDAwMDAwMDAwCkVYUFI6Nyo4KzkqMTAtMTErMTIvMwpMQ1M6ZGF0YWJhc2UsZGF0YXN0b3JlClRPUE86WD5ZLFg+WixZPlcsWj5XClBPV0VSOjMsMTAwMDAwMDAwMDAwMDAwMDAwMCwxMDAwMDAwMDA3",
          "testOut": "248516400",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "Firewall",
          "isTest": true,
          "testIn": "R1JBUEg6Uy1BOjIsUy1COjUsUy1DOjksQS1EOjMsQS1FOjgsQi1EOjEsQi1GOjYsQy1GOjIsQy1HOjcsRC1IOjQsRS1IOjIsRi1IOjUsRy1IOjMsSC1JOjEsSS1KOjMsSi1FOjIsRC1HOjQsRS1GOjMsSS1FOjYsSi1LOjIsSy1MOjEsTC1FOjQKSVRFTVM6cmFtLDQsNTU7Y3B1LDgsMTIwO2dwdSw2LDk1O3NzZCwzLDQwO2ZhbiwyLDI1O3BzdSw1LDY1O21vYm8sOSwxMzA7Y29vbCw3LDg1O3JnYiwxLDEwO2Nhc2UsMTAsMTQwO2R2ZCwzLDMwO2JhdCw0LDQ1O25ldCw2LDcwO21pYywyLDIwO2NhbSw1LDU1CkNBUDozNQpHVUFSRFM6MywzLFJSUlJERERETExMTFVVVVU7OCwyLExMTExEREREUlJSUlVVVVU7NSw3LFVVVVVSUlJSRERERExMTEwKVFg6NQpUWTo1ClBBVFRFUk46Y3J5cHRvZ3JhcGh5LGNyeXB0Z3JhcGh5LGN5cHRvZ3JhcGh5LGNyeXB0b2dycGh5LGNyeXB0b2dyYXBoaSxjcnlwdG9ncmFweQpGQUNUT1I6OTk5OTk5OTk5OTk5OTM3CkZJQjo1NzY0NjA3NTIzMDM0MjM0ODgKRVhQUjooMTAwKzIwMCkqMy01MC81KzcqKDgtMykKTENTOnByb2dyYW1taW5nLGdhbWluZwpUT1BPOlg+WSxYPlosWT5XLFo+VyxXPlYsVj5VClBPV0VSOjk5OSw5OTk5OTk5OTk5OTk5OTk5OTksMTAwMDAwMDAwNw==",
          "testOut": "15949521559",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Backdoor",
          "isTest": false,
          "testIn": "R1JBUEg6Uy1BOjMsUy1COjQsQS1DOjIsQi1DOjMsQS1EOjYsQi1EOjEsQy1FOjUsRC1FOjQsQy1EOjIsUy1DOjgsQS1FOjEyLEItRToxMApJVEVNUzptZW0sNSw2MDtwcm9jLDcsMTEwO2Rpc3AsNCw1MDtwb3J0LDMsMzU7aHViLDYsNzU7Y3RybCw4LDEyNTtidXMsMiwyODtyYW0sOSwxMTU7Z3B1LDEwLDE0MDtzc2QsNCw1MjtuaWMsNiw3MjtwY2ksMywzODtkbWEsNSw1ODt1c2IsNyw4ODtpZGUsOCw5OApDQVA6NDAKR1VBUkRTOjQsMixSUlJSRERERExMTExVVVVVOzYsNCxMTExMRERERFJSUlJVVVVVOzIsNixVVVVVUlJSUkRERERMTExMClRYOjQKVFk6NApQQVRURVJOOmVuY3J5cHRpb24sZW5jcnlwaW9uLGVuY3J5cHRvbixlbmNyeXB0aW4sZW5jcnB0aW9uLGVuY3lycHRpb24KRkFDVE9SOjIzNDU2Nzg5MTAxMTEyMQpGSUI6Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3CkVYUFI6KDUwKjUwLTEpLyg1MCs1MCkqMTAwCkxDUzplbmNyeXB0aW9uLGRlY3J5cHRpb24KVE9QTzpBPkMsQj5DLEM+RCxEPkUsRD5GLEU+RyxGPkcKUE9XRVI6NDIsNDIsMTAwMDAwMDAwOQ==",
          "testOut": "78190650603898",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "Labyrinth",
          "isTest": true,
          "testIn": "R1JBUEg6Uy1BOjEsUy1COjQsUy1DOjcsQS1EOjMsQS1FOjEwLEItRDoxLEItRjo1LEMtRjoyLEQtRzo2LEUtRzoxLEYtRzozLEctSDoyLEgtSTo4LEktSjoxLEotSzoyLEstRToxLEYtSDo0LEEtRjo5LEItRzo4LEMtSDo2LEQtSTo1LEUtSjozLEYtSzo3CklURU1TOnAxLDIsMjM7cDIsMywyOTtwMyw1LDMxO3A0LDcsMzc7cDUsMTEsNDE7cDYsNCwzMztwNyw2LDM1O3A4LDgsMzk7cDksMSwxNTtwMTAsMywyNztwMTEsOSw0MztwMTIsMiwxOTtwMTMsNCwzMjtwMTQsNiwzODtwMTUsMywyNTtwMTYsNSwzNDtwMTcsNyw0MDtwMTgsOCw0NDtwMTksMSwxMjtwMjAsMiwxOApDQVA6NTAKR1VBUkRTOjEsMSxSUlJVVVVMTExERERSUlVVTExERDszLDAsRERERERSUlJSUlVVVVVVTExMTEwKVFg6MgpUWToyClBBVFRFUk46YXV0aGVudGljYXRpb24sYXV0aGVudGNhdGlvbixhdXRoYW50aWNhdGlvbixhdXRlbnRpY2F0aW9uLGF1dGhlbnRpY2F0b24sYXV0aGVudGlmaWNhdGlvbgpGQUNUT1I6OTk5OTk5OTk5OTk5ODkzCkZJQjoxMjM0NTY3ODkwMTIzNDU2NzgKRVhQUjooKDEwKzIwKSooMzAtNSkpLzI1KzEwMCoyLTc1CkxDUzphYmNkZWZnaGlqLGFjZWdpYmRmaGoKVE9QTzpNPk4sTT5PLE4+UCxPPlAsUD5RLFE+UixSPlQKUE9XRVI6MTcsMjMsMTAwMDAwMDAwOQ==",
          "testOut": "4797271650",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Maze",
          "isTest": false,
          "testIn": "R1JBUEg6Uy1BOjIsUy1COjMsUy1DOjgsQS1EOjQsQS1FOjksQi1EOjIsQi1GOjYsQy1GOjEsRC1HOjUsRS1HOjIsRi1HOjQsRy1IOjMsSC1JOjcsSS1KOjIsSi1LOjMsSy1FOjIsRi1IOjMsQS1GOjEwLEItRzo5LEMtSDo3LEQtSTo2LEUtSjo0CklURU1TOnExLDMsMjU7cTIsNCwzMDtxMyw2LDM1O3E0LDgsNDA7cTUsMTAsNDU7cTYsNSwzODtxNyw3LDQyO3E4LDksNDg7cTksMiwxODtxMTAsNCwyODtxMTEsOCw0NjtxMTIsMywyMjtxMTMsNSwzNjtxMTQsNyw0NDtxMTUsMiwxNjtxMTYsNCwyNjtxMTcsNiwzNDtxMTgsOCw0MjtxMTksMSwxMDtxMjAsMywyNApDQVA6NTUKR1VBUkRTOjIsMixSUlJVVVVMTExERERSUlVVTExERDs0LDEsRERERERSUlJSUlVVVVVVTExMTEwKVFg6MwpUWTozClBBVFRFUk46YXV0aG9yaXphdGlvbixhdXRob3JpemF0b24sYXV0aG9yaXp0aW9uLGF1dGhyaXphdGlvbixhdXRob3JpemFpb24sYXV0aGVudGl6YXRpb24KRkFDVE9SOjk5OTk5OTk5OTk5ODk4NwpGSUI6MjM0NTY3ODkwMTIzNDU2Nzg5CkVYUFI6MSsyKjMrNCo1KjYrNwpMQ1M6YXV0aG9yaXphdGlvbixhdXRoZW50aWNhdGlvbgpUT1BPOk0+TixNPk8sTj5QLE8+UCxQPlEsUT5SClBPV0VSOjE5LDI5LDEwMDAwMDAwMDc=",
          "testOut": "76923470527284",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "Cipher",
          "isTest": true,
          "testIn": "R1JBUEg6Uy1OMTo1LFMtTjI6OCxTLU4zOjEyLE4xLU40OjMsTjEtTjU6NyxOMi1ONDoyLE4yLU42OjYsTjMtTjY6MSxONC1ONzo0LE41LU43OjIsTjYtTjc6NSxONy1OODozLE44LU45OjEsTjktRToyLE41LUU6MTUsTjgtRTo2LE4xLU42OjksTjItTjU6NCxOMy1ONzo4CklURU1TOmFscGhhLDUsNjA7YmV0YSw4LDk1O2dhbW1hLDMsMzU7ZGVsdGEsMTIsMTUwO2Vwc2lsb24sNiw3NTt6ZXRhLDQsNTA7ZXRhLDcsODU7dGhldGEsMTAsMTIwO2lvdGEsMiwyNTtrYXBwYSw5LDExMDtsYW1iZGEsMTEsMTM1O211LDEsMTU7bnUsMyw0MDt4aSw2LDcwO29taWNyLDgsMTAwCkNBUDo0NQpHVUFSRFM6NCw0LFJSRERVVUxMUlJERFVVTEw7NywyLExMRERSUlVVOzEsNixVVVJSRERMTApUWDo1ClRZOjUKUEFUVEVSTjp2dWxuZXJhYmlsaXR5LHZ1bG5lcmFiaWx0eSx2dWxuYXJhYmlsaXR5LHZ1bmxlcmFiaWxpdHksdnVsbmVyYmlsaXR5LHZ1bG5lcmFiaWxpeQpGQUNUT1I6OTk5OTk5OTk5OTk5OTczCkZJQjo5OTk5OTk5OTk5OTk5OTk5OTkKRVhQUjo1KjUqNSo1KzQqNCo0KjQtMyozKjMqMysyKjIqMioyLTEKTENTOnZ1bG5lcmFiaWxpdHksaW52dWxuZXJhYmxlClRPUE86QT5DLEE+RCxCPkMsQj5FLEM+RixEPkYsRT5GLEY+RwpQT1dFUjoxMjM0LDU2NzgsMTAwMDAwMDAwNw==",
          "testOut": "685776536",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Vault",
          "isTest": false,
          "testIn": "R1JBUEg6Uy1OMTo0LFMtTjI6OSxTLU4zOjExLE4xLU40OjIsTjEtTjU6OCxOMi1ONDozLE4yLU42OjUsTjMtTjY6MixONC1ONzo1LE41LU43OjMsTjYtTjc6NCxONy1OODoyLE44LU45OjMsTjktRToxLE41LUU6MTQsTjgtRTo3LE4xLU42OjEwLE4yLU41OjYsTjMtTjc6OQpJVEVNUzpiMSw0LDU1O2IyLDksMTAwO2IzLDMsNDA7YjQsMTEsMTQwO2I1LDcsODA7YjYsNSw2MDtiNyw4LDkwO2I4LDEwLDEzMDtiOSwyLDMwO2IxMCw2LDcwO2IxMSwxMiwxNTU7YjEyLDEsMTg7YjEzLDQsNTI7YjE0LDcsODI7YjE1LDMsMzgKQ0FQOjQyCkdVQVJEUzozLDMsUlJERFVVTExSUkREVVVMTDs2LDEsTExERFJSVVU7MSw1LFVVUlJERExMClRYOjQKVFk6NApQQVRURVJOOmF1dGhlbnRpY2F0aW9uLGF1dGhlbnRjYXRpb24sYXV0aG50aWNhdGlvbixhdXRlbnRpY2F0aW9uLGF1dGhlbnRpY2Fpb24sYXV0aGVudGlhY3Rpb24KRkFDVE9SOjk5OTk5OTk5OTk5OTk4OQpGSUI6ODc2NTQzMjEwOTg3NjU0MzIxCkVYUFI6MTAwKig5OS05OCkrOTcqKDk2LTk1KQpMQ1M6YXV0aGVudGljYXRpb24sYXV0aG9yaXphdGlvbgpUT1BPOlA+USxQPlIsUT5TLFI+UyxTPlQKUE9XRVI6Myw0MiwxMDAwMDAwMDA5",
          "testOut": "1000000895581586",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "Omega",
          "isTest": true,
          "testIn": "R1JBUEg6Uy1BOjIsUy1COjUsQS1COjEsQS1DOjQsQi1EOjMsQy1EOjIsQy1FOjcsRC1FOjEsRC1GOjUsRS1GOjIsRi1HOjMsRy1IOjEsSC1JOjQsSS1KOjYsSi1FOjgsRy1FOjksQS1FOjIwLEItRjoxMgpJVEVNUzpvMSwzLDI4O28yLDUsNDI7bzMsNyw1NTtvNCwyLDIwO281LDQsMzU7bzYsNiw0ODtvNyw4LDYyO284LDEsMTI7bzksOSw3MDtvMTAsMywzMDtvMTEsNSw0NTtvMTIsNyw1ODtvMTMsNCwzODtvMTQsNiw1MjtvMTUsMiwyMjtvMTYsOCw2NDtvMTcsMSwxNDtvMTgsMywzMjtvMTksNSw0NjtvMjAsNyw2MApDQVA6NDAKR1VBUkRTOjIsMixSUkREVVVMTFJSRERVVUxMOzUsMSxEREREUlJSUlVVVVVMTExMOzEsNSxVVVVVUlJSUkRERERMTExMClRYOjMKVFk6MwpQQVRURVJOOmluZnJhc3RydWN0dXJlLGluZmFzdHJ1Y3R1cmUsaW5mcmFzdHJ1Y3VyZSxpbmZyYXN0dWN0dXJlLGluZnJhc3RydWN0cmUsaW5mcmFzdHJjdHVyZQpGQUNUT1I6OTg3NjU0MzIxMDk4NzY1CkZJQjo3Nzc3Nzc3Nzc3Nzc3Nzc3NzcKRVhQUjoxMDAwLTUwMCsyNTAtMTI1KzYyLTMxKzE1LTcrMy0xCkxDUzppbmZyYXN0cnVjdHVyZSxpbnN0cnVjdHVyZQpUT1BPOlA+USxQPlIsUT5TLFI+UyxTPlQsVD5VLFU+VixQPlQKUE9XRVI6ODg4LDg4OCwxMDAwMDAwMDA5",
          "testOut": "2195937114",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Sigma",
          "isTest": false,
          "testIn": "R1JBUEg6Uy1BOjMsUy1COjQsQS1COjIsQS1DOjUsQi1EOjQsQy1EOjEsQy1FOjgsRC1FOjIsRC1GOjYsRS1GOjEsRi1HOjQsRy1IOjIsSC1JOjMsSS1KOjUsSi1FOjcsRy1FOjksQS1FOjE4LEItRjoxNApJVEVNUzp2MSw0LDMyO3YyLDYsNDg7djMsOCw2MDt2NCwyLDIyO3Y1LDUsNDA7djYsNyw1NDt2Nyw5LDY4O3Y4LDEsMTQ7djksMywyNjt2MTAsNSw0Mjt2MTEsNyw1Njt2MTIsNCwzNDt2MTMsNiw1MDt2MTQsOCw2NDt2MTUsMywyODt2MTYsOSw3Mjt2MTcsMSwxNjt2MTgsMywzMDt2MTksNSw0NDt2MjAsNyw1OApDQVA6NDIKR1VBUkRTOjMsMSxSUkREVVVMTFJSRERVVUxMOzYsMyxEREREUlJSUlVVVVVMTExMOzEsNixVVVVVUlJSUkRERERMTExMClRYOjQKVFk6NApQQVRURVJOOm9wdGltaXphdGlvbixvcHRpbWl6YXRvbixvcHRpbXphdGlvbixvcHRpbWlzYXRvbixvcHRpbWl6dGlvbixvcHRtaXphdGlvbgpGQUNUT1I6ODc2NTQzMjEwOTg3NjU0CkZJQjo2NTQzMjEwOTg3NjU0MzIxMDkKRVhQUjo5OTktOTkrOS0xKzEwMDAKTENTOm9wdGltaXphdGlvbixvcmdhbml6YXRpb24KVE9QTzpLPkwsSz5NLEw+TixNPk4sTj5PClBPV0VSOjg4OCw4ODg4ODg4ODg4ODg4ODg4ODgsMTAwMDAwMDAwNw==",
          "testOut": "20870927398435",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "Storm",
          "isTest": true,
          "testIn": "R1JBUEg6Uy1BOjEwLFMtQjozLEItQToxLEEtQzo1LEItQzo4LEItRDoyLEQtQzoxLEMtRTo0LEQtRTo3LEEtRToxNSxTLUM6MTEsUy1EOjYsQS1EOjQsQi1FOjEzLEMtRDozCklURU1TOnMxLDQsNTA7czIsNiw3MDtzMyw4LDkwO3M0LDMsMzU7czUsNSw2MDtzNiw3LDgwO3M3LDIsMjU7czgsMTAsMTEwO3M5LDEsMTU7czEwLDQsNDg7czExLDYsNjg7czEyLDgsODg7czEzLDMsMzM7czE0LDUsNTg7czE1LDcsNzgKQ0FQOjM1CkdVQVJEUzozLDMsUlJVVUxMREQ7NSw1LExMRERSUlVVOzcsMSxVVVJSRERMTApUWDo0ClRZOjQKUEFUVEVSTjpzeW5jaHJvbml6YXRpb24sc3luY2hyb25pemF0b24sc3luY3Jvbml6YXRpb24sc3ljaHJvbml6YXRpb24sc3luY2hyb25pc2F0aW9uLHN5bmNocm5pemF0aW9uCkZBQ1RPUjozMTQxNTkyNjUzNTg5NzkKRklCOjUwMDAwMDAwMDAwMDAwMDAwMApFWFBSOig5OSsxKSooNTAtMjUpKzMwMC8zKjIKTENTOnN5bmNocm9uaXplLHN5bnRoZXNpemUKVE9QTzpLPkwsSz5NLEw+TixNPk4sTj5PLEs+TwpQT1dFUjo3LDc3LDc3Nzc3Nzc3Nw==",
          "testOut": "590875301",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Thunder",
          "isTest": false,
          "testIn": "R1JBUEg6Uy1BOjgsUy1COjQsQi1BOjIsQS1DOjYsQi1DOjcsQi1EOjMsRC1DOjIsQy1FOjUsRC1FOjYsQS1FOjE0LFMtQzoxMCxTLUQ6NSxBLUQ6MyxCLUU6MTIKSVRFTVM6dDEsNSw1NTt0Miw3LDc1O3QzLDksOTU7dDQsNCw0MDt0NSw2LDY1O3Q2LDgsODU7dDcsMywzMDt0OCwxMSwxMTU7dDksMiwyMDt0MTAsNSw1Mzt0MTEsNyw3Mzt0MTIsOSw5Mzt0MTMsNCwzODt0MTQsNiw2Mzt0MTUsOCw4MwpDQVA6MzgKR1VBUkRTOjQsMyxSUlVVTExERDs2LDYsTExERFJSVVU7Miw1LFVVUlJERExMClRYOjUKVFk6NQpQQVRURVJOOnBhcmFsbGVsaXphdGlvbixwYXJhbGxlbGl6YXRvbixwYXJhbGxlbGl6dGlvbixwYXJhbGxlbHphdGlvbixwYXJhbGVsaXphdGlvbixwYXJlbGxlbGl6YXRpb24KRkFDVE9SOjI3MTgyODE4Mjg0NTkwNApGSUI6NDMyMTA5ODc2NTQzMjEwOTg3CkVYUFI6KDcrOCkqKDkrMTApLSgxMSsxMikqKDMrNCkKTENTOnBhcmFsbGVsaXphdGlvbixyYXRpb25hbGl6YXRpb24KVE9QTzpBPkIsQT5DLEI+RCxDPkQsRD5FLEU+RgpQT1dFUjoxMSw3Nyw3Nzc3Nzc3NzM=",
          "testOut": "1759415807",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "Nova",
          "isTest": true,
          "testIn": "R1JBUEg6Uy1QOjEsUC1ROjIsUS1SOjMsUi1UOjQsVC1VOjUsVS1WOjYsVi1XOjcsVy1YOjgsWC1ZOjksWS1FOjEwLFMtUToxMCxTLVI6MTUsUC1UOjEyLFEtVToxMSxSLVY6OSxULVc6OCxVLVg6NyxWLVk6NixXLUU6NQpJVEVNUzpuMSwzLDQ1O24yLDUsNjU7bjMsNyw4NTtuNCwyLDMwO241LDQsNTU7bjYsNiw3NTtuNyw4LDk1O244LDEsMjA7bjksOSwxMDA7bjEwLDMsNTA7bjExLDUsNzA7bjEyLDcsOTA7bjEzLDQsNjA7bjE0LDYsODA7bjE1LDgsMTA1O24xNiwyLDM1O24xNywxMCwxMTU7bjE4LDEsMTg7bjE5LDMsNDI7bjIwLDUsNjI7bjIxLDcsODI7bjIyLDQsNTI7bjIzLDYsNzI7bjI0LDgsOTI7bjI1LDksMTA4CkNBUDo2MApHVUFSRFM6MSwxLFJSVVVMTEREOzMsMCxMTEREUlJVVTswLDMsVVVSUkRETEw7MiwyLEREUlJVTExSClRYOjIKVFk6MQpQQVRURVJOOmVsZWN0cm9tYWduZXRpYyxlbGVjdG9tYWduZXRpYyxlbGVjdHJvbWFnbmV0YyxlbGVjdHJvbWFnbnRpYyxlbGV0cm9tYWduZXRpYyxlbGN0cm9tYWduZXRpYwpGQUNUT1I6MTIzNDU2Nzg5MDEyMzQ1CkZJQjo4ODg4ODg4ODg4ODg4ODg4ODgKRVhQUjoyKjMqNSo3KjExKjEzLTEwMDArMTcqMTkKTENTOmVsZWN0cm9tYWduZXRpYyxlbGVjdHJvc3RhdGljClRPUE86QT5CLEE+QyxBPkQsQj5FLEM+RSxEPkYsRT5HLEY+RwpQT1dFUjo5OTk5OTksOTk5OTk5LDEwMDAwMDAwMDc=",
          "testOut": "1139341409",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Pulse",
          "isTest": false,
          "testIn": "R1JBUEg6Uy1QOjIsUC1ROjMsUS1SOjQsUi1UOjUsVC1VOjYsVS1WOjcsVi1XOjgsVy1YOjksWC1ZOjEwLFktRToxMSxTLVE6OSxTLVI6MTQsUC1UOjExLFEtVToxMCxSLVY6OCxULVc6NyxVLVg6NixWLVk6NSxXLUU6NApJVEVNUzptMSw0LDUwO20yLDYsNzA7bTMsOCw5MDttNCwyLDM1O201LDUsNjA7bTYsNyw4MDttNyw5LDEwMDttOCwxLDI1O205LDMsNDU7bTEwLDUsNjU7bTExLDcsODU7bTEyLDQsNTU7bTEzLDYsNzU7bTE0LDgsOTU7bTE1LDksMTEwO20xNiwzLDQwO20xNywxMSwxMjA7bTE4LDEsMTg7bTE5LDMsNDI7bTIwLDUsNjI7bTIxLDcsODI7bTIyLDQsNTI7bTIzLDYsNzI7bTI0LDgsOTI7bTI1LDEwLDExMgpDQVA6NjUKR1VBUkRTOjIsMSxSUlVVTExERDs0LDMsTExERFJSVVU7MSw0LFVVUlJERExMOzMsMixERFJSVUxMUgpUWDozClRZOjIKUEFUVEVSTjppbXBsZW1lbnRhdGlvbixpbXBsZW1lbnRhdG9uLGltcGxtZW50YXRpb24saW1wbGVtZW50dGlvbixpbWxlbWVudGF0aW9uLGltcGxlbW50YXRpb24KRkFDVE9SOjIzNDU2Nzg5MDEyMzQ1NgpGSUI6NzY1NDMyMTA5ODc2NTQzMjEwCkVYUFI6MTAqMTAqMTArOSo5KjktOCo4KjgrNyo3KjcKTENTOmltcGxlbWVudGF0aW9uLGltcGxpY2F0aW9uClRPUE86WD5ZLFg+WixZPlcsWj5XLFc+VixWPlUsVT5UClBPV0VSOjk5OTk5OSw5OTk5OTk5OTk5OTksMTAwMDAwMDAwOQ==",
          "testOut": "1112644380",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "Apex",
          "isTest": true,
          "testIn": "R1JBUEg6Uy1BOjEsUy1COjIsQS1DOjMsQi1DOjEsQy1EOjQsRC1GOjUsRi1HOjYsRy1IOjcsSC1JOjgsSS1KOjksSi1LOjEwLEstTDoxMSxMLU06MTIsTS1OOjEzLE4tTzoxNCxPLUU6MTUsQS1EOjIwLEItRjoxOCxDLUc6MTYsRC1IOjE0LEYtSToxMixHLUo6MTAsSC1LOjgsSS1MOjYsSi1NOjQsSy1OOjIsTC1POjEsTS1FOjMsUy1DOjUsQS1GOjE1LEItRzoxMwpJVEVNUzphMSwxLDEwO2EyLDIsMjA7YTMsMywzMDthNCw0LDQwO2E1LDUsNTA7YTYsNiw2MDthNyw3LDcwO2E4LDgsODA7YTksOSw5MDthMTAsMTAsMTAwO2ExMSwxLDE1O2ExMiwyLDI1O2ExMywzLDM1O2ExNCw0LDQ1O2ExNSw1LDU1O2ExNiw2LDY1O2ExNyw3LDc1O2ExOCw4LDg1O2ExOSw5LDk1O2EyMCwxMCwxMDU7YTIxLDEsMTI7YTIyLDIsMjI7YTIzLDMsMzI7YTI0LDQsNDI7YTI1LDUsNTIKQ0FQOjY1CkdVQVJEUzoxLDAsUlVSRFJVTERMVTswLDEsVUxETFVSRFJVUjsyLDEsRFJETFVMRFJVTApUWDoxClRZOjEKUEFUVEVSTjppbnRlcm5hdGlvbmFsaXphdGlvbixpbnRlcm5hdG9uYWxpemF0aW9uLGludGVybmF0aW9uYWxpemF0b24saW50ZXJuYXRpb25saXphdGlvbixpbnRlcm5hdGlvbmFsemF0aW9uLGludGVybmF0aW9uYWxpenRpb24KRkFDVE9SOjk5OTk5OTk5OTk5OTk5OQpGSUI6MTAwMDAwMDAwMDAwMDAwMDAwMApFWFBSOigoMSsyKzMrNCs1KSooNis3KzgrOSsxMCkpLTEwMApMQ1M6aW50ZXJuYXRpb25hbGl6YXRpb24saW50ZXJjb250aW5lbnRhbApUT1BPOkE+QixBPkMsQj5ELEI+RSxDPkUsQz5GLEQ+RyxFPkcsRj5HLEc+SApQT1dFUjoxMjM0NTY3LDg5MDEyMzQsMTAwMDAwMDAwOQ==",
          "testOut": "1007680832",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Zenith",
          "isTest": false,
          "testIn": "R1JBUEg6Uy1BOjIsUy1COjMsQS1DOjQsQi1DOjIsQy1EOjUsRC1GOjYsRi1HOjcsRy1IOjgsSC1JOjksSS1KOjEwLEotSzoxMSxLLUw6MTIsTC1NOjEzLE0tTjoxNCxOLU86MTUsTy1FOjE2LEEtRDoxOSxCLUY6MTcsQy1HOjE1LEQtSDoxMyxGLUk6MTEsRy1KOjksSC1LOjcsSS1MOjUsSi1NOjMsSy1OOjEsTC1POjIsTS1FOjQsUy1DOjYsQS1GOjE2LEItRzoxNApJVEVNUzp6MSwyLDEyO3oyLDMsMjI7ejMsNCwzMjt6NCw1LDQyO3o1LDYsNTI7ejYsNyw2Mjt6Nyw4LDcyO3o4LDksODI7ejksMTAsOTI7ejEwLDEsODt6MTEsMiwxODt6MTIsMywyODt6MTMsNCwzODt6MTQsNSw0ODt6MTUsNiw1ODt6MTYsNyw2ODt6MTcsOCw3ODt6MTgsOSw4ODt6MTksMTAsOTg7ejIwLDEsMTQ7ejIxLDIsMjQ7ejIyLDMsMzQ7ejIzLDQsNDQ7ejI0LDUsNTQ7ejI1LDYsNjQKQ0FQOjcwCkdVQVJEUzoyLDAsUlVSRFJVTERMVTswLDIsVUxETFVSRFJVUjsxLDIsRFJETFVMRFJVTApUWDoxClRZOjEKUEFUVEVSTjppbnRlcm5hdGlvbmFsaXphdGlvbixpbnRlcm5hdG9uYWxpemF0aW9uLGludGVybmF0aW9uYWxpemF0b24saW50ZXJuYXRpb25saXphdGlvbixpbnRlcm5hdGlvbmFsemF0aW9uLGludGVybmF0aW9uYWxpenRpb24KRkFDVE9SOjg4ODg4ODg4ODg4ODg4OApGSUI6OTk5OTk5OTk5OTk5OTk5OTM3CkVYUFI6KCgxMDAtNTApKigyMDAtMTAwKSkvKDI1KjIpKzEKTENTOmludGVybmF0aW9uYWxpemF0aW9uLGludGVyY29udGluZW50YWwKVE9QTzpBPkIsQT5DLEI+RCxCPkUsQz5FLEM+RixEPkcsRT5HLEY+RyxHPkgKUE9XRVI6MTIzNDU2Nyw4OTAxMjM0LDEwMDAwMDAwMDk=",
          "testOut": "797893274",
          "isValidator": true,
          "needValidation": true
        }
      ],
      "difficulty": "expert",
      "constraints": "1 ≤ length of [[encoded]] ≤ 2000\n\n{{GRAPH}}:\n1 ≤ number of nodes ≤ 50\n1 ≤ number of edges ≤ 200\n1 ≤ [[W]] ≤ 20\n{{S}} and {{E}} are guaranteed to exist and be connected.\n\n{{KNAPSACK}}:\n1 ≤ number of items ≤ 25\n1 ≤ [[CAP]] ≤ 5000\n1 ≤ [[WEIGHT]] ≤ 12\n1 ≤ [[VALUE]] ≤ 200\n\n{{GUARDS}}:\n0 ≤ number of guards ≤ 4\n1 ≤ length of [[PATH]] ≤ 20\n0 ≤ [[GX]], [[GY]], [[TX]], [[TY]] ≤ 20\n\n{{PATTERN}}:\n2 ≤ number of strings ≤ 10\n1 ≤ length of each string ≤ 25\n\n{{FACTOR}}:\n2 ≤ [[N]] ≤ 10^15\n\n{{FIB}}:\n0 ≤ [[N]] ≤ 10^18\n\n{{EVAL}}:\n1 ≤ length of [[EXPR]] ≤ 100\nIntermediate values fit in a 64-bit signed integer.\n\n{{LCS}}:\n1 ≤ length of each string ≤ 50\n\n{{TOPO}}:\n1 ≤ number of nodes ≤ 20\n1 ≤ number of edges ≤ 30\nThe graph is a directed acyclic graph (DAG).\n\n{{POWMOD}}:\n1 ≤ [[BASE]] ≤ 10^18\n1 ≤ [[EXP]] ≤ 10^18\n2 ≤ [[MOD]] ≤ 10^9+9\n\nAll final numeric results fit in a 64-bit signed integer.",
      "coverBinaryId": 157524348218478,
      "stubGenerator": "read encoded:string(2000)\nwrite answer",
      "inputDescription": "<<Line 1:>> A single Base64-encoded string [[encoded]].\n\nAfter decoding, data contains one parameter per line as [[KEY]]{{:}}[[VALUE]]. Keys per task:\n\n{{GRAPH}}: [[GRAPH]] — edges as [[A]]{{-}}[[B]]{{:}}[[W]] (node names, integer weight), comma-separated.\n{{KNAPSACK}}: [[ITEMS]] — items as [[NAME]]{{,}}[[WEIGHT]]{{,}}[[VALUE]], semicolon-separated. [[CAP]] — integer capacity.\n{{GUARDS}}: [[GUARDS]] — guards as [[GX]]{{,}}[[GY]]{{,}}[[PATH]], semicolon-separated (may be empty). [[TX]], [[TY]] — integer target coordinates.\n{{PATTERN}}: [[PATTERN]] — comma-separated strings. First is the target, rest are candidates.\n{{FACTOR}}: [[FACTOR]] — integer [[N]].\n{{FIB}}: [[FIB]] — integer [[N]].\n{{EVAL}}: [[EXPR]] — arithmetic expression string.\n{{LCS}}: [[LCS]] — two strings separated by a comma.\n{{TOPO}}: [[TOPO]] — directed edges as [[P]]{{>}}[[C]], comma-separated.\n{{POWMOD}}: [[POWER]] — three integers as [[BASE]]{{,}}[[EXP]]{{,}}[[MOD]].",
      "solutionLanguage": "C",
      "outputDescription": "<<Line 1:>> A single integer — the final access code computed in Step 4."
    },
    "draft": false,
    "readyForModeration": true,
    "statementHTML": "<div class=\"statement-body\">\n<div class=\"statement-section statement-goal\">\n   <h2><span class=\"icon icon-goal\">&nbsp;</span><span>Goal </span></h2>\n   <span class=\"question-statement\">You intercepted a transmission from the NEXUS mainframe. Your mission: decode it and solve <strong>10</strong> independent tasks to compute the access code.<br><br><strong>Step 1 &mdash; DECODE</strong><br>The input is a single Base64-encoded string. Decode it to obtain the raw mission data.<br><br><strong>Step 2 &mdash; PARSE</strong><br>The decoded text contains lines in <var>KEY</var><const>:</const><var>VALUE</var> format. Each line corresponds to one parameter. Each task below reads its own set of keys from this parsed data.<br><br><strong>Step 3 &mdash; TASKS</strong><br>All tasks are independent of each other.<br><br><strong>GRAPH</strong> &mdash; Shortest Path<br>The key <var>GRAPH</var> contains a comma-separated list of edges. Each edge is formatted as <var>A</var><const>-</const><var>B</var><const>:</const><var>W</var>, meaning a bidirectional edge between nodes <var>A</var> and <var>B</var> with integer weight <var>W</var>. Find the shortest path from the node named <const>S</const> to the node named <const>E</const> and return the total path weight.<br><br><strong>KNAPSACK</strong> &mdash; 0/1 Knapsack<br>The key <var>ITEMS</var> contains a semicolon-separated list of items. Each item is formatted as <var>NAME</var><const>,</const><var>WEIGHT</var><const>,</const><var>VALUE</var>. The key <var>CAP</var> is the maximum weight capacity. Select a subset of items such that their total weight does not exceed <var>CAP</var> and their total value is maximized. Each item may be selected at most once. Return the maximum total value.<br><br><strong>GUARDS</strong> &mdash; Patrol Simulation<br>The key <var>GUARDS</var> contains a semicolon-separated list of guards. Each guard is formatted as <var>GX</var><const>,</const><var>GY</var><const>,</const><var>PATH</var>. A guard starts at position (<var>GX</var>, <var>GY</var>). The keys <var>TX</var> and <var>TY</var> define the target position. Each guard moves one step per unit of time, cycling through its <var>PATH</var> string (<const>U</const>: Y+1, <const>D</const>: Y-1, <const>R</const>: X+1, <const>L</const>: X-1). At time <var>t</var>, a guard has completed exactly <var>t</var> moves. Find the smallest non-negative integer <var>t</var> such that the target is safe: the Manhattan distance from the target to every guard is strictly greater than <const>1</const>. If <var>GUARDS</var> is empty, return <const>0</const>.<br><br><strong>PATTERN</strong> &mdash; Edit Distance Matching<br>The key <var>PATTERN</var> contains a comma-separated list of strings. The first string is the target; the remaining strings are candidates. Compute the Levenshtein (edit) distance from the target to each candidate. Return the candidate with the smallest distance. If there is a tie, return the lexicographically smallest candidate. The result is the string itself, not a number.<br><br><strong>FACTOR</strong> &mdash; Prime Factorization Sum<br>The key <var>FACTOR</var> contains a single integer <var>N</var>. Decompose <var>N</var> into its prime factors, counting each factor as many times as it divides <var>N</var> (with multiplicity). Return the sum of all those prime factors. For example, <const>12</const> = <const>2</const> &times; <const>2</const> &times; <const>3</const>, so the sum is <const>7</const>.<br><br><strong>FIB</strong> &mdash; Fibonacci Number<br>The key <var>FIB</var> contains a single integer <var>N</var>. Compute the <var>N</var>-th Fibonacci number modulo <const>10^9+7</const>. The Fibonacci sequence is defined as F(<const>0</const>) = <const>0</const>, F(<const>1</const>) = <const>1</const>, and F(<var>k</var>) = F(<var>k</var> - <const>1</const>) + F(<var>k</var> - <const>2</const>) for <var>k</var> &ge; <const>2</const>. Return F(<var>N</var>) mod <const>10^9+7</const>.<br><br><strong>EVAL</strong> &mdash; Expression Evaluation<br>The key <var>EXPR</var> contains an arithmetic expression built from non-negative integers, the operators <const>+</const>, <const>-</const>, <const>*</const>, <const>/</const> (integer division, truncated toward zero), and parentheses. Standard operator precedence applies: <const>*</const> and <const>/</const> bind tighter than <const>+</const> and <const>-</const>. Evaluate the expression and return the integer result.<br><br><strong>LCS</strong> &mdash; Longest Common Subsequence<br>The key <var>LCS</var> contains two strings separated by a comma. Compute the length of the longest common subsequence (not substring) of these two strings. Return the length as an integer.<br><br><strong>TOPO</strong> &mdash; Topological Sort<br>The key <var>TOPO</var> contains a comma-separated list of directed edges. Each edge is formatted as <var>P</var><const>&gt;</const><var>C</var>, meaning a directed edge from node <var>P</var> to node <var>C</var>. Perform a topological sort on the resulting directed acyclic graph. When multiple nodes have zero in-degree simultaneously, process them in lexicographic order. Return the sorted node names joined by commas.<br><br><strong>POWMOD</strong> &mdash; Modular Exponentiation<br>The key <var>POWER</var> contains three comma-separated integers <var>BASE</var><const>,</const><var>EXP</var><const>,</const><var>MOD</var>. Compute <var>BASE</var> raised to the power <var>EXP</var>, modulo <var>MOD</var>, using fast exponentiation. Return the result.<br><br><strong>Step 4 &mdash; FINAL COMPUTATION</strong><br>Sum all numeric task results: <const>GRAPH</const> + <const>KNAPSACK</const> + <const>GUARDS</const> + <const>FACTOR</const> + <const>FIB</const> + <const>EVAL</const> + <const>LCS</const> + <const>POWMOD</const>. Then compute the sum of ASCII values of every character in the <const>PATTERN</const> result string, and the sum of ASCII values of every character in the <const>TOPO</const> result string. Add those two ASCII sums together. Finally, XOR the numeric sum with the combined ASCII sum. Output the result.</span>\n</div>\n<div class=\"statement-section statement-protocol\">\n   <div class=\"blk\">\n      <div class=\"title\">Input</div>\n      <div class=\"question-statement-input\"><strong>Line 1:</strong> A single Base64-encoded string <var>encoded</var>.<br><br>After decoding, data contains one parameter per line as <var>KEY</var><const>:</const><var>VALUE</var>. Keys per task:<br><br><const>GRAPH</const>: <var>GRAPH</var> &mdash; edges as <var>A</var><const>-</const><var>B</var><const>:</const><var>W</var> (node names, integer weight), comma-separated.<br><const>KNAPSACK</const>: <var>ITEMS</var> &mdash; items as <var>NAME</var><const>,</const><var>WEIGHT</var><const>,</const><var>VALUE</var>, semicolon-separated. <var>CAP</var> &mdash; integer capacity.<br><const>GUARDS</const>: <var>GUARDS</var> &mdash; guards as <var>GX</var><const>,</const><var>GY</var><const>,</const><var>PATH</var>, semicolon-separated (may be empty). <var>TX</var>, <var>TY</var> &mdash; integer target coordinates.<br><const>PATTERN</const>: <var>PATTERN</var> &mdash; comma-separated strings. First is the target, rest are candidates.<br><const>FACTOR</const>: <var>FACTOR</var> &mdash; integer <var>N</var>.<br><const>FIB</const>: <var>FIB</var> &mdash; integer <var>N</var>.<br><const>EVAL</const>: <var>EXPR</var> &mdash; arithmetic expression string.<br><const>LCS</const>: <var>LCS</var> &mdash; two strings separated by a comma.<br><const>TOPO</const>: <var>TOPO</var> &mdash; directed edges as <var>P</var><const>&gt;</const><var>C</var>, comma-separated.<br><const>POWMOD</const>: <var>POWER</var> &mdash; three integers as <var>BASE</var><const>,</const><var>EXP</var><const>,</const><var>MOD</var>.</div>\n   </div>\n   <div class=\"blk\">\n      <div class=\"title\">Output</div>\n      <div class=\"question-statement-output\"><strong>Line 1:</strong> A single integer &mdash; the final access code computed in Step 4.</div>\n   </div>\n   <div class=\"blk\">\n      <div class=\"title\">Constraints</div>\n      <div class=\"question-statement-constraints\">1 &le; length of <var>encoded</var> &le; 2000<br><br><const>GRAPH</const>:<br>1 &le; number of nodes &le; 50<br>1 &le; number of edges &le; 200<br>1 &le; <var>W</var> &le; 20<br><const>S</const> and <const>E</const> are guaranteed to exist and be connected.<br><br><const>KNAPSACK</const>:<br>1 &le; number of items &le; 25<br>1 &le; <var>CAP</var> &le; 5000<br>1 &le; <var>WEIGHT</var> &le; 12<br>1 &le; <var>VALUE</var> &le; 200<br><br><const>GUARDS</const>:<br>0 &le; number of guards &le; 4<br>1 &le; length of <var>PATH</var> &le; 20<br>0 &le; <var>GX</var>, <var>GY</var>, <var>TX</var>, <var>TY</var> &le; 20<br><br><const>PATTERN</const>:<br>2 &le; number of strings &le; 10<br>1 &le; length of each string &le; 25<br><br><const>FACTOR</const>:<br>2 &le; <var>N</var> &le; 10^15<br><br><const>FIB</const>:<br>0 &le; <var>N</var> &le; 10^18<br><br><const>EVAL</const>:<br>1 &le; length of <var>EXPR</var> &le; 100<br>Intermediate values fit in a 64-bit signed integer.<br><br><const>LCS</const>:<br>1 &le; length of each string &le; 50<br><br><const>TOPO</const>:<br>1 &le; number of nodes &le; 20<br>1 &le; number of edges &le; 30<br>The graph is a directed acyclic graph (DAG).<br><br><const>POWMOD</const>:<br>1 &le; <var>BASE</var> &le; 10^18<br>1 &le; <var>EXP</var> &le; 10^18<br>2 &le; <var>MOD</var> &le; 10^9+9<br><br>All final numeric results fit in a 64-bit signed integer.</div>\n   </div>\n   <div class=\"blk\">\n      <div class=\"title\">Example</div>\n      <div class=\"statement-inout\">\n         <div class=\"statement-inout-in\">\n            <div class=\"title\">Input</div>\n            <pre class=\"question-statement-example-in\">R1JBUEg6Uy1FOjEKSVRFTVM6eCwxLDEKQ0FQOjEKR1VBUkRTOgpUWDowClRZOjAKUEFUVEVSTjphLGIsYwpGQUNUT1I6MgpGSUI6MApFWFBSOjErMQpMQ1M6YSxhClRPUE86QT5CClBPV0VSOjEsMSwy</pre>\n         </div>\n         <div class=\"statement-inout-out\">\n            <div class=\"title\">Output</div>\n            <pre class=\"question-statement-example-out\">281</pre>\n         </div>\n      </div>\n   </div>\n</div>"
  },
  "avatar": 157535060876255,
  "commentCount": 23,
  "upVotes": 0,
  "downVotes": 3,
  "statusHistory": [],
  "editable": true,
  "draft": false,
  "readyForModeration": true
}