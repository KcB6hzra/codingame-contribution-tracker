{
  "id": 14933,
  "activeVersion": 9,
  "score": 7,
  "votableId": 22954759,
  "codingamerId": 2065521,
  "views": 321,
  "commentableId": 22841365,
  "title": "circular automation, the period of chaos",
  "status": "ACCEPTED",
  "type": "PUZZLE_INOUT",
  "nickname": "igolus",
  "publicHandle": "149332ba58a69964fc862958c2317fd33aa23",
  "codingamerHandle": "54583f3963f08a7e4a231ed45eec805e1255602",
  "lastVersion": {
    "version": 9,
    "autocloseTime": 1655119315268,
    "data": {
      "title": "circular automation, the period of chaos",
      "topics": [
        {
          "labelMap": {
            "2": "chaos"
          }
        },
        {
          "labelMap": {
            "2": "Fractal"
          }
        },
        {
          "labelMap": {
            "2": "Cellular Automaton"
          }
        }
      ],
      "solution": "const lineLength = parseInt(readline());\nconst maxIter = parseInt(readline());\nconst ruleNumber = parseInt(readline());\n\n\nvar binaryValue = getBinaryWithHeader(ruleNumber, 8);\n\nconst s1 = '1'\nconst sp = '.'\n\n\nvar line = '';\nvar midLine = '';\nfor (let i=0; i < (lineLength-1)/2; i++) {\n    midLine += sp; \n}\n\nvar line = midLine + s1 + midLine;\n\nvar allLines=[];\nvar mapping = {};\n\n\nfor (let i=7; i>=0; i--) {\n    mapping[getBinaryWithHeader(i, 3)] = binaryValue.charAt(7-i);\n}\n\n//console.log(line);\nallLines.push(line);\nconsole.error(line);\nfor (let i = 1; i < maxIter - 1; i ++) {\n    line = transformLine(line);\n    console.error(line);\n    var indexDup = allLines.indexOf(line);\n    //console.log(indexDup);\n    if (indexDup != -1) {\n        console.log(i - indexDup);\n        return;\n    }\n    allLines.push(line);\n}\n\nconsole.log(\"BIG\");\n\n\nfunction getBinaryWithHeader(value, nbDigit) {\n    var binaryValue = value.toString(2);\n    binaryValue = '0'.repeat(nbDigit - binaryValue.length) + binaryValue;\n    return binaryValue;\n}\n\nfunction transformLine(line) {\n    var out = '';\n    for (let i=0; i < line.length; i++) {\n        var replaced = replaceCharToBinary(line.charAt(i));\n        var charLeft='';\n        var charRight='';\n       \n        if (i>0) {\n            charLeft = replaceCharToBinary(line.charAt(i-1)); \n        }\n        else {\n            charLeft = replaceCharToBinary(line.charAt(line.length - 1)); \n        }\n        if (i < line.length - 1) {\n             charRight = replaceCharToBinary(line.charAt(i+1)); \n        }\n        else {\n            charRight = replaceCharToBinary(line.charAt(0)); \n        }\n        var source =  charLeft + replaced + charRight;\n        out += mapping[source];\n    }\n    return out.replace(/0/g, '.');\n\n}\n\nfunction replaceCharToBinary(char) {\n    return char.replace('\\.', '0'); \n}",
      "statement": "In mathematics and computability theory, an elementary cellular automaton is a one-dimensional cellular automaton where there are two possible states (labeled 0 and 1) and the rule to determine the state of a cell in the next generation depends only on the current state of the cell and its two immediate neighbors.\n\n<<The numbering system>>\n\nThere are 2^3=8 possible configurations for a cell and its two immediate neighbors. The rule defining the cellular automaton must specify the resulting state for each of these possibilities so there are 2^(2^3) = 256 possible elementary cellular automates. Stephen Wolfram proposed a scheme, known as the Wolfram code, to assign each rule a number from 0 to 255 which has become standard. Each possible current configuration is written in order, 111, 110, ..., 001, 000, and the resulting state for each of these configurations is written in the same order and interpreted as the binary representation of an integer. This number is taken to be the rule number of the automaton. For example, 110 (base 10)=01101110 (base 2). So rule 110 ([[ruleNumber]]) is defined by the transition rule:\n\n`=================================\n|111|110|101|100|011|010|001|000|\n| 0 | 1 | 1 | 0 | 1 | 1 | 1 | 0 |\n=================================`\n\nYou can find similar a puzzle in coding game here: https://www.codingame.com/training/medium/elementary-cellular-automaton\n\nMore information about elementary cellular automaton  can be found here : http://mathworld.wolfram.com/ElementaryCellularAutomaton.html\n\n<<Statement>> \n\nbased on [[lineLength]] an odd number, start with a line with 1 in the middle and fill all the rest with '.'  char.\n\n'.' character represent the 0 value, it is used to make the display more readable.\n'1' character represent the 1 value.\n\nExample:\nline_length = 1 :  1 for 1\nline_length = 3 :  .1.  for 010\nline_length = 5 : ..1.. for 00100\n\nFor this exercise, we connect the two extremities of the line, think about a motif that will be displayed over an infinite cylinder\n\nThe left cell of the first cell is the last cell.\nThe right cell of the last cell is the first cell.\n\nThen repeat the transformation to the current line till you find a repetition scheme, a line that was already outputted before. \n\nSince same line will always provide same output, we can be sure that a repetition period exist and this period is less or equal to 2^([[lineLength]]) + 1\n\n<<Goal>>\n \nOutput the repetition period (the number of iteration separating two matching patterns), if the number of iteration comes greater than  [[maxIter]] and no solution was found yet, output \"BIG\". \n\nExample 1: \n\n- [[lineLength ]] = 5\n- [[maxIter]] = 20000\n- [[ruleNumber]] = 254\n\nThe lines will be like that:\n\n`..1..\n.111.\n11111\n11111`\n\nAfter the second line, the lines stay the same forever the the repetition period is then <<1>>\n\nExample 2: \n\n- [[lineLength]] = 5\n- [[maxIter]] = 20000\n- [[ruleNumber]] = 1\n\nThe lines will be like that:\n\n`..1..\n1...1\n..1..`\n\nPeriod is <<2>>\n\n<<bonus>>\n\nDisplay each line of iteration inside the error stream to better understand how the chaos can emerge from a simple defined problem.",
      "testCases": [
        {
          "title": "Simple example",
          "isTest": true,
          "testIn": "5\n20000\n254",
          "testOut": "1",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Simple example validator",
          "isTest": false,
          "testIn": "3\n20000\n254",
          "testOut": "1",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "Blinker",
          "isTest": true,
          "testIn": "5\n20000\n1",
          "testOut": "2",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Blinker validator",
          "isTest": false,
          "testIn": "7\n20000\n1",
          "testOut": "2",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "Rule 250 Mix",
          "isTest": true,
          "testIn": "51\n20000\n250",
          "testOut": "1",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Rule 250 Mix validator",
          "isTest": false,
          "testIn": "53\n20000\n250",
          "testOut": "1",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "126 = Fractal",
          "isTest": true,
          "testIn": "37\n20000\n126",
          "testOut": "1022",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "126 = Fractal validator",
          "isTest": false,
          "testIn": "53\n20000\n126",
          "testOut": "1022",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "So Long",
          "isTest": true,
          "testIn": "57\n7000\n126",
          "testOut": "BIG",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "So Long validator",
          "isTest": false,
          "testIn": "73\n7000\n126",
          "testOut": "BIG",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "Rule 110",
          "isTest": true,
          "testIn": "91\n5000\n110",
          "testOut": "2730",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Rule 110 Validator",
          "isTest": false,
          "testIn": "63\n5000\n110",
          "testOut": "1890",
          "isValidator": true,
          "needValidation": true
        },
        {
          "title": "Where is the motif",
          "isTest": true,
          "testIn": "15\n5000\n30",
          "testOut": "1455",
          "isValidator": false,
          "needValidation": true
        },
        {
          "title": "Where is the motif validator",
          "isTest": false,
          "testIn": "23\n5000\n30",
          "testOut": "BIG",
          "isValidator": true,
          "needValidation": true
        }
      ],
      "difficulty": "medium",
      "constraints": "[[lineLength]] is odd and < 500\n[[maxIter]] < 50000\n0 ≤ [[ruleNumber]] ≤ 255",
      "coverBinaryId": 82183383725276,
      "stubGenerator": "read lineLength:int\nread maxIter:int\nread ruleNumber:int\nwrite 0",
      "inputDescription": "<<Line 1:>> [[lineLength]] the length of the line to repeat\n<<Line 2:>> [[maxIter]] maximum number of iteration\n<<Line 3:>> [[ruleNumber]] the rule number",
      "solutionLanguage": "Javascript",
      "outputDescription": "The repetition period or \"BIG\" if no period can be found after [[maxIter]]iterations"
    },
    "draft": false,
    "readyForModeration": true,
    "statementHTML": "<div class=\"statement-body\">\n<div class=\"statement-section statement-goal\">\n   <h2><span class=\"icon icon-goal\">&nbsp;</span><span>Goal </span></h2>\n   <span class=\"question-statement\">In mathematics and computability theory, an elementary cellular automaton is a one-dimensional cellular automaton where there are two possible states (labeled 0 and 1) and the rule to determine the state of a cell in the next generation depends only on the current state of the cell and its two immediate neighbors.<br><br><strong>The numbering system</strong><br><br>There are 2^3=8 possible configurations for a cell and its two immediate neighbors. The rule defining the cellular automaton must specify the resulting state for each of these possibilities so there are 2^(2^3) = 256 possible elementary cellular automates. Stephen Wolfram proposed a scheme, known as the Wolfram code, to assign each rule a number from 0 to 255 which has become standard. Each possible current configuration is written in order, 111, 110, ..., 001, 000, and the resulting state for each of these configurations is written in the same order and interpreted as the binary representation of an integer. This number is taken to be the rule number of the automaton. For example, 110 (base 10)=01101110 (base 2). So rule 110 (<var>ruleNumber</var>) is defined by the transition rule:<br><br><pre style=\"font-family: monospace\">=================================<br>|111|110|101|100|011|010|001|000|<br>| 0 | 1 | 1 | 0 | 1 | 1 | 1 | 0 |<br>=================================</pre><br><br>You can find similar a puzzle in coding game here: https://www.codingame.com/training/medium/elementary-cellular-automaton<br><br>More information about elementary cellular automaton  can be found here : http://mathworld.wolfram.com/ElementaryCellularAutomaton.html<br><br><strong>Statement</strong> <br><br>based on <var>lineLength</var> an odd number, start with a line with 1 in the middle and fill all the rest with '.'  char.<br><br>'.' character represent the 0 value, it is used to make the display more readable.<br>'1' character represent the 1 value.<br><br>Example:<br>line_length = 1 :  1 for 1<br>line_length = 3 :  .1.  for 010<br>line_length = 5 : ..1.. for 00100<br><br>For this exercise, we connect the two extremities of the line, think about a motif that will be displayed over an infinite cylinder<br><br>The left cell of the first cell is the last cell.<br>The right cell of the last cell is the first cell.<br><br>Then repeat the transformation to the current line till you find a repetition scheme, a line that was already outputted before. <br><br>Since same line will always provide same output, we can be sure that a repetition period exist and this period is less or equal to 2^(<var>lineLength</var>) + 1<br><br><strong>Goal</strong><br> <br>Output the repetition period (the number of iteration separating two matching patterns), if the number of iteration comes greater than  <var>maxIter</var> and no solution was found yet, output &quot;BIG&quot;. <br><br>Example 1: <br><br>- <var>lineLength </var> = 5<br>- <var>maxIter</var> = 20000<br>- <var>ruleNumber</var> = 254<br><br>The lines will be like that:<br><br><pre style=\"font-family: monospace\">..1..<br>.111.<br>11111<br>11111</pre><br><br>After the second line, the lines stay the same forever the the repetition period is then <strong>1</strong><br><br>Example 2: <br><br>- <var>lineLength</var> = 5<br>- <var>maxIter</var> = 20000<br>- <var>ruleNumber</var> = 1<br><br>The lines will be like that:<br><br><pre style=\"font-family: monospace\">..1..<br>1...1<br>..1..</pre><br><br>Period is <strong>2</strong><br><br><strong>bonus</strong><br><br>Display each line of iteration inside the error stream to better understand how the chaos can emerge from a simple defined problem.</span>\n</div>\n<div class=\"statement-section statement-protocol\">\n   <div class=\"blk\">\n      <div class=\"title\">Input</div>\n      <div class=\"question-statement-input\"><strong>Line 1:</strong> <var>lineLength</var> the length of the line to repeat<br><strong>Line 2:</strong> <var>maxIter</var> maximum number of iteration<br><strong>Line 3:</strong> <var>ruleNumber</var> the rule number</div>\n   </div>\n   <div class=\"blk\">\n      <div class=\"title\">Output</div>\n      <div class=\"question-statement-output\">The repetition period or &quot;BIG&quot; if no period can be found after <var>maxIter</var>iterations</div>\n   </div>\n   <div class=\"blk\">\n      <div class=\"title\">Constraints</div>\n      <div class=\"question-statement-constraints\"><var>lineLength</var> is odd and &lt; 500<br><var>maxIter</var> &lt; 50000<br>0 &le; <var>ruleNumber</var> &le; 255</div>\n   </div>\n   <div class=\"blk\">\n      <div class=\"title\">Example</div>\n      <div class=\"statement-inout\">\n         <div class=\"statement-inout-in\">\n            <div class=\"title\">Input</div>\n            <pre class=\"question-statement-example-in\">5\n20000\n254</pre>\n         </div>\n         <div class=\"statement-inout-out\">\n            <div class=\"title\">Output</div>\n            <pre class=\"question-statement-example-out\">1</pre>\n         </div>\n      </div>\n   </div>\n</div>"
  },
  "validatedFor": 115948898243,
  "avatar": 39913769766376,
  "commentCount": 12,
  "upVotes": 9,
  "downVotes": 2,
  "validateAction": {
    "actionId": 664515,
    "progress": 1,
    "alreadyDone": false
  },
  "statusHistory": [
    {
      "status": "ACCEPTED",
      "date": 1654781005071,
      "data": {
        "author": "ACTION"
      }
    }
  ],
  "editable": true,
  "draft": false,
  "readyForModeration": true
}